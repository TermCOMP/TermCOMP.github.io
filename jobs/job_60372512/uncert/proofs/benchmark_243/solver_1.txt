YES
proof of /home/ff862203/input_pkA0FXmXMg.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Outermost Termination of the given OTRS could be proven:

(0) OTRS
(1) Thiemann-SpecialC-Transformation [EQUIVALENT, 0 ms]
(2) QTRS
(3) QTRSRRRProof [EQUIVALENT, 62 ms]
(4) QTRS
(5) QTRSRRRProof [EQUIVALENT, 26 ms]
(6) QTRS
(7) QTRSRRRProof [EQUIVALENT, 0 ms]
(8) QTRS
(9) DependencyPairsProof [EQUIVALENT, 0 ms]
(10) QDP
(11) DependencyGraphProof [EQUIVALENT, 0 ms]
(12) AND
    (13) QDP
        (14) UsableRulesProof [EQUIVALENT, 0 ms]
        (15) QDP
        (16) QReductionProof [EQUIVALENT, 0 ms]
        (17) QDP
        (18) UsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (19) QDP
        (20) DependencyGraphProof [EQUIVALENT, 0 ms]
        (21) TRUE
    (22) QDP
        (23) UsableRulesProof [EQUIVALENT, 0 ms]
        (24) QDP
        (25) QReductionProof [EQUIVALENT, 0 ms]
        (26) QDP
        (27) TransformationProof [SOUND, 0 ms]
        (28) QDP
        (29) TransformationProof [EQUIVALENT, 0 ms]
        (30) QDP
        (31) TransformationProof [EQUIVALENT, 0 ms]
        (32) QDP
        (33) TransformationProof [SOUND, 0 ms]
        (34) QDP
        (35) TransformationProof [EQUIVALENT, 0 ms]
        (36) QDP
        (37) DependencyGraphProof [EQUIVALENT, 0 ms]
        (38) QDP
        (39) TransformationProof [EQUIVALENT, 0 ms]
        (40) QDP
        (41) DependencyGraphProof [EQUIVALENT, 0 ms]
        (42) QDP
        (43) QDPOrderProof [EQUIVALENT, 0 ms]
        (44) QDP
        (45) SemLabProof [SOUND, 116 ms]
        (46) QDP
        (47) UsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (48) QDP
        (49) UsableRulesReductionPairsProof [EQUIVALENT, 6 ms]
        (50) QDP
        (51) MRRProof [EQUIVALENT, 0 ms]
        (52) QDP
        (53) MRRProof [EQUIVALENT, 0 ms]
        (54) QDP
        (55) UsableRulesReductionPairsProof [EQUIVALENT, 4 ms]
        (56) QDP
        (57) MRRProof [EQUIVALENT, 0 ms]
        (58) QDP
        (59) UsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (60) QDP
        (61) UsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (62) QDP
        (63) MRRProof [EQUIVALENT, 0 ms]
        (64) QDP
        (65) PisEmptyProof [EQUIVALENT, 0 ms]
        (66) YES


----------------------------------------

(0)
Obligation:
Term rewrite system R:
The TRS R consists of the following rules:

   f(x, x) -> f(i(x), g(g(x)))
   f(x, y) -> x
   g(x) -> i(x)
   f(x, i(x)) -> f(x, x)
   f(i(x), i(g(x))) -> a
   h(x, x) -> a



Outermost Strategy.

----------------------------------------

(1) Thiemann-SpecialC-Transformation (EQUIVALENT)
We applied the Thiemann-SpecialC transformation  to transform the outermost TRS to an innermost TRS.
----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   top(go_up(x)) -> top(reduce(x))
   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, y) -> result_f(x)
   redex_g(x) -> result_g(i(x))
   redex_f(x, i(x)) -> result_f(f(x, x))
   redex_f(i(x), i(g(x))) -> result_f(a)
   redex_h(x, x) -> result_h(a)
   check_f(result_f(x)) -> go_up(x)
   check_g(result_g(x)) -> go_up(x)
   check_h(result_h(x)) -> go_up(x)
   check_f(redex_f(x_1, x_2)) -> in_f_1(reduce(x_1), x_2)
   check_f(redex_f(x_1, x_2)) -> in_f_2(x_1, reduce(x_2))
   check_g(redex_g(x_1)) -> in_g_1(reduce(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_f_1(go_up(x_1), x_2) -> go_up(f(x_1, x_2))
   in_f_2(x_1, go_up(x_2)) -> go_up(f(x_1, x_2))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   in_g_1(go_up(x_1)) -> go_up(g(x_1))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))

The set Q consists of the following terms:

   top(go_up(x0))
   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_f_1(go_up(x0), x1)
   in_f_2(x0, go_up(x1))
   in_i_1(go_up(x0))
   in_g_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))


----------------------------------------

(3) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(a) = 0
   POL(check_f(x_1)) = x_1
   POL(check_g(x_1)) = x_1
   POL(check_h(x_1)) = 1 + 2*x_1
   POL(f(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(g(x_1)) = x_1
   POL(go_up(x_1)) = x_1
   POL(h(x_1, x_2)) = 1 + 2*x_1 + 2*x_2
   POL(i(x_1)) = x_1
   POL(in_f_1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(in_f_2(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(in_g_1(x_1)) = x_1
   POL(in_h_1(x_1, x_2)) = 1 + 2*x_1 + 2*x_2
   POL(in_h_2(x_1, x_2)) = 1 + 2*x_1 + 2*x_2
   POL(in_i_1(x_1)) = x_1
   POL(redex_f(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(redex_g(x_1)) = x_1
   POL(redex_h(x_1, x_2)) = x_1 + x_2
   POL(reduce(x_1)) = x_1
   POL(result_f(x_1)) = x_1
   POL(result_g(x_1)) = x_1
   POL(result_h(x_1)) = 2*x_1
   POL(top(x_1)) = 2*x_1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   check_h(result_h(x)) -> go_up(x)




----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   top(go_up(x)) -> top(reduce(x))
   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, y) -> result_f(x)
   redex_g(x) -> result_g(i(x))
   redex_f(x, i(x)) -> result_f(f(x, x))
   redex_f(i(x), i(g(x))) -> result_f(a)
   redex_h(x, x) -> result_h(a)
   check_f(result_f(x)) -> go_up(x)
   check_g(result_g(x)) -> go_up(x)
   check_f(redex_f(x_1, x_2)) -> in_f_1(reduce(x_1), x_2)
   check_f(redex_f(x_1, x_2)) -> in_f_2(x_1, reduce(x_2))
   check_g(redex_g(x_1)) -> in_g_1(reduce(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_f_1(go_up(x_1), x_2) -> go_up(f(x_1, x_2))
   in_f_2(x_1, go_up(x_2)) -> go_up(f(x_1, x_2))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   in_g_1(go_up(x_1)) -> go_up(g(x_1))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))

The set Q consists of the following terms:

   top(go_up(x0))
   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_f_1(go_up(x0), x1)
   in_f_2(x0, go_up(x1))
   in_i_1(go_up(x0))
   in_g_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))


----------------------------------------

(5) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(a) = 0
   POL(check_f(x_1)) = x_1
   POL(check_g(x_1)) = x_1
   POL(check_h(x_1)) = x_1
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(g(x_1)) = x_1
   POL(go_up(x_1)) = 2*x_1
   POL(h(x_1, x_2)) = 1 + x_1 + x_2
   POL(i(x_1)) = x_1
   POL(in_f_1(x_1, x_2)) = x_1 + 2*x_2
   POL(in_f_2(x_1, x_2)) = 2*x_1 + x_2
   POL(in_g_1(x_1)) = x_1
   POL(in_h_1(x_1, x_2)) = 2 + x_1 + 2*x_2
   POL(in_h_2(x_1, x_2)) = 2 + 2*x_1 + x_2
   POL(in_i_1(x_1)) = x_1
   POL(redex_f(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(redex_g(x_1)) = 2*x_1
   POL(redex_h(x_1, x_2)) = 2 + 2*x_1 + 2*x_2
   POL(reduce(x_1)) = 2*x_1
   POL(result_f(x_1)) = 2*x_1
   POL(result_g(x_1)) = 2*x_1
   POL(result_h(x_1)) = 1 + 2*x_1
   POL(top(x_1)) = 2*x_1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   redex_h(x, x) -> result_h(a)




----------------------------------------

(6)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   top(go_up(x)) -> top(reduce(x))
   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, y) -> result_f(x)
   redex_g(x) -> result_g(i(x))
   redex_f(x, i(x)) -> result_f(f(x, x))
   redex_f(i(x), i(g(x))) -> result_f(a)
   check_f(result_f(x)) -> go_up(x)
   check_g(result_g(x)) -> go_up(x)
   check_f(redex_f(x_1, x_2)) -> in_f_1(reduce(x_1), x_2)
   check_f(redex_f(x_1, x_2)) -> in_f_2(x_1, reduce(x_2))
   check_g(redex_g(x_1)) -> in_g_1(reduce(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_f_1(go_up(x_1), x_2) -> go_up(f(x_1, x_2))
   in_f_2(x_1, go_up(x_2)) -> go_up(f(x_1, x_2))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   in_g_1(go_up(x_1)) -> go_up(g(x_1))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))

The set Q consists of the following terms:

   top(go_up(x0))
   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_f_1(go_up(x0), x1)
   in_f_2(x0, go_up(x1))
   in_i_1(go_up(x0))
   in_g_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))


----------------------------------------

(7) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(a) = 0
   POL(check_f(x_1)) = x_1
   POL(check_g(x_1)) = x_1
   POL(check_h(x_1)) = x_1
   POL(f(x_1, x_2)) = 1 + 2*x_1 + x_2
   POL(g(x_1)) = x_1
   POL(go_up(x_1)) = x_1
   POL(h(x_1, x_2)) = 2*x_1 + x_2
   POL(i(x_1)) = x_1
   POL(in_f_1(x_1, x_2)) = 1 + 2*x_1 + x_2
   POL(in_f_2(x_1, x_2)) = 1 + 2*x_1 + x_2
   POL(in_g_1(x_1)) = x_1
   POL(in_h_1(x_1, x_2)) = 2*x_1 + x_2
   POL(in_h_2(x_1, x_2)) = 2*x_1 + x_2
   POL(in_i_1(x_1)) = x_1
   POL(redex_f(x_1, x_2)) = 1 + 2*x_1 + x_2
   POL(redex_g(x_1)) = x_1
   POL(redex_h(x_1, x_2)) = 2*x_1 + x_2
   POL(reduce(x_1)) = x_1
   POL(result_f(x_1)) = x_1
   POL(result_g(x_1)) = x_1
   POL(top(x_1)) = 2*x_1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   redex_f(x, y) -> result_f(x)
   redex_f(i(x), i(g(x))) -> result_f(a)




----------------------------------------

(8)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   top(go_up(x)) -> top(reduce(x))
   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_g(x) -> result_g(i(x))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)
   check_g(result_g(x)) -> go_up(x)
   check_f(redex_f(x_1, x_2)) -> in_f_1(reduce(x_1), x_2)
   check_f(redex_f(x_1, x_2)) -> in_f_2(x_1, reduce(x_2))
   check_g(redex_g(x_1)) -> in_g_1(reduce(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_f_1(go_up(x_1), x_2) -> go_up(f(x_1, x_2))
   in_f_2(x_1, go_up(x_2)) -> go_up(f(x_1, x_2))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   in_g_1(go_up(x_1)) -> go_up(g(x_1))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))

The set Q consists of the following terms:

   top(go_up(x0))
   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_f_1(go_up(x0), x1)
   in_f_2(x0, go_up(x1))
   in_i_1(go_up(x0))
   in_g_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))


----------------------------------------

(9) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(10)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(x)) -> TOP(reduce(x))
   TOP(go_up(x)) -> REDUCE(x)
   REDUCE(f(x_1, x_2)) -> CHECK_F(redex_f(x_1, x_2))
   REDUCE(f(x_1, x_2)) -> REDEX_F(x_1, x_2)
   REDUCE(g(x_1)) -> CHECK_G(redex_g(x_1))
   REDUCE(g(x_1)) -> REDEX_G(x_1)
   REDUCE(h(x_1, x_2)) -> CHECK_H(redex_h(x_1, x_2))
   CHECK_F(redex_f(x_1, x_2)) -> IN_F_1(reduce(x_1), x_2)
   CHECK_F(redex_f(x_1, x_2)) -> REDUCE(x_1)
   CHECK_F(redex_f(x_1, x_2)) -> IN_F_2(x_1, reduce(x_2))
   CHECK_F(redex_f(x_1, x_2)) -> REDUCE(x_2)
   CHECK_G(redex_g(x_1)) -> IN_G_1(reduce(x_1))
   CHECK_G(redex_g(x_1)) -> REDUCE(x_1)
   CHECK_H(redex_h(x_1, x_2)) -> IN_H_1(reduce(x_1), x_2)
   CHECK_H(redex_h(x_1, x_2)) -> REDUCE(x_1)
   CHECK_H(redex_h(x_1, x_2)) -> IN_H_2(x_1, reduce(x_2))
   CHECK_H(redex_h(x_1, x_2)) -> REDUCE(x_2)
   REDUCE(i(x_1)) -> IN_I_1(reduce(x_1))
   REDUCE(i(x_1)) -> REDUCE(x_1)

The TRS R consists of the following rules:

   top(go_up(x)) -> top(reduce(x))
   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_g(x) -> result_g(i(x))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)
   check_g(result_g(x)) -> go_up(x)
   check_f(redex_f(x_1, x_2)) -> in_f_1(reduce(x_1), x_2)
   check_f(redex_f(x_1, x_2)) -> in_f_2(x_1, reduce(x_2))
   check_g(redex_g(x_1)) -> in_g_1(reduce(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_f_1(go_up(x_1), x_2) -> go_up(f(x_1, x_2))
   in_f_2(x_1, go_up(x_2)) -> go_up(f(x_1, x_2))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   in_g_1(go_up(x_1)) -> go_up(g(x_1))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))

The set Q consists of the following terms:

   top(go_up(x0))
   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_f_1(go_up(x0), x1)
   in_f_2(x0, go_up(x1))
   in_i_1(go_up(x0))
   in_g_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(11) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 14 less nodes.
----------------------------------------

(12)
Complex Obligation (AND)

----------------------------------------

(13)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REDUCE(h(x_1, x_2)) -> CHECK_H(redex_h(x_1, x_2))
   CHECK_H(redex_h(x_1, x_2)) -> REDUCE(x_1)
   REDUCE(i(x_1)) -> REDUCE(x_1)
   CHECK_H(redex_h(x_1, x_2)) -> REDUCE(x_2)

The TRS R consists of the following rules:

   top(go_up(x)) -> top(reduce(x))
   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_g(x) -> result_g(i(x))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)
   check_g(result_g(x)) -> go_up(x)
   check_f(redex_f(x_1, x_2)) -> in_f_1(reduce(x_1), x_2)
   check_f(redex_f(x_1, x_2)) -> in_f_2(x_1, reduce(x_2))
   check_g(redex_g(x_1)) -> in_g_1(reduce(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_f_1(go_up(x_1), x_2) -> go_up(f(x_1, x_2))
   in_f_2(x_1, go_up(x_2)) -> go_up(f(x_1, x_2))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   in_g_1(go_up(x_1)) -> go_up(g(x_1))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))

The set Q consists of the following terms:

   top(go_up(x0))
   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_f_1(go_up(x0), x1)
   in_f_2(x0, go_up(x1))
   in_i_1(go_up(x0))
   in_g_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(14) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(15)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REDUCE(h(x_1, x_2)) -> CHECK_H(redex_h(x_1, x_2))
   CHECK_H(redex_h(x_1, x_2)) -> REDUCE(x_1)
   REDUCE(i(x_1)) -> REDUCE(x_1)
   CHECK_H(redex_h(x_1, x_2)) -> REDUCE(x_2)

R is empty.
The set Q consists of the following terms:

   top(go_up(x0))
   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_f_1(go_up(x0), x1)
   in_f_2(x0, go_up(x1))
   in_i_1(go_up(x0))
   in_g_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(16) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   top(go_up(x0))
   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_f_1(go_up(x0), x1)
   in_f_2(x0, go_up(x1))
   in_i_1(go_up(x0))
   in_g_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))


----------------------------------------

(17)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REDUCE(h(x_1, x_2)) -> CHECK_H(redex_h(x_1, x_2))
   CHECK_H(redex_h(x_1, x_2)) -> REDUCE(x_1)
   REDUCE(i(x_1)) -> REDUCE(x_1)
   CHECK_H(redex_h(x_1, x_2)) -> REDUCE(x_2)

R is empty.
The set Q consists of the following terms:

   redex_h(x0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(18) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   REDUCE(h(x_1, x_2)) -> CHECK_H(redex_h(x_1, x_2))
   REDUCE(i(x_1)) -> REDUCE(x_1)
No rules are removed from R.

Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(CHECK_H(x_1)) = x_1
   POL(REDUCE(x_1)) = 2*x_1
   POL(h(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(i(x_1)) = 2*x_1
   POL(redex_h(x_1, x_2)) = 2*x_1 + 2*x_2


----------------------------------------

(19)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   CHECK_H(redex_h(x_1, x_2)) -> REDUCE(x_1)
   CHECK_H(redex_h(x_1, x_2)) -> REDUCE(x_2)

R is empty.
The set Q consists of the following terms:

   redex_h(x0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(20) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 2 less nodes.
----------------------------------------

(21)
TRUE

----------------------------------------

(22)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(x)) -> TOP(reduce(x))

The TRS R consists of the following rules:

   top(go_up(x)) -> top(reduce(x))
   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_g(x) -> result_g(i(x))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)
   check_g(result_g(x)) -> go_up(x)
   check_f(redex_f(x_1, x_2)) -> in_f_1(reduce(x_1), x_2)
   check_f(redex_f(x_1, x_2)) -> in_f_2(x_1, reduce(x_2))
   check_g(redex_g(x_1)) -> in_g_1(reduce(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_f_1(go_up(x_1), x_2) -> go_up(f(x_1, x_2))
   in_f_2(x_1, go_up(x_2)) -> go_up(f(x_1, x_2))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   in_g_1(go_up(x_1)) -> go_up(g(x_1))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))

The set Q consists of the following terms:

   top(go_up(x0))
   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_f_1(go_up(x0), x1)
   in_f_2(x0, go_up(x1))
   in_i_1(go_up(x0))
   in_g_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(23) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(24)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(x)) -> TOP(reduce(x))

The TRS R consists of the following rules:

   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   redex_g(x) -> result_g(i(x))
   check_g(result_g(x)) -> go_up(x)
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)

The set Q consists of the following terms:

   top(go_up(x0))
   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_f_1(go_up(x0), x1)
   in_f_2(x0, go_up(x1))
   in_i_1(go_up(x0))
   in_g_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(25) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   top(go_up(x0))
   in_f_1(go_up(x0), x1)
   in_f_2(x0, go_up(x1))
   in_g_1(go_up(x0))


----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(x)) -> TOP(reduce(x))

The TRS R consists of the following rules:

   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   redex_g(x) -> result_g(i(x))
   check_g(result_g(x)) -> go_up(x)
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)

The set Q consists of the following terms:

   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_i_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(27) TransformationProof (SOUND)
By narrowing [LPAR04] the rule TOP(go_up(x)) -> TOP(reduce(x)) at position [0] we obtained the following new rules [LPAR04]:

   (TOP(go_up(f(x0, x1))) -> TOP(check_f(redex_f(x0, x1))),TOP(go_up(f(x0, x1))) -> TOP(check_f(redex_f(x0, x1))))
   (TOP(go_up(g(x0))) -> TOP(check_g(redex_g(x0))),TOP(go_up(g(x0))) -> TOP(check_g(redex_g(x0))))
   (TOP(go_up(h(x0, x1))) -> TOP(check_h(redex_h(x0, x1))),TOP(go_up(h(x0, x1))) -> TOP(check_h(redex_h(x0, x1))))
   (TOP(go_up(i(x0))) -> TOP(in_i_1(reduce(x0))),TOP(go_up(i(x0))) -> TOP(in_i_1(reduce(x0))))


----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(f(x0, x1))) -> TOP(check_f(redex_f(x0, x1)))
   TOP(go_up(g(x0))) -> TOP(check_g(redex_g(x0)))
   TOP(go_up(h(x0, x1))) -> TOP(check_h(redex_h(x0, x1)))
   TOP(go_up(i(x0))) -> TOP(in_i_1(reduce(x0)))

The TRS R consists of the following rules:

   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   redex_g(x) -> result_g(i(x))
   check_g(result_g(x)) -> go_up(x)
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)

The set Q consists of the following terms:

   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_i_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(29) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule TOP(go_up(g(x0))) -> TOP(check_g(redex_g(x0))) at position [0,0] we obtained the following new rules [LPAR04]:

   (TOP(go_up(g(x0))) -> TOP(check_g(result_g(i(x0)))),TOP(go_up(g(x0))) -> TOP(check_g(result_g(i(x0)))))


----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(f(x0, x1))) -> TOP(check_f(redex_f(x0, x1)))
   TOP(go_up(h(x0, x1))) -> TOP(check_h(redex_h(x0, x1)))
   TOP(go_up(i(x0))) -> TOP(in_i_1(reduce(x0)))
   TOP(go_up(g(x0))) -> TOP(check_g(result_g(i(x0))))

The TRS R consists of the following rules:

   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   redex_g(x) -> result_g(i(x))
   check_g(result_g(x)) -> go_up(x)
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)

The set Q consists of the following terms:

   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_i_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(31) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule TOP(go_up(g(x0))) -> TOP(check_g(result_g(i(x0)))) at position [0] we obtained the following new rules [LPAR04]:

   (TOP(go_up(g(x0))) -> TOP(go_up(i(x0))),TOP(go_up(g(x0))) -> TOP(go_up(i(x0))))


----------------------------------------

(32)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(f(x0, x1))) -> TOP(check_f(redex_f(x0, x1)))
   TOP(go_up(h(x0, x1))) -> TOP(check_h(redex_h(x0, x1)))
   TOP(go_up(i(x0))) -> TOP(in_i_1(reduce(x0)))
   TOP(go_up(g(x0))) -> TOP(go_up(i(x0)))

The TRS R consists of the following rules:

   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   redex_g(x) -> result_g(i(x))
   check_g(result_g(x)) -> go_up(x)
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)

The set Q consists of the following terms:

   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_i_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(33) TransformationProof (SOUND)
By narrowing [LPAR04] the rule TOP(go_up(f(x0, x1))) -> TOP(check_f(redex_f(x0, x1))) at position [0,0] we obtained the following new rules [LPAR04]:

   (TOP(go_up(f(x0, x0))) -> TOP(check_f(result_f(f(i(x0), g(g(x0)))))),TOP(go_up(f(x0, x0))) -> TOP(check_f(result_f(f(i(x0), g(g(x0)))))))
   (TOP(go_up(f(x0, i(x0)))) -> TOP(check_f(result_f(f(x0, x0)))),TOP(go_up(f(x0, i(x0)))) -> TOP(check_f(result_f(f(x0, x0)))))


----------------------------------------

(34)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(h(x0, x1))) -> TOP(check_h(redex_h(x0, x1)))
   TOP(go_up(i(x0))) -> TOP(in_i_1(reduce(x0)))
   TOP(go_up(g(x0))) -> TOP(go_up(i(x0)))
   TOP(go_up(f(x0, x0))) -> TOP(check_f(result_f(f(i(x0), g(g(x0))))))
   TOP(go_up(f(x0, i(x0)))) -> TOP(check_f(result_f(f(x0, x0))))

The TRS R consists of the following rules:

   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   redex_g(x) -> result_g(i(x))
   check_g(result_g(x)) -> go_up(x)
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)

The set Q consists of the following terms:

   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_i_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(35) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule TOP(go_up(f(x0, x0))) -> TOP(check_f(result_f(f(i(x0), g(g(x0)))))) at position [0] we obtained the following new rules [LPAR04]:

   (TOP(go_up(f(x0, x0))) -> TOP(go_up(f(i(x0), g(g(x0))))),TOP(go_up(f(x0, x0))) -> TOP(go_up(f(i(x0), g(g(x0))))))


----------------------------------------

(36)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(h(x0, x1))) -> TOP(check_h(redex_h(x0, x1)))
   TOP(go_up(i(x0))) -> TOP(in_i_1(reduce(x0)))
   TOP(go_up(g(x0))) -> TOP(go_up(i(x0)))
   TOP(go_up(f(x0, i(x0)))) -> TOP(check_f(result_f(f(x0, x0))))
   TOP(go_up(f(x0, x0))) -> TOP(go_up(f(i(x0), g(g(x0)))))

The TRS R consists of the following rules:

   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   redex_g(x) -> result_g(i(x))
   check_g(result_g(x)) -> go_up(x)
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)

The set Q consists of the following terms:

   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_i_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(37) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(38)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(h(x0, x1))) -> TOP(check_h(redex_h(x0, x1)))
   TOP(go_up(i(x0))) -> TOP(in_i_1(reduce(x0)))
   TOP(go_up(g(x0))) -> TOP(go_up(i(x0)))
   TOP(go_up(f(x0, i(x0)))) -> TOP(check_f(result_f(f(x0, x0))))

The TRS R consists of the following rules:

   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   redex_g(x) -> result_g(i(x))
   check_g(result_g(x)) -> go_up(x)
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)

The set Q consists of the following terms:

   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_i_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(39) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule TOP(go_up(f(x0, i(x0)))) -> TOP(check_f(result_f(f(x0, x0)))) at position [0] we obtained the following new rules [LPAR04]:

   (TOP(go_up(f(x0, i(x0)))) -> TOP(go_up(f(x0, x0))),TOP(go_up(f(x0, i(x0)))) -> TOP(go_up(f(x0, x0))))


----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(h(x0, x1))) -> TOP(check_h(redex_h(x0, x1)))
   TOP(go_up(i(x0))) -> TOP(in_i_1(reduce(x0)))
   TOP(go_up(g(x0))) -> TOP(go_up(i(x0)))
   TOP(go_up(f(x0, i(x0)))) -> TOP(go_up(f(x0, x0)))

The TRS R consists of the following rules:

   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   redex_g(x) -> result_g(i(x))
   check_g(result_g(x)) -> go_up(x)
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)

The set Q consists of the following terms:

   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_i_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(41) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(h(x0, x1))) -> TOP(check_h(redex_h(x0, x1)))
   TOP(go_up(i(x0))) -> TOP(in_i_1(reduce(x0)))
   TOP(go_up(g(x0))) -> TOP(go_up(i(x0)))

The TRS R consists of the following rules:

   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   redex_g(x) -> result_g(i(x))
   check_g(result_g(x)) -> go_up(x)
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)

The set Q consists of the following terms:

   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_i_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(43) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   TOP(go_up(g(x0))) -> TOP(go_up(i(x0)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial interpretation [POLO]:

   POL(TOP(x_1)) = x_1
   POL(check_f(x_1)) = 1
   POL(check_g(x_1)) = 1
   POL(check_h(x_1)) = 0
   POL(f(x_1, x_2)) = 0
   POL(g(x_1)) = 1
   POL(go_up(x_1)) = x_1
   POL(h(x_1, x_2)) = 0
   POL(i(x_1)) = 0
   POL(in_h_1(x_1, x_2)) = 0
   POL(in_h_2(x_1, x_2)) = 0
   POL(in_i_1(x_1)) = 0
   POL(redex_f(x_1, x_2)) = x_1
   POL(redex_g(x_1)) = 1 + x_1
   POL(redex_h(x_1, x_2)) = x_1 + x_2
   POL(reduce(x_1)) = 0
   POL(result_f(x_1)) = 0
   POL(result_g(x_1)) = 1 + x_1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))


----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(go_up(h(x0, x1))) -> TOP(check_h(redex_h(x0, x1)))
   TOP(go_up(i(x0))) -> TOP(in_i_1(reduce(x0)))

The TRS R consists of the following rules:

   reduce(f(x_1, x_2)) -> check_f(redex_f(x_1, x_2))
   reduce(g(x_1)) -> check_g(redex_g(x_1))
   reduce(h(x_1, x_2)) -> check_h(redex_h(x_1, x_2))
   reduce(i(x_1)) -> in_i_1(reduce(x_1))
   in_i_1(go_up(x_1)) -> go_up(i(x_1))
   check_h(redex_h(x_1, x_2)) -> in_h_1(reduce(x_1), x_2)
   check_h(redex_h(x_1, x_2)) -> in_h_2(x_1, reduce(x_2))
   in_h_2(x_1, go_up(x_2)) -> go_up(h(x_1, x_2))
   in_h_1(go_up(x_1), x_2) -> go_up(h(x_1, x_2))
   redex_g(x) -> result_g(i(x))
   check_g(result_g(x)) -> go_up(x)
   redex_f(x, x) -> result_f(f(i(x), g(g(x))))
   redex_f(x, i(x)) -> result_f(f(x, x))
   check_f(result_f(x)) -> go_up(x)

The set Q consists of the following terms:

   reduce(f(x0, x1))
   reduce(g(x0))
   reduce(h(x0, x1))
   redex_f(x0, x1)
   redex_g(x0)
   redex_h(x0, x0)
   check_f(result_f(x0))
   check_g(result_g(x0))
   check_h(result_h(x0))
   check_h(redex_h(x0, x1))
   reduce(i(x0))
   in_i_1(go_up(x0))
   in_h_1(go_up(x0), x1)
   in_h_2(x0, go_up(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(45) SemLabProof (SOUND)
We found the following model for the rules of the TRSs R and P.
Interpretation over the domain with elements from 0 to 1.
result_f: 0
result_h: 0
reduce: 0
in_i_1: 0
in_h_2: 0
redex_f: 0
check_f: 0
TOP: 0
in_h_1: 0
g: 0
go_up: 0
result_g: 0
check_h: 0
f: 0
redex_h: 0
i: 1
h: 0
check_g: 0
redex_g: 0
By semantic labelling [SEMLAB] we obtain the following labelled QDP problem.
----------------------------------------

(46)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP.0(go_up.0(h.0-0(x0, x1))) -> TOP.0(check_h.0(redex_h.0-0(x0, x1)))
   TOP.0(go_up.0(h.0-1(x0, x1))) -> TOP.0(check_h.0(redex_h.0-1(x0, x1)))
   TOP.0(go_up.0(h.1-0(x0, x1))) -> TOP.0(check_h.0(redex_h.1-0(x0, x1)))
   TOP.0(go_up.0(h.1-1(x0, x1))) -> TOP.0(check_h.0(redex_h.1-1(x0, x1)))
   TOP.0(go_up.1(i.0(x0))) -> TOP.0(in_i_1.0(reduce.0(x0)))
   TOP.0(go_up.1(i.1(x0))) -> TOP.0(in_i_1.0(reduce.1(x0)))

The TRS R consists of the following rules:

   reduce.0(f.0-0(x_1, x_2)) -> check_f.0(redex_f.0-0(x_1, x_2))
   reduce.0(f.0-1(x_1, x_2)) -> check_f.0(redex_f.0-1(x_1, x_2))
   reduce.0(f.1-0(x_1, x_2)) -> check_f.0(redex_f.1-0(x_1, x_2))
   reduce.0(f.1-1(x_1, x_2)) -> check_f.0(redex_f.1-1(x_1, x_2))
   reduce.0(g.0(x_1)) -> check_g.0(redex_g.0(x_1))
   reduce.0(g.1(x_1)) -> check_g.0(redex_g.1(x_1))
   reduce.0(h.0-0(x_1, x_2)) -> check_h.0(redex_h.0-0(x_1, x_2))
   reduce.0(h.0-1(x_1, x_2)) -> check_h.0(redex_h.0-1(x_1, x_2))
   reduce.0(h.1-0(x_1, x_2)) -> check_h.0(redex_h.1-0(x_1, x_2))
   reduce.0(h.1-1(x_1, x_2)) -> check_h.0(redex_h.1-1(x_1, x_2))
   reduce.1(i.0(x_1)) -> in_i_1.0(reduce.0(x_1))
   reduce.1(i.1(x_1)) -> in_i_1.0(reduce.1(x_1))
   in_i_1.0(go_up.0(x_1)) -> go_up.1(i.0(x_1))
   in_i_1.0(go_up.1(x_1)) -> go_up.1(i.1(x_1))
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_1.0-0(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_1.0-1(reduce.0(x_1), x_2)
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_1.0-0(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_1.0-1(reduce.1(x_1), x_2)
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.0(x_2))
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.1(x_2))
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.0(x_2))
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.1(x_2))
   in_h_2.0-0(x_1, go_up.0(x_2)) -> go_up.0(h.0-0(x_1, x_2))
   in_h_2.0-0(x_1, go_up.1(x_2)) -> go_up.0(h.0-1(x_1, x_2))
   in_h_2.1-0(x_1, go_up.0(x_2)) -> go_up.0(h.1-0(x_1, x_2))
   in_h_2.1-0(x_1, go_up.1(x_2)) -> go_up.0(h.1-1(x_1, x_2))
   in_h_1.0-0(go_up.0(x_1), x_2) -> go_up.0(h.0-0(x_1, x_2))
   in_h_1.0-1(go_up.0(x_1), x_2) -> go_up.0(h.0-1(x_1, x_2))
   in_h_1.0-0(go_up.1(x_1), x_2) -> go_up.0(h.1-0(x_1, x_2))
   in_h_1.0-1(go_up.1(x_1), x_2) -> go_up.0(h.1-1(x_1, x_2))
   redex_g.0(x) -> result_g.1(i.0(x))
   redex_g.1(x) -> result_g.1(i.1(x))
   check_g.0(result_g.0(x)) -> go_up.0(x)
   check_g.0(result_g.1(x)) -> go_up.1(x)
   redex_f.0-0(x, x) -> result_f.0(f.1-0(i.0(x), g.0(g.0(x))))
   redex_f.1-1(x, x) -> result_f.0(f.1-0(i.1(x), g.0(g.1(x))))
   redex_f.0-1(x, i.0(x)) -> result_f.0(f.0-0(x, x))
   redex_f.1-1(x, i.1(x)) -> result_f.0(f.1-1(x, x))
   check_f.0(result_f.0(x)) -> go_up.0(x)
   check_f.0(result_f.1(x)) -> go_up.1(x)

The set Q consists of the following terms:

   reduce.0(f.0-0(x0, x1))
   reduce.0(f.0-1(x0, x1))
   reduce.0(f.1-0(x0, x1))
   reduce.0(f.1-1(x0, x1))
   reduce.0(g.0(x0))
   reduce.0(g.1(x0))
   reduce.0(h.0-0(x0, x1))
   reduce.0(h.0-1(x0, x1))
   reduce.0(h.1-0(x0, x1))
   reduce.0(h.1-1(x0, x1))
   redex_f.0-0(x0, x1)
   redex_f.0-1(x0, x1)
   redex_f.1-0(x0, x1)
   redex_f.1-1(x0, x1)
   redex_g.0(x0)
   redex_g.1(x0)
   redex_h.0-0(x0, x0)
   redex_h.1-1(x0, x0)
   check_f.0(result_f.0(x0))
   check_f.0(result_f.1(x0))
   check_g.0(result_g.0(x0))
   check_g.0(result_g.1(x0))
   check_h.0(result_h.0(x0))
   check_h.0(result_h.1(x0))
   check_h.0(redex_h.0-0(x0, x1))
   check_h.0(redex_h.0-1(x0, x1))
   check_h.0(redex_h.1-0(x0, x1))
   check_h.0(redex_h.1-1(x0, x1))
   reduce.1(i.0(x0))
   reduce.1(i.1(x0))
   in_i_1.0(go_up.0(x0))
   in_i_1.0(go_up.1(x0))
   in_h_1.0-0(go_up.0(x0), x1)
   in_h_1.0-1(go_up.0(x0), x1)
   in_h_1.0-0(go_up.1(x0), x1)
   in_h_1.0-1(go_up.1(x0), x1)
   in_h_2.0-0(x0, go_up.0(x1))
   in_h_2.0-0(x0, go_up.1(x1))
   in_h_2.1-0(x0, go_up.0(x1))
   in_h_2.1-0(x0, go_up.1(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(47) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   reduce.0(f.0-1(x_1, x_2)) -> check_f.0(redex_f.0-1(x_1, x_2))
   redex_g.1(x) -> result_g.1(i.1(x))
   check_g.0(result_g.0(x)) -> go_up.0(x)
   redex_f.0-0(x, x) -> result_f.0(f.1-0(i.0(x), g.0(g.0(x))))
   check_f.0(result_f.1(x)) -> go_up.1(x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(TOP.0(x_1)) = x_1
   POL(check_f.0(x_1)) = x_1
   POL(check_g.0(x_1)) = x_1
   POL(check_h.0(x_1)) = x_1
   POL(f.0-0(x_1, x_2)) = 1 + x_1 + x_2
   POL(f.0-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(f.1-0(x_1, x_2)) = x_1 + x_2
   POL(f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(g.0(x_1)) = x_1
   POL(g.1(x_1)) = 1 + x_1
   POL(go_up.0(x_1)) = x_1
   POL(go_up.1(x_1)) = x_1
   POL(h.0-0(x_1, x_2)) = x_1 + x_2
   POL(h.0-1(x_1, x_2)) = x_1 + x_2
   POL(h.1-0(x_1, x_2)) = x_1 + x_2
   POL(h.1-1(x_1, x_2)) = x_1 + x_2
   POL(i.0(x_1)) = x_1
   POL(i.1(x_1)) = x_1
   POL(in_h_1.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_1.0-1(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.1-0(x_1, x_2)) = x_1 + x_2
   POL(in_i_1.0(x_1)) = x_1
   POL(redex_f.0-0(x_1, x_2)) = 1 + x_1 + x_2
   POL(redex_f.0-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(redex_f.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(redex_g.0(x_1)) = x_1
   POL(redex_g.1(x_1)) = 1 + x_1
   POL(redex_h.0-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.0-1(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-1(x_1, x_2)) = x_1 + x_2
   POL(reduce.0(x_1)) = x_1
   POL(reduce.1(x_1)) = x_1
   POL(result_f.0(x_1)) = x_1
   POL(result_f.1(x_1)) = x_1
   POL(result_g.0(x_1)) = x_1
   POL(result_g.1(x_1)) = x_1


----------------------------------------

(48)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP.0(go_up.0(h.0-0(x0, x1))) -> TOP.0(check_h.0(redex_h.0-0(x0, x1)))
   TOP.0(go_up.0(h.0-1(x0, x1))) -> TOP.0(check_h.0(redex_h.0-1(x0, x1)))
   TOP.0(go_up.0(h.1-0(x0, x1))) -> TOP.0(check_h.0(redex_h.1-0(x0, x1)))
   TOP.0(go_up.0(h.1-1(x0, x1))) -> TOP.0(check_h.0(redex_h.1-1(x0, x1)))
   TOP.0(go_up.1(i.0(x0))) -> TOP.0(in_i_1.0(reduce.0(x0)))
   TOP.0(go_up.1(i.1(x0))) -> TOP.0(in_i_1.0(reduce.1(x0)))

The TRS R consists of the following rules:

   reduce.1(i.0(x_1)) -> in_i_1.0(reduce.0(x_1))
   reduce.1(i.1(x_1)) -> in_i_1.0(reduce.1(x_1))
   in_i_1.0(go_up.0(x_1)) -> go_up.1(i.0(x_1))
   in_i_1.0(go_up.1(x_1)) -> go_up.1(i.1(x_1))
   reduce.0(f.0-0(x_1, x_2)) -> check_f.0(redex_f.0-0(x_1, x_2))
   reduce.0(f.1-0(x_1, x_2)) -> check_f.0(redex_f.1-0(x_1, x_2))
   reduce.0(f.1-1(x_1, x_2)) -> check_f.0(redex_f.1-1(x_1, x_2))
   reduce.0(g.0(x_1)) -> check_g.0(redex_g.0(x_1))
   reduce.0(g.1(x_1)) -> check_g.0(redex_g.1(x_1))
   reduce.0(h.0-0(x_1, x_2)) -> check_h.0(redex_h.0-0(x_1, x_2))
   reduce.0(h.0-1(x_1, x_2)) -> check_h.0(redex_h.0-1(x_1, x_2))
   reduce.0(h.1-0(x_1, x_2)) -> check_h.0(redex_h.1-0(x_1, x_2))
   reduce.0(h.1-1(x_1, x_2)) -> check_h.0(redex_h.1-1(x_1, x_2))
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_1.0-1(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.1(x_2))
   in_h_2.1-0(x_1, go_up.0(x_2)) -> go_up.0(h.1-0(x_1, x_2))
   in_h_2.1-0(x_1, go_up.1(x_2)) -> go_up.0(h.1-1(x_1, x_2))
   in_h_1.0-1(go_up.0(x_1), x_2) -> go_up.0(h.0-1(x_1, x_2))
   in_h_1.0-1(go_up.1(x_1), x_2) -> go_up.0(h.1-1(x_1, x_2))
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_1.0-0(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.0(x_2))
   in_h_1.0-0(go_up.0(x_1), x_2) -> go_up.0(h.0-0(x_1, x_2))
   in_h_1.0-0(go_up.1(x_1), x_2) -> go_up.0(h.1-0(x_1, x_2))
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_1.0-1(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.1(x_2))
   in_h_2.0-0(x_1, go_up.0(x_2)) -> go_up.0(h.0-0(x_1, x_2))
   in_h_2.0-0(x_1, go_up.1(x_2)) -> go_up.0(h.0-1(x_1, x_2))
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_1.0-0(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.0(x_2))
   check_g.0(result_g.1(x)) -> go_up.1(x)
   redex_g.0(x) -> result_g.1(i.0(x))
   redex_f.1-1(x, x) -> result_f.0(f.1-0(i.1(x), g.0(g.1(x))))
   redex_f.1-1(x, i.1(x)) -> result_f.0(f.1-1(x, x))
   check_f.0(result_f.0(x)) -> go_up.0(x)
   redex_f.0-1(x, i.0(x)) -> result_f.0(f.0-0(x, x))

The set Q consists of the following terms:

   reduce.0(f.0-0(x0, x1))
   reduce.0(f.0-1(x0, x1))
   reduce.0(f.1-0(x0, x1))
   reduce.0(f.1-1(x0, x1))
   reduce.0(g.0(x0))
   reduce.0(g.1(x0))
   reduce.0(h.0-0(x0, x1))
   reduce.0(h.0-1(x0, x1))
   reduce.0(h.1-0(x0, x1))
   reduce.0(h.1-1(x0, x1))
   redex_f.0-0(x0, x1)
   redex_f.0-1(x0, x1)
   redex_f.1-0(x0, x1)
   redex_f.1-1(x0, x1)
   redex_g.0(x0)
   redex_g.1(x0)
   redex_h.0-0(x0, x0)
   redex_h.1-1(x0, x0)
   check_f.0(result_f.0(x0))
   check_f.0(result_f.1(x0))
   check_g.0(result_g.0(x0))
   check_g.0(result_g.1(x0))
   check_h.0(result_h.0(x0))
   check_h.0(result_h.1(x0))
   check_h.0(redex_h.0-0(x0, x1))
   check_h.0(redex_h.0-1(x0, x1))
   check_h.0(redex_h.1-0(x0, x1))
   check_h.0(redex_h.1-1(x0, x1))
   reduce.1(i.0(x0))
   reduce.1(i.1(x0))
   in_i_1.0(go_up.0(x0))
   in_i_1.0(go_up.1(x0))
   in_h_1.0-0(go_up.0(x0), x1)
   in_h_1.0-1(go_up.0(x0), x1)
   in_h_1.0-0(go_up.1(x0), x1)
   in_h_1.0-1(go_up.1(x0), x1)
   in_h_2.0-0(x0, go_up.0(x1))
   in_h_2.0-0(x0, go_up.1(x1))
   in_h_2.1-0(x0, go_up.0(x1))
   in_h_2.1-0(x0, go_up.1(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(49) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   reduce.0(f.0-0(x_1, x_2)) -> check_f.0(redex_f.0-0(x_1, x_2))
   check_g.0(result_g.1(x)) -> go_up.1(x)
   redex_f.0-1(x, i.0(x)) -> result_f.0(f.0-0(x, x))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(TOP.0(x_1)) = x_1
   POL(check_f.0(x_1)) = x_1
   POL(check_g.0(x_1)) = x_1
   POL(check_h.0(x_1)) = x_1
   POL(f.0-0(x_1, x_2)) = 1 + x_1 + x_2
   POL(f.1-0(x_1, x_2)) = x_1 + x_2
   POL(f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(g.0(x_1)) = 1 + x_1
   POL(g.1(x_1)) = x_1
   POL(go_up.0(x_1)) = x_1
   POL(go_up.1(x_1)) = x_1
   POL(h.0-0(x_1, x_2)) = x_1 + x_2
   POL(h.0-1(x_1, x_2)) = x_1 + x_2
   POL(h.1-0(x_1, x_2)) = x_1 + x_2
   POL(h.1-1(x_1, x_2)) = x_1 + x_2
   POL(i.0(x_1)) = x_1
   POL(i.1(x_1)) = x_1
   POL(in_h_1.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_1.0-1(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.1-0(x_1, x_2)) = x_1 + x_2
   POL(in_i_1.0(x_1)) = x_1
   POL(redex_f.0-0(x_1, x_2)) = x_1 + x_2
   POL(redex_f.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(redex_g.0(x_1)) = 1 + x_1
   POL(redex_g.1(x_1)) = x_1
   POL(redex_h.0-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.0-1(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-1(x_1, x_2)) = x_1 + x_2
   POL(reduce.0(x_1)) = x_1
   POL(reduce.1(x_1)) = x_1
   POL(result_f.0(x_1)) = x_1
   POL(result_g.1(x_1)) = 1 + x_1


----------------------------------------

(50)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP.0(go_up.0(h.0-0(x0, x1))) -> TOP.0(check_h.0(redex_h.0-0(x0, x1)))
   TOP.0(go_up.0(h.0-1(x0, x1))) -> TOP.0(check_h.0(redex_h.0-1(x0, x1)))
   TOP.0(go_up.0(h.1-0(x0, x1))) -> TOP.0(check_h.0(redex_h.1-0(x0, x1)))
   TOP.0(go_up.0(h.1-1(x0, x1))) -> TOP.0(check_h.0(redex_h.1-1(x0, x1)))
   TOP.0(go_up.1(i.0(x0))) -> TOP.0(in_i_1.0(reduce.0(x0)))
   TOP.0(go_up.1(i.1(x0))) -> TOP.0(in_i_1.0(reduce.1(x0)))

The TRS R consists of the following rules:

   reduce.1(i.0(x_1)) -> in_i_1.0(reduce.0(x_1))
   reduce.1(i.1(x_1)) -> in_i_1.0(reduce.1(x_1))
   in_i_1.0(go_up.0(x_1)) -> go_up.1(i.0(x_1))
   in_i_1.0(go_up.1(x_1)) -> go_up.1(i.1(x_1))
   reduce.0(f.1-0(x_1, x_2)) -> check_f.0(redex_f.1-0(x_1, x_2))
   reduce.0(f.1-1(x_1, x_2)) -> check_f.0(redex_f.1-1(x_1, x_2))
   reduce.0(g.0(x_1)) -> check_g.0(redex_g.0(x_1))
   reduce.0(g.1(x_1)) -> check_g.0(redex_g.1(x_1))
   reduce.0(h.0-0(x_1, x_2)) -> check_h.0(redex_h.0-0(x_1, x_2))
   reduce.0(h.0-1(x_1, x_2)) -> check_h.0(redex_h.0-1(x_1, x_2))
   reduce.0(h.1-0(x_1, x_2)) -> check_h.0(redex_h.1-0(x_1, x_2))
   reduce.0(h.1-1(x_1, x_2)) -> check_h.0(redex_h.1-1(x_1, x_2))
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_1.0-1(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.1(x_2))
   in_h_2.1-0(x_1, go_up.0(x_2)) -> go_up.0(h.1-0(x_1, x_2))
   in_h_2.1-0(x_1, go_up.1(x_2)) -> go_up.0(h.1-1(x_1, x_2))
   in_h_1.0-1(go_up.0(x_1), x_2) -> go_up.0(h.0-1(x_1, x_2))
   in_h_1.0-1(go_up.1(x_1), x_2) -> go_up.0(h.1-1(x_1, x_2))
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_1.0-0(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.0(x_2))
   in_h_1.0-0(go_up.0(x_1), x_2) -> go_up.0(h.0-0(x_1, x_2))
   in_h_1.0-0(go_up.1(x_1), x_2) -> go_up.0(h.1-0(x_1, x_2))
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_1.0-1(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.1(x_2))
   in_h_2.0-0(x_1, go_up.0(x_2)) -> go_up.0(h.0-0(x_1, x_2))
   in_h_2.0-0(x_1, go_up.1(x_2)) -> go_up.0(h.0-1(x_1, x_2))
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_1.0-0(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.0(x_2))
   redex_g.0(x) -> result_g.1(i.0(x))
   redex_f.1-1(x, x) -> result_f.0(f.1-0(i.1(x), g.0(g.1(x))))
   redex_f.1-1(x, i.1(x)) -> result_f.0(f.1-1(x, x))
   check_f.0(result_f.0(x)) -> go_up.0(x)

The set Q consists of the following terms:

   reduce.0(f.0-0(x0, x1))
   reduce.0(f.0-1(x0, x1))
   reduce.0(f.1-0(x0, x1))
   reduce.0(f.1-1(x0, x1))
   reduce.0(g.0(x0))
   reduce.0(g.1(x0))
   reduce.0(h.0-0(x0, x1))
   reduce.0(h.0-1(x0, x1))
   reduce.0(h.1-0(x0, x1))
   reduce.0(h.1-1(x0, x1))
   redex_f.0-0(x0, x1)
   redex_f.0-1(x0, x1)
   redex_f.1-0(x0, x1)
   redex_f.1-1(x0, x1)
   redex_g.0(x0)
   redex_g.1(x0)
   redex_h.0-0(x0, x0)
   redex_h.1-1(x0, x0)
   check_f.0(result_f.0(x0))
   check_f.0(result_f.1(x0))
   check_g.0(result_g.0(x0))
   check_g.0(result_g.1(x0))
   check_h.0(result_h.0(x0))
   check_h.0(result_h.1(x0))
   check_h.0(redex_h.0-0(x0, x1))
   check_h.0(redex_h.0-1(x0, x1))
   check_h.0(redex_h.1-0(x0, x1))
   check_h.0(redex_h.1-1(x0, x1))
   reduce.1(i.0(x0))
   reduce.1(i.1(x0))
   in_i_1.0(go_up.0(x0))
   in_i_1.0(go_up.1(x0))
   in_h_1.0-0(go_up.0(x0), x1)
   in_h_1.0-1(go_up.0(x0), x1)
   in_h_1.0-0(go_up.1(x0), x1)
   in_h_1.0-1(go_up.1(x0), x1)
   in_h_2.0-0(x0, go_up.0(x1))
   in_h_2.0-0(x0, go_up.1(x1))
   in_h_2.1-0(x0, go_up.0(x1))
   in_h_2.1-0(x0, go_up.1(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(51) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   reduce.0(g.1(x_1)) -> check_g.0(redex_g.1(x_1))

Used ordering: Polynomial interpretation [POLO]:

   POL(TOP.0(x_1)) = x_1
   POL(check_f.0(x_1)) = x_1
   POL(check_g.0(x_1)) = x_1
   POL(check_h.0(x_1)) = x_1
   POL(f.1-0(x_1, x_2)) = x_1 + x_2
   POL(f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(g.0(x_1)) = x_1
   POL(g.1(x_1)) = 1 + x_1
   POL(go_up.0(x_1)) = x_1
   POL(go_up.1(x_1)) = x_1
   POL(h.0-0(x_1, x_2)) = x_1 + x_2
   POL(h.0-1(x_1, x_2)) = x_1 + x_2
   POL(h.1-0(x_1, x_2)) = x_1 + x_2
   POL(h.1-1(x_1, x_2)) = x_1 + x_2
   POL(i.0(x_1)) = x_1
   POL(i.1(x_1)) = x_1
   POL(in_h_1.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_1.0-1(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.1-0(x_1, x_2)) = x_1 + x_2
   POL(in_i_1.0(x_1)) = x_1
   POL(redex_f.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(redex_g.0(x_1)) = x_1
   POL(redex_g.1(x_1)) = x_1
   POL(redex_h.0-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.0-1(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-1(x_1, x_2)) = x_1 + x_2
   POL(reduce.0(x_1)) = x_1
   POL(reduce.1(x_1)) = x_1
   POL(result_f.0(x_1)) = x_1
   POL(result_g.1(x_1)) = x_1


----------------------------------------

(52)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP.0(go_up.0(h.0-0(x0, x1))) -> TOP.0(check_h.0(redex_h.0-0(x0, x1)))
   TOP.0(go_up.0(h.0-1(x0, x1))) -> TOP.0(check_h.0(redex_h.0-1(x0, x1)))
   TOP.0(go_up.0(h.1-0(x0, x1))) -> TOP.0(check_h.0(redex_h.1-0(x0, x1)))
   TOP.0(go_up.0(h.1-1(x0, x1))) -> TOP.0(check_h.0(redex_h.1-1(x0, x1)))
   TOP.0(go_up.1(i.0(x0))) -> TOP.0(in_i_1.0(reduce.0(x0)))
   TOP.0(go_up.1(i.1(x0))) -> TOP.0(in_i_1.0(reduce.1(x0)))

The TRS R consists of the following rules:

   reduce.1(i.0(x_1)) -> in_i_1.0(reduce.0(x_1))
   reduce.1(i.1(x_1)) -> in_i_1.0(reduce.1(x_1))
   in_i_1.0(go_up.0(x_1)) -> go_up.1(i.0(x_1))
   in_i_1.0(go_up.1(x_1)) -> go_up.1(i.1(x_1))
   reduce.0(f.1-0(x_1, x_2)) -> check_f.0(redex_f.1-0(x_1, x_2))
   reduce.0(f.1-1(x_1, x_2)) -> check_f.0(redex_f.1-1(x_1, x_2))
   reduce.0(g.0(x_1)) -> check_g.0(redex_g.0(x_1))
   reduce.0(h.0-0(x_1, x_2)) -> check_h.0(redex_h.0-0(x_1, x_2))
   reduce.0(h.0-1(x_1, x_2)) -> check_h.0(redex_h.0-1(x_1, x_2))
   reduce.0(h.1-0(x_1, x_2)) -> check_h.0(redex_h.1-0(x_1, x_2))
   reduce.0(h.1-1(x_1, x_2)) -> check_h.0(redex_h.1-1(x_1, x_2))
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_1.0-1(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.1(x_2))
   in_h_2.1-0(x_1, go_up.0(x_2)) -> go_up.0(h.1-0(x_1, x_2))
   in_h_2.1-0(x_1, go_up.1(x_2)) -> go_up.0(h.1-1(x_1, x_2))
   in_h_1.0-1(go_up.0(x_1), x_2) -> go_up.0(h.0-1(x_1, x_2))
   in_h_1.0-1(go_up.1(x_1), x_2) -> go_up.0(h.1-1(x_1, x_2))
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_1.0-0(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.0(x_2))
   in_h_1.0-0(go_up.0(x_1), x_2) -> go_up.0(h.0-0(x_1, x_2))
   in_h_1.0-0(go_up.1(x_1), x_2) -> go_up.0(h.1-0(x_1, x_2))
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_1.0-1(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.1(x_2))
   in_h_2.0-0(x_1, go_up.0(x_2)) -> go_up.0(h.0-0(x_1, x_2))
   in_h_2.0-0(x_1, go_up.1(x_2)) -> go_up.0(h.0-1(x_1, x_2))
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_1.0-0(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.0(x_2))
   redex_g.0(x) -> result_g.1(i.0(x))
   redex_f.1-1(x, x) -> result_f.0(f.1-0(i.1(x), g.0(g.1(x))))
   redex_f.1-1(x, i.1(x)) -> result_f.0(f.1-1(x, x))
   check_f.0(result_f.0(x)) -> go_up.0(x)

The set Q consists of the following terms:

   reduce.0(f.0-0(x0, x1))
   reduce.0(f.0-1(x0, x1))
   reduce.0(f.1-0(x0, x1))
   reduce.0(f.1-1(x0, x1))
   reduce.0(g.0(x0))
   reduce.0(g.1(x0))
   reduce.0(h.0-0(x0, x1))
   reduce.0(h.0-1(x0, x1))
   reduce.0(h.1-0(x0, x1))
   reduce.0(h.1-1(x0, x1))
   redex_f.0-0(x0, x1)
   redex_f.0-1(x0, x1)
   redex_f.1-0(x0, x1)
   redex_f.1-1(x0, x1)
   redex_g.0(x0)
   redex_g.1(x0)
   redex_h.0-0(x0, x0)
   redex_h.1-1(x0, x0)
   check_f.0(result_f.0(x0))
   check_f.0(result_f.1(x0))
   check_g.0(result_g.0(x0))
   check_g.0(result_g.1(x0))
   check_h.0(result_h.0(x0))
   check_h.0(result_h.1(x0))
   check_h.0(redex_h.0-0(x0, x1))
   check_h.0(redex_h.0-1(x0, x1))
   check_h.0(redex_h.1-0(x0, x1))
   check_h.0(redex_h.1-1(x0, x1))
   reduce.1(i.0(x0))
   reduce.1(i.1(x0))
   in_i_1.0(go_up.0(x0))
   in_i_1.0(go_up.1(x0))
   in_h_1.0-0(go_up.0(x0), x1)
   in_h_1.0-1(go_up.0(x0), x1)
   in_h_1.0-0(go_up.1(x0), x1)
   in_h_1.0-1(go_up.1(x0), x1)
   in_h_2.0-0(x0, go_up.0(x1))
   in_h_2.0-0(x0, go_up.1(x1))
   in_h_2.1-0(x0, go_up.0(x1))
   in_h_2.1-0(x0, go_up.1(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(53) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   reduce.0(g.0(x_1)) -> check_g.0(redex_g.0(x_1))

Used ordering: Polynomial interpretation [POLO]:

   POL(TOP.0(x_1)) = x_1
   POL(check_f.0(x_1)) = x_1
   POL(check_g.0(x_1)) = x_1
   POL(check_h.0(x_1)) = x_1
   POL(f.1-0(x_1, x_2)) = x_1 + x_2
   POL(f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(g.0(x_1)) = 1 + x_1
   POL(g.1(x_1)) = x_1
   POL(go_up.0(x_1)) = x_1
   POL(go_up.1(x_1)) = x_1
   POL(h.0-0(x_1, x_2)) = x_1 + x_2
   POL(h.0-1(x_1, x_2)) = x_1 + x_2
   POL(h.1-0(x_1, x_2)) = x_1 + x_2
   POL(h.1-1(x_1, x_2)) = x_1 + x_2
   POL(i.0(x_1)) = x_1
   POL(i.1(x_1)) = x_1
   POL(in_h_1.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_1.0-1(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.1-0(x_1, x_2)) = x_1 + x_2
   POL(in_i_1.0(x_1)) = x_1
   POL(redex_f.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(redex_g.0(x_1)) = x_1
   POL(redex_h.0-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.0-1(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-1(x_1, x_2)) = x_1 + x_2
   POL(reduce.0(x_1)) = x_1
   POL(reduce.1(x_1)) = x_1
   POL(result_f.0(x_1)) = x_1
   POL(result_g.1(x_1)) = x_1


----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP.0(go_up.0(h.0-0(x0, x1))) -> TOP.0(check_h.0(redex_h.0-0(x0, x1)))
   TOP.0(go_up.0(h.0-1(x0, x1))) -> TOP.0(check_h.0(redex_h.0-1(x0, x1)))
   TOP.0(go_up.0(h.1-0(x0, x1))) -> TOP.0(check_h.0(redex_h.1-0(x0, x1)))
   TOP.0(go_up.0(h.1-1(x0, x1))) -> TOP.0(check_h.0(redex_h.1-1(x0, x1)))
   TOP.0(go_up.1(i.0(x0))) -> TOP.0(in_i_1.0(reduce.0(x0)))
   TOP.0(go_up.1(i.1(x0))) -> TOP.0(in_i_1.0(reduce.1(x0)))

The TRS R consists of the following rules:

   reduce.1(i.0(x_1)) -> in_i_1.0(reduce.0(x_1))
   reduce.1(i.1(x_1)) -> in_i_1.0(reduce.1(x_1))
   in_i_1.0(go_up.0(x_1)) -> go_up.1(i.0(x_1))
   in_i_1.0(go_up.1(x_1)) -> go_up.1(i.1(x_1))
   reduce.0(f.1-0(x_1, x_2)) -> check_f.0(redex_f.1-0(x_1, x_2))
   reduce.0(f.1-1(x_1, x_2)) -> check_f.0(redex_f.1-1(x_1, x_2))
   reduce.0(h.0-0(x_1, x_2)) -> check_h.0(redex_h.0-0(x_1, x_2))
   reduce.0(h.0-1(x_1, x_2)) -> check_h.0(redex_h.0-1(x_1, x_2))
   reduce.0(h.1-0(x_1, x_2)) -> check_h.0(redex_h.1-0(x_1, x_2))
   reduce.0(h.1-1(x_1, x_2)) -> check_h.0(redex_h.1-1(x_1, x_2))
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_1.0-1(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.1(x_2))
   in_h_2.1-0(x_1, go_up.0(x_2)) -> go_up.0(h.1-0(x_1, x_2))
   in_h_2.1-0(x_1, go_up.1(x_2)) -> go_up.0(h.1-1(x_1, x_2))
   in_h_1.0-1(go_up.0(x_1), x_2) -> go_up.0(h.0-1(x_1, x_2))
   in_h_1.0-1(go_up.1(x_1), x_2) -> go_up.0(h.1-1(x_1, x_2))
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_1.0-0(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.0(x_2))
   in_h_1.0-0(go_up.0(x_1), x_2) -> go_up.0(h.0-0(x_1, x_2))
   in_h_1.0-0(go_up.1(x_1), x_2) -> go_up.0(h.1-0(x_1, x_2))
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_1.0-1(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.1(x_2))
   in_h_2.0-0(x_1, go_up.0(x_2)) -> go_up.0(h.0-0(x_1, x_2))
   in_h_2.0-0(x_1, go_up.1(x_2)) -> go_up.0(h.0-1(x_1, x_2))
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_1.0-0(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.0(x_2))
   redex_g.0(x) -> result_g.1(i.0(x))
   redex_f.1-1(x, x) -> result_f.0(f.1-0(i.1(x), g.0(g.1(x))))
   redex_f.1-1(x, i.1(x)) -> result_f.0(f.1-1(x, x))
   check_f.0(result_f.0(x)) -> go_up.0(x)

The set Q consists of the following terms:

   reduce.0(f.0-0(x0, x1))
   reduce.0(f.0-1(x0, x1))
   reduce.0(f.1-0(x0, x1))
   reduce.0(f.1-1(x0, x1))
   reduce.0(g.0(x0))
   reduce.0(g.1(x0))
   reduce.0(h.0-0(x0, x1))
   reduce.0(h.0-1(x0, x1))
   reduce.0(h.1-0(x0, x1))
   reduce.0(h.1-1(x0, x1))
   redex_f.0-0(x0, x1)
   redex_f.0-1(x0, x1)
   redex_f.1-0(x0, x1)
   redex_f.1-1(x0, x1)
   redex_g.0(x0)
   redex_g.1(x0)
   redex_h.0-0(x0, x0)
   redex_h.1-1(x0, x0)
   check_f.0(result_f.0(x0))
   check_f.0(result_f.1(x0))
   check_g.0(result_g.0(x0))
   check_g.0(result_g.1(x0))
   check_h.0(result_h.0(x0))
   check_h.0(result_h.1(x0))
   check_h.0(redex_h.0-0(x0, x1))
   check_h.0(redex_h.0-1(x0, x1))
   check_h.0(redex_h.1-0(x0, x1))
   check_h.0(redex_h.1-1(x0, x1))
   reduce.1(i.0(x0))
   reduce.1(i.1(x0))
   in_i_1.0(go_up.0(x0))
   in_i_1.0(go_up.1(x0))
   in_h_1.0-0(go_up.0(x0), x1)
   in_h_1.0-1(go_up.0(x0), x1)
   in_h_1.0-0(go_up.1(x0), x1)
   in_h_1.0-1(go_up.1(x0), x1)
   in_h_2.0-0(x0, go_up.0(x1))
   in_h_2.0-0(x0, go_up.1(x1))
   in_h_2.1-0(x0, go_up.0(x1))
   in_h_2.1-0(x0, go_up.1(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(55) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   reduce.0(f.1-0(x_1, x_2)) -> check_f.0(redex_f.1-0(x_1, x_2))
   redex_g.0(x) -> result_g.1(i.0(x))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(TOP.0(x_1)) = x_1
   POL(check_f.0(x_1)) = x_1
   POL(check_h.0(x_1)) = x_1
   POL(f.1-0(x_1, x_2)) = 1 + x_1 + x_2
   POL(f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(g.0(x_1)) = x_1
   POL(g.1(x_1)) = x_1
   POL(go_up.0(x_1)) = x_1
   POL(go_up.1(x_1)) = x_1
   POL(h.0-0(x_1, x_2)) = x_1 + x_2
   POL(h.0-1(x_1, x_2)) = x_1 + x_2
   POL(h.1-0(x_1, x_2)) = x_1 + x_2
   POL(h.1-1(x_1, x_2)) = x_1 + x_2
   POL(i.0(x_1)) = x_1
   POL(i.1(x_1)) = x_1
   POL(in_h_1.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_1.0-1(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.1-0(x_1, x_2)) = x_1 + x_2
   POL(in_i_1.0(x_1)) = x_1
   POL(redex_f.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(redex_h.0-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.0-1(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-1(x_1, x_2)) = x_1 + x_2
   POL(reduce.0(x_1)) = x_1
   POL(reduce.1(x_1)) = x_1
   POL(result_f.0(x_1)) = x_1


----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP.0(go_up.0(h.0-0(x0, x1))) -> TOP.0(check_h.0(redex_h.0-0(x0, x1)))
   TOP.0(go_up.0(h.0-1(x0, x1))) -> TOP.0(check_h.0(redex_h.0-1(x0, x1)))
   TOP.0(go_up.0(h.1-0(x0, x1))) -> TOP.0(check_h.0(redex_h.1-0(x0, x1)))
   TOP.0(go_up.0(h.1-1(x0, x1))) -> TOP.0(check_h.0(redex_h.1-1(x0, x1)))
   TOP.0(go_up.1(i.0(x0))) -> TOP.0(in_i_1.0(reduce.0(x0)))
   TOP.0(go_up.1(i.1(x0))) -> TOP.0(in_i_1.0(reduce.1(x0)))

The TRS R consists of the following rules:

   reduce.1(i.0(x_1)) -> in_i_1.0(reduce.0(x_1))
   reduce.1(i.1(x_1)) -> in_i_1.0(reduce.1(x_1))
   in_i_1.0(go_up.0(x_1)) -> go_up.1(i.0(x_1))
   in_i_1.0(go_up.1(x_1)) -> go_up.1(i.1(x_1))
   reduce.0(f.1-1(x_1, x_2)) -> check_f.0(redex_f.1-1(x_1, x_2))
   reduce.0(h.0-0(x_1, x_2)) -> check_h.0(redex_h.0-0(x_1, x_2))
   reduce.0(h.0-1(x_1, x_2)) -> check_h.0(redex_h.0-1(x_1, x_2))
   reduce.0(h.1-0(x_1, x_2)) -> check_h.0(redex_h.1-0(x_1, x_2))
   reduce.0(h.1-1(x_1, x_2)) -> check_h.0(redex_h.1-1(x_1, x_2))
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_1.0-1(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.1(x_2))
   in_h_2.1-0(x_1, go_up.0(x_2)) -> go_up.0(h.1-0(x_1, x_2))
   in_h_2.1-0(x_1, go_up.1(x_2)) -> go_up.0(h.1-1(x_1, x_2))
   in_h_1.0-1(go_up.0(x_1), x_2) -> go_up.0(h.0-1(x_1, x_2))
   in_h_1.0-1(go_up.1(x_1), x_2) -> go_up.0(h.1-1(x_1, x_2))
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_1.0-0(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.0(x_2))
   in_h_1.0-0(go_up.0(x_1), x_2) -> go_up.0(h.0-0(x_1, x_2))
   in_h_1.0-0(go_up.1(x_1), x_2) -> go_up.0(h.1-0(x_1, x_2))
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_1.0-1(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.1(x_2))
   in_h_2.0-0(x_1, go_up.0(x_2)) -> go_up.0(h.0-0(x_1, x_2))
   in_h_2.0-0(x_1, go_up.1(x_2)) -> go_up.0(h.0-1(x_1, x_2))
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_1.0-0(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.0(x_2))
   redex_f.1-1(x, x) -> result_f.0(f.1-0(i.1(x), g.0(g.1(x))))
   redex_f.1-1(x, i.1(x)) -> result_f.0(f.1-1(x, x))
   check_f.0(result_f.0(x)) -> go_up.0(x)

The set Q consists of the following terms:

   reduce.0(f.0-0(x0, x1))
   reduce.0(f.0-1(x0, x1))
   reduce.0(f.1-0(x0, x1))
   reduce.0(f.1-1(x0, x1))
   reduce.0(g.0(x0))
   reduce.0(g.1(x0))
   reduce.0(h.0-0(x0, x1))
   reduce.0(h.0-1(x0, x1))
   reduce.0(h.1-0(x0, x1))
   reduce.0(h.1-1(x0, x1))
   redex_f.0-0(x0, x1)
   redex_f.0-1(x0, x1)
   redex_f.1-0(x0, x1)
   redex_f.1-1(x0, x1)
   redex_g.0(x0)
   redex_g.1(x0)
   redex_h.0-0(x0, x0)
   redex_h.1-1(x0, x0)
   check_f.0(result_f.0(x0))
   check_f.0(result_f.1(x0))
   check_g.0(result_g.0(x0))
   check_g.0(result_g.1(x0))
   check_h.0(result_h.0(x0))
   check_h.0(result_h.1(x0))
   check_h.0(redex_h.0-0(x0, x1))
   check_h.0(redex_h.0-1(x0, x1))
   check_h.0(redex_h.1-0(x0, x1))
   check_h.0(redex_h.1-1(x0, x1))
   reduce.1(i.0(x0))
   reduce.1(i.1(x0))
   in_i_1.0(go_up.0(x0))
   in_i_1.0(go_up.1(x0))
   in_h_1.0-0(go_up.0(x0), x1)
   in_h_1.0-1(go_up.0(x0), x1)
   in_h_1.0-0(go_up.1(x0), x1)
   in_h_1.0-1(go_up.1(x0), x1)
   in_h_2.0-0(x0, go_up.0(x1))
   in_h_2.0-0(x0, go_up.1(x1))
   in_h_2.1-0(x0, go_up.0(x1))
   in_h_2.1-0(x0, go_up.1(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(57) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   redex_f.1-1(x, i.1(x)) -> result_f.0(f.1-1(x, x))

Used ordering: Polynomial interpretation [POLO]:

   POL(TOP.0(x_1)) = x_1
   POL(check_f.0(x_1)) = x_1
   POL(check_h.0(x_1)) = x_1
   POL(f.1-0(x_1, x_2)) = x_1 + x_2
   POL(f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(g.0(x_1)) = x_1
   POL(g.1(x_1)) = x_1
   POL(go_up.0(x_1)) = x_1
   POL(go_up.1(x_1)) = x_1
   POL(h.0-0(x_1, x_2)) = x_1 + x_2
   POL(h.0-1(x_1, x_2)) = x_1 + x_2
   POL(h.1-0(x_1, x_2)) = x_1 + x_2
   POL(h.1-1(x_1, x_2)) = x_1 + x_2
   POL(i.0(x_1)) = 1 + x_1
   POL(i.1(x_1)) = 1 + x_1
   POL(in_h_1.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_1.0-1(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.1-0(x_1, x_2)) = x_1 + x_2
   POL(in_i_1.0(x_1)) = 1 + x_1
   POL(redex_f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(redex_h.0-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.0-1(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-1(x_1, x_2)) = x_1 + x_2
   POL(reduce.0(x_1)) = x_1
   POL(reduce.1(x_1)) = x_1
   POL(result_f.0(x_1)) = x_1


----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP.0(go_up.0(h.0-0(x0, x1))) -> TOP.0(check_h.0(redex_h.0-0(x0, x1)))
   TOP.0(go_up.0(h.0-1(x0, x1))) -> TOP.0(check_h.0(redex_h.0-1(x0, x1)))
   TOP.0(go_up.0(h.1-0(x0, x1))) -> TOP.0(check_h.0(redex_h.1-0(x0, x1)))
   TOP.0(go_up.0(h.1-1(x0, x1))) -> TOP.0(check_h.0(redex_h.1-1(x0, x1)))
   TOP.0(go_up.1(i.0(x0))) -> TOP.0(in_i_1.0(reduce.0(x0)))
   TOP.0(go_up.1(i.1(x0))) -> TOP.0(in_i_1.0(reduce.1(x0)))

The TRS R consists of the following rules:

   reduce.1(i.0(x_1)) -> in_i_1.0(reduce.0(x_1))
   reduce.1(i.1(x_1)) -> in_i_1.0(reduce.1(x_1))
   in_i_1.0(go_up.0(x_1)) -> go_up.1(i.0(x_1))
   in_i_1.0(go_up.1(x_1)) -> go_up.1(i.1(x_1))
   reduce.0(f.1-1(x_1, x_2)) -> check_f.0(redex_f.1-1(x_1, x_2))
   reduce.0(h.0-0(x_1, x_2)) -> check_h.0(redex_h.0-0(x_1, x_2))
   reduce.0(h.0-1(x_1, x_2)) -> check_h.0(redex_h.0-1(x_1, x_2))
   reduce.0(h.1-0(x_1, x_2)) -> check_h.0(redex_h.1-0(x_1, x_2))
   reduce.0(h.1-1(x_1, x_2)) -> check_h.0(redex_h.1-1(x_1, x_2))
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_1.0-1(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.1(x_2))
   in_h_2.1-0(x_1, go_up.0(x_2)) -> go_up.0(h.1-0(x_1, x_2))
   in_h_2.1-0(x_1, go_up.1(x_2)) -> go_up.0(h.1-1(x_1, x_2))
   in_h_1.0-1(go_up.0(x_1), x_2) -> go_up.0(h.0-1(x_1, x_2))
   in_h_1.0-1(go_up.1(x_1), x_2) -> go_up.0(h.1-1(x_1, x_2))
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_1.0-0(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.0(x_2))
   in_h_1.0-0(go_up.0(x_1), x_2) -> go_up.0(h.0-0(x_1, x_2))
   in_h_1.0-0(go_up.1(x_1), x_2) -> go_up.0(h.1-0(x_1, x_2))
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_1.0-1(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.1(x_2))
   in_h_2.0-0(x_1, go_up.0(x_2)) -> go_up.0(h.0-0(x_1, x_2))
   in_h_2.0-0(x_1, go_up.1(x_2)) -> go_up.0(h.0-1(x_1, x_2))
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_1.0-0(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.0(x_2))
   redex_f.1-1(x, x) -> result_f.0(f.1-0(i.1(x), g.0(g.1(x))))
   check_f.0(result_f.0(x)) -> go_up.0(x)

The set Q consists of the following terms:

   reduce.0(f.0-0(x0, x1))
   reduce.0(f.0-1(x0, x1))
   reduce.0(f.1-0(x0, x1))
   reduce.0(f.1-1(x0, x1))
   reduce.0(g.0(x0))
   reduce.0(g.1(x0))
   reduce.0(h.0-0(x0, x1))
   reduce.0(h.0-1(x0, x1))
   reduce.0(h.1-0(x0, x1))
   reduce.0(h.1-1(x0, x1))
   redex_f.0-0(x0, x1)
   redex_f.0-1(x0, x1)
   redex_f.1-0(x0, x1)
   redex_f.1-1(x0, x1)
   redex_g.0(x0)
   redex_g.1(x0)
   redex_h.0-0(x0, x0)
   redex_h.1-1(x0, x0)
   check_f.0(result_f.0(x0))
   check_f.0(result_f.1(x0))
   check_g.0(result_g.0(x0))
   check_g.0(result_g.1(x0))
   check_h.0(result_h.0(x0))
   check_h.0(result_h.1(x0))
   check_h.0(redex_h.0-0(x0, x1))
   check_h.0(redex_h.0-1(x0, x1))
   check_h.0(redex_h.1-0(x0, x1))
   check_h.0(redex_h.1-1(x0, x1))
   reduce.1(i.0(x0))
   reduce.1(i.1(x0))
   in_i_1.0(go_up.0(x0))
   in_i_1.0(go_up.1(x0))
   in_h_1.0-0(go_up.0(x0), x1)
   in_h_1.0-1(go_up.0(x0), x1)
   in_h_1.0-0(go_up.1(x0), x1)
   in_h_1.0-1(go_up.1(x0), x1)
   in_h_2.0-0(x0, go_up.0(x1))
   in_h_2.0-0(x0, go_up.1(x1))
   in_h_2.1-0(x0, go_up.0(x1))
   in_h_2.1-0(x0, go_up.1(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(59) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   reduce.0(f.1-1(x_1, x_2)) -> check_f.0(redex_f.1-1(x_1, x_2))
   check_f.0(result_f.0(x)) -> go_up.0(x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(TOP.0(x_1)) = x_1
   POL(check_f.0(x_1)) = x_1
   POL(check_h.0(x_1)) = x_1
   POL(f.1-0(x_1, x_2)) = x_1 + x_2
   POL(f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(g.0(x_1)) = x_1
   POL(g.1(x_1)) = x_1
   POL(go_up.0(x_1)) = x_1
   POL(go_up.1(x_1)) = x_1
   POL(h.0-0(x_1, x_2)) = x_1 + x_2
   POL(h.0-1(x_1, x_2)) = x_1 + x_2
   POL(h.1-0(x_1, x_2)) = x_1 + x_2
   POL(h.1-1(x_1, x_2)) = x_1 + x_2
   POL(i.0(x_1)) = x_1
   POL(i.1(x_1)) = x_1
   POL(in_h_1.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_1.0-1(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.1-0(x_1, x_2)) = x_1 + x_2
   POL(in_i_1.0(x_1)) = x_1
   POL(redex_f.1-1(x_1, x_2)) = 1 + x_1 + x_2
   POL(redex_h.0-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.0-1(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-1(x_1, x_2)) = x_1 + x_2
   POL(reduce.0(x_1)) = x_1
   POL(reduce.1(x_1)) = x_1
   POL(result_f.0(x_1)) = 1 + x_1


----------------------------------------

(60)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP.0(go_up.0(h.0-0(x0, x1))) -> TOP.0(check_h.0(redex_h.0-0(x0, x1)))
   TOP.0(go_up.0(h.0-1(x0, x1))) -> TOP.0(check_h.0(redex_h.0-1(x0, x1)))
   TOP.0(go_up.0(h.1-0(x0, x1))) -> TOP.0(check_h.0(redex_h.1-0(x0, x1)))
   TOP.0(go_up.0(h.1-1(x0, x1))) -> TOP.0(check_h.0(redex_h.1-1(x0, x1)))
   TOP.0(go_up.1(i.0(x0))) -> TOP.0(in_i_1.0(reduce.0(x0)))
   TOP.0(go_up.1(i.1(x0))) -> TOP.0(in_i_1.0(reduce.1(x0)))

The TRS R consists of the following rules:

   reduce.1(i.0(x_1)) -> in_i_1.0(reduce.0(x_1))
   reduce.1(i.1(x_1)) -> in_i_1.0(reduce.1(x_1))
   in_i_1.0(go_up.0(x_1)) -> go_up.1(i.0(x_1))
   in_i_1.0(go_up.1(x_1)) -> go_up.1(i.1(x_1))
   reduce.0(h.0-0(x_1, x_2)) -> check_h.0(redex_h.0-0(x_1, x_2))
   reduce.0(h.0-1(x_1, x_2)) -> check_h.0(redex_h.0-1(x_1, x_2))
   reduce.0(h.1-0(x_1, x_2)) -> check_h.0(redex_h.1-0(x_1, x_2))
   reduce.0(h.1-1(x_1, x_2)) -> check_h.0(redex_h.1-1(x_1, x_2))
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_1.0-1(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.1(x_2))
   in_h_2.1-0(x_1, go_up.0(x_2)) -> go_up.0(h.1-0(x_1, x_2))
   in_h_2.1-0(x_1, go_up.1(x_2)) -> go_up.0(h.1-1(x_1, x_2))
   in_h_1.0-1(go_up.0(x_1), x_2) -> go_up.0(h.0-1(x_1, x_2))
   in_h_1.0-1(go_up.1(x_1), x_2) -> go_up.0(h.1-1(x_1, x_2))
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_1.0-0(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.0(x_2))
   in_h_1.0-0(go_up.0(x_1), x_2) -> go_up.0(h.0-0(x_1, x_2))
   in_h_1.0-0(go_up.1(x_1), x_2) -> go_up.0(h.1-0(x_1, x_2))
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_1.0-1(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.1(x_2))
   in_h_2.0-0(x_1, go_up.0(x_2)) -> go_up.0(h.0-0(x_1, x_2))
   in_h_2.0-0(x_1, go_up.1(x_2)) -> go_up.0(h.0-1(x_1, x_2))
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_1.0-0(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.0(x_2))
   redex_f.1-1(x, x) -> result_f.0(f.1-0(i.1(x), g.0(g.1(x))))

The set Q consists of the following terms:

   reduce.0(f.0-0(x0, x1))
   reduce.0(f.0-1(x0, x1))
   reduce.0(f.1-0(x0, x1))
   reduce.0(f.1-1(x0, x1))
   reduce.0(g.0(x0))
   reduce.0(g.1(x0))
   reduce.0(h.0-0(x0, x1))
   reduce.0(h.0-1(x0, x1))
   reduce.0(h.1-0(x0, x1))
   reduce.0(h.1-1(x0, x1))
   redex_f.0-0(x0, x1)
   redex_f.0-1(x0, x1)
   redex_f.1-0(x0, x1)
   redex_f.1-1(x0, x1)
   redex_g.0(x0)
   redex_g.1(x0)
   redex_h.0-0(x0, x0)
   redex_h.1-1(x0, x0)
   check_f.0(result_f.0(x0))
   check_f.0(result_f.1(x0))
   check_g.0(result_g.0(x0))
   check_g.0(result_g.1(x0))
   check_h.0(result_h.0(x0))
   check_h.0(result_h.1(x0))
   check_h.0(redex_h.0-0(x0, x1))
   check_h.0(redex_h.0-1(x0, x1))
   check_h.0(redex_h.1-0(x0, x1))
   check_h.0(redex_h.1-1(x0, x1))
   reduce.1(i.0(x0))
   reduce.1(i.1(x0))
   in_i_1.0(go_up.0(x0))
   in_i_1.0(go_up.1(x0))
   in_h_1.0-0(go_up.0(x0), x1)
   in_h_1.0-1(go_up.0(x0), x1)
   in_h_1.0-0(go_up.1(x0), x1)
   in_h_1.0-1(go_up.1(x0), x1)
   in_h_2.0-0(x0, go_up.0(x1))
   in_h_2.0-0(x0, go_up.1(x1))
   in_h_2.1-0(x0, go_up.0(x1))
   in_h_2.1-0(x0, go_up.1(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(61) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   redex_f.1-1(x, x) -> result_f.0(f.1-0(i.1(x), g.0(g.1(x))))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(TOP.0(x_1)) = x_1
   POL(check_h.0(x_1)) = x_1
   POL(go_up.0(x_1)) = x_1
   POL(go_up.1(x_1)) = x_1
   POL(h.0-0(x_1, x_2)) = x_1 + x_2
   POL(h.0-1(x_1, x_2)) = x_1 + x_2
   POL(h.1-0(x_1, x_2)) = x_1 + x_2
   POL(h.1-1(x_1, x_2)) = x_1 + x_2
   POL(i.0(x_1)) = x_1
   POL(i.1(x_1)) = x_1
   POL(in_h_1.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_1.0-1(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.1-0(x_1, x_2)) = x_1 + x_2
   POL(in_i_1.0(x_1)) = x_1
   POL(redex_h.0-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.0-1(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-1(x_1, x_2)) = x_1 + x_2
   POL(reduce.0(x_1)) = x_1
   POL(reduce.1(x_1)) = x_1


----------------------------------------

(62)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP.0(go_up.0(h.0-0(x0, x1))) -> TOP.0(check_h.0(redex_h.0-0(x0, x1)))
   TOP.0(go_up.0(h.0-1(x0, x1))) -> TOP.0(check_h.0(redex_h.0-1(x0, x1)))
   TOP.0(go_up.0(h.1-0(x0, x1))) -> TOP.0(check_h.0(redex_h.1-0(x0, x1)))
   TOP.0(go_up.0(h.1-1(x0, x1))) -> TOP.0(check_h.0(redex_h.1-1(x0, x1)))
   TOP.0(go_up.1(i.0(x0))) -> TOP.0(in_i_1.0(reduce.0(x0)))
   TOP.0(go_up.1(i.1(x0))) -> TOP.0(in_i_1.0(reduce.1(x0)))

The TRS R consists of the following rules:

   reduce.1(i.0(x_1)) -> in_i_1.0(reduce.0(x_1))
   reduce.1(i.1(x_1)) -> in_i_1.0(reduce.1(x_1))
   in_i_1.0(go_up.0(x_1)) -> go_up.1(i.0(x_1))
   in_i_1.0(go_up.1(x_1)) -> go_up.1(i.1(x_1))
   reduce.0(h.0-0(x_1, x_2)) -> check_h.0(redex_h.0-0(x_1, x_2))
   reduce.0(h.0-1(x_1, x_2)) -> check_h.0(redex_h.0-1(x_1, x_2))
   reduce.0(h.1-0(x_1, x_2)) -> check_h.0(redex_h.1-0(x_1, x_2))
   reduce.0(h.1-1(x_1, x_2)) -> check_h.0(redex_h.1-1(x_1, x_2))
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_1.0-1(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.1(x_2))
   in_h_2.1-0(x_1, go_up.0(x_2)) -> go_up.0(h.1-0(x_1, x_2))
   in_h_2.1-0(x_1, go_up.1(x_2)) -> go_up.0(h.1-1(x_1, x_2))
   in_h_1.0-1(go_up.0(x_1), x_2) -> go_up.0(h.0-1(x_1, x_2))
   in_h_1.0-1(go_up.1(x_1), x_2) -> go_up.0(h.1-1(x_1, x_2))
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_1.0-0(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.0(x_2))
   in_h_1.0-0(go_up.0(x_1), x_2) -> go_up.0(h.0-0(x_1, x_2))
   in_h_1.0-0(go_up.1(x_1), x_2) -> go_up.0(h.1-0(x_1, x_2))
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_1.0-1(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.1(x_2))
   in_h_2.0-0(x_1, go_up.0(x_2)) -> go_up.0(h.0-0(x_1, x_2))
   in_h_2.0-0(x_1, go_up.1(x_2)) -> go_up.0(h.0-1(x_1, x_2))
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_1.0-0(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.0(x_2))

The set Q consists of the following terms:

   reduce.0(f.0-0(x0, x1))
   reduce.0(f.0-1(x0, x1))
   reduce.0(f.1-0(x0, x1))
   reduce.0(f.1-1(x0, x1))
   reduce.0(g.0(x0))
   reduce.0(g.1(x0))
   reduce.0(h.0-0(x0, x1))
   reduce.0(h.0-1(x0, x1))
   reduce.0(h.1-0(x0, x1))
   reduce.0(h.1-1(x0, x1))
   redex_f.0-0(x0, x1)
   redex_f.0-1(x0, x1)
   redex_f.1-0(x0, x1)
   redex_f.1-1(x0, x1)
   redex_g.0(x0)
   redex_g.1(x0)
   redex_h.0-0(x0, x0)
   redex_h.1-1(x0, x0)
   check_f.0(result_f.0(x0))
   check_f.0(result_f.1(x0))
   check_g.0(result_g.0(x0))
   check_g.0(result_g.1(x0))
   check_h.0(result_h.0(x0))
   check_h.0(result_h.1(x0))
   check_h.0(redex_h.0-0(x0, x1))
   check_h.0(redex_h.0-1(x0, x1))
   check_h.0(redex_h.1-0(x0, x1))
   check_h.0(redex_h.1-1(x0, x1))
   reduce.1(i.0(x0))
   reduce.1(i.1(x0))
   in_i_1.0(go_up.0(x0))
   in_i_1.0(go_up.1(x0))
   in_h_1.0-0(go_up.0(x0), x1)
   in_h_1.0-1(go_up.0(x0), x1)
   in_h_1.0-0(go_up.1(x0), x1)
   in_h_1.0-1(go_up.1(x0), x1)
   in_h_2.0-0(x0, go_up.0(x1))
   in_h_2.0-0(x0, go_up.1(x1))
   in_h_2.1-0(x0, go_up.0(x1))
   in_h_2.1-0(x0, go_up.1(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(63) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   TOP.0(go_up.0(h.0-0(x0, x1))) -> TOP.0(check_h.0(redex_h.0-0(x0, x1)))
   TOP.0(go_up.0(h.0-1(x0, x1))) -> TOP.0(check_h.0(redex_h.0-1(x0, x1)))
   TOP.0(go_up.0(h.1-0(x0, x1))) -> TOP.0(check_h.0(redex_h.1-0(x0, x1)))
   TOP.0(go_up.0(h.1-1(x0, x1))) -> TOP.0(check_h.0(redex_h.1-1(x0, x1)))
   TOP.0(go_up.1(i.0(x0))) -> TOP.0(in_i_1.0(reduce.0(x0)))
   TOP.0(go_up.1(i.1(x0))) -> TOP.0(in_i_1.0(reduce.1(x0)))


Used ordering: Polynomial interpretation [POLO]:

   POL(TOP.0(x_1)) = x_1
   POL(check_h.0(x_1)) = x_1
   POL(go_up.0(x_1)) = 1 + x_1
   POL(go_up.1(x_1)) = 1 + x_1
   POL(h.0-0(x_1, x_2)) = x_1 + x_2
   POL(h.0-1(x_1, x_2)) = x_1 + x_2
   POL(h.1-0(x_1, x_2)) = x_1 + x_2
   POL(h.1-1(x_1, x_2)) = x_1 + x_2
   POL(i.0(x_1)) = x_1
   POL(i.1(x_1)) = x_1
   POL(in_h_1.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_1.0-1(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.0-0(x_1, x_2)) = x_1 + x_2
   POL(in_h_2.1-0(x_1, x_2)) = x_1 + x_2
   POL(in_i_1.0(x_1)) = x_1
   POL(redex_h.0-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.0-1(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-0(x_1, x_2)) = x_1 + x_2
   POL(redex_h.1-1(x_1, x_2)) = x_1 + x_2
   POL(reduce.0(x_1)) = x_1
   POL(reduce.1(x_1)) = x_1


----------------------------------------

(64)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   reduce.1(i.0(x_1)) -> in_i_1.0(reduce.0(x_1))
   reduce.1(i.1(x_1)) -> in_i_1.0(reduce.1(x_1))
   in_i_1.0(go_up.0(x_1)) -> go_up.1(i.0(x_1))
   in_i_1.0(go_up.1(x_1)) -> go_up.1(i.1(x_1))
   reduce.0(h.0-0(x_1, x_2)) -> check_h.0(redex_h.0-0(x_1, x_2))
   reduce.0(h.0-1(x_1, x_2)) -> check_h.0(redex_h.0-1(x_1, x_2))
   reduce.0(h.1-0(x_1, x_2)) -> check_h.0(redex_h.1-0(x_1, x_2))
   reduce.0(h.1-1(x_1, x_2)) -> check_h.0(redex_h.1-1(x_1, x_2))
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_1.0-1(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-1(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.1(x_2))
   in_h_2.1-0(x_1, go_up.0(x_2)) -> go_up.0(h.1-0(x_1, x_2))
   in_h_2.1-0(x_1, go_up.1(x_2)) -> go_up.0(h.1-1(x_1, x_2))
   in_h_1.0-1(go_up.0(x_1), x_2) -> go_up.0(h.0-1(x_1, x_2))
   in_h_1.0-1(go_up.1(x_1), x_2) -> go_up.0(h.1-1(x_1, x_2))
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_1.0-0(reduce.1(x_1), x_2)
   check_h.0(redex_h.1-0(x_1, x_2)) -> in_h_2.1-0(x_1, reduce.0(x_2))
   in_h_1.0-0(go_up.0(x_1), x_2) -> go_up.0(h.0-0(x_1, x_2))
   in_h_1.0-0(go_up.1(x_1), x_2) -> go_up.0(h.1-0(x_1, x_2))
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_1.0-1(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-1(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.1(x_2))
   in_h_2.0-0(x_1, go_up.0(x_2)) -> go_up.0(h.0-0(x_1, x_2))
   in_h_2.0-0(x_1, go_up.1(x_2)) -> go_up.0(h.0-1(x_1, x_2))
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_1.0-0(reduce.0(x_1), x_2)
   check_h.0(redex_h.0-0(x_1, x_2)) -> in_h_2.0-0(x_1, reduce.0(x_2))

The set Q consists of the following terms:

   reduce.0(f.0-0(x0, x1))
   reduce.0(f.0-1(x0, x1))
   reduce.0(f.1-0(x0, x1))
   reduce.0(f.1-1(x0, x1))
   reduce.0(g.0(x0))
   reduce.0(g.1(x0))
   reduce.0(h.0-0(x0, x1))
   reduce.0(h.0-1(x0, x1))
   reduce.0(h.1-0(x0, x1))
   reduce.0(h.1-1(x0, x1))
   redex_f.0-0(x0, x1)
   redex_f.0-1(x0, x1)
   redex_f.1-0(x0, x1)
   redex_f.1-1(x0, x1)
   redex_g.0(x0)
   redex_g.1(x0)
   redex_h.0-0(x0, x0)
   redex_h.1-1(x0, x0)
   check_f.0(result_f.0(x0))
   check_f.0(result_f.1(x0))
   check_g.0(result_g.0(x0))
   check_g.0(result_g.1(x0))
   check_h.0(result_h.0(x0))
   check_h.0(result_h.1(x0))
   check_h.0(redex_h.0-0(x0, x1))
   check_h.0(redex_h.0-1(x0, x1))
   check_h.0(redex_h.1-0(x0, x1))
   check_h.0(redex_h.1-1(x0, x1))
   reduce.1(i.0(x0))
   reduce.1(i.1(x0))
   in_i_1.0(go_up.0(x0))
   in_i_1.0(go_up.1(x0))
   in_h_1.0-0(go_up.0(x0), x1)
   in_h_1.0-1(go_up.0(x0), x1)
   in_h_1.0-0(go_up.1(x0), x1)
   in_h_1.0-1(go_up.1(x0), x1)
   in_h_2.0-0(x0, go_up.0(x1))
   in_h_2.0-0(x0, go_up.1(x1))
   in_h_2.1-0(x0, go_up.0(x1))
   in_h_2.1-0(x0, go_up.1(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(65) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(66)
YES
