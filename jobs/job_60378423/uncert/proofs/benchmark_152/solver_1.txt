NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/BrLvo.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be disproven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 160 ms]
(4) JBCTerminationGraph
(5) JBCNonTerm [COMPLETE, 112 ms]
(6) NO


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
package simple.upAndDownIneq;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		UpAndDownIneq.upAndDown(args.length);

	}

}


package simple.upAndDownIneq;

public class UpAndDownIneq {
	
	public static void upAndDown(int i) {
		int up = 0;
		while (0 <= i && i <= 10) {
			if (i >= 10) {
				up = 0;
			}
			if (i <= 0) {
				up = 1;
			}
			if (up >= 1) {
				i++;
			} else {
				i--;
			}
		}
	}
	
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
package simple.upAndDownIneq;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		UpAndDownIneq.upAndDown(args.length);

	}

}


package simple.upAndDownIneq;

public class UpAndDownIneq {
	
	public static void upAndDown(int i) {
		int up = 0;
		while (0 <= i && i <= 10) {
			if (i >= 10) {
				up = 0;
			}
			if (i <= 0) {
				up = 1;
			}
			if (up >= 1) {
				i++;
			} else {
				i--;
			}
		}
	}
	
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
simple.upAndDownIneq.Main.main([Ljava/lang/String;)V: Graph of 58 nodes with 1 SCC.





----------------------------------------

(5) JBCNonTerm (COMPLETE)
Reached a loop using the following run: 

0:<simple.upAndDownIneq.Main.main||0: load ADDR args||args: a44|| ->
	a44([java.lang.String...]): length 1 -->{java.lang.Object...}
YES:  (JL1)
1:<simple.upAndDownIneq.Main.main||1: arraylength|| - ||a44>
	a44([java.lang.String...]): length 1 -->{java.lang.Object...}
YES:  (JL1)
2:<simple.upAndDownIneq.Main.main||2: simple.upAndDownIneq.UpAndDownIneq.upAndDown(I)V|| - ||1>
YES:  (JL1)
3:<simple.upAndDownIneq.UpAndDownIneq.upAndDown||0: push 0||i: 1|| ->
<simple.upAndDownIneq.Main.main||2: simple.upAndDownIneq.UpAndDownIneq.upAndDown|| - || ->
YES:  (JL1)
4:<simple.upAndDownIneq.UpAndDownIneq.upAndDown||1: store INT to up||i: 1||0>
<simple.upAndDownIneq.Main.main||2: simple.upAndDownIneq.UpAndDownIneq.upAndDown|| - || ->
YES:  (JL1)
5:<simple.upAndDownIneq.UpAndDownIneq.upAndDown||2: push 0||i: 1, up: 0|| ->
<simple.upAndDownIneq.Main.main||2: simple.upAndDownIneq.UpAndDownIneq.upAndDown|| - || ->
YES:  (JL1)
Start state of loop: 

<simple.upAndDownIneq.UpAndDownIneq.upAndDown||2: push 0||i: i57, up: i58|| ->
[a14(lv_0_0)]
<simple.upAndDownIneq.Main.main||2: simple.upAndDownIneq.UpAndDownIneq.upAndDown|| - || ->
	i57: [0,+inf)(l2)
	i58: [0,1](1,1)
	i17: [0,+inf)(l1)
	a14([java.lang.String...]): length i17 -->{java.lang.Object...}
YES:  (JL1)


In the loop head node, references [i57, i58] were interesting.

All methods calls in the loop body are side-effect free, hence they can be ignored.

By SMT, we could prove

((0 <= initial_i57 and 0 <= initial_i58 and initial_i58 <= 1 and 0 <= initial_i17) and ((((path1_i57 = path1_i62 and path1_i62 = path1_i64 and path1_i64 = path1_i65 and path1_i66 = (path1_i65 + -1) and path1_i66 = res_i57 and 0 = res_i58 and path1_i57 = initial_i57 and path1_i58 = initial_i58) and (0 <= path1_i57 and T and 10 = 10 and path1_i62 <= 10 and T and 10 = 10 and path1_i64 < 10 and path1_i65 > 0 and path1_i58 = 0 and path1_i58 = 0 and 1 = 1)) or ((path2_i57 = path2_i62 and path2_i62 = path2_i64 and path2_i64 = path2_i65 and path2_i67 = (path2_i65 + 1) and path2_i67 = res_i57 and 1 = res_i58 and path2_i57 = initial_i57 and path2_i58 = initial_i58) and (0 <= path2_i57 and T and 10 = 10 and path2_i62 <= 10 and T and 10 = 10 and path2_i64 < 10 and path2_i65 > 0 and path2_i58 = 1 and path2_i58 = 1 and 1 = 1)) or ((path3_i57 = path3_i62 and 9 = res_i57 and 0 = res_i58 and path3_i57 = initial_i57 and path3_i58 = initial_i58) and (0 <= path3_i57 and T and 10 = 10 and path3_i62 <= 10 and path3_i62 = 10 and path3_i62 = 10 and 10 = 10 and 10 > 0)) or ((path4_i57 = path4_i62 and path4_i62 = path4_i64 and 1 = res_i57 and 1 = res_i58 and path4_i57 = initial_i57 and path4_i58 = initial_i58) and (0 <= path4_i57 and T and 10 = 10 and path4_i62 <= 10 and T and 10 = 10 and path4_i64 < 10 and path4_i64 = 0 and 0 <= 0))) and (((res1_i57 = res1_i62 and res1_i62 = res1_i64 and res1_i64 = res1_i65 and res1_i66 = (res1_i65 + -1) and res_i57 = res1_i57 and res_i58 = res1_i58) and !(0 <= res1_i57 and T and 10 = 10 and res1_i62 <= 10 and T and 10 = 10 and res1_i64 < 10 and res1_i65 > 0 and res1_i58 = 0 and res1_i58 = 0 and 1 = 1)) and ((res2_i57 = res2_i62 and res2_i62 = res2_i64 and res2_i64 = res2_i65 and res2_i67 = (res2_i65 + 1) and res_i57 = res2_i57 and res_i58 = res2_i58) and !(0 <= res2_i57 and T and 10 = 10 and res2_i62 <= 10 and T and 10 = 10 and res2_i64 < 10 and res2_i65 > 0 and res2_i58 = 1 and res2_i58 = 1 and 1 = 1)) and ((res3_i57 = res3_i62 and res_i57 = res3_i57 and res_i58 = res3_i58) and !(0 <= res3_i57 and T and 10 = 10 and res3_i62 <= 10 and res3_i62 = 10 and res3_i62 = 10 and 10 = 10 and 10 > 0)) and ((res4_i57 = res4_i62 and res4_i62 = res4_i64 and res_i57 = res4_i57 and res_i58 = res4_i58) and !(0 <= res4_i57 and T and 10 = 10 and res4_i62 <= 10 and T and 10 = 10 and res4_i64 < 10 and res4_i64 = 0 and 0 <= 0)))))

to be UNSAT. Consequently, the loop will not terminate.
----------------------------------------

(6)
NO
