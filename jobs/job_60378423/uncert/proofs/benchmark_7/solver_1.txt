YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/d4Jex.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 236 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) JBCTerminationSCC
(7) SCCToIRSProof [SOUND, 57 ms]
(8) IRSwT
(9) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
(10) IRSwT
(11) IRSwTTerminationDigraphProof [EQUIVALENT, 19 ms]
(12) IRSwT
(13) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(14) IRSwT
(15) TempFilterProof [SOUND, 32 ms]
(16) IntTRS
(17) RankingReductionPairProof [EQUIVALENT, 15 ms]
(18) IntTRS
(19) PolynomialOrderProcessor [EQUIVALENT, 0 ms]
(20) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class DivMinus2 {
  public static int div(int x, int y) {
    int res = 0;
    while (x >= y && y > 0) {
      x = minus(x,y);
      res = res + 1;
    }
    return res;
  }

  public static int minus(int x, int y) {
    while (y != 0) {
      if (y > 0)  {
        y--;
        x--;
      } else  {
        y++;
        x++;
      }
    }
    return x;
  }

  public static void main(String[] args) {
    Random.args = args;
    int x = Random.random();
    int y = Random.random();
    div(x, y);
  }
}


public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
    String string = args[index];
    index++;
    return string.length();
  }
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class DivMinus2 {
  public static int div(int x, int y) {
    int res = 0;
    while (x >= y && y > 0) {
      x = minus(x,y);
      res = res + 1;
    }
    return res;
  }

  public static int minus(int x, int y) {
    while (y != 0) {
      if (y > 0)  {
        y--;
        x--;
      } else  {
        y++;
        x++;
      }
    }
    return x;
  }

  public static void main(String[] args) {
    Random.args = args;
    int x = Random.random();
    int y = Random.random();
    div(x, y);
  }
}


public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
    String string = args[index];
    index++;
    return string.length();
  }
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
DivMinus2.main([Ljava/lang/String;)V: Graph of 210 nodes with 1 SCC.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 1 SCCs.
----------------------------------------

(6)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: DivMinus2.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(7) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 31 IRulesP rules:
f1181_0_div_Load(EOS(STATIC_1181), i225, i226, i225) -> f1183_0_div_LT(EOS(STATIC_1183), i225, i226, i225, i226) :|: TRUE
f1183_0_div_LT(EOS(STATIC_1183), i225, i226, i225, i226) -> f1198_0_div_LT(EOS(STATIC_1198), i225, i226, i225, i226) :|: i225 >= i226
f1198_0_div_LT(EOS(STATIC_1198), i225, i226, i225, i226) -> f1200_0_div_Load(EOS(STATIC_1200), i225, i226) :|: i225 >= i226
f1200_0_div_Load(EOS(STATIC_1200), i225, i226) -> f1202_0_div_LE(EOS(STATIC_1202), i225, i226, i226) :|: TRUE
f1202_0_div_LE(EOS(STATIC_1202), i244, i243, i243) -> f1205_0_div_LE(EOS(STATIC_1205), i244, i243, i243) :|: TRUE
f1205_0_div_LE(EOS(STATIC_1205), i244, i243, i243) -> f1212_0_div_Load(EOS(STATIC_1212), i244, i243) :|: i243 > 0
f1212_0_div_Load(EOS(STATIC_1212), i244, i243) -> f1214_0_div_Load(EOS(STATIC_1214), i243, i244) :|: TRUE
f1214_0_div_Load(EOS(STATIC_1214), i243, i244) -> f1215_0_div_InvokeMethod(EOS(STATIC_1215), i243, i244, i243) :|: TRUE
f1215_0_div_InvokeMethod(EOS(STATIC_1215), i243, i244, i243) -> f1216_0_minus_Load(EOS(STATIC_1216), i243, i244, i243) :|: TRUE
f1216_0_minus_Load(EOS(STATIC_1216), i243, i244, i243) -> f1253_0_minus_Load(EOS(STATIC_1253), i243, i244, i243) :|: TRUE
f1253_0_minus_Load(EOS(STATIC_1253), i243, i248, i249) -> f1256_0_minus_EQ(EOS(STATIC_1256), i243, i248, i249, i249) :|: TRUE
f1256_0_minus_EQ(EOS(STATIC_1256), i243, i260, i259, i259) -> f1259_0_minus_EQ(EOS(STATIC_1259), i243, i260, i259, i259) :|: TRUE
f1256_0_minus_EQ(EOS(STATIC_1256), i243, i248, matching1, matching2) -> f1260_0_minus_EQ(EOS(STATIC_1260), i243, i248, 0, 0) :|: TRUE && matching1 = 0 && matching2 = 0
f1259_0_minus_EQ(EOS(STATIC_1259), i243, i260, i259, i259) -> f1261_0_minus_Load(EOS(STATIC_1261), i243, i260, i259) :|: i259 > 0
f1261_0_minus_Load(EOS(STATIC_1261), i243, i260, i259) -> f1263_0_minus_LE(EOS(STATIC_1263), i243, i260, i259, i259) :|: TRUE
f1263_0_minus_LE(EOS(STATIC_1263), i243, i260, i259, i259) -> f1266_0_minus_Inc(EOS(STATIC_1266), i243, i260, i259) :|: i259 > 0
f1266_0_minus_Inc(EOS(STATIC_1266), i243, i260, i259) -> f1268_0_minus_Inc(EOS(STATIC_1268), i243, i260, i259 + -1) :|: TRUE
f1268_0_minus_Inc(EOS(STATIC_1268), i243, i260, i261) -> f1270_0_minus_JMP(EOS(STATIC_1270), i243, i260 + -1, i261) :|: TRUE
f1270_0_minus_JMP(EOS(STATIC_1270), i243, i262, i261) -> f1373_0_minus_Load(EOS(STATIC_1373), i243, i262, i261) :|: TRUE
f1373_0_minus_Load(EOS(STATIC_1373), i243, i262, i261) -> f1253_0_minus_Load(EOS(STATIC_1253), i243, i262, i261) :|: TRUE
f1260_0_minus_EQ(EOS(STATIC_1260), i243, i248, matching1, matching2) -> f1262_0_minus_Load(EOS(STATIC_1262), i243, i248) :|: TRUE && matching1 = 0 && matching2 = 0
f1262_0_minus_Load(EOS(STATIC_1262), i243, i248) -> f1264_0_minus_Return(EOS(STATIC_1264), i243, i248) :|: TRUE
f1264_0_minus_Return(EOS(STATIC_1264), i243, i248) -> f1267_0_div_Store(EOS(STATIC_1267), i243, i248) :|: TRUE
f1267_0_div_Store(EOS(STATIC_1267), i243, i248) -> f1269_0_div_Load(EOS(STATIC_1269), i248, i243) :|: TRUE
f1269_0_div_Load(EOS(STATIC_1269), i248, i243) -> f1271_0_div_ConstantStackPush(EOS(STATIC_1271), i248, i243) :|: TRUE
f1271_0_div_ConstantStackPush(EOS(STATIC_1271), i248, i243) -> f1375_0_div_IntArithmetic(EOS(STATIC_1375), i248, i243) :|: TRUE
f1375_0_div_IntArithmetic(EOS(STATIC_1375), i248, i243) -> f1469_0_div_Store(EOS(STATIC_1469), i248, i243) :|: TRUE
f1469_0_div_Store(EOS(STATIC_1469), i248, i243) -> f1471_0_div_JMP(EOS(STATIC_1471), i248, i243) :|: TRUE
f1471_0_div_JMP(EOS(STATIC_1471), i248, i243) -> f1483_0_div_Load(EOS(STATIC_1483), i248, i243) :|: TRUE
f1483_0_div_Load(EOS(STATIC_1483), i248, i243) -> f1175_0_div_Load(EOS(STATIC_1175), i248, i243) :|: TRUE
f1175_0_div_Load(EOS(STATIC_1175), i225, i226) -> f1181_0_div_Load(EOS(STATIC_1181), i225, i226, i225) :|: TRUE
Combined rules. Obtained 2 IRulesP rules:
f1256_0_minus_EQ(EOS(STATIC_1256), i243:0, i248:0, 0, 0) -> f1256_0_minus_EQ(EOS(STATIC_1256), i243:0, i248:0, i243:0, i243:0) :|: i248:0 >= i243:0 && i243:0 > 0
f1256_0_minus_EQ(EOS(STATIC_1256), i243:0, i260:0, i259:0, i259:0) -> f1256_0_minus_EQ(EOS(STATIC_1256), i243:0, i260:0 - 1, i259:0 - 1, i259:0 - 1) :|: i259:0 > 0
Filtered constant ground arguments:
   f1256_0_minus_EQ(x1, x2, x3, x4, x5) -> f1256_0_minus_EQ(x2, x3, x4, x5)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f1256_0_minus_EQ(x1, x2, x3, x4) -> f1256_0_minus_EQ(x1, x2, x4)
Finished conversion. Obtained 2 rules.P rules:
f1256_0_minus_EQ(i243:0, i248:0, cons_0) -> f1256_0_minus_EQ(i243:0, i248:0, i243:0) :|: i248:0 >= i243:0 && i243:0 > 0 && cons_0 = 0
f1256_0_minus_EQ(i243:0, i260:0, i259:0) -> f1256_0_minus_EQ(i243:0, i260:0 - 1, i259:0 - 1) :|: i259:0 > 0

----------------------------------------

(8)
Obligation:
Rules:
f1256_0_minus_EQ(i243:0, i248:0, cons_0) -> f1256_0_minus_EQ(i243:0, i248:0, i243:0) :|: i248:0 >= i243:0 && i243:0 > 0 && cons_0 = 0
f1256_0_minus_EQ(x, x1, x2) -> f1256_0_minus_EQ(x, x1 - 1, x2 - 1) :|: x2 > 0

----------------------------------------

(9) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(10)
Obligation:
Rules:
f1256_0_minus_EQ(i243:0, i248:0, cons_0) -> f1256_0_minus_EQ(i243:0, i248:0, i243:0) :|: i248:0 >= i243:0 && i243:0 > 0 && cons_0 = 0
f1256_0_minus_EQ(x, x1, x2) -> f1256_0_minus_EQ(x, arith, arith1) :|: x2 > 0 && arith = x1 - 1 && arith1 = x2 - 1

----------------------------------------

(11) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f1256_0_minus_EQ(i243:0, i248:0, cons_0) -> f1256_0_minus_EQ(i243:0, i248:0, i243:0) :|: i248:0 >= i243:0 && i243:0 > 0 && cons_0 = 0
(2) f1256_0_minus_EQ(x, x1, x2) -> f1256_0_minus_EQ(x, arith, arith1) :|: x2 > 0 && arith = x1 - 1 && arith1 = x2 - 1

Arcs:
(1) -> (2)
(2) -> (1), (2)

This digraph is fully evaluated!
----------------------------------------

(12)
Obligation:

Termination digraph:
Nodes:
(1) f1256_0_minus_EQ(i243:0, i248:0, cons_0) -> f1256_0_minus_EQ(i243:0, i248:0, i243:0) :|: i248:0 >= i243:0 && i243:0 > 0 && cons_0 = 0
(2) f1256_0_minus_EQ(x, x1, x2) -> f1256_0_minus_EQ(x, arith, arith1) :|: x2 > 0 && arith = x1 - 1 && arith1 = x2 - 1

Arcs:
(1) -> (2)
(2) -> (1), (2)

This digraph is fully evaluated!

----------------------------------------

(13) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(14)
Obligation:
Rules:
f1256_0_minus_EQ(x:0, x1:0, x2:0) -> f1256_0_minus_EQ(x:0, x1:0 - 1, x2:0 - 1) :|: x2:0 > 0
f1256_0_minus_EQ(i243:0:0, i248:0:0, cons_0) -> f1256_0_minus_EQ(i243:0:0, i248:0:0, i243:0:0) :|: i248:0:0 >= i243:0:0 && i243:0:0 > 0 && cons_0 = 0

----------------------------------------

(15) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f1256_0_minus_EQ(VARIABLE, VARIABLE, INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(16)
Obligation:
Rules:
f1256_0_minus_EQ(x:0, x1:0, x2:0) -> f1256_0_minus_EQ(x:0, c, c1) :|: c1 = x2:0 - 1 && c = x1:0 - 1 && x2:0 > 0
f1256_0_minus_EQ(i243:0:0, i248:0:0, c2) -> f1256_0_minus_EQ(i243:0:0, i248:0:0, i243:0:0) :|: c2 = 0 && (i248:0:0 >= i243:0:0 && i243:0:0 > 0 && cons_0 = 0)

----------------------------------------

(17) RankingReductionPairProof (EQUIVALENT)
Interpretation:
[ f1256_0_minus_EQ ] = -1*f1256_0_minus_EQ_3 + 2*f1256_0_minus_EQ_1 + 2*f1256_0_minus_EQ_2

The following rules are decreasing:
f1256_0_minus_EQ(x:0, x1:0, x2:0) -> f1256_0_minus_EQ(x:0, c, c1) :|: c1 = x2:0 - 1 && c = x1:0 - 1 && x2:0 > 0
f1256_0_minus_EQ(i243:0:0, i248:0:0, c2) -> f1256_0_minus_EQ(i243:0:0, i248:0:0, i243:0:0) :|: c2 = 0 && (i248:0:0 >= i243:0:0 && i243:0:0 > 0 && cons_0 = 0)

The following rules are bounded:
f1256_0_minus_EQ(i243:0:0, i248:0:0, c2) -> f1256_0_minus_EQ(i243:0:0, i248:0:0, i243:0:0) :|: c2 = 0 && (i248:0:0 >= i243:0:0 && i243:0:0 > 0 && cons_0 = 0)


----------------------------------------

(18)
Obligation:
Rules:
f1256_0_minus_EQ(x:0, x1:0, x2:0) -> f1256_0_minus_EQ(x:0, c, c1) :|: c1 = x2:0 - 1 && c = x1:0 - 1 && x2:0 > 0

----------------------------------------

(19) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f1256_0_minus_EQ(x, x1, x2)] = x2

The following rules are decreasing:
f1256_0_minus_EQ(x:0, x1:0, x2:0) -> f1256_0_minus_EQ(x:0, c, c1) :|: c1 = x2:0 - 1 && c = x1:0 - 1 && x2:0 > 0
The following rules are bounded:
f1256_0_minus_EQ(x:0, x1:0, x2:0) -> f1256_0_minus_EQ(x:0, c, c1) :|: c1 = x2:0 - 1 && c = x1:0 - 1 && x2:0 > 0

----------------------------------------

(20)
YES
