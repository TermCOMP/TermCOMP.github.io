YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/ool2N.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 49 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 110 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) AND
    (7) JBCTerminationSCC
        (8) SCCToQDPProof [SOUND, 79 ms]
        (9) QDP
        (10) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (11) YES
    (12) JBCTerminationSCC
        (13) SCCToIRSProof [SOUND, 24 ms]
        (14) IRSwT
        (15) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (16) IRSwT
        (17) IRSwTTerminationDigraphProof [EQUIVALENT, 12 ms]
        (18) IRSwT
        (19) IntTRSCompressionProof [EQUIVALENT, 0 ms]
        (20) IRSwT
        (21) TempFilterProof [SOUND, 19 ms]
        (22) IntTRS
        (23) PolynomialOrderProcessor [EQUIVALENT, 5 ms]
        (24) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class ListReverseAcyclicList {
	public static void main(String... args) {
		List x = List.createList(args[0].length(), null);
		List.reverse(x);
	}
}

class List {
	List n;

	public List(List next) {
		this.n = next;
	}

	public static void reverse(List x) {		
		List y = null;
		while (x != null) {
			List z = x;
			x = x.n;
			z.n = y;
			y = z;
		}
	}

	public static List createList(int l, List end) {
		while (--l > 0) {
			end = new List(end);
		}
		return end;
	}

	public static List createCycle(int l) {
		List last = new List(null);
		List first = createList(l - 1, last);
		last.n = first;
		return first;
	}

	public static List createPanhandleList(int pl, int cl) {
		return createList(pl, createCycle(cl));
	}

}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class ListReverseAcyclicList {
	public static void main(String... args) {
		List x = List.createList(args[0].length(), null);
		List.reverse(x);
	}
}

class List {
	List n;

	public List(List next) {
		this.n = next;
	}

	public static void reverse(List x) {		
		List y = null;
		while (x != null) {
			List z = x;
			x = x.n;
			z.n = y;
			y = z;
		}
	}

	public static List createList(int l, List end) {
		while (--l > 0) {
			end = new List(end);
		}
		return end;
	}

	public static List createCycle(int l) {
		List last = new List(null);
		List first = createList(l - 1, last);
		last.n = first;
		return first;
	}

	public static List createPanhandleList(int pl, int cl) {
		return createList(pl, createCycle(cl));
	}

}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
ListReverseAcyclicList.main([Ljava/lang/String;)V: Graph of 147 nodes with 2 SCCs.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 2 SCCss.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: ListReverseAcyclicList.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:
*List: [n]
*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(8) SCCToQDPProof (SOUND)
Transformed TerminationGraph SCC to QDP. Log: 
Generated 16 rules for P and 0 rules for R.P rules:
f787_0_reverse_NULL(EOS(STATIC_787), java.lang.Object(o206sub), java.lang.Object(List(EOC, o182)), java.lang.Object(o206sub)) -> f793_0_reverse_Load(EOS(STATIC_793), java.lang.Object(o206sub), java.lang.Object(List(EOC, o182))) :|: TRUE
f793_0_reverse_Load(EOS(STATIC_793), java.lang.Object(o206sub), java.lang.Object(List(EOC, o182))) -> f804_0_reverse_Store(EOS(STATIC_804), java.lang.Object(o206sub), java.lang.Object(List(EOC, o182)), java.lang.Object(o206sub)) :|: TRUE
f804_0_reverse_Store(EOS(STATIC_804), java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217))) -> f811_0_reverse_Store(EOS(STATIC_811), java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217))) :|: TRUE
f811_0_reverse_Store(EOS(STATIC_811), java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217))) -> f817_0_reverse_Load(EOS(STATIC_817), java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217))) :|: TRUE
f817_0_reverse_Load(EOS(STATIC_817), java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217))) -> f821_0_reverse_FieldAccess(EOS(STATIC_821), java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o217))) :|: TRUE
f821_0_reverse_FieldAccess(EOS(STATIC_821), java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o217))) -> f825_0_reverse_Store(EOS(STATIC_825), java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217)), o217) :|: TRUE
f825_0_reverse_Store(EOS(STATIC_825), java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217)), o217) -> f827_0_reverse_Load(EOS(STATIC_827), o217, java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217))) :|: TRUE
f827_0_reverse_Load(EOS(STATIC_827), o217, java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217))) -> f828_0_reverse_Load(EOS(STATIC_828), o217, java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o217))) :|: TRUE
f828_0_reverse_Load(EOS(STATIC_828), o217, java.lang.Object(List(EOC, o182)), java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o217))) -> f832_0_reverse_FieldAccess(EOS(STATIC_832), o217, java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o182))) :|: TRUE
f832_0_reverse_FieldAccess(EOS(STATIC_832), o217, java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o217)), java.lang.Object(List(EOC, o182))) -> f841_0_reverse_Load(EOS(STATIC_841), o217, java.lang.Object(List(EOC, java.lang.Object(List(EOC, o182))))) :|: TRUE
f841_0_reverse_Load(EOS(STATIC_841), o217, java.lang.Object(List(EOC, java.lang.Object(List(EOC, o182))))) -> f890_0_reverse_Store(EOS(STATIC_890), o217, java.lang.Object(List(EOC, java.lang.Object(List(EOC, o182))))) :|: TRUE
f890_0_reverse_Store(EOS(STATIC_890), o217, java.lang.Object(List(EOC, java.lang.Object(List(EOC, o182))))) -> f895_0_reverse_JMP(EOS(STATIC_895), o217, java.lang.Object(List(EOC, java.lang.Object(List(EOC, o182))))) :|: TRUE
f895_0_reverse_JMP(EOS(STATIC_895), o217, java.lang.Object(List(EOC, java.lang.Object(List(EOC, o182))))) -> f905_0_reverse_Load(EOS(STATIC_905), o217, java.lang.Object(List(EOC, java.lang.Object(List(EOC, o182))))) :|: TRUE
f905_0_reverse_Load(EOS(STATIC_905), o217, java.lang.Object(List(EOC, java.lang.Object(List(EOC, o182))))) -> f737_0_reverse_Load(EOS(STATIC_737), o217, java.lang.Object(List(EOC, java.lang.Object(List(EOC, o182))))) :|: TRUE
f737_0_reverse_Load(EOS(STATIC_737), o180, java.lang.Object(List(EOC, o182))) -> f782_0_reverse_NULL(EOS(STATIC_782), o180, java.lang.Object(List(EOC, o182)), o180) :|: TRUE
f782_0_reverse_NULL(EOS(STATIC_782), java.lang.Object(o206sub), java.lang.Object(List(EOC, o182)), java.lang.Object(o206sub)) -> f787_0_reverse_NULL(EOS(STATIC_787), java.lang.Object(o206sub), java.lang.Object(List(EOC, o182)), java.lang.Object(o206sub)) :|: TRUE
R rules:
Combined rules. Obtained 1 conditional rules for P and 0 conditional rules for R.P rules:
f787_0_reverse_NULL(EOS(STATIC_787), java.lang.Object(List(EOC, java.lang.Object(o206sub:0))), java.lang.Object(List(EOC, o182:0)), java.lang.Object(List(EOC, java.lang.Object(o206sub:0)))) -> f787_0_reverse_NULL(EOS(STATIC_787), java.lang.Object(o206sub:0), java.lang.Object(List(EOC, java.lang.Object(List(EOC, o182:0)))), java.lang.Object(o206sub:0)) :|: TRUE
R rules:
Filtered ground terms:
   f787_0_reverse_NULL(x1, x2, x3, x4) -> f787_0_reverse_NULL(x2, x3, x4)
   EOS(x1) -> EOS
   List(x1, x2) -> List(x2)
Filtered duplicate args:
   f787_0_reverse_NULL(x1, x2, x3) -> f787_0_reverse_NULL(x2, x3)
Combined rules. Obtained 1 conditional rules for P and 0 conditional rules for R.P rules:
F787_0_REVERSE_NULL(java.lang.Object(List(o182:0:0)), java.lang.Object(List(java.lang.Object(o206sub:0:0)))) -> F787_0_REVERSE_NULL(java.lang.Object(List(java.lang.Object(List(o182:0:0)))), java.lang.Object(o206sub:0:0)) :|: TRUE
R rules:

----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F787_0_REVERSE_NULL(java.lang.Object(List(o182:0:0)), java.lang.Object(List(java.lang.Object(o206sub:0:0)))) -> F787_0_REVERSE_NULL(java.lang.Object(List(java.lang.Object(List(o182:0:0)))), java.lang.Object(o206sub:0:0))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(10) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*F787_0_REVERSE_NULL(java.lang.Object(List(o182:0:0)), java.lang.Object(List(java.lang.Object(o206sub:0:0)))) -> F787_0_REVERSE_NULL(java.lang.Object(List(java.lang.Object(List(o182:0:0)))), java.lang.Object(o206sub:0:0))
The graph contains the following edges 2 > 2


----------------------------------------

(11)
YES

----------------------------------------

(12)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: ListReverseAcyclicList.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(13) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 17 IRulesP rules:
f551_0_createList_LE(EOS(STATIC_551), i73, i73) -> f553_0_createList_New(EOS(STATIC_553), i73) :|: i73 > 0
f553_0_createList_New(EOS(STATIC_553), i73) -> f555_0_createList_Duplicate(EOS(STATIC_555), i73) :|: TRUE
f555_0_createList_Duplicate(EOS(STATIC_555), i73) -> f557_0_createList_Load(EOS(STATIC_557), i73) :|: TRUE
f557_0_createList_Load(EOS(STATIC_557), i73) -> f559_0_createList_InvokeMethod(EOS(STATIC_559), i73) :|: TRUE
f559_0_createList_InvokeMethod(EOS(STATIC_559), i73) -> f561_0__init__Load(EOS(STATIC_561), i73) :|: TRUE
f561_0__init__Load(EOS(STATIC_561), i73) -> f564_0__init__InvokeMethod(EOS(STATIC_564), i73) :|: TRUE
f564_0__init__InvokeMethod(EOS(STATIC_564), i73) -> f570_0__init__Load(EOS(STATIC_570), i73) :|: TRUE
f570_0__init__Load(EOS(STATIC_570), i73) -> f576_0__init__Load(EOS(STATIC_576), i73) :|: TRUE
f576_0__init__Load(EOS(STATIC_576), i73) -> f581_0__init__FieldAccess(EOS(STATIC_581), i73) :|: TRUE
f581_0__init__FieldAccess(EOS(STATIC_581), i73) -> f583_0__init__Return(EOS(STATIC_583), i73) :|: TRUE
f583_0__init__Return(EOS(STATIC_583), i73) -> f627_0_createList_Store(EOS(STATIC_627), i73) :|: TRUE
f627_0_createList_Store(EOS(STATIC_627), i73) -> f630_0_createList_JMP(EOS(STATIC_630), i73) :|: TRUE
f630_0_createList_JMP(EOS(STATIC_630), i73) -> f638_0_createList_Inc(EOS(STATIC_638), i73) :|: TRUE
f638_0_createList_Inc(EOS(STATIC_638), i73) -> f540_0_createList_Inc(EOS(STATIC_540), i73) :|: TRUE
f540_0_createList_Inc(EOS(STATIC_540), i65) -> f547_0_createList_Load(EOS(STATIC_547), i65 + -1) :|: TRUE
f547_0_createList_Load(EOS(STATIC_547), i69) -> f549_0_createList_LE(EOS(STATIC_549), i69, i69) :|: TRUE
f549_0_createList_LE(EOS(STATIC_549), i73, i73) -> f551_0_createList_LE(EOS(STATIC_551), i73, i73) :|: TRUE
Combined rules. Obtained 1 IRulesP rules:
f551_0_createList_LE(EOS(STATIC_551), i73:0, i73:0) -> f551_0_createList_LE(EOS(STATIC_551), i73:0 - 1, i73:0 - 1) :|: i73:0 > 0
Filtered constant ground arguments:
   f551_0_createList_LE(x1, x2, x3) -> f551_0_createList_LE(x2, x3)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f551_0_createList_LE(x1, x2) -> f551_0_createList_LE(x2)
Finished conversion. Obtained 1 rules.P rules:
f551_0_createList_LE(i73:0) -> f551_0_createList_LE(i73:0 - 1) :|: i73:0 > 0

----------------------------------------

(14)
Obligation:
Rules:
f551_0_createList_LE(i73:0) -> f551_0_createList_LE(i73:0 - 1) :|: i73:0 > 0

----------------------------------------

(15) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(16)
Obligation:
Rules:
f551_0_createList_LE(i73:0) -> f551_0_createList_LE(arith) :|: i73:0 > 0 && arith = i73:0 - 1

----------------------------------------

(17) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f551_0_createList_LE(i73:0) -> f551_0_createList_LE(arith) :|: i73:0 > 0 && arith = i73:0 - 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(18)
Obligation:

Termination digraph:
Nodes:
(1) f551_0_createList_LE(i73:0) -> f551_0_createList_LE(arith) :|: i73:0 > 0 && arith = i73:0 - 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(19) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(20)
Obligation:
Rules:
f551_0_createList_LE(i73:0:0) -> f551_0_createList_LE(i73:0:0 - 1) :|: i73:0:0 > 0

----------------------------------------

(21) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f551_0_createList_LE(INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(22)
Obligation:
Rules:
f551_0_createList_LE(i73:0:0) -> f551_0_createList_LE(c) :|: c = i73:0:0 - 1 && i73:0:0 > 0

----------------------------------------

(23) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f551_0_createList_LE(x)] = x

The following rules are decreasing:
f551_0_createList_LE(i73:0:0) -> f551_0_createList_LE(c) :|: c = i73:0:0 - 1 && i73:0:0 > 0
The following rules are bounded:
f551_0_createList_LE(i73:0:0) -> f551_0_createList_LE(c) :|: c = i73:0:0 - 1 && i73:0:0 > 0

----------------------------------------

(24)
YES
