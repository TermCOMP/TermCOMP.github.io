NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/FvMg6.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be disproven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCNonTerm [COMPLETE, 112 ms]
(4) NO


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class Choose {
    public static void main(String[] args) {
	int i = 3;
	while (i >= 3) {
	    if (i > 5)
		i += 3;
	    else if (i > 10)
		i -= 2;
	    else
		i++;
	}
    }
}


----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class Choose {
    public static void main(String[] args) {
	int i = 3;
	while (i >= 3) {
	    if (i > 5)
		i += 3;
	    else if (i > 10)
		i -= 2;
	    else
		i++;
	}
    }
}


----------------------------------------

(3) JBCNonTerm (COMPLETE)
Reached a loop using the following run: 

0:<Choose.main||0: push 3|| - || ->
YES:  (JL1)
1:<Choose.main||1: store INT to #1|| - ||3>
YES:  (JL1)
2:<Choose.main||2: load INT #1||#1: 3|| ->
YES:  (JL1)
3:<Choose.main||3: push 3||#1: 3||3>
YES:  (JL1)
4:<Choose.main||4: LT||#1: 3||3, 3>
YES:  (JL1)
5:<Choose.main||7: load INT #1||#1: 3|| ->
YES:  (JL1)
6:<Choose.main||8: push 5||#1: 3||3>
YES:  (JL1)
7:<Choose.main||9: LE||#1: 3||3, 5>
YES:  (JL1)
8:<Choose.main||18: load INT #1||#1: 3|| ->
YES:  (JL1)
9:<Choose.main||19: push 10||#1: 3||3>
YES:  (JL1)
10:<Choose.main||21: LE||#1: 3||3, 10>
YES:  (JL1)
11:<Choose.main||30: increment #1 by 1||#1: 3|| ->
YES:  (JL1)
12:<Choose.main||33: jmp||#1: 4|| ->
YES:  (JL1)
13:<Choose.main||2: load INT #1||#1: 4|| ->
YES:  (JL1)
14:<Choose.main||3: push 3||#1: 4||4>
YES:  (JL1)
15:<Choose.main||4: LT||#1: 4||4, 3>
YES:  (JL1)
16:<Choose.main||7: load INT #1||#1: 4|| ->
YES:  (JL1)
17:<Choose.main||8: push 5||#1: 4||4>
YES:  (JL1)
18:<Choose.main||9: LE||#1: 4||4, 5>
YES:  (JL1)
19:<Choose.main||18: load INT #1||#1: 4|| ->
YES:  (JL1)
20:<Choose.main||19: push 10||#1: 4||4>
YES:  (JL1)
21:<Choose.main||21: LE||#1: 4||4, 10>
YES:  (JL1)
22:<Choose.main||30: increment #1 by 1||#1: 4|| ->
YES:  (JL1)
23:<Choose.main||33: jmp||#1: 5|| ->
YES:  (JL1)
24:<Choose.main||2: load INT #1||#1: 5|| ->
YES:  (JL1)
25:<Choose.main||3: push 3||#1: 5||5>
YES:  (JL1)
26:<Choose.main||4: LT||#1: 5||5, 3>
YES:  (JL1)
27:<Choose.main||7: load INT #1||#1: 5|| ->
YES:  (JL1)
28:<Choose.main||8: push 5||#1: 5||5>
YES:  (JL1)
29:<Choose.main||9: LE||#1: 5||5, 5>
YES:  (JL1)
30:<Choose.main||18: load INT #1||#1: 5|| ->
YES:  (JL1)
31:<Choose.main||19: push 10||#1: 5||5>
YES:  (JL1)
32:<Choose.main||21: LE||#1: 5||5, 10>
YES:  (JL1)
33:<Choose.main||30: increment #1 by 1||#1: 5|| ->
YES:  (JL1)
34:<Choose.main||33: jmp||#1: 6|| ->
YES:  (JL1)
35:<Choose.main||2: load INT #1||#1: 6|| ->
YES:  (JL1)
Start state of loop: 

[o12(lv_0_0)]
<Choose.main||2: load INT #1||#1: i7|| ->
	o12([java.lang.String...]): Object() -->{java.lang.Object...}
	i7: [3,+inf)(l3)
YES:  (JL1)


In the loop head node, references [i7] were interesting.

All methods calls in the loop body are side-effect free, hence they can be ignored.

By SMT, we could prove

(3 <= initial_i7 and (((path1_i7 = path1_i10 and path1_i11 = (path1_i10 + 3) and path1_i11 = res_i7 and path1_i7 = initial_i7) and (path1_i7 >= 3 and T and 5 = 5 and path1_i10 > 5)) and ((res1_i7 = res1_i10 and res1_i11 = (res1_i10 + 3) and res_i7 = res1_i7) and !(res1_i7 >= 3 and T and 5 = 5 and res1_i10 > 5))))

to be UNSAT. Consequently, the loop will not terminate.
----------------------------------------

(4)
NO
