NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/6Lg7A.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be disproven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 142 ms]
(4) JBCTerminationGraph
(5) JBCNonTerm [COMPLETE, 54 ms]
(6) NO


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class NO_12 {
    public static void main(String args[]) {
	int j = 0;
	for (int i = 0; i <= j; i++)
	    if (j-i < 1) j += 2;	    
    }
}


----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class NO_12 {
    public static void main(String args[]) {
	int j = 0;
	for (int i = 0; i <= j; i++)
	    if (j-i < 1) j += 2;	    
    }
}


----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
NO_12.main([Ljava/lang/String;)V: Graph of 30 nodes with 1 SCC.





----------------------------------------

(5) JBCNonTerm (COMPLETE)
Reached a loop using the following run: 

0:<NO_12.main||0: push 0|| - || ->
YES:  (JL1)
1:<NO_12.main||1: store INT to #1|| - ||0>
YES:  (JL1)
2:<NO_12.main||2: push 0||#1: 0|| ->
YES:  (JL1)
3:<NO_12.main||3: store INT to #2||#1: 0||0>
YES:  (JL1)
4:<NO_12.main||4: load INT #2||#1: 0, #2: 0|| ->
YES:  (JL1)
Start state of loop: 

[o30(lv_0_0)]
<NO_12.main||4: load INT #2||#1: i35, #2: i36|| ->
	o30([java.lang.String...]): Object() -->{java.lang.Object...}
	i35: [0,+inf)(l3)
	i36: [0,+inf)(l5)
YES:  (JL1)


In the loop head node, references [i36, i35] were interesting.

All methods calls in the loop body are side-effect free, hence they can be ignored.

By SMT, we could prove

((0 <= initial_i35 and 0 <= initial_i36) and ((((path1_i39 = (path1_i35 - path1_i36) and path1_i39 = path1_i40 and path1_i42 = (path1_i36 + 1) and path1_i35 = res_i35 and path1_i42 = res_i36 and path1_i35 = initial_i35 and path1_i36 = initial_i36) and (path1_i36 <= path1_i35 and path1_i36 <= path1_i35 and T and 1 = 1 and path1_i40 >= 1)) or ((path2_i39 = (path2_i35 - path2_i36) and path2_i41 = (path2_i35 + 2) and path2_i43 = (path2_i36 + 1) and path2_i41 = res_i35 and path2_i43 = res_i36 and path2_i35 = initial_i35 and path2_i36 = initial_i36) and (path2_i36 <= path2_i35 and path2_i36 <= path2_i35 and path2_i39 = 0 and path2_i39 = 0 and 1 = 1))) and (((res1_i39 = (res1_i35 - res1_i36) and res1_i39 = res1_i40 and res1_i42 = (res1_i36 + 1) and res_i35 = res1_i35 and res_i36 = res1_i36) and !(res1_i36 <= res1_i35 and res1_i36 <= res1_i35 and T and 1 = 1 and res1_i40 >= 1)) and ((res2_i39 = (res2_i35 - res2_i36) and res2_i41 = (res2_i35 + 2) and res2_i43 = (res2_i36 + 1) and res_i35 = res2_i35 and res_i36 = res2_i36) and !(res2_i36 <= res2_i35 and res2_i36 <= res2_i35 and res2_i39 = 0 and res2_i39 = 0 and 1 = 1)))))

to be UNSAT. Consequently, the loop will not terminate.
----------------------------------------

(6)
NO
