YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/3958W.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 170 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) AND
    (7) JBCTerminationSCC
        (8) SCCToQDPProof [SOUND, 49 ms]
        (9) QDP
        (10) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (11) YES
    (12) JBCTerminationSCC
        (13) SCCToIRSProof [SOUND, 61 ms]
        (14) IRSwT
        (15) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (16) IRSwT
        (17) IRSwTTerminationDigraphProof [EQUIVALENT, 22 ms]
        (18) IRSwT
        (19) IntTRSCompressionProof [EQUIVALENT, 0 ms]
        (20) IRSwT
        (21) TempFilterProof [SOUND, 23 ms]
        (22) IntTRS
        (23) PolynomialOrderProcessor [EQUIVALENT, 7 ms]
        (24) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class List1 {
	List1 pred, next;

	List1(List1 pred) {
		if (pred != null) {
			pred.next = this;
		}
		this.pred = pred;
	}

	static int length(List1 l) {
		int r = 1;
		while (null != (l = l.next))
			r++;
		return r;
	}

	public static void main(String[] args) {
		//Create doubly-linked list:
		int length = args.length;
		List1 cur = new List1(null);
		List1 first = cur;
		while (length-- > 0) {
			cur = new List1(cur);
		}

		length(first);		
	}
}




----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class List1 {
	List1 pred, next;

	List1(List1 pred) {
		if (pred != null) {
			pred.next = this;
		}
		this.pred = pred;
	}

	static int length(List1 l) {
		int r = 1;
		while (null != (l = l.next))
			r++;
		return r;
	}

	public static void main(String[] args) {
		//Create doubly-linked list:
		int length = args.length;
		List1 cur = new List1(null);
		List1 first = cur;
		while (length-- > 0) {
			cur = new List1(cur);
		}

		length(first);		
	}
}




----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
List1.main([Ljava/lang/String;)V: Graph of 79 nodes with 2 SCCs.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 2 SCCss.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: List1.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:
*List1: [next]
*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(8) SCCToQDPProof (SOUND)
Transformed TerminationGraph SCC to QDP. Log: 
Generated 11 rules for P and 0 rules for R.P rules:
f2188_0_length_Load(EOS(STATIC_2188), java.lang.Object(o191sub)) -> f2189_0_length_FieldAccess(EOS(STATIC_2189), java.lang.Object(o191sub)) :|: TRUE
f2189_0_length_FieldAccess(EOS(STATIC_2189), java.lang.Object(List1(EOC, o196))) -> f2190_0_length_FieldAccess(EOS(STATIC_2190), java.lang.Object(List1(EOC, o196))) :|: TRUE
f2190_0_length_FieldAccess(EOS(STATIC_2190), java.lang.Object(List1(EOC, o196))) -> f2223_0_length_Duplicate(EOS(STATIC_2223), o196) :|: TRUE
f2223_0_length_Duplicate(EOS(STATIC_2223), o196) -> f2226_0_length_Store(EOS(STATIC_2226), o196, o196) :|: TRUE
f2226_0_length_Store(EOS(STATIC_2226), o196, o196) -> f2228_0_length_EQ(EOS(STATIC_2228), o196, o196) :|: TRUE
f2228_0_length_EQ(EOS(STATIC_2228), java.lang.Object(o197sub), java.lang.Object(o197sub)) -> f2232_0_length_EQ(EOS(STATIC_2232), java.lang.Object(o197sub), java.lang.Object(o197sub)) :|: TRUE
f2232_0_length_EQ(EOS(STATIC_2232), java.lang.Object(o197sub), java.lang.Object(o197sub)) -> f2236_0_length_Inc(EOS(STATIC_2236), java.lang.Object(o197sub)) :|: TRUE
f2236_0_length_Inc(EOS(STATIC_2236), java.lang.Object(o197sub)) -> f2241_0_length_JMP(EOS(STATIC_2241), java.lang.Object(o197sub)) :|: TRUE
f2241_0_length_JMP(EOS(STATIC_2241), java.lang.Object(o197sub)) -> f2262_0_length_ConstantStackPush(EOS(STATIC_2262), java.lang.Object(o197sub)) :|: TRUE
f2262_0_length_ConstantStackPush(EOS(STATIC_2262), java.lang.Object(o197sub)) -> f2187_0_length_ConstantStackPush(EOS(STATIC_2187), java.lang.Object(o197sub)) :|: TRUE
f2187_0_length_ConstantStackPush(EOS(STATIC_2187), java.lang.Object(o191sub)) -> f2188_0_length_Load(EOS(STATIC_2188), java.lang.Object(o191sub)) :|: TRUE
R rules:
Combined rules. Obtained 1 conditional rules for P and 0 conditional rules for R.P rules:
f2188_0_length_Load(EOS(STATIC_2188), java.lang.Object(List1(EOC, java.lang.Object(o197sub:0)))) -> f2188_0_length_Load(EOS(STATIC_2188), java.lang.Object(o197sub:0)) :|: TRUE
R rules:
Filtered ground terms:
   f2188_0_length_Load(x1, x2) -> f2188_0_length_Load(x2)
   EOS(x1) -> EOS
   List1(x1, x2) -> List1(x2)
Combined rules. Obtained 1 conditional rules for P and 0 conditional rules for R.P rules:
F2188_0_LENGTH_LOAD(java.lang.Object(List1(java.lang.Object(o197sub:0:0)))) -> F2188_0_LENGTH_LOAD(java.lang.Object(o197sub:0:0)) :|: TRUE
R rules:

----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F2188_0_LENGTH_LOAD(java.lang.Object(List1(java.lang.Object(o197sub:0:0)))) -> F2188_0_LENGTH_LOAD(java.lang.Object(o197sub:0:0))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(10) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*F2188_0_LENGTH_LOAD(java.lang.Object(List1(java.lang.Object(o197sub:0:0)))) -> F2188_0_LENGTH_LOAD(java.lang.Object(o197sub:0:0))
The graph contains the following edges 1 > 1


----------------------------------------

(11)
YES

----------------------------------------

(12)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: List1.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(13) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 33 IRulesP rules:
f1792_0_main_Inc(EOS(STATIC_1792), i108, i108, o127[List1.next]o125) -> f1797_0_main_LE(EOS(STATIC_1797), i108 + -1, i108, o127[List1.next]o125) :|: TRUE
f1797_0_main_LE(EOS(STATIC_1797), i112, i115, o127[List1.next]o125) -> f1806_0_main_LE(EOS(STATIC_1806), i112, i115, o127[List1.next]o125) :|: TRUE
f1806_0_main_LE(EOS(STATIC_1806), i112, i115, o127[List1.next]o125) -> f1813_0_main_New(EOS(STATIC_1813), i112, o127[List1.next]o125) :|: i115 > 0
f1813_0_main_New(EOS(STATIC_1813), i112, o127[List1.next]o125) -> f1818_0_main_Duplicate(EOS(STATIC_1818), i112, o127[List1.next]o125) :|: TRUE
f1818_0_main_Duplicate(EOS(STATIC_1818), i112, o127[List1.next]o125) -> f1823_0_main_Load(EOS(STATIC_1823), i112, o127[List1.next]o125) :|: TRUE
f1823_0_main_Load(EOS(STATIC_1823), i112, o127[List1.next]o125) -> f1826_0_main_InvokeMethod(EOS(STATIC_1826), i112, o127[List1.next]o125) :|: TRUE
f1826_0_main_InvokeMethod(EOS(STATIC_1826), i112, o127[List1.next]o125) -> f1828_0__init__Load(EOS(STATIC_1828), i112, o127[List1.next]o125) :|: TRUE
f1828_0__init__Load(EOS(STATIC_1828), i112, o127[List1.next]o125) -> f1831_0__init__InvokeMethod(EOS(STATIC_1831), i112, o127[List1.next]o125) :|: TRUE
f1831_0__init__InvokeMethod(EOS(STATIC_1831), i112, o127[List1.next]o125) -> f1833_0__init__Load(EOS(STATIC_1833), i112, o127[List1.next]o125) :|: TRUE
f1833_0__init__Load(EOS(STATIC_1833), i112, o127[List1.next]o125) -> f1835_0__init__NULL(EOS(STATIC_1835), i112, o127[List1.next]o125) :|: TRUE
f1835_0__init__NULL(EOS(STATIC_1835), i112, o127[List1.next]o125) -> f1837_0__init__Load(EOS(STATIC_1837), i112, o127[List1.next]o125) :|: TRUE
f1837_0__init__Load(EOS(STATIC_1837), i112, o127[List1.next]o125) -> f1839_0__init__Load(EOS(STATIC_1839), i112, o127[List1.next]o125) :|: TRUE
f1839_0__init__Load(EOS(STATIC_1839), i112, o127[List1.next]o125) -> f1843_0__init__FieldAccess(EOS(STATIC_1843), i112, o127[List1.next]o125) :|: TRUE
f1843_0__init__FieldAccess(EOS(STATIC_1843), i112, o127[List1.next]o125) -> f1862_0__init__FieldAccess(EOS(STATIC_1862), i112, o127[List1.next]o125) :|: o127[List1.next]o125 > 0
f1843_0__init__FieldAccess(EOS(STATIC_1843), i112, o143[List1.next]o143) -> f1863_0__init__FieldAccess(EOS(STATIC_1863), i112) :|: TRUE
f1862_0__init__FieldAccess(EOS(STATIC_1862), i112, o127[List1.next]o125) -> f1866_0__init__Load(EOS(STATIC_1866), i112, o127[List1.next]o125) :|: TRUE
f1866_0__init__Load(EOS(STATIC_1866), i112, o127[List1.next]o125) -> f1872_0__init__Load(EOS(STATIC_1872), i112, o127[List1.next]o125) :|: TRUE
f1872_0__init__Load(EOS(STATIC_1872), i112, o127[List1.next]o125) -> f1917_0__init__FieldAccess(EOS(STATIC_1917), i112, o127[List1.next]o125) :|: TRUE
f1917_0__init__FieldAccess(EOS(STATIC_1917), i112, o127[List1.next]o125) -> f1942_0__init__Return(EOS(STATIC_1942), i112, o127[List1.next]o125) :|: TRUE
f1942_0__init__Return(EOS(STATIC_1942), i112, o127[List1.next]o125) -> f1952_0_main_Store(EOS(STATIC_1952), i112, o127[List1.next]o125) :|: TRUE
f1952_0_main_Store(EOS(STATIC_1952), i112, o127[List1.next]o125) -> f1974_0_main_JMP(EOS(STATIC_1974), i112, o127[List1.next]o125) :|: TRUE
f1974_0_main_JMP(EOS(STATIC_1974), i112, o127[List1.next]o125) -> f2012_0_main_Load(EOS(STATIC_2012), i112, o127[List1.next]o125) :|: TRUE
f2012_0_main_Load(EOS(STATIC_2012), i112, o127[List1.next]o125) -> f1779_0_main_Load(EOS(STATIC_1779), i112, o127[List1.next]o131) :|: TRUE
f1779_0_main_Load(EOS(STATIC_1779), i108, o127[List1.next]o125) -> f1792_0_main_Inc(EOS(STATIC_1792), i108, i108, o127[List1.next]o125) :|: TRUE
f1863_0__init__FieldAccess(EOS(STATIC_1863), i112) -> f1867_0__init__FieldAccess(EOS(STATIC_1867), i112) :|: TRUE
f1867_0__init__FieldAccess(EOS(STATIC_1867), i112) -> f1885_0__init__Load(EOS(STATIC_1885), i112) :|: TRUE
f1885_0__init__Load(EOS(STATIC_1885), i112) -> f1923_0__init__Load(EOS(STATIC_1923), i112) :|: TRUE
f1923_0__init__Load(EOS(STATIC_1923), i112) -> f1948_0__init__FieldAccess(EOS(STATIC_1948), i112) :|: TRUE
f1948_0__init__FieldAccess(EOS(STATIC_1948), i112) -> f1965_0__init__Return(EOS(STATIC_1965), i112) :|: TRUE
f1965_0__init__Return(EOS(STATIC_1965), i112) -> f1978_0_main_Store(EOS(STATIC_1978), i112) :|: TRUE
f1978_0_main_Store(EOS(STATIC_1978), i112) -> f2016_0_main_JMP(EOS(STATIC_2016), i112) :|: TRUE
f2016_0_main_JMP(EOS(STATIC_2016), i112) -> f2095_0_main_Load(EOS(STATIC_2095), i112) :|: TRUE
f2095_0_main_Load(EOS(STATIC_2095), i112) -> f1779_0_main_Load(EOS(STATIC_1779), i112, o146[List1.next]o131) :|: o146[List1.next]o131 = 1
Combined rules. Obtained 2 IRulesP rules:
f1792_0_main_Inc(EOS(STATIC_1792), i108:0, i108:0, o127[List1.next]o125:0) -> f1792_0_main_Inc(EOS(STATIC_1792), i108:0 - 1, i108:0 - 1, 1) :|: i108:0 > 0
f1792_0_main_Inc(EOS(STATIC_1792), i108:0, i108:0, o127[List1.next]o125:0) -> f1792_0_main_Inc(EOS(STATIC_1792), i108:0 - 1, i108:0 - 1, o127[List1.next]o131:0) :|: o127[List1.next]o125:0 > 0 && i108:0 > 0
Filtered constant ground arguments:
   f1792_0_main_Inc(x1, x2, x3, x4) -> f1792_0_main_Inc(x2, x3, x4)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f1792_0_main_Inc(x1, x2, x3) -> f1792_0_main_Inc(x2, x3)
Finished conversion. Obtained 2 rules.P rules:
f1792_0_main_Inc(i108:0, o127[List1.next]o125:0) -> f1792_0_main_Inc(i108:0 - 1, 1) :|: i108:0 > 0
f1792_0_main_Inc(i108:0, o127[List1.next]o125:0) -> f1792_0_main_Inc(i108:0 - 1, o127[List1.next]o131:0) :|: o127[List1.next]o125:0 > 0 && i108:0 > 0

----------------------------------------

(14)
Obligation:
Rules:
f1792_0_main_Inc(i108:0, o127[List1.next]o125:0) -> f1792_0_main_Inc(i108:0 - 1, 1) :|: i108:0 > 0
f1792_0_main_Inc(x, x1) -> f1792_0_main_Inc(x - 1, x2) :|: x1 > 0 && x > 0

----------------------------------------

(15) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(16)
Obligation:
Rules:
f1792_0_main_Inc(i108:0, o127[List1.next]o125:0) -> f1792_0_main_Inc(arith, 1) :|: i108:0 > 0 && arith = i108:0 - 1
f1792_0_main_Inc(x3, x4) -> f1792_0_main_Inc(x5, x6) :|: x4 > 0 && x3 > 0 && x5 = x3 - 1

----------------------------------------

(17) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f1792_0_main_Inc(i108:0, o127[List1.next]o125:0) -> f1792_0_main_Inc(arith, 1) :|: i108:0 > 0 && arith = i108:0 - 1
(2) f1792_0_main_Inc(x3, x4) -> f1792_0_main_Inc(x5, x6) :|: x4 > 0 && x3 > 0 && x5 = x3 - 1

Arcs:
(1) -> (1), (2)
(2) -> (1), (2)

This digraph is fully evaluated!
----------------------------------------

(18)
Obligation:

Termination digraph:
Nodes:
(1) f1792_0_main_Inc(i108:0, o127[List1.next]o125:0) -> f1792_0_main_Inc(arith, 1) :|: i108:0 > 0 && arith = i108:0 - 1
(2) f1792_0_main_Inc(x3, x4) -> f1792_0_main_Inc(x5, x6) :|: x4 > 0 && x3 > 0 && x5 = x3 - 1

Arcs:
(1) -> (1), (2)
(2) -> (1), (2)

This digraph is fully evaluated!

----------------------------------------

(19) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(20)
Obligation:
Rules:
f1792_0_main_Inc(i108:0:0, o127[List1.next]o125:0:0) -> f1792_0_main_Inc(i108:0:0 - 1, 1) :|: i108:0:0 > 0
f1792_0_main_Inc(x3:0, x4:0) -> f1792_0_main_Inc(x3:0 - 1, x6:0) :|: x4:0 > 0 && x3:0 > 0

----------------------------------------

(21) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f1792_0_main_Inc(INTEGER, VARIABLE)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(22)
Obligation:
Rules:
f1792_0_main_Inc(i108:0:0, o127[List1.next]o125:0:0) -> f1792_0_main_Inc(c, c1) :|: c1 = 1 && c = i108:0:0 - 1 && i108:0:0 > 0
f1792_0_main_Inc(x3:0, x4:0) -> f1792_0_main_Inc(c2, x6:0) :|: c2 = x3:0 - 1 && (x4:0 > 0 && x3:0 > 0)

----------------------------------------

(23) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f1792_0_main_Inc(x, x1)] = x

The following rules are decreasing:
f1792_0_main_Inc(i108:0:0, o127[List1.next]o125:0:0) -> f1792_0_main_Inc(c, c1) :|: c1 = 1 && c = i108:0:0 - 1 && i108:0:0 > 0
f1792_0_main_Inc(x3:0, x4:0) -> f1792_0_main_Inc(c2, x6:0) :|: c2 = x3:0 - 1 && (x4:0 > 0 && x3:0 > 0)
The following rules are bounded:
f1792_0_main_Inc(i108:0:0, o127[List1.next]o125:0:0) -> f1792_0_main_Inc(c, c1) :|: c1 = 1 && c = i108:0:0 - 1 && i108:0:0 > 0
f1792_0_main_Inc(x3:0, x4:0) -> f1792_0_main_Inc(c2, x6:0) :|: c2 = x3:0 - 1 && (x4:0 > 0 && x3:0 > 0)

----------------------------------------

(24)
YES
