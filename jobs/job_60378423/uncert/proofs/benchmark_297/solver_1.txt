YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/nJyTQ.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 264 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) AND
    (7) JBCTerminationSCC
        (8) SCCToIRSProof [SOUND, 11 ms]
        (9) IRSwT
        (10) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (11) IRSwT
        (12) IRSwTTerminationDigraphProof [EQUIVALENT, 9 ms]
        (13) IRSwT
        (14) IntTRSCompressionProof [EQUIVALENT, 0 ms]
        (15) IRSwT
        (16) IRSwTChainingProof [EQUIVALENT, 0 ms]
        (17) IRSwT
        (18) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
        (19) IRSwT
        (20) IntTRSCompressionProof [EQUIVALENT, 0 ms]
        (21) IRSwT
        (22) IRSwTChainingProof [EQUIVALENT, 0 ms]
        (23) IRSwT
        (24) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
        (25) IRSwT
        (26) IntTRSCompressionProof [EQUIVALENT, 0 ms]
        (27) IRSwT
        (28) TempFilterProof [SOUND, 20 ms]
        (29) IntTRS
        (30) PolynomialOrderProcessor [EQUIVALENT, 2 ms]
        (31) YES
    (32) JBCTerminationSCC
        (33) SCCToIRSProof [SOUND, 4 ms]
        (34) IRSwT
        (35) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (36) IRSwT
        (37) IRSwTTerminationDigraphProof [EQUIVALENT, 8 ms]
        (38) IRSwT
        (39) IntTRSCompressionProof [EQUIVALENT, 0 ms]
        (40) IRSwT
        (41) IRSwTChainingProof [EQUIVALENT, 0 ms]
        (42) IRSwT
        (43) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
        (44) IRSwT
        (45) IntTRSCompressionProof [EQUIVALENT, 0 ms]
        (46) IRSwT
        (47) IRSwTChainingProof [EQUIVALENT, 0 ms]
        (48) IRSwT
        (49) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
        (50) IRSwT
        (51) IntTRSCompressionProof [EQUIVALENT, 0 ms]
        (52) IRSwT
        (53) TempFilterProof [SOUND, 6 ms]
        (54) IntTRS
        (55) PolynomialOrderProcessor [EQUIVALENT, 0 ms]
        (56) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class Et3 {
    public static void main(String[] args) {
		Random.args = args;
	    int a =  Random.random(); 
	   	int b =  Random.random();	
	   	while (a > 0) {
	   	    a = a + b;
	   	    b = b - 1;

	   	}
    }
}

// bin(entry(C,D),[C>=1,A=C+D,B=D-1],entry(A,B))

public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
      if (index >= args.length)
	  return 0;

      String string = args[index];
      index++;
      return string.length();
  }
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class Et3 {
    public static void main(String[] args) {
		Random.args = args;
	    int a =  Random.random(); 
	   	int b =  Random.random();	
	   	while (a > 0) {
	   	    a = a + b;
	   	    b = b - 1;

	   	}
    }
}

// bin(entry(C,D),[C>=1,A=C+D,B=D-1],entry(A,B))

public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
      if (index >= args.length)
	  return 0;

      String string = args[index];
      index++;
      return string.length();
  }
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
Et3.main([Ljava/lang/String;)V: Graph of 234 nodes with 2 SCCs.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 2 SCCss.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: Et3.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(8) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 13 IRulesP rules:
f3434_0_main_LE(EOS(STATIC_3434), i975, i896, i975) -> f3445_0_main_LE(EOS(STATIC_3445), i975, i896, i975) :|: TRUE
f3445_0_main_LE(EOS(STATIC_3445), i975, i896, i975) -> f3458_0_main_Load(EOS(STATIC_3458), i975, i896) :|: i975 > 0
f3458_0_main_Load(EOS(STATIC_3458), i975, i896) -> f3466_0_main_Load(EOS(STATIC_3466), i896, i975) :|: TRUE
f3466_0_main_Load(EOS(STATIC_3466), i896, i975) -> f3471_0_main_IntArithmetic(EOS(STATIC_3471), i896, i975, i896) :|: TRUE
f3471_0_main_IntArithmetic(EOS(STATIC_3471), i896, i975, i896) -> f3479_0_main_Store(EOS(STATIC_3479), i896, i975 + i896) :|: i975 > 0
f3479_0_main_Store(EOS(STATIC_3479), i896, i983) -> f3486_0_main_Load(EOS(STATIC_3486), i983, i896) :|: TRUE
f3486_0_main_Load(EOS(STATIC_3486), i983, i896) -> f3665_0_main_ConstantStackPush(EOS(STATIC_3665), i983, i896) :|: TRUE
f3665_0_main_ConstantStackPush(EOS(STATIC_3665), i983, i896) -> f3669_0_main_IntArithmetic(EOS(STATIC_3669), i983, i896, 1) :|: TRUE
f3669_0_main_IntArithmetic(EOS(STATIC_3669), i983, i896, matching1) -> f3671_0_main_Store(EOS(STATIC_3671), i983, i896 - 1) :|: TRUE && matching1 = 1
f3671_0_main_Store(EOS(STATIC_3671), i983, i1030) -> f3675_0_main_JMP(EOS(STATIC_3675), i983, i1030) :|: TRUE
f3675_0_main_JMP(EOS(STATIC_3675), i983, i1030) -> f3778_0_main_Load(EOS(STATIC_3778), i983, i1030) :|: TRUE
f3778_0_main_Load(EOS(STATIC_3778), i983, i1030) -> f3300_0_main_Load(EOS(STATIC_3300), i983, i1030) :|: TRUE
f3300_0_main_Load(EOS(STATIC_3300), i895, i896) -> f3434_0_main_LE(EOS(STATIC_3434), i895, i896, i895) :|: TRUE
Combined rules. Obtained 1 IRulesP rules:
f3434_0_main_LE(EOS(STATIC_3434), i975:0, i896:0, i975:0) -> f3434_0_main_LE(EOS(STATIC_3434), i975:0 + i896:0, i896:0 - 1, i975:0 + i896:0) :|: i975:0 > 0
Filtered constant ground arguments:
   f3434_0_main_LE(x1, x2, x3, x4) -> f3434_0_main_LE(x2, x3, x4)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f3434_0_main_LE(x1, x2, x3) -> f3434_0_main_LE(x2, x3)
Finished conversion. Obtained 1 rules.P rules:
f3434_0_main_LE(i896:0, i975:0) -> f3434_0_main_LE(i896:0 - 1, i975:0 + i896:0) :|: i975:0 > 0

----------------------------------------

(9)
Obligation:
Rules:
f3434_0_main_LE(i896:0, i975:0) -> f3434_0_main_LE(i896:0 - 1, i975:0 + i896:0) :|: i975:0 > 0

----------------------------------------

(10) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(11)
Obligation:
Rules:
f3434_0_main_LE(i896:0, i975:0) -> f3434_0_main_LE(arith, arith1) :|: i975:0 > 0 && arith = i896:0 - 1 && arith1 = i975:0 + i896:0

----------------------------------------

(12) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f3434_0_main_LE(i896:0, i975:0) -> f3434_0_main_LE(arith, arith1) :|: i975:0 > 0 && arith = i896:0 - 1 && arith1 = i975:0 + i896:0

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(13)
Obligation:

Termination digraph:
Nodes:
(1) f3434_0_main_LE(i896:0, i975:0) -> f3434_0_main_LE(arith, arith1) :|: i975:0 > 0 && arith = i896:0 - 1 && arith1 = i975:0 + i896:0

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(14) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(15)
Obligation:
Rules:
f3434_0_main_LE(i896:0:0, i975:0:0) -> f3434_0_main_LE(i896:0:0 - 1, i975:0:0 + i896:0:0) :|: i975:0:0 > 0

----------------------------------------

(16) IRSwTChainingProof (EQUIVALENT)
Chaining!
----------------------------------------

(17)
Obligation:
Rules:
f3434_0_main_LE(x, x1) -> f3434_0_main_LE(x + -2, x1 + 2 * x + -1) :|: TRUE && x1 >= 1 && x1 + x >= 1

----------------------------------------

(18) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f3434_0_main_LE(x, x1) -> f3434_0_main_LE(x + -2, x1 + 2 * x + -1) :|: TRUE && x1 >= 1 && x1 + x >= 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(19)
Obligation:

Termination digraph:
Nodes:
(1) f3434_0_main_LE(x, x1) -> f3434_0_main_LE(x + -2, x1 + 2 * x + -1) :|: TRUE && x1 >= 1 && x1 + x >= 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(20) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(21)
Obligation:
Rules:
f3434_0_main_LE(x:0, x1:0) -> f3434_0_main_LE(x:0 - 2, x1:0 + 2 * x:0 - 1) :|: x1:0 + x:0 >= 1 && x1:0 > 0

----------------------------------------

(22) IRSwTChainingProof (EQUIVALENT)
Chaining!
----------------------------------------

(23)
Obligation:
Rules:
f3434_0_main_LE(x, x1) -> f3434_0_main_LE(x + -4, x1 + 4 * x + -6) :|: TRUE && x1 + x >= 1 && x1 >= 1 && x1 + 3 * x >= 4 && x1 + 2 * x >= 2

----------------------------------------

(24) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f3434_0_main_LE(x, x1) -> f3434_0_main_LE(x + -4, x1 + 4 * x + -6) :|: TRUE && x1 + x >= 1 && x1 >= 1 && x1 + 3 * x >= 4 && x1 + 2 * x >= 2

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(25)
Obligation:

Termination digraph:
Nodes:
(1) f3434_0_main_LE(x, x1) -> f3434_0_main_LE(x + -4, x1 + 4 * x + -6) :|: TRUE && x1 + x >= 1 && x1 >= 1 && x1 + 3 * x >= 4 && x1 + 2 * x >= 2

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(26) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(27)
Obligation:
Rules:
f3434_0_main_LE(x:0, x1:0) -> f3434_0_main_LE(x:0 - 4, x1:0 + 4 * x:0 - 6) :|: x1:0 + 3 * x:0 >= 4 && x1:0 + 2 * x:0 >= 2 && x1:0 + x:0 >= 1 && x1:0 > 0

----------------------------------------

(28) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f3434_0_main_LE(INTEGER, INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(29)
Obligation:
Rules:
f3434_0_main_LE(x:0, x1:0) -> f3434_0_main_LE(c, c1) :|: c1 = x1:0 + 4 * x:0 - 6 && c = x:0 - 4 && (x1:0 + 3 * x:0 >= 4 && x1:0 + 2 * x:0 >= 2 && x1:0 + x:0 >= 1 && x1:0 > 0)

----------------------------------------

(30) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f3434_0_main_LE(x, x1)] = -2 + 2*x + x^2 + 2*x1

The following rules are decreasing:
f3434_0_main_LE(x:0, x1:0) -> f3434_0_main_LE(c, c1) :|: c1 = x1:0 + 4 * x:0 - 6 && c = x:0 - 4 && (x1:0 + 3 * x:0 >= 4 && x1:0 + 2 * x:0 >= 2 && x1:0 + x:0 >= 1 && x1:0 > 0)
The following rules are bounded:
f3434_0_main_LE(x:0, x1:0) -> f3434_0_main_LE(c, c1) :|: c1 = x1:0 + 4 * x:0 - 6 && c = x:0 - 4 && (x1:0 + 3 * x:0 >= 4 && x1:0 + 2 * x:0 >= 2 && x1:0 + x:0 >= 1 && x1:0 > 0)

----------------------------------------

(31)
YES

----------------------------------------

(32)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: Et3.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(33) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 13 IRulesP rules:
f2996_0_main_LE(EOS(STATIC_2996), i832, i679, i832) -> f3005_0_main_LE(EOS(STATIC_3005), i832, i679, i832) :|: TRUE
f3005_0_main_LE(EOS(STATIC_3005), i832, i679, i832) -> f3093_0_main_Load(EOS(STATIC_3093), i832, i679) :|: i832 > 0
f3093_0_main_Load(EOS(STATIC_3093), i832, i679) -> f3141_0_main_Load(EOS(STATIC_3141), i679, i832) :|: TRUE
f3141_0_main_Load(EOS(STATIC_3141), i679, i832) -> f3308_0_main_IntArithmetic(EOS(STATIC_3308), i679, i832, i679) :|: TRUE
f3308_0_main_IntArithmetic(EOS(STATIC_3308), i679, i832, i679) -> f3440_0_main_Store(EOS(STATIC_3440), i679, i832 + i679) :|: i832 > 0
f3440_0_main_Store(EOS(STATIC_3440), i679, i972) -> f3447_0_main_Load(EOS(STATIC_3447), i972, i679) :|: TRUE
f3447_0_main_Load(EOS(STATIC_3447), i972, i679) -> f3460_0_main_ConstantStackPush(EOS(STATIC_3460), i972, i679) :|: TRUE
f3460_0_main_ConstantStackPush(EOS(STATIC_3460), i972, i679) -> f3469_0_main_IntArithmetic(EOS(STATIC_3469), i972, i679, 1) :|: TRUE
f3469_0_main_IntArithmetic(EOS(STATIC_3469), i972, i679, matching1) -> f3475_0_main_Store(EOS(STATIC_3475), i972, i679 - 1) :|: TRUE && matching1 = 1
f3475_0_main_Store(EOS(STATIC_3475), i972, i981) -> f3482_0_main_JMP(EOS(STATIC_3482), i972, i981) :|: TRUE
f3482_0_main_JMP(EOS(STATIC_3482), i972, i981) -> f3660_0_main_Load(EOS(STATIC_3660), i972, i981) :|: TRUE
f3660_0_main_Load(EOS(STATIC_3660), i972, i981) -> f2806_0_main_Load(EOS(STATIC_2806), i972, i981) :|: TRUE
f2806_0_main_Load(EOS(STATIC_2806), i678, i679) -> f2996_0_main_LE(EOS(STATIC_2996), i678, i679, i678) :|: TRUE
Combined rules. Obtained 1 IRulesP rules:
f2996_0_main_LE(EOS(STATIC_2996), i832:0, i679:0, i832:0) -> f2996_0_main_LE(EOS(STATIC_2996), i832:0 + i679:0, i679:0 - 1, i832:0 + i679:0) :|: i832:0 > 0
Filtered constant ground arguments:
   f2996_0_main_LE(x1, x2, x3, x4) -> f2996_0_main_LE(x2, x3, x4)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f2996_0_main_LE(x1, x2, x3) -> f2996_0_main_LE(x2, x3)
Finished conversion. Obtained 1 rules.P rules:
f2996_0_main_LE(i679:0, i832:0) -> f2996_0_main_LE(i679:0 - 1, i832:0 + i679:0) :|: i832:0 > 0

----------------------------------------

(34)
Obligation:
Rules:
f2996_0_main_LE(i679:0, i832:0) -> f2996_0_main_LE(i679:0 - 1, i832:0 + i679:0) :|: i832:0 > 0

----------------------------------------

(35) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(36)
Obligation:
Rules:
f2996_0_main_LE(i679:0, i832:0) -> f2996_0_main_LE(arith, arith1) :|: i832:0 > 0 && arith = i679:0 - 1 && arith1 = i832:0 + i679:0

----------------------------------------

(37) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f2996_0_main_LE(i679:0, i832:0) -> f2996_0_main_LE(arith, arith1) :|: i832:0 > 0 && arith = i679:0 - 1 && arith1 = i832:0 + i679:0

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(38)
Obligation:

Termination digraph:
Nodes:
(1) f2996_0_main_LE(i679:0, i832:0) -> f2996_0_main_LE(arith, arith1) :|: i832:0 > 0 && arith = i679:0 - 1 && arith1 = i832:0 + i679:0

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(39) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(40)
Obligation:
Rules:
f2996_0_main_LE(i679:0:0, i832:0:0) -> f2996_0_main_LE(i679:0:0 - 1, i832:0:0 + i679:0:0) :|: i832:0:0 > 0

----------------------------------------

(41) IRSwTChainingProof (EQUIVALENT)
Chaining!
----------------------------------------

(42)
Obligation:
Rules:
f2996_0_main_LE(x, x1) -> f2996_0_main_LE(x + -2, x1 + 2 * x + -1) :|: TRUE && x1 >= 1 && x1 + x >= 1

----------------------------------------

(43) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f2996_0_main_LE(x, x1) -> f2996_0_main_LE(x + -2, x1 + 2 * x + -1) :|: TRUE && x1 >= 1 && x1 + x >= 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(44)
Obligation:

Termination digraph:
Nodes:
(1) f2996_0_main_LE(x, x1) -> f2996_0_main_LE(x + -2, x1 + 2 * x + -1) :|: TRUE && x1 >= 1 && x1 + x >= 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(45) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(46)
Obligation:
Rules:
f2996_0_main_LE(x:0, x1:0) -> f2996_0_main_LE(x:0 - 2, x1:0 + 2 * x:0 - 1) :|: x1:0 + x:0 >= 1 && x1:0 > 0

----------------------------------------

(47) IRSwTChainingProof (EQUIVALENT)
Chaining!
----------------------------------------

(48)
Obligation:
Rules:
f2996_0_main_LE(x, x1) -> f2996_0_main_LE(x + -4, x1 + 4 * x + -6) :|: TRUE && x1 + x >= 1 && x1 >= 1 && x1 + 3 * x >= 4 && x1 + 2 * x >= 2

----------------------------------------

(49) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f2996_0_main_LE(x, x1) -> f2996_0_main_LE(x + -4, x1 + 4 * x + -6) :|: TRUE && x1 + x >= 1 && x1 >= 1 && x1 + 3 * x >= 4 && x1 + 2 * x >= 2

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(50)
Obligation:

Termination digraph:
Nodes:
(1) f2996_0_main_LE(x, x1) -> f2996_0_main_LE(x + -4, x1 + 4 * x + -6) :|: TRUE && x1 + x >= 1 && x1 >= 1 && x1 + 3 * x >= 4 && x1 + 2 * x >= 2

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(51) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(52)
Obligation:
Rules:
f2996_0_main_LE(x:0, x1:0) -> f2996_0_main_LE(x:0 - 4, x1:0 + 4 * x:0 - 6) :|: x1:0 + 3 * x:0 >= 4 && x1:0 + 2 * x:0 >= 2 && x1:0 + x:0 >= 1 && x1:0 > 0

----------------------------------------

(53) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f2996_0_main_LE(INTEGER, INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(54)
Obligation:
Rules:
f2996_0_main_LE(x:0, x1:0) -> f2996_0_main_LE(c, c1) :|: c1 = x1:0 + 4 * x:0 - 6 && c = x:0 - 4 && (x1:0 + 3 * x:0 >= 4 && x1:0 + 2 * x:0 >= 2 && x1:0 + x:0 >= 1 && x1:0 > 0)

----------------------------------------

(55) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f2996_0_main_LE(x, x1)] = -2 + 2*x + x^2 + 2*x1

The following rules are decreasing:
f2996_0_main_LE(x:0, x1:0) -> f2996_0_main_LE(c, c1) :|: c1 = x1:0 + 4 * x:0 - 6 && c = x:0 - 4 && (x1:0 + 3 * x:0 >= 4 && x1:0 + 2 * x:0 >= 2 && x1:0 + x:0 >= 1 && x1:0 > 0)
The following rules are bounded:
f2996_0_main_LE(x:0, x1:0) -> f2996_0_main_LE(c, c1) :|: c1 = x1:0 + 4 * x:0 - 6 && c = x:0 - 4 && (x1:0 + 3 * x:0 >= 4 && x1:0 + 2 * x:0 >= 2 && x1:0 + x:0 >= 1 && x1:0 > 0)

----------------------------------------

(56)
YES
