YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/v5CLV.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 163 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) AND
    (7) JBCTerminationSCC
        (8) SCCToQDPProof [SOUND, 32 ms]
        (9) QDP
        (10) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (11) YES
    (12) JBCTerminationSCC
        (13) SCCToIRSProof [SOUND, 24 ms]
        (14) IRSwT
        (15) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (16) IRSwT
        (17) IRSwTTerminationDigraphProof [EQUIVALENT, 8 ms]
        (18) IRSwT
        (19) IntTRSCompressionProof [EQUIVALENT, 0 ms]
        (20) IRSwT
        (21) TempFilterProof [SOUND, 5 ms]
        (22) IntTRS
        (23) PolynomialOrderProcessor [EQUIVALENT, 0 ms]
        (24) YES
    (25) JBCTerminationSCC
        (26) SCCToIRSProof [SOUND, 11 ms]
        (27) IRSwT
        (28) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (29) IRSwT
        (30) IRSwTTerminationDigraphProof [EQUIVALENT, 6 ms]
        (31) IRSwT
        (32) IntTRSCompressionProof [EQUIVALENT, 0 ms]
        (33) IRSwT
        (34) TempFilterProof [SOUND, 4 ms]
        (35) IntTRS
        (36) PolynomialOrderProcessor [EQUIVALENT, 0 ms]
        (37) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
package CyclicAnalysis;

public class CyclicAnalysis {
	CyclicAnalysis field;

	public static void main(String[] args) {
		Random.args = args;
		CyclicAnalysis t = new CyclicAnalysis();
		t.field = new CyclicAnalysis();
		t.field.appendNewCyclicList(Random.random());
		t.appendNewList(Random.random());
		t.length();
	}

	public int length() {
		int length = 1;
		CyclicAnalysis cur = this.field;
		while (cur != null) {
			cur = cur.field;
			length++;
		}
		return length;
	}

	public void appendNewCyclicList(int i) {
		CyclicAnalysis last = this.appendNewList(i);
		last.field = this;
	}

	/**
 	 * @param i number of elements to append
 	 * @return the last list element appended
 	 */
	private CyclicAnalysis appendNewList(int i) {
		this.field = new CyclicAnalysis();
		CyclicAnalysis cur = this.field;
		while (i > 1) {
			i--;
			cur = cur.field = new CyclicAnalysis();
		}
		return cur;
	}
}


package CyclicAnalysis;

public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
    final String string = args[index];
    index++;
    return string.length();
  }
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
package CyclicAnalysis;

public class CyclicAnalysis {
	CyclicAnalysis field;

	public static void main(String[] args) {
		Random.args = args;
		CyclicAnalysis t = new CyclicAnalysis();
		t.field = new CyclicAnalysis();
		t.field.appendNewCyclicList(Random.random());
		t.appendNewList(Random.random());
		t.length();
	}

	public int length() {
		int length = 1;
		CyclicAnalysis cur = this.field;
		while (cur != null) {
			cur = cur.field;
			length++;
		}
		return length;
	}

	public void appendNewCyclicList(int i) {
		CyclicAnalysis last = this.appendNewList(i);
		last.field = this;
	}

	/**
 	 * @param i number of elements to append
 	 * @return the last list element appended
 	 */
	private CyclicAnalysis appendNewList(int i) {
		this.field = new CyclicAnalysis();
		CyclicAnalysis cur = this.field;
		while (i > 1) {
			i--;
			cur = cur.field = new CyclicAnalysis();
		}
		return cur;
	}
}


package CyclicAnalysis;

public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
    final String string = args[index];
    index++;
    return string.length();
  }
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
CyclicAnalysis.CyclicAnalysis.main([Ljava/lang/String;)V: Graph of 299 nodes with 3 SCCs.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 3 SCCss.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: CyclicAnalysis.CyclicAnalysis.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:
*CyclicAnalysis.CyclicAnalysis: [field]
*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(8) SCCToQDPProof (SOUND)
Transformed TerminationGraph SCC to QDP. Log: 
Generated 10 rules for P and 0 rules for R.P rules:
f1250_0_length_NULL(EOS(STATIC_1250), java.lang.Object(o185sub), java.lang.Object(o185sub)) -> f1251_0_length_NULL(EOS(STATIC_1251), java.lang.Object(o185sub), java.lang.Object(o185sub)) :|: TRUE
f1251_0_length_NULL(EOS(STATIC_1251), java.lang.Object(o185sub), java.lang.Object(o185sub)) -> f1253_0_length_Load(EOS(STATIC_1253), java.lang.Object(o185sub)) :|: TRUE
f1253_0_length_Load(EOS(STATIC_1253), java.lang.Object(o185sub)) -> f1255_0_length_FieldAccess(EOS(STATIC_1255), java.lang.Object(o185sub)) :|: TRUE
f1255_0_length_FieldAccess(EOS(STATIC_1255), java.lang.Object(CyclicAnalysis.CyclicAnalysis(EOC, o187))) -> f1257_0_length_FieldAccess(EOS(STATIC_1257), java.lang.Object(CyclicAnalysis.CyclicAnalysis(EOC, o187))) :|: TRUE
f1257_0_length_FieldAccess(EOS(STATIC_1257), java.lang.Object(CyclicAnalysis.CyclicAnalysis(EOC, o187))) -> f1259_0_length_Store(EOS(STATIC_1259), o187) :|: TRUE
f1259_0_length_Store(EOS(STATIC_1259), o187) -> f1261_0_length_Inc(EOS(STATIC_1261), o187) :|: TRUE
f1261_0_length_Inc(EOS(STATIC_1261), o187) -> f1263_0_length_JMP(EOS(STATIC_1263), o187) :|: TRUE
f1263_0_length_JMP(EOS(STATIC_1263), o187) -> f1264_0_length_Load(EOS(STATIC_1264), o187) :|: TRUE
f1264_0_length_Load(EOS(STATIC_1264), o187) -> f1249_0_length_Load(EOS(STATIC_1249), o187) :|: TRUE
f1249_0_length_Load(EOS(STATIC_1249), o183) -> f1250_0_length_NULL(EOS(STATIC_1250), o183, o183) :|: TRUE
R rules:
Combined rules. Obtained 1 conditional rules for P and 0 conditional rules for R.P rules:
f1250_0_length_NULL(EOS(STATIC_1250), java.lang.Object(CyclicAnalysis.CyclicAnalysis(EOC, o187:0)), java.lang.Object(CyclicAnalysis.CyclicAnalysis(EOC, o187:0))) -> f1250_0_length_NULL(EOS(STATIC_1250), o187:0, o187:0) :|: TRUE
R rules:
Filtered ground terms:
   f1250_0_length_NULL(x1, x2, x3) -> f1250_0_length_NULL(x2, x3)
   EOS(x1) -> EOS
   CyclicAnalysis.CyclicAnalysis(x1, x2) -> CyclicAnalysis.CyclicAnalysis(x2)
Filtered duplicate args:
   f1250_0_length_NULL(x1, x2) -> f1250_0_length_NULL(x2)
Combined rules. Obtained 1 conditional rules for P and 0 conditional rules for R.P rules:
F1250_0_LENGTH_NULL(java.lang.Object(CyclicAnalysis.CyclicAnalysis(o187:0:0))) -> F1250_0_LENGTH_NULL(o187:0:0) :|: TRUE
R rules:

----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1250_0_LENGTH_NULL(java.lang.Object(CyclicAnalysis.CyclicAnalysis(o187:0:0))) -> F1250_0_LENGTH_NULL(o187:0:0)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(10) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*F1250_0_LENGTH_NULL(java.lang.Object(CyclicAnalysis.CyclicAnalysis(o187:0:0))) -> F1250_0_LENGTH_NULL(o187:0:0)
The graph contains the following edges 1 > 1


----------------------------------------

(11)
YES

----------------------------------------

(12)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: CyclicAnalysis.CyclicAnalysis.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(13) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 23 IRulesP rules:
f887_0_appendNewList_ConstantStackPush(EOS(STATIC_887), i101, i101, o135[CyclicAnalysis.field]o132) -> f889_0_appendNewList_LE(EOS(STATIC_889), i101, i101, 1, o135[CyclicAnalysis.field]o132) :|: TRUE
f889_0_appendNewList_LE(EOS(STATIC_889), i109, i109, matching1, o135[CyclicAnalysis.field]o132) -> f894_0_appendNewList_LE(EOS(STATIC_894), i109, i109, 1, o135[CyclicAnalysis.field]o132) :|: TRUE && matching1 = 1
f894_0_appendNewList_LE(EOS(STATIC_894), i109, i109, matching1, o135[CyclicAnalysis.field]o132) -> f905_0_appendNewList_Inc(EOS(STATIC_905), i109, o135[CyclicAnalysis.field]o132) :|: i109 > 1 && matching1 = 1
f905_0_appendNewList_Inc(EOS(STATIC_905), i109, o135[CyclicAnalysis.field]o132) -> f975_0_appendNewList_Load(EOS(STATIC_975), i109 + -1, o135[CyclicAnalysis.field]o132) :|: TRUE
f975_0_appendNewList_Load(EOS(STATIC_975), i119, o135[CyclicAnalysis.field]o132) -> f977_0_appendNewList_New(EOS(STATIC_977), i119, o135[CyclicAnalysis.field]o132) :|: TRUE
f977_0_appendNewList_New(EOS(STATIC_977), i119, o135[CyclicAnalysis.field]o132) -> f983_0_appendNewList_Duplicate(EOS(STATIC_983), i119, o135[CyclicAnalysis.field]o132) :|: TRUE
f983_0_appendNewList_Duplicate(EOS(STATIC_983), i119, o135[CyclicAnalysis.field]o132) -> f990_0_appendNewList_InvokeMethod(EOS(STATIC_990), i119, o135[CyclicAnalysis.field]o132) :|: TRUE
f990_0_appendNewList_InvokeMethod(EOS(STATIC_990), i119, o135[CyclicAnalysis.field]o132) -> f995_0__init__Load(EOS(STATIC_995), i119, o135[CyclicAnalysis.field]o132) :|: TRUE
f995_0__init__Load(EOS(STATIC_995), i119, o135[CyclicAnalysis.field]o132) -> f1002_0__init__InvokeMethod(EOS(STATIC_1002), i119, o135[CyclicAnalysis.field]o132) :|: TRUE
f1002_0__init__InvokeMethod(EOS(STATIC_1002), i119, o135[CyclicAnalysis.field]o132) -> f1016_0__init__Return(EOS(STATIC_1016), i119, o135[CyclicAnalysis.field]o132) :|: TRUE
f1016_0__init__Return(EOS(STATIC_1016), i119, o135[CyclicAnalysis.field]o132) -> f1018_0_appendNewList_Duplicate(EOS(STATIC_1018), i119, o135[CyclicAnalysis.field]o132) :|: TRUE
f1018_0_appendNewList_Duplicate(EOS(STATIC_1018), i119, o135[CyclicAnalysis.field]o132) -> f1025_0_appendNewList_FieldAccess(EOS(STATIC_1025), i119, o135[CyclicAnalysis.field]o132) :|: TRUE
f1025_0_appendNewList_FieldAccess(EOS(STATIC_1025), i119, o135[CyclicAnalysis.field]o132) -> f1038_0_appendNewList_FieldAccess(EOS(STATIC_1038), i119, o135[CyclicAnalysis.field]o132) :|: o135[CyclicAnalysis.field]o132 > 0
f1025_0_appendNewList_FieldAccess(EOS(STATIC_1025), i119, o153[CyclicAnalysis.field]o153) -> f1039_0_appendNewList_FieldAccess(EOS(STATIC_1039), i119) :|: TRUE
f1038_0_appendNewList_FieldAccess(EOS(STATIC_1038), i119, o135[CyclicAnalysis.field]o132) -> f1053_0_appendNewList_Store(EOS(STATIC_1053), i119, o135[CyclicAnalysis.field]o144) :|: o135[CyclicAnalysis.field]o144 > o135[CyclicAnalysis.field]o132 && o135[CyclicAnalysis.field]o132 >= 0
f1053_0_appendNewList_Store(EOS(STATIC_1053), i119, o135[CyclicAnalysis.field]o144) -> f1060_0_appendNewList_JMP(EOS(STATIC_1060), i119, o135[CyclicAnalysis.field]o144) :|: TRUE
f1060_0_appendNewList_JMP(EOS(STATIC_1060), i119, o135[CyclicAnalysis.field]o144) -> f1080_0_appendNewList_Load(EOS(STATIC_1080), i119, o135[CyclicAnalysis.field]o144) :|: TRUE
f1080_0_appendNewList_Load(EOS(STATIC_1080), i119, o135[CyclicAnalysis.field]o144) -> f885_0_appendNewList_Load(EOS(STATIC_885), i119, o135[CyclicAnalysis.field]o144) :|: TRUE
f885_0_appendNewList_Load(EOS(STATIC_885), i101, o135[CyclicAnalysis.field]o132) -> f887_0_appendNewList_ConstantStackPush(EOS(STATIC_887), i101, i101, o135[CyclicAnalysis.field]o132) :|: TRUE
f1039_0_appendNewList_FieldAccess(EOS(STATIC_1039), i119) -> f1057_0_appendNewList_Store(EOS(STATIC_1057), i119) :|: TRUE
f1057_0_appendNewList_Store(EOS(STATIC_1057), i119) -> f1061_0_appendNewList_JMP(EOS(STATIC_1061), i119) :|: TRUE
f1061_0_appendNewList_JMP(EOS(STATIC_1061), i119) -> f1096_0_appendNewList_Load(EOS(STATIC_1096), i119) :|: TRUE
f1096_0_appendNewList_Load(EOS(STATIC_1096), i119) -> f885_0_appendNewList_Load(EOS(STATIC_885), i119, o153[CyclicAnalysis.field]o144) :|: o153[CyclicAnalysis.field]o144 = 1
Combined rules. Obtained 2 IRulesP rules:
f887_0_appendNewList_ConstantStackPush(EOS(STATIC_887), i101:0, i101:0, o135[CyclicAnalysis.field]o132:0) -> f887_0_appendNewList_ConstantStackPush(EOS(STATIC_887), i101:0 - 1, i101:0 - 1, 1) :|: i101:0 > 1
f887_0_appendNewList_ConstantStackPush(EOS(STATIC_887), i101:0, i101:0, o135[CyclicAnalysis.field]o132:0) -> f887_0_appendNewList_ConstantStackPush(EOS(STATIC_887), i101:0 - 1, i101:0 - 1, o135[CyclicAnalysis.field]o144:0) :|: o135[CyclicAnalysis.field]o132:0 > 0 && o135[CyclicAnalysis.field]o144:0 > o135[CyclicAnalysis.field]o132:0 && i101:0 > 1
Filtered constant ground arguments:
   f887_0_appendNewList_ConstantStackPush(x1, x2, x3, x4) -> f887_0_appendNewList_ConstantStackPush(x2, x3, x4)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f887_0_appendNewList_ConstantStackPush(x1, x2, x3) -> f887_0_appendNewList_ConstantStackPush(x2, x3)
Finished conversion. Obtained 2 rules.P rules:
f887_0_appendNewList_ConstantStackPush(i101:0, o135[CyclicAnalysis.field]o132:0) -> f887_0_appendNewList_ConstantStackPush(i101:0 - 1, 1) :|: i101:0 > 1
f887_0_appendNewList_ConstantStackPush(i101:0, o135[CyclicAnalysis.field]o132:0) -> f887_0_appendNewList_ConstantStackPush(i101:0 - 1, o135[CyclicAnalysis.field]o144:0) :|: o135[CyclicAnalysis.field]o144:0 > o135[CyclicAnalysis.field]o132:0 && i101:0 > 1 && o135[CyclicAnalysis.field]o132:0 > 0

----------------------------------------

(14)
Obligation:
Rules:
f887_0_appendNewList_ConstantStackPush(i101:0, o135[CyclicAnalysis.field]o132:0) -> f887_0_appendNewList_ConstantStackPush(i101:0 - 1, 1) :|: i101:0 > 1
f887_0_appendNewList_ConstantStackPush(x, x1) -> f887_0_appendNewList_ConstantStackPush(x - 1, x2) :|: x2 > x1 && x > 1 && x1 > 0

----------------------------------------

(15) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(16)
Obligation:
Rules:
f887_0_appendNewList_ConstantStackPush(i101:0, o135[CyclicAnalysis.field]o132:0) -> f887_0_appendNewList_ConstantStackPush(arith, 1) :|: i101:0 > 1 && arith = i101:0 - 1
f887_0_appendNewList_ConstantStackPush(x3, x4) -> f887_0_appendNewList_ConstantStackPush(x5, x6) :|: x6 > x4 && x3 > 1 && x4 > 0 && x5 = x3 - 1

----------------------------------------

(17) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f887_0_appendNewList_ConstantStackPush(i101:0, o135[CyclicAnalysis.field]o132:0) -> f887_0_appendNewList_ConstantStackPush(arith, 1) :|: i101:0 > 1 && arith = i101:0 - 1
(2) f887_0_appendNewList_ConstantStackPush(x3, x4) -> f887_0_appendNewList_ConstantStackPush(x5, x6) :|: x6 > x4 && x3 > 1 && x4 > 0 && x5 = x3 - 1

Arcs:
(1) -> (1), (2)
(2) -> (1), (2)

This digraph is fully evaluated!
----------------------------------------

(18)
Obligation:

Termination digraph:
Nodes:
(1) f887_0_appendNewList_ConstantStackPush(i101:0, o135[CyclicAnalysis.field]o132:0) -> f887_0_appendNewList_ConstantStackPush(arith, 1) :|: i101:0 > 1 && arith = i101:0 - 1
(2) f887_0_appendNewList_ConstantStackPush(x3, x4) -> f887_0_appendNewList_ConstantStackPush(x5, x6) :|: x6 > x4 && x3 > 1 && x4 > 0 && x5 = x3 - 1

Arcs:
(1) -> (1), (2)
(2) -> (1), (2)

This digraph is fully evaluated!

----------------------------------------

(19) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(20)
Obligation:
Rules:
f887_0_appendNewList_ConstantStackPush(x3:0, x4:0) -> f887_0_appendNewList_ConstantStackPush(x3:0 - 1, x6:0) :|: x6:0 > x4:0 && x3:0 > 1 && x4:0 > 0
f887_0_appendNewList_ConstantStackPush(i101:0:0, o135[CyclicAnalysis.field]o132:0:0) -> f887_0_appendNewList_ConstantStackPush(i101:0:0 - 1, 1) :|: i101:0:0 > 1

----------------------------------------

(21) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f887_0_appendNewList_ConstantStackPush(INTEGER, VARIABLE)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(22)
Obligation:
Rules:
f887_0_appendNewList_ConstantStackPush(x3:0, x4:0) -> f887_0_appendNewList_ConstantStackPush(c, x6:0) :|: c = x3:0 - 1 && (x6:0 > x4:0 && x3:0 > 1 && x4:0 > 0)
f887_0_appendNewList_ConstantStackPush(i101:0:0, o135[CyclicAnalysis.field]o132:0:0) -> f887_0_appendNewList_ConstantStackPush(c1, c2) :|: c2 = 1 && c1 = i101:0:0 - 1 && i101:0:0 > 1

----------------------------------------

(23) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f887_0_appendNewList_ConstantStackPush(x, x1)] = x

The following rules are decreasing:
f887_0_appendNewList_ConstantStackPush(x3:0, x4:0) -> f887_0_appendNewList_ConstantStackPush(c, x6:0) :|: c = x3:0 - 1 && (x6:0 > x4:0 && x3:0 > 1 && x4:0 > 0)
f887_0_appendNewList_ConstantStackPush(i101:0:0, o135[CyclicAnalysis.field]o132:0:0) -> f887_0_appendNewList_ConstantStackPush(c1, c2) :|: c2 = 1 && c1 = i101:0:0 - 1 && i101:0:0 > 1
The following rules are bounded:
f887_0_appendNewList_ConstantStackPush(x3:0, x4:0) -> f887_0_appendNewList_ConstantStackPush(c, x6:0) :|: c = x3:0 - 1 && (x6:0 > x4:0 && x3:0 > 1 && x4:0 > 0)
f887_0_appendNewList_ConstantStackPush(i101:0:0, o135[CyclicAnalysis.field]o132:0:0) -> f887_0_appendNewList_ConstantStackPush(c1, c2) :|: c2 = 1 && c1 = i101:0:0 - 1 && i101:0:0 > 1

----------------------------------------

(24)
YES

----------------------------------------

(25)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: CyclicAnalysis.CyclicAnalysis.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(26) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 23 IRulesP rules:
f385_0_appendNewList_ConstantStackPush(EOS(STATIC_385), i33, i33, o43[CyclicAnalysis.field]o41) -> f389_0_appendNewList_LE(EOS(STATIC_389), i33, i33, 1, o43[CyclicAnalysis.field]o41) :|: TRUE
f389_0_appendNewList_LE(EOS(STATIC_389), i42, i42, matching1, o43[CyclicAnalysis.field]o41) -> f397_0_appendNewList_LE(EOS(STATIC_397), i42, i42, 1, o43[CyclicAnalysis.field]o41) :|: TRUE && matching1 = 1
f397_0_appendNewList_LE(EOS(STATIC_397), i42, i42, matching1, o43[CyclicAnalysis.field]o41) -> f410_0_appendNewList_Inc(EOS(STATIC_410), i42, o43[CyclicAnalysis.field]o41) :|: i42 > 1 && matching1 = 1
f410_0_appendNewList_Inc(EOS(STATIC_410), i42, o43[CyclicAnalysis.field]o41) -> f415_0_appendNewList_Load(EOS(STATIC_415), i42 + -1, o43[CyclicAnalysis.field]o41) :|: TRUE
f415_0_appendNewList_Load(EOS(STATIC_415), i44, o43[CyclicAnalysis.field]o41) -> f418_0_appendNewList_New(EOS(STATIC_418), i44, o43[CyclicAnalysis.field]o41) :|: TRUE
f418_0_appendNewList_New(EOS(STATIC_418), i44, o43[CyclicAnalysis.field]o41) -> f420_0_appendNewList_Duplicate(EOS(STATIC_420), i44, o43[CyclicAnalysis.field]o41) :|: TRUE
f420_0_appendNewList_Duplicate(EOS(STATIC_420), i44, o43[CyclicAnalysis.field]o41) -> f423_0_appendNewList_InvokeMethod(EOS(STATIC_423), i44, o43[CyclicAnalysis.field]o41) :|: TRUE
f423_0_appendNewList_InvokeMethod(EOS(STATIC_423), i44, o43[CyclicAnalysis.field]o41) -> f425_0__init__Load(EOS(STATIC_425), i44, o43[CyclicAnalysis.field]o41) :|: TRUE
f425_0__init__Load(EOS(STATIC_425), i44, o43[CyclicAnalysis.field]o41) -> f481_0__init__InvokeMethod(EOS(STATIC_481), i44, o43[CyclicAnalysis.field]o41) :|: TRUE
f481_0__init__InvokeMethod(EOS(STATIC_481), i44, o43[CyclicAnalysis.field]o41) -> f490_0__init__Return(EOS(STATIC_490), i44, o43[CyclicAnalysis.field]o41) :|: TRUE
f490_0__init__Return(EOS(STATIC_490), i44, o43[CyclicAnalysis.field]o41) -> f498_0_appendNewList_Duplicate(EOS(STATIC_498), i44, o43[CyclicAnalysis.field]o41) :|: TRUE
f498_0_appendNewList_Duplicate(EOS(STATIC_498), i44, o43[CyclicAnalysis.field]o41) -> f505_0_appendNewList_FieldAccess(EOS(STATIC_505), i44, o43[CyclicAnalysis.field]o41) :|: TRUE
f505_0_appendNewList_FieldAccess(EOS(STATIC_505), i44, o43[CyclicAnalysis.field]o41) -> f513_0_appendNewList_FieldAccess(EOS(STATIC_513), i44, o43[CyclicAnalysis.field]o41) :|: o43[CyclicAnalysis.field]o41 > 0
f505_0_appendNewList_FieldAccess(EOS(STATIC_505), i44, o79[CyclicAnalysis.field]o79) -> f514_0_appendNewList_FieldAccess(EOS(STATIC_514), i44) :|: TRUE
f513_0_appendNewList_FieldAccess(EOS(STATIC_513), i44, o43[CyclicAnalysis.field]o41) -> f524_0_appendNewList_Store(EOS(STATIC_524), i44, o43[CyclicAnalysis.field]o60) :|: o43[CyclicAnalysis.field]o60 > o43[CyclicAnalysis.field]o41 && o43[CyclicAnalysis.field]o41 >= 0
f524_0_appendNewList_Store(EOS(STATIC_524), i44, o43[CyclicAnalysis.field]o60) -> f561_0_appendNewList_JMP(EOS(STATIC_561), i44, o43[CyclicAnalysis.field]o60) :|: TRUE
f561_0_appendNewList_JMP(EOS(STATIC_561), i44, o43[CyclicAnalysis.field]o60) -> f590_0_appendNewList_Load(EOS(STATIC_590), i44, o43[CyclicAnalysis.field]o60) :|: TRUE
f590_0_appendNewList_Load(EOS(STATIC_590), i44, o43[CyclicAnalysis.field]o60) -> f376_0_appendNewList_Load(EOS(STATIC_376), i44, o43[CyclicAnalysis.field]o60) :|: TRUE
f376_0_appendNewList_Load(EOS(STATIC_376), i33, o43[CyclicAnalysis.field]o41) -> f385_0_appendNewList_ConstantStackPush(EOS(STATIC_385), i33, i33, o43[CyclicAnalysis.field]o41) :|: TRUE
f514_0_appendNewList_FieldAccess(EOS(STATIC_514), i44) -> f526_0_appendNewList_Store(EOS(STATIC_526), i44) :|: TRUE
f526_0_appendNewList_Store(EOS(STATIC_526), i44) -> f565_0_appendNewList_JMP(EOS(STATIC_565), i44) :|: TRUE
f565_0_appendNewList_JMP(EOS(STATIC_565), i44) -> f615_0_appendNewList_Load(EOS(STATIC_615), i44) :|: TRUE
f615_0_appendNewList_Load(EOS(STATIC_615), i44) -> f376_0_appendNewList_Load(EOS(STATIC_376), i44, o79[CyclicAnalysis.field]o60) :|: o79[CyclicAnalysis.field]o60 = 1
Combined rules. Obtained 2 IRulesP rules:
f385_0_appendNewList_ConstantStackPush(EOS(STATIC_385), i33:0, i33:0, o43[CyclicAnalysis.field]o41:0) -> f385_0_appendNewList_ConstantStackPush(EOS(STATIC_385), i33:0 - 1, i33:0 - 1, 1) :|: i33:0 > 1
f385_0_appendNewList_ConstantStackPush(EOS(STATIC_385), i33:0, i33:0, o43[CyclicAnalysis.field]o41:0) -> f385_0_appendNewList_ConstantStackPush(EOS(STATIC_385), i33:0 - 1, i33:0 - 1, o43[CyclicAnalysis.field]o60:0) :|: o43[CyclicAnalysis.field]o41:0 > 0 && o43[CyclicAnalysis.field]o60:0 > o43[CyclicAnalysis.field]o41:0 && i33:0 > 1
Filtered constant ground arguments:
   f385_0_appendNewList_ConstantStackPush(x1, x2, x3, x4) -> f385_0_appendNewList_ConstantStackPush(x2, x3, x4)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f385_0_appendNewList_ConstantStackPush(x1, x2, x3) -> f385_0_appendNewList_ConstantStackPush(x2, x3)
Finished conversion. Obtained 2 rules.P rules:
f385_0_appendNewList_ConstantStackPush(i33:0, o43[CyclicAnalysis.field]o41:0) -> f385_0_appendNewList_ConstantStackPush(i33:0 - 1, 1) :|: i33:0 > 1
f385_0_appendNewList_ConstantStackPush(i33:0, o43[CyclicAnalysis.field]o41:0) -> f385_0_appendNewList_ConstantStackPush(i33:0 - 1, o43[CyclicAnalysis.field]o60:0) :|: o43[CyclicAnalysis.field]o60:0 > o43[CyclicAnalysis.field]o41:0 && i33:0 > 1 && o43[CyclicAnalysis.field]o41:0 > 0

----------------------------------------

(27)
Obligation:
Rules:
f385_0_appendNewList_ConstantStackPush(i33:0, o43[CyclicAnalysis.field]o41:0) -> f385_0_appendNewList_ConstantStackPush(i33:0 - 1, 1) :|: i33:0 > 1
f385_0_appendNewList_ConstantStackPush(x, x1) -> f385_0_appendNewList_ConstantStackPush(x - 1, x2) :|: x2 > x1 && x > 1 && x1 > 0

----------------------------------------

(28) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(29)
Obligation:
Rules:
f385_0_appendNewList_ConstantStackPush(i33:0, o43[CyclicAnalysis.field]o41:0) -> f385_0_appendNewList_ConstantStackPush(arith, 1) :|: i33:0 > 1 && arith = i33:0 - 1
f385_0_appendNewList_ConstantStackPush(x3, x4) -> f385_0_appendNewList_ConstantStackPush(x5, x6) :|: x6 > x4 && x3 > 1 && x4 > 0 && x5 = x3 - 1

----------------------------------------

(30) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f385_0_appendNewList_ConstantStackPush(i33:0, o43[CyclicAnalysis.field]o41:0) -> f385_0_appendNewList_ConstantStackPush(arith, 1) :|: i33:0 > 1 && arith = i33:0 - 1
(2) f385_0_appendNewList_ConstantStackPush(x3, x4) -> f385_0_appendNewList_ConstantStackPush(x5, x6) :|: x6 > x4 && x3 > 1 && x4 > 0 && x5 = x3 - 1

Arcs:
(1) -> (1), (2)
(2) -> (1), (2)

This digraph is fully evaluated!
----------------------------------------

(31)
Obligation:

Termination digraph:
Nodes:
(1) f385_0_appendNewList_ConstantStackPush(i33:0, o43[CyclicAnalysis.field]o41:0) -> f385_0_appendNewList_ConstantStackPush(arith, 1) :|: i33:0 > 1 && arith = i33:0 - 1
(2) f385_0_appendNewList_ConstantStackPush(x3, x4) -> f385_0_appendNewList_ConstantStackPush(x5, x6) :|: x6 > x4 && x3 > 1 && x4 > 0 && x5 = x3 - 1

Arcs:
(1) -> (1), (2)
(2) -> (1), (2)

This digraph is fully evaluated!

----------------------------------------

(32) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(33)
Obligation:
Rules:
f385_0_appendNewList_ConstantStackPush(x3:0, x4:0) -> f385_0_appendNewList_ConstantStackPush(x3:0 - 1, x6:0) :|: x6:0 > x4:0 && x3:0 > 1 && x4:0 > 0
f385_0_appendNewList_ConstantStackPush(i33:0:0, o43[CyclicAnalysis.field]o41:0:0) -> f385_0_appendNewList_ConstantStackPush(i33:0:0 - 1, 1) :|: i33:0:0 > 1

----------------------------------------

(34) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f385_0_appendNewList_ConstantStackPush(INTEGER, VARIABLE)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(35)
Obligation:
Rules:
f385_0_appendNewList_ConstantStackPush(x3:0, x4:0) -> f385_0_appendNewList_ConstantStackPush(c, x6:0) :|: c = x3:0 - 1 && (x6:0 > x4:0 && x3:0 > 1 && x4:0 > 0)
f385_0_appendNewList_ConstantStackPush(i33:0:0, o43[CyclicAnalysis.field]o41:0:0) -> f385_0_appendNewList_ConstantStackPush(c1, c2) :|: c2 = 1 && c1 = i33:0:0 - 1 && i33:0:0 > 1

----------------------------------------

(36) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f385_0_appendNewList_ConstantStackPush(x, x1)] = x

The following rules are decreasing:
f385_0_appendNewList_ConstantStackPush(x3:0, x4:0) -> f385_0_appendNewList_ConstantStackPush(c, x6:0) :|: c = x3:0 - 1 && (x6:0 > x4:0 && x3:0 > 1 && x4:0 > 0)
f385_0_appendNewList_ConstantStackPush(i33:0:0, o43[CyclicAnalysis.field]o41:0:0) -> f385_0_appendNewList_ConstantStackPush(c1, c2) :|: c2 = 1 && c1 = i33:0:0 - 1 && i33:0:0 > 1
The following rules are bounded:
f385_0_appendNewList_ConstantStackPush(x3:0, x4:0) -> f385_0_appendNewList_ConstantStackPush(c, x6:0) :|: c = x3:0 - 1 && (x6:0 > x4:0 && x3:0 > 1 && x4:0 > 0)
f385_0_appendNewList_ConstantStackPush(i33:0:0, o43[CyclicAnalysis.field]o41:0:0) -> f385_0_appendNewList_ConstantStackPush(c1, c2) :|: c2 = 1 && c1 = i33:0:0 - 1 && i33:0:0 > 1

----------------------------------------

(37)
YES
