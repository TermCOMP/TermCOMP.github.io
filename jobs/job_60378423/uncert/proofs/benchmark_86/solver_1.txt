YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/hqZbF.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 161 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) JBCTerminationSCC
(7) SCCToIRSProof [SOUND, 36 ms]
(8) IRSwT
(9) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
(10) IRSwT
(11) IRSwTTerminationDigraphProof [EQUIVALENT, 16 ms]
(12) IRSwT
(13) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(14) IRSwT
(15) TempFilterProof [SOUND, 8 ms]
(16) IntTRS
(17) PolynomialOrderProcessor [EQUIVALENT, 0 ms]
(18) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class IntRTA {
  // only wrap a primitive int
  private int val;

  // count up to the value
  // in "limit"
  public static void count(
      IntRTA orig, IntRTA limit) {

    if (orig == null
        || limit == null) {
      return;
    }

    // introduce sharing
    IntRTA copy = orig;

    while (orig.val < limit.val) {
      copy.val++;
    }
  }

  public static void main(String[] args) {
    Random.args = args;
    IntRTA x = new IntRTA();
    x.val = Random.random();
    IntRTA y = new IntRTA();
    y.val = Random.random();
    count(x, y);
  }
}


public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
    String string = args[index];
    index++;
    return string.length();
  }
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class IntRTA {
  // only wrap a primitive int
  private int val;

  // count up to the value
  // in "limit"
  public static void count(
      IntRTA orig, IntRTA limit) {

    if (orig == null
        || limit == null) {
      return;
    }

    // introduce sharing
    IntRTA copy = orig;

    while (orig.val < limit.val) {
      copy.val++;
    }
  }

  public static void main(String[] args) {
    Random.args = args;
    IntRTA x = new IntRTA();
    x.val = Random.random();
    IntRTA y = new IntRTA();
    y.val = Random.random();
    count(x, y);
  }
}


public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
    String string = args[index];
    index++;
    return string.length();
  }
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
IntRTA.main([Ljava/lang/String;)V: Graph of 208 nodes with 1 SCC.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 1 SCCs.
----------------------------------------

(6)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: IntRTA.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:
*IntRTA: [val]
*Marker field analysis yielded the following relations that could be markers:
*IntRTA.val > i48 (Introduced counter i142)
----------------------------------------

(7) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 14 IRulesP rules:
f439_0_count_FieldAccess(EOS(STATIC_439), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), i142) -> f441_0_count_Load(EOS(STATIC_441), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), i48, i142) :|: TRUE
f441_0_count_Load(EOS(STATIC_441), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), i48, i142) -> f442_0_count_FieldAccess(EOS(STATIC_442), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), i48, java.lang.Object(IntRTA(EOC, i49)), i142) :|: TRUE
f442_0_count_FieldAccess(EOS(STATIC_442), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), i48, java.lang.Object(IntRTA(EOC, i49)), i142) -> f443_0_count_GE(EOS(STATIC_443), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), i48, i49, i142) :|: TRUE
f443_0_count_GE(EOS(STATIC_443), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), i48, i49, i142) -> f445_0_count_GE(EOS(STATIC_445), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), i48, i49, i142) :|: i48 < i49
f445_0_count_GE(EOS(STATIC_445), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), i48, i49, i142) -> f459_0_count_Load(EOS(STATIC_459), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), i142) :|: i48 < i49
f459_0_count_Load(EOS(STATIC_459), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), i142) -> f463_0_count_Duplicate(EOS(STATIC_463), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), i142) :|: TRUE
f463_0_count_Duplicate(EOS(STATIC_463), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), i142) -> f465_0_count_FieldAccess(EOS(STATIC_465), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), i142) :|: TRUE
f465_0_count_FieldAccess(EOS(STATIC_465), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), i142) -> f466_0_count_ConstantStackPush(EOS(STATIC_466), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), i48, i142) :|: TRUE
f466_0_count_ConstantStackPush(EOS(STATIC_466), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), i48, i142) -> f467_0_count_IntArithmetic(EOS(STATIC_467), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), i48, 1, i142) :|: TRUE
f467_0_count_IntArithmetic(EOS(STATIC_467), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), i48, matching1, i142) -> f468_0_count_FieldAccess(EOS(STATIC_468), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), i48 + 1, i142) :|: i48 >= 0 && matching1 = 1
f468_0_count_FieldAccess(EOS(STATIC_468), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), i56, i142) -> f469_0_count_JMP(EOS(STATIC_469), java.lang.Object(IntRTA(EOC, i56)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i56)), i142 + 1) :|: i142 >= 0
f469_0_count_JMP(EOS(STATIC_469), java.lang.Object(IntRTA(EOC, i56)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i56)), i142) -> f487_0_count_Load(EOS(STATIC_487), java.lang.Object(IntRTA(EOC, i56)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i56)), i142) :|: TRUE
f487_0_count_Load(EOS(STATIC_487), java.lang.Object(IntRTA(EOC, i56)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i56)), i142) -> f436_0_count_Load(EOS(STATIC_436), java.lang.Object(IntRTA(EOC, i56)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i56)), i142) :|: TRUE
f436_0_count_Load(EOS(STATIC_436), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), i142) -> f439_0_count_FieldAccess(EOS(STATIC_439), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i49)), java.lang.Object(IntRTA(EOC, i48)), java.lang.Object(IntRTA(EOC, i48)), i142) :|: TRUE
Combined rules. Obtained 1 IRulesP rules:
f439_0_count_FieldAccess(EOS(STATIC_439), java.lang.Object(IntRTA(EOC, i48:0)), java.lang.Object(IntRTA(EOC, i49:0)), java.lang.Object(IntRTA(EOC, i48:0)), java.lang.Object(IntRTA(EOC, i48:0)), i142:0) -> f439_0_count_FieldAccess(EOS(STATIC_439), java.lang.Object(IntRTA(EOC, i48:0 + 1)), java.lang.Object(IntRTA(EOC, i49:0)), java.lang.Object(IntRTA(EOC, i48:0 + 1)), java.lang.Object(IntRTA(EOC, i48:0 + 1)), i142:0 + 1) :|: i49:0 > i48:0 && i142:0 > -1 && i48:0 > -1
Filtered constant ground arguments:
   f439_0_count_FieldAccess(x1, x2, x3, x4, x5, x6) -> f439_0_count_FieldAccess(x2, x3, x4, x5, x6)
   EOS(x1) -> EOS
   IntRTA(x1, x2) -> IntRTA(x2)
Filtered duplicate arguments:
   f439_0_count_FieldAccess(x1, x2, x3, x4, x5) -> f439_0_count_FieldAccess(x2, x4, x5)
Finished conversion. Obtained 1 rules.P rules:
f439_0_count_FieldAccess(java.lang.Object(IntRTA(i49:0)), java.lang.Object(IntRTA(i48:0)), i142:0, i49:0, i48:0) -> f439_0_count_FieldAccess(java.lang.Object(IntRTA(i49:0)), java.lang.Object(IntRTA(i48:0 + 1)), i142:0 + 1, i49:0, i48:0 + 1) :|: i142:0 > -1 && i48:0 > -1 && i49:0 > i48:0

----------------------------------------

(8)
Obligation:
Rules:
f439_0_count_FieldAccess(java.lang.Object(IntRTA(i49:0)), java.lang.Object(IntRTA(i48:0)), i142:0, i49:0, i48:0) -> f439_0_count_FieldAccess(java.lang.Object(IntRTA(i49:0)), java.lang.Object(IntRTA(i48:0 + 1)), i142:0 + 1, i49:0, i48:0 + 1) :|: i142:0 > -1 && i48:0 > -1 && i49:0 > i48:0

----------------------------------------

(9) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(10)
Obligation:
Rules:
f439_0_count_FieldAccess(java.lang.Object(IntRTA(i49:0)), java.lang.Object(IntRTA(i48:0)), i142:0, i49:0, i48:0) -> f439_0_count_FieldAccess(java.lang.Object(IntRTA(i49:0)), java.lang.Object(IntRTA(arith1)), arith, i49:0, arith1) :|: i142:0 > -1 && i48:0 > -1 && i49:0 > i48:0 && arith = i142:0 + 1 && arith1 = i48:0 + 1 && arith1 = i48:0 + 1

----------------------------------------

(11) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f439_0_count_FieldAccess(java.lang.Object(IntRTA(i49:0)), java.lang.Object(IntRTA(i48:0)), i142:0, i49:0, i48:0) -> f439_0_count_FieldAccess(java.lang.Object(IntRTA(i49:0)), java.lang.Object(IntRTA(arith1)), arith, i49:0, arith1) :|: i142:0 > -1 && i48:0 > -1 && i49:0 > i48:0 && arith = i142:0 + 1 && arith1 = i48:0 + 1 && arith1 = i48:0 + 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(12)
Obligation:

Termination digraph:
Nodes:
(1) f439_0_count_FieldAccess(java.lang.Object(IntRTA(i49:0)), java.lang.Object(IntRTA(i48:0)), i142:0, i49:0, i48:0) -> f439_0_count_FieldAccess(java.lang.Object(IntRTA(i49:0)), java.lang.Object(IntRTA(arith1)), arith, i49:0, arith1) :|: i142:0 > -1 && i48:0 > -1 && i49:0 > i48:0 && arith = i142:0 + 1 && arith1 = i48:0 + 1 && arith1 = i48:0 + 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(13) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(14)
Obligation:
Rules:
f439_0_count_FieldAccess(java.lang.Object(IntRTA(i49:0:0)), java.lang.Object(IntRTA(i48:0:0)), i142:0:0, i49:0:0, i48:0:0) -> f439_0_count_FieldAccess(java.lang.Object(IntRTA(i49:0:0)), java.lang.Object(IntRTA(i48:0:0 + 1)), i142:0:0 + 1, i49:0:0, i48:0:0 + 1) :|: i142:0:0 > -1 && i48:0:0 > -1 && i49:0:0 > i48:0:0

----------------------------------------

(15) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f439_0_count_FieldAccess(VARIABLE, VARIABLE, INTEGER, INTEGER, INTEGER)
java.lang.Object(VARIABLE)
IntRTA(INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(16)
Obligation:
Rules:
f439_0_count_FieldAccess(c, c1, i142:0:0, i49:0:0, i48:0:0) -> f439_0_count_FieldAccess(c2, c3, c4, i49:0:0, c5) :|: c5 = i48:0:0 + 1 && (c4 = i142:0:0 + 1 && (c3 = 0 && (c2 = 0 && (c1 = 0 && c = 0)))) && (i142:0:0 > -1 && i48:0:0 > -1 && i49:0:0 > i48:0:0)

----------------------------------------

(17) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f439_0_count_FieldAccess(x, x1, x2, x3, x4)] = c*x + c1*x1 + x3 - x4

The following rules are decreasing:
f439_0_count_FieldAccess(c, c1, i142:0:0, i49:0:0, i48:0:0) -> f439_0_count_FieldAccess(c2, c3, c4, i49:0:0, c5) :|: c5 = i48:0:0 + 1 && (c4 = i142:0:0 + 1 && (c3 = 0 && (c2 = 0 && (c1 = 0 && c = 0)))) && (i142:0:0 > -1 && i48:0:0 > -1 && i49:0:0 > i48:0:0)
The following rules are bounded:
f439_0_count_FieldAccess(c, c1, i142:0:0, i49:0:0, i48:0:0) -> f439_0_count_FieldAccess(c2, c3, c4, i49:0:0, c5) :|: c5 = i48:0:0 + 1 && (c4 = i142:0:0 + 1 && (c3 = 0 && (c2 = 0 && (c1 = 0 && c = 0)))) && (i142:0:0 > -1 && i48:0:0 > -1 && i49:0:0 > i48:0:0)

----------------------------------------

(18)
YES
