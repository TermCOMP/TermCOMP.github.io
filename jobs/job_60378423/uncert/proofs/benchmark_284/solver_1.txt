NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/kIkWn.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be disproven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCNonTerm [COMPLETE, 130 ms]
(4) NO


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class NO_10 {
    public static void main(String args[]) {
	int j = 100;
	for (int i = 0; i < j; i++) j++;
    }
}


----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class NO_10 {
    public static void main(String args[]) {
	int j = 100;
	for (int i = 0; i < j; i++) j++;
    }
}


----------------------------------------

(3) JBCNonTerm (COMPLETE)
Reached a loop using the following run: 

0:<NO_10.main||0: push 100|| - || ->
YES:  (JL1)
1:<NO_10.main||2: store INT to #1|| - ||100>
YES:  (JL1)
2:<NO_10.main||3: push 0||#1: 100|| ->
YES:  (JL1)
3:<NO_10.main||4: store INT to #2||#1: 100||0>
YES:  (JL1)
4:<NO_10.main||5: load INT #2||#1: 100, #2: 0|| ->
YES:  (JL1)
Start state of loop: 

[o16(lv_0_0)]
<NO_10.main||5: load INT #2||#1: i21, #2: i22|| ->
	o16([java.lang.String...]): Object() -->{java.lang.Object...}
	i21: [100,+inf)(l4)
	i22: [0,+inf)(l4)
YES:  (JL1)


In the loop head node, references [i22, i21] were interesting.

All methods calls in the loop body are side-effect free, hence they can be ignored.

By SMT, we could prove

((100 <= initial_i21 and 0 <= initial_i22) and (((path1_i27 = (path1_i21 + 1) and path1_i28 = (path1_i22 + 1) and path1_i27 = res_i21 and path1_i28 = res_i22 and path1_i21 = initial_i21 and path1_i22 = initial_i22) and (path1_i22 < path1_i21 and path1_i22 < path1_i21)) and ((res1_i27 = (res1_i21 + 1) and res1_i28 = (res1_i22 + 1) and res_i21 = res1_i21 and res_i22 = res1_i22) and !(res1_i22 < res1_i21 and res1_i22 < res1_i21))))

to be UNSAT. Consequently, the loop will not terminate.
----------------------------------------

(4)
NO
