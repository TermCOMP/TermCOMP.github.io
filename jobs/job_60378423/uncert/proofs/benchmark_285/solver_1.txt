NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/QgMAm.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be disproven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 150 ms]
(4) JBCTerminationGraph
(5) JBCNonTerm [COMPLETE, 50 ms]
(6) NO


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class NO_11 {
    public static void main(String args[]) {
	int j = 100;
	for (int i = 0; i < j; i++) {
	    if (i < j - 2) continue;
	    if (i > j - 2) break;
	    j++;
	}
   }
}


----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class NO_11 {
    public static void main(String args[]) {
	int j = 100;
	for (int i = 0; i < j; i++) {
	    if (i < j - 2) continue;
	    if (i > j - 2) break;
	    j++;
	}
   }
}


----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
NO_11.main([Ljava/lang/String;)V: Graph of 41 nodes with 1 SCC.





----------------------------------------

(5) JBCNonTerm (COMPLETE)
Reached a loop using the following run: 

0:<NO_11.main||0: push 100|| - || ->
YES:  (JL1)
1:<NO_11.main||2: store INT to #1|| - ||100>
YES:  (JL1)
2:<NO_11.main||3: push 0||#1: 100|| ->
YES:  (JL1)
3:<NO_11.main||4: store INT to #2||#1: 100||0>
YES:  (JL1)
4:<NO_11.main||5: load INT #2||#1: 100, #2: 0|| ->
YES:  (JL1)
Start state of loop: 

[o36(lv_0_0)]
<NO_11.main||5: load INT #2||#1: i35, #2: i36|| ->
	o36([java.lang.String...]): Object() -->{java.lang.Object...}
	i35: [100,+inf)(l3)
	i36: #
YES:  (JL1)


In the loop head node, references [i36, i35] were interesting.

All methods calls in the loop body are side-effect free, hence they can be ignored.

By SMT, we could prove

(100 <= initial_i35 and ((((path1_i39 = (path1_i35 - 2) and path1_i40 = (path1_i36 + 1) and path1_i35 = res_i35 and path1_i40 = res_i36 and path1_i35 = initial_i35 and path1_i36 = initial_i36) and (path1_i36 < path1_i35 and path1_i36 < path1_i35 and path1_i36 < path1_i39 and path1_i36 < path1_i39)) or ((path2_i39 = (path2_i35 - 2) and path2_i42 = (path2_i35 - 2) and path2_i43 = (path2_i35 + 1) and path2_i44 = (path2_i36 + 1) and path2_i43 = res_i35 and path2_i44 = res_i36 and path2_i35 = initial_i35 and path2_i36 = initial_i36) and (path2_i36 < path2_i35 and path2_i36 < path2_i35 and path2_i36 >= path2_i39 and path2_i36 >= path2_i39 and path2_i36 <= path2_i42 and path2_i36 <= path2_i42))) and (((res1_i39 = (res1_i35 - 2) and res1_i40 = (res1_i36 + 1) and res_i35 = res1_i35 and res_i36 = res1_i36) and !(res1_i36 < res1_i35 and res1_i36 < res1_i35 and res1_i36 < res1_i39 and res1_i36 < res1_i39)) and ((res2_i39 = (res2_i35 - 2) and res2_i42 = (res2_i35 - 2) and res2_i43 = (res2_i35 + 1) and res2_i44 = (res2_i36 + 1) and res_i35 = res2_i35 and res_i36 = res2_i36) and !(res2_i36 < res2_i35 and res2_i36 < res2_i35 and res2_i36 >= res2_i39 and res2_i36 >= res2_i39 and res2_i36 <= res2_i42 and res2_i36 <= res2_i42)))))

to be UNSAT. Consequently, the loop will not terminate.
----------------------------------------

(6)
NO
