YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/uOPK7.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 59 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 233 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) JBCTerminationSCC
(7) SCCToIRSProof [SOUND, 84 ms]
(8) IRSwT
(9) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
(10) IRSwT
(11) IRSwTTerminationDigraphProof [EQUIVALENT, 61 ms]
(12) IRSwT
(13) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(14) IRSwT
(15) FilterProof [EQUIVALENT, 0 ms]
(16) IntTRS
(17) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(18) IntTRS
(19) PolynomialOrderProcessor [EQUIVALENT, 2 ms]
(20) IntTRS
(21) TerminationGraphProcessor [EQUIVALENT, 0 ms]
(22) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
/**
 * Abstract class to provide some additional mathematical functions
 * which are not provided by java.lang.Math.
 *
 * @author fuhs
 */
public abstract class AProVEMath {

  /**
   * Returns <code>base<sup>exponent</sup></code>.
   * Works considerably faster than java.lang.Math.pow(double, double).
   *
   * @param base base of the power
   * @param exponent non-negative exponent of the power
   * @return base<sup>exponent</sup>
   */
  public static int power (int base, int exponent) {
    if (exponent == 0) {
      return 1;
    }
    else if (exponent == 1) {
      return base;
    }
    else if (base == 2) {
      return base << (exponent-1);
    }
    else {
      int result = 1;
      while (exponent > 0) {
        if (exponent % 2 == 1) {
          result *= base;
        }
        base *= base;
        exponent /= 2;
      }
      return result;
    }
  }

  public static void main(String[] args) {
    Random.args = args;
    int x = Random.random();
    int y = Random.random();
    power(x, y);
  }
}


public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
    String string = args[index];
    index++;
    return string.length();
  }
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
/**
 * Abstract class to provide some additional mathematical functions
 * which are not provided by java.lang.Math.
 *
 * @author fuhs
 */
public abstract class AProVEMath {

  /**
   * Returns <code>base<sup>exponent</sup></code>.
   * Works considerably faster than java.lang.Math.pow(double, double).
   *
   * @param base base of the power
   * @param exponent non-negative exponent of the power
   * @return base<sup>exponent</sup>
   */
  public static int power (int base, int exponent) {
    if (exponent == 0) {
      return 1;
    }
    else if (exponent == 1) {
      return base;
    }
    else if (base == 2) {
      return base << (exponent-1);
    }
    else {
      int result = 1;
      while (exponent > 0) {
        if (exponent % 2 == 1) {
          result *= base;
        }
        base *= base;
        exponent /= 2;
      }
      return result;
    }
  }

  public static void main(String[] args) {
    Random.args = args;
    int x = Random.random();
    int y = Random.random();
    power(x, y);
  }
}


public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
    String string = args[index];
    index++;
    return string.length();
  }
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
AProVEMath.main([Ljava/lang/String;)V: Graph of 240 nodes with 1 SCC.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 1 SCCs.
----------------------------------------

(6)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: AProVEMath.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(7) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 26 IRulesP rules:
f1573_0_power_LE(EOS(STATIC_1573), i352, i352) -> f1575_0_power_Load(EOS(STATIC_1575), i352) :|: i352 > 0
f1575_0_power_Load(EOS(STATIC_1575), i352) -> f1577_0_power_ConstantStackPush(EOS(STATIC_1577), i352, i352) :|: TRUE
f1577_0_power_ConstantStackPush(EOS(STATIC_1577), i352, i352) -> f1579_0_power_IntArithmetic(EOS(STATIC_1579), i352, i352, 2) :|: TRUE
f1579_0_power_IntArithmetic(EOS(STATIC_1579), i352, i352, matching1) -> f1581_0_power_ConstantStackPush(EOS(STATIC_1581), i352, i352 % 2) :|: TRUE && matching1 = 2
f1581_0_power_ConstantStackPush(EOS(STATIC_1581), i352, i355) -> f1582_0_power_NE(EOS(STATIC_1582), i352, i355, 1) :|: TRUE
f1582_0_power_NE(EOS(STATIC_1582), i352, matching1, matching2) -> f1583_0_power_NE(EOS(STATIC_1583), i352, 0, 1) :|: i355 = 0 && matching1 = 0 && matching2 = 1
f1582_0_power_NE(EOS(STATIC_1582), i352, matching1, matching2) -> f1584_0_power_NE(EOS(STATIC_1584), i352, 1, 1) :|: i355 = 1 && matching1 = 1 && matching2 = 1
f1583_0_power_NE(EOS(STATIC_1583), i352, matching1, matching2) -> f1585_0_power_Load(EOS(STATIC_1585), i352) :|: TRUE && matching1 = 0 && matching2 = 1
f1585_0_power_Load(EOS(STATIC_1585), i352) -> f1587_0_power_Load(EOS(STATIC_1587), i352) :|: TRUE
f1587_0_power_Load(EOS(STATIC_1587), i352) -> f1589_0_power_IntArithmetic(EOS(STATIC_1589), i352) :|: TRUE
f1589_0_power_IntArithmetic(EOS(STATIC_1589), i352) -> f1591_0_power_Store(EOS(STATIC_1591), i352) :|: TRUE
f1591_0_power_Store(EOS(STATIC_1591), i352) -> f1593_0_power_Load(EOS(STATIC_1593), i352) :|: TRUE
f1593_0_power_Load(EOS(STATIC_1593), i352) -> f1595_0_power_ConstantStackPush(EOS(STATIC_1595), i352) :|: TRUE
f1595_0_power_ConstantStackPush(EOS(STATIC_1595), i352) -> f1596_0_power_IntArithmetic(EOS(STATIC_1596), i352, 2) :|: TRUE
f1596_0_power_IntArithmetic(EOS(STATIC_1596), i352, matching1) -> f1597_0_power_Store(EOS(STATIC_1597), i359) :|: i359 = i352 / 2 && i352 >= 1 && i359 < i352 && matching1 = 2
f1597_0_power_Store(EOS(STATIC_1597), i359) -> f1598_0_power_JMP(EOS(STATIC_1598), i359) :|: TRUE
f1598_0_power_JMP(EOS(STATIC_1598), i359) -> f1599_0_power_Load(EOS(STATIC_1599), i359) :|: TRUE
f1599_0_power_Load(EOS(STATIC_1599), i359) -> f1570_0_power_Load(EOS(STATIC_1570), i359) :|: TRUE
f1570_0_power_Load(EOS(STATIC_1570), i344) -> f1571_0_power_LE(EOS(STATIC_1571), i344, i344) :|: TRUE
f1571_0_power_LE(EOS(STATIC_1571), i352, i352) -> f1573_0_power_LE(EOS(STATIC_1573), i352, i352) :|: TRUE
f1584_0_power_NE(EOS(STATIC_1584), i352, matching1, matching2) -> f1586_0_power_Load(EOS(STATIC_1586), i352) :|: TRUE && matching1 = 1 && matching2 = 1
f1586_0_power_Load(EOS(STATIC_1586), i352) -> f1588_0_power_Load(EOS(STATIC_1588), i352) :|: TRUE
f1588_0_power_Load(EOS(STATIC_1588), i352) -> f1590_0_power_IntArithmetic(EOS(STATIC_1590), i352) :|: TRUE
f1590_0_power_IntArithmetic(EOS(STATIC_1590), i352) -> f1592_0_power_Store(EOS(STATIC_1592), i352) :|: TRUE
f1592_0_power_Store(EOS(STATIC_1592), i352) -> f1594_0_power_Load(EOS(STATIC_1594), i352) :|: TRUE
f1594_0_power_Load(EOS(STATIC_1594), i352) -> f1585_0_power_Load(EOS(STATIC_1585), i352) :|: TRUE
Combined rules. Obtained 4 IRulesP rules:
f1573_0_power_LE(EOS(STATIC_1573), i352:0, i352:0) -> f1573_0_power_LE'(EOS(STATIC_1573), i352:0, i352:0) :|: i352:0 > 0 && i352:0 - 2 * div = 1 && i352:0 > div1
f1573_0_power_LE'(EOS(STATIC_1573), i352:0, i352:0) -> f1573_0_power_LE(EOS(STATIC_1573), div1, div1) :|: i352:0 > 0 && i352:0 > div1 && i352:0 - 2 * div = 1 && i352:0 - 2 * div > -2 && i352:0 - 2 * div < 2 && i352:0 - 2 * div1 < 2 && i352:0 - 2 * div1 > -2
f1573_0_power_LE(EOS(STATIC_1573), i352:0, i352:0) -> f1573_0_power_LE'(EOS(STATIC_1573), i352:0, i352:0) :|: i352:0 > 0 && i352:0 - 2 * div = 0 && i352:0 > div1
f1573_0_power_LE'(EOS(STATIC_1573), i352:0, i352:0) -> f1573_0_power_LE(EOS(STATIC_1573), div1, div1) :|: i352:0 > 0 && i352:0 - 2 * div = 0 && i352:0 > div1 && i352:0 - 2 * div > -2 && i352:0 - 2 * div < 2 && i352:0 - 2 * div1 < 2 && i352:0 - 2 * div1 > -2
Filtered constant ground arguments:
   f1573_0_power_LE(x1, x2, x3) -> f1573_0_power_LE(x2, x3)
   f1573_0_power_LE'(x1, x2, x3) -> f1573_0_power_LE'(x2, x3)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f1573_0_power_LE(x1, x2) -> f1573_0_power_LE(x2)
   f1573_0_power_LE'(x1, x2) -> f1573_0_power_LE'(x2)
Finished conversion. Obtained 4 rules.P rules:
f1573_0_power_LE(i352:0) -> f1573_0_power_LE'(i352:0) :|: i352:0 - 2 * div = 1 && i352:0 > div1 && i352:0 > 0
f1573_0_power_LE'(i352:0) -> f1573_0_power_LE(div1) :|: i352:0 > div1 && i352:0 > 0 && i352:0 - 2 * div = 1 && i352:0 - 2 * div > -2 && i352:0 - 2 * div < 2 && i352:0 - 2 * div1 > -2 && i352:0 - 2 * div1 < 2
f1573_0_power_LE(i352:0) -> f1573_0_power_LE'(i352:0) :|: i352:0 - 2 * div = 0 && i352:0 > div1 && i352:0 > 0
f1573_0_power_LE'(i352:0) -> f1573_0_power_LE(div1) :|: i352:0 - 2 * div = 0 && i352:0 > 0 && i352:0 > div1 && i352:0 - 2 * div > -2 && i352:0 - 2 * div < 2 && i352:0 - 2 * div1 > -2 && i352:0 - 2 * div1 < 2

----------------------------------------

(8)
Obligation:
Rules:
f1573_0_power_LE(x) -> f1573_0_power_LE'(x) :|: x - 2 * x1 = 1 && x > x2 && x > 0
f1573_0_power_LE'(x3) -> f1573_0_power_LE(x4) :|: x3 > x4 && x3 > 0 && x3 - 2 * x5 = 1 && x3 - 2 * x5 > -2 && x3 - 2 * x5 < 2 && x3 - 2 * x4 > -2 && x3 - 2 * x4 < 2
f1573_0_power_LE(x6) -> f1573_0_power_LE'(x6) :|: x6 - 2 * x7 = 0 && x6 > x8 && x6 > 0
f1573_0_power_LE'(x9) -> f1573_0_power_LE(x10) :|: x9 - 2 * x11 = 0 && x9 > 0 && x9 > x10 && x9 - 2 * x11 > -2 && x9 - 2 * x11 < 2 && x9 - 2 * x10 > -2 && x9 - 2 * x10 < 2

----------------------------------------

(9) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(10)
Obligation:
Rules:
f1573_0_power_LE(x) -> f1573_0_power_LE'(x) :|: x - 2 * x1 = 1 && x > x2 && x > 0
f1573_0_power_LE'(x3) -> f1573_0_power_LE(x4) :|: x3 > x4 && x3 > 0 && x3 - 2 * x5 = 1 && x3 - 2 * x5 > -2 && x3 - 2 * x5 < 2 && x3 - 2 * x4 > -2 && x3 - 2 * x4 < 2
f1573_0_power_LE(x6) -> f1573_0_power_LE'(x6) :|: x6 - 2 * x7 = 0 && x6 > x8 && x6 > 0
f1573_0_power_LE'(x9) -> f1573_0_power_LE(x10) :|: x9 - 2 * x11 = 0 && x9 > 0 && x9 > x10 && x9 - 2 * x11 > -2 && x9 - 2 * x11 < 2 && x9 - 2 * x10 > -2 && x9 - 2 * x10 < 2

----------------------------------------

(11) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f1573_0_power_LE(x) -> f1573_0_power_LE'(x) :|: x - 2 * x1 = 1 && x > x2 && x > 0
(2) f1573_0_power_LE'(x3) -> f1573_0_power_LE(x4) :|: x3 > x4 && x3 > 0 && x3 - 2 * x5 = 1 && x3 - 2 * x5 > -2 && x3 - 2 * x5 < 2 && x3 - 2 * x4 > -2 && x3 - 2 * x4 < 2
(3) f1573_0_power_LE(x6) -> f1573_0_power_LE'(x6) :|: x6 - 2 * x7 = 0 && x6 > x8 && x6 > 0
(4) f1573_0_power_LE'(x9) -> f1573_0_power_LE(x10) :|: x9 - 2 * x11 = 0 && x9 > 0 && x9 > x10 && x9 - 2 * x11 > -2 && x9 - 2 * x11 < 2 && x9 - 2 * x10 > -2 && x9 - 2 * x10 < 2

Arcs:
(1) -> (2)
(2) -> (1), (3)
(3) -> (4)
(4) -> (1), (3)

This digraph is fully evaluated!
----------------------------------------

(12)
Obligation:

Termination digraph:
Nodes:
(1) f1573_0_power_LE(x) -> f1573_0_power_LE'(x) :|: x - 2 * x1 = 1 && x > x2 && x > 0
(2) f1573_0_power_LE'(x9) -> f1573_0_power_LE(x10) :|: x9 - 2 * x11 = 0 && x9 > 0 && x9 > x10 && x9 - 2 * x11 > -2 && x9 - 2 * x11 < 2 && x9 - 2 * x10 > -2 && x9 - 2 * x10 < 2
(3) f1573_0_power_LE(x6) -> f1573_0_power_LE'(x6) :|: x6 - 2 * x7 = 0 && x6 > x8 && x6 > 0
(4) f1573_0_power_LE'(x3) -> f1573_0_power_LE(x4) :|: x3 > x4 && x3 > 0 && x3 - 2 * x5 = 1 && x3 - 2 * x5 > -2 && x3 - 2 * x5 < 2 && x3 - 2 * x4 > -2 && x3 - 2 * x4 < 2

Arcs:
(1) -> (4)
(2) -> (1), (3)
(3) -> (2)
(4) -> (1), (3)

This digraph is fully evaluated!

----------------------------------------

(13) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(14)
Obligation:
Rules:
f1573_0_power_LE(x:0) -> f1573_0_power_LE'(x:0) :|: x:0 - 2 * x1:0 = 1 && x:0 > x2:0 && x:0 > 0
f1573_0_power_LE'(x9:0) -> f1573_0_power_LE(x10:0) :|: x9:0 - 2 * x10:0 > -2 && x9:0 - 2 * x10:0 < 2 && x9:0 - 2 * x11:0 < 2 && x9:0 - 2 * x11:0 > -2 && x9:0 > x10:0 && x9:0 > 0 && x9:0 - 2 * x11:0 = 0
f1573_0_power_LE(x6:0) -> f1573_0_power_LE'(x6:0) :|: x6:0 - 2 * x7:0 = 0 && x8:0 < x6:0 && x6:0 > 0
f1573_0_power_LE'(x3:0) -> f1573_0_power_LE(x4:0) :|: x3:0 - 2 * x4:0 > -2 && x3:0 - 2 * x4:0 < 2 && x3:0 - 2 * x5:0 < 2 && x3:0 - 2 * x5:0 > -2 && x3:0 - 2 * x5:0 = 1 && x3:0 > 0 && x4:0 < x3:0

----------------------------------------

(15) FilterProof (EQUIVALENT)
Used the following sort dictionary for filtering: 
f1573_0_power_LE(INTEGER)
f1573_0_power_LE'(INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(16)
Obligation:
Rules:
f1573_0_power_LE(x:0) -> f1573_0_power_LE'(x:0) :|: x:0 - 2 * x1:0 = 1 && x:0 > x2:0 && x:0 > 0
f1573_0_power_LE'(x9:0) -> f1573_0_power_LE(x10:0) :|: x9:0 - 2 * x10:0 > -2 && x9:0 - 2 * x10:0 < 2 && x9:0 - 2 * x11:0 < 2 && x9:0 - 2 * x11:0 > -2 && x9:0 > x10:0 && x9:0 > 0 && x9:0 - 2 * x11:0 = 0
f1573_0_power_LE(x6:0) -> f1573_0_power_LE'(x6:0) :|: x6:0 - 2 * x7:0 = 0 && x8:0 < x6:0 && x6:0 > 0
f1573_0_power_LE'(x3:0) -> f1573_0_power_LE(x4:0) :|: x3:0 - 2 * x4:0 > -2 && x3:0 - 2 * x4:0 < 2 && x3:0 - 2 * x5:0 < 2 && x3:0 - 2 * x5:0 > -2 && x3:0 - 2 * x5:0 = 1 && x3:0 > 0 && x4:0 < x3:0

----------------------------------------

(17) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(18)
Obligation:
Rules:
f1573_0_power_LE(x:0:0) -> f1573_0_power_LE'(x:0:0) :|: x:0:0 - 2 * x1:0:0 = 1 && x:0:0 > x2:0:0 && x:0:0 > 0
f1573_0_power_LE'(x3:0:0) -> f1573_0_power_LE(x4:0:0) :|: x3:0:0 > 0 && x4:0:0 < x3:0:0 && x3:0:0 - 2 * x5:0:0 = 1 && x3:0:0 - 2 * x5:0:0 > -2 && x3:0:0 - 2 * x5:0:0 < 2 && x3:0:0 - 2 * x4:0:0 < 2 && x3:0:0 - 2 * x4:0:0 > -2
f1573_0_power_LE'(x9:0:0) -> f1573_0_power_LE(x10:0:0) :|: x9:0:0 > 0 && x9:0:0 - 2 * x11:0:0 = 0 && x9:0:0 > x10:0:0 && x9:0:0 - 2 * x11:0:0 > -2 && x9:0:0 - 2 * x11:0:0 < 2 && x9:0:0 - 2 * x10:0:0 < 2 && x9:0:0 - 2 * x10:0:0 > -2
f1573_0_power_LE(x6:0:0) -> f1573_0_power_LE'(x6:0:0) :|: x6:0:0 - 2 * x7:0:0 = 0 && x8:0:0 < x6:0:0 && x6:0:0 > 0

----------------------------------------

(19) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f1573_0_power_LE(x)] = 1 + x
[f1573_0_power_LE'(x1)] = x1

The following rules are decreasing:
f1573_0_power_LE(x:0:0) -> f1573_0_power_LE'(x:0:0) :|: x:0:0 - 2 * x1:0:0 = 1 && x:0:0 > x2:0:0 && x:0:0 > 0
f1573_0_power_LE(x6:0:0) -> f1573_0_power_LE'(x6:0:0) :|: x6:0:0 - 2 * x7:0:0 = 0 && x8:0:0 < x6:0:0 && x6:0:0 > 0
The following rules are bounded:
f1573_0_power_LE(x:0:0) -> f1573_0_power_LE'(x:0:0) :|: x:0:0 - 2 * x1:0:0 = 1 && x:0:0 > x2:0:0 && x:0:0 > 0
f1573_0_power_LE'(x3:0:0) -> f1573_0_power_LE(x4:0:0) :|: x3:0:0 > 0 && x4:0:0 < x3:0:0 && x3:0:0 - 2 * x5:0:0 = 1 && x3:0:0 - 2 * x5:0:0 > -2 && x3:0:0 - 2 * x5:0:0 < 2 && x3:0:0 - 2 * x4:0:0 < 2 && x3:0:0 - 2 * x4:0:0 > -2
f1573_0_power_LE'(x9:0:0) -> f1573_0_power_LE(x10:0:0) :|: x9:0:0 > 0 && x9:0:0 - 2 * x11:0:0 = 0 && x9:0:0 > x10:0:0 && x9:0:0 - 2 * x11:0:0 > -2 && x9:0:0 - 2 * x11:0:0 < 2 && x9:0:0 - 2 * x10:0:0 < 2 && x9:0:0 - 2 * x10:0:0 > -2
f1573_0_power_LE(x6:0:0) -> f1573_0_power_LE'(x6:0:0) :|: x6:0:0 - 2 * x7:0:0 = 0 && x8:0:0 < x6:0:0 && x6:0:0 > 0

----------------------------------------

(20)
Obligation:
Rules:
f1573_0_power_LE'(x3:0:0) -> f1573_0_power_LE(x4:0:0) :|: x3:0:0 > 0 && x4:0:0 < x3:0:0 && x3:0:0 - 2 * x5:0:0 = 1 && x3:0:0 - 2 * x5:0:0 > -2 && x3:0:0 - 2 * x5:0:0 < 2 && x3:0:0 - 2 * x4:0:0 < 2 && x3:0:0 - 2 * x4:0:0 > -2
f1573_0_power_LE'(x9:0:0) -> f1573_0_power_LE(x10:0:0) :|: x9:0:0 > 0 && x9:0:0 - 2 * x11:0:0 = 0 && x9:0:0 > x10:0:0 && x9:0:0 - 2 * x11:0:0 > -2 && x9:0:0 - 2 * x11:0:0 < 2 && x9:0:0 - 2 * x10:0:0 < 2 && x9:0:0 - 2 * x10:0:0 > -2

----------------------------------------

(21) TerminationGraphProcessor (EQUIVALENT)
Constructed the termination graph and obtained no non-trivial SCC(s).

----------------------------------------

(22)
YES
