NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/E2qWH.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be disproven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 196 ms]
(4) JBCTerminationGraph
(5) JBCNonTerm [COMPLETE, 143 ms]
(6) NO


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
package simple.ex08;

public class Ex08 {

	public static void loop(int i) {
		boolean up = false;
		while (i > 0) {
			if (i == 1) {
				up = true;
			}
			if (i == 10) {
				up = false;
			}
			if (up) {
				i++;
			} else {
				i--;
			}
		}
	}
}


package simple.ex08;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Ex08.loop(args.length);
	}

}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
package simple.ex08;

public class Ex08 {

	public static void loop(int i) {
		boolean up = false;
		while (i > 0) {
			if (i == 1) {
				up = true;
			}
			if (i == 10) {
				up = false;
			}
			if (up) {
				i++;
			} else {
				i--;
			}
		}
	}
}


package simple.ex08;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Ex08.loop(args.length);
	}

}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
simple.ex08.Main.main([Ljava/lang/String;)V: Graph of 57 nodes with 1 SCC.





----------------------------------------

(5) JBCNonTerm (COMPLETE)
Reached a loop using the following run: 

0:<simple.ex08.Main.main||0: load ADDR args||args: a60|| ->
	a60([java.lang.String...]): length 1 -->{java.lang.Object...}
YES:  (JL1)
1:<simple.ex08.Main.main||1: arraylength|| - ||a60>
	a60([java.lang.String...]): length 1 -->{java.lang.Object...}
YES:  (JL1)
2:<simple.ex08.Main.main||2: simple.ex08.Ex08.loop(I)V|| - ||1>
YES:  (JL1)
3:<simple.ex08.Ex08.loop||0: push 0||i: 1|| ->
<simple.ex08.Main.main||2: simple.ex08.Ex08.loop|| - || ->
YES:  (JL1)
4:<simple.ex08.Ex08.loop||1: store INT to up||i: 1||0>
<simple.ex08.Main.main||2: simple.ex08.Ex08.loop|| - || ->
YES:  (JL1)
5:<simple.ex08.Ex08.loop||2: load INT i||i: 1, up: 0|| ->
<simple.ex08.Main.main||2: simple.ex08.Ex08.loop|| - || ->
YES:  (JL1)
Start state of loop: 

<simple.ex08.Ex08.loop||2: load INT i||i: i111, up: i112|| ->
[a12(lv_0_0)]
<simple.ex08.Main.main||2: simple.ex08.Ex08.loop|| - || ->
	i111: #
	i112: [0,1](2,1)
	i50: [0,+inf)(l2)
	a12([java.lang.String...]): length i50 -->{java.lang.Object...}
YES:  (JL1)


In the loop head node, references [i111, i112] were interesting.

All methods calls in the loop body are side-effect free, hence they can be ignored.

By SMT, we could prove

((0 <= initial_i112 and initial_i112 <= 1 and 0 <= initial_i50) and ((((path1_i111 = path1_i118 and 2 = res_i111 and 1 = res_i112 and path1_i111 = initial_i111 and path1_i112 = initial_i112) and (path1_i118 > 0 and path1_i118 = 1 and path1_i118 = 1 and 1 = 1 and 1 > 0)) or ((path2_i111 = path2_i118 and path2_i118 = path2_i120 and path2_i120 = path2_i121 and path2_i121 = path2_i123 and path2_i126 = (path2_i123 + 1) and path2_i126 = res_i111 and 1 = res_i112 and path2_i111 = initial_i111 and path2_i112 = initial_i112) and (path2_i118 > 0 and T and 1 = 1 and path2_i120 > 1 and T and 10 = 10 and path2_i121 < 10 and path2_i112 = 1 and 1 > 0)) or ((path3_i111 = path3_i118 and path3_i118 = path3_i120 and path3_i120 = path3_i121 and path3_i121 = path3_i123 and path3_i127 = (path3_i123 + -1) and path3_i127 = res_i111 and 0 = res_i112 and path3_i111 = initial_i111 and path3_i112 = initial_i112) and (path3_i118 > 0 and T and 1 = 1 and path3_i120 > 1 and T and 10 = 10 and path3_i121 < 10 and path3_i112 = 0 and T)) or ((path4_i111 = path4_i118 and path4_i118 = path4_i120 and 9 = res_i111 and 0 = res_i112 and path4_i111 = initial_i111 and path4_i112 = initial_i112) and (path4_i118 > 0 and T and 1 = 1 and path4_i120 > 1 and path4_i120 = 10 and path4_i120 = 10 and 10 = 10 and T)) or ((path5_i111 = path5_i118 and path5_i118 = path5_i120 and path5_i120 = path5_i122 and path5_i122 = path5_i123 and path5_i126 = (path5_i123 + 1) and path5_i126 = res_i111 and 1 = res_i112 and path5_i111 = initial_i111 and path5_i112 = initial_i112) and (path5_i118 > 0 and T and 1 = 1 and path5_i120 > 1 and T and 10 = 10 and path5_i122 > 10 and path5_i112 = 1 and 1 > 0)) or ((path6_i111 = path6_i118 and path6_i118 = path6_i120 and path6_i120 = path6_i122 and path6_i122 = path6_i123 and path6_i127 = (path6_i123 + -1) and path6_i127 = res_i111 and 0 = res_i112 and path6_i111 = initial_i111 and path6_i112 = initial_i112) and (path6_i118 > 0 and T and 1 = 1 and path6_i120 > 1 and T and 10 = 10 and path6_i122 > 10 and path6_i112 = 0 and T))) and (((res1_i111 = res1_i118 and res_i111 = res1_i111 and res_i112 = res1_i112) and !(res1_i118 > 0 and res1_i118 = 1 and res1_i118 = 1 and 1 = 1 and 1 > 0)) and ((res2_i111 = res2_i118 and res2_i118 = res2_i120 and res2_i120 = res2_i121 and res2_i121 = res2_i123 and res2_i126 = (res2_i123 + 1) and res_i111 = res2_i111 and res_i112 = res2_i112) and !(res2_i118 > 0 and T and 1 = 1 and res2_i120 > 1 and T and 10 = 10 and res2_i121 < 10 and res2_i112 = 1 and 1 > 0)) and ((res3_i111 = res3_i118 and res3_i118 = res3_i120 and res3_i120 = res3_i121 and res3_i121 = res3_i123 and res3_i127 = (res3_i123 + -1) and res_i111 = res3_i111 and res_i112 = res3_i112) and !(res3_i118 > 0 and T and 1 = 1 and res3_i120 > 1 and T and 10 = 10 and res3_i121 < 10 and res3_i112 = 0 and T)) and ((res4_i111 = res4_i118 and res4_i118 = res4_i120 and res_i111 = res4_i111 and res_i112 = res4_i112) and !(res4_i118 > 0 and T and 1 = 1 and res4_i120 > 1 and res4_i120 = 10 and res4_i120 = 10 and 10 = 10 and T)) and ((res5_i111 = res5_i118 and res5_i118 = res5_i120 and res5_i120 = res5_i122 and res5_i122 = res5_i123 and res5_i126 = (res5_i123 + 1) and res_i111 = res5_i111 and res_i112 = res5_i112) and !(res5_i118 > 0 and T and 1 = 1 and res5_i120 > 1 and T and 10 = 10 and res5_i122 > 10 and res5_i112 = 1 and 1 > 0)) and ((res6_i111 = res6_i118 and res6_i118 = res6_i120 and res6_i120 = res6_i122 and res6_i122 = res6_i123 and res6_i127 = (res6_i123 + -1) and res_i111 = res6_i111 and res_i112 = res6_i112) and !(res6_i118 > 0 and T and 1 = 1 and res6_i120 > 1 and T and 10 = 10 and res6_i122 > 10 and res6_i112 = 0 and T)))))

to be UNSAT. Consequently, the loop will not terminate.
----------------------------------------

(6)
NO
