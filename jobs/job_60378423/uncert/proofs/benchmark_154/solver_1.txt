NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/C8F5Y.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be disproven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 113 ms]
(4) JBCTerminationGraph
(5) JBCNonTerm [COMPLETE, 65 ms]
(6) NO


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
package simple.whileBreak;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		WhileBreak.loop(args.length);

	}

}


package simple.whileBreak;

public class WhileBreak {

	public static void loop(int i) {
		while (i > 10) {
			if (i > 20) {
				i++;
			} else {
				i--;
			}
			if (i == 30) {
				break;
			}
		}
	}
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
package simple.whileBreak;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		WhileBreak.loop(args.length);

	}

}


package simple.whileBreak;

public class WhileBreak {

	public static void loop(int i) {
		while (i > 10) {
			if (i > 20) {
				i++;
			} else {
				i--;
			}
			if (i == 30) {
				break;
			}
		}
	}
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
simple.whileBreak.Main.main([Ljava/lang/String;)V: Graph of 36 nodes with 1 SCC.





----------------------------------------

(5) JBCNonTerm (COMPLETE)
Reached a loop using the following run: 

0:<simple.whileBreak.Main.main||0: load ADDR args||args: a22|| ->
	a22([java.lang.String...]): length 30 -->{java.lang.Object...}
YES:  (JL1)
1:<simple.whileBreak.Main.main||1: arraylength|| - ||a22>
	a22([java.lang.String...]): length 30 -->{java.lang.Object...}
YES:  (JL1)
2:<simple.whileBreak.Main.main||2: simple.whileBreak.WhileBreak.loop(I)V|| - ||30>
YES:  (JL1)
3:<simple.whileBreak.WhileBreak.loop||0: load INT i||i: 30|| ->
<simple.whileBreak.Main.main||2: simple.whileBreak.WhileBreak.loop|| - || ->
YES:  (JL1)
Start state of loop: 

<simple.whileBreak.WhileBreak.loop||0: load INT i||i: i175|| ->
[a10(lv_0_0)]
<simple.whileBreak.Main.main||2: simple.whileBreak.WhileBreak.loop|| - || ->
	i175: [0,+inf)(l2)
	i176: [0,+inf)(l2)
	a10([java.lang.String...]): length i176 -->{java.lang.Object...}
YES:  (JL1)


In the loop head node, references [i175] were interesting.

All methods calls in the loop body are side-effect free, hence they can be ignored.

By SMT, we could prove

((0 <= initial_i175 and 0 <= initial_i176) and (((path3_i175 = path3_i185 and path3_i185 = path3_i188 and path3_i191 = (path3_i188 + 1) and path3_i191 = path3_i203 and path3_i203 = res_i175 and path3_i175 = initial_i175) and (T and 10 = 10 and path3_i185 > 10 and T and 20 = 20 and path3_i188 > 20 and T and 30 = 30 and path3_i203 > 30)) and ((res3_i175 = res3_i185 and res3_i185 = res3_i188 and res3_i191 = (res3_i188 + 1) and res3_i191 = res3_i203 and res_i175 = res3_i175) and !(T and 10 = 10 and res3_i185 > 10 and T and 20 = 20 and res3_i188 > 20 and T and 30 = 30 and res3_i203 > 30))))

to be UNSAT. Consequently, the loop will not terminate.
----------------------------------------

(6)
NO
