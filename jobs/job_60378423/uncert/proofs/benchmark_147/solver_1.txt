NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/7BmVZ.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be disproven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 187 ms]
(4) JBCTerminationGraph
(5) JBCNonTerm [COMPLETE, 188 ms]
(6) NO


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
package simple.narrowKonv;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		NarrowKonv.loop(args.length);
	}

}


package simple.narrowKonv;

public class NarrowKonv {

	public static void loop(int i) {
		int range = 20;
		while (0 <= i && i <= range) {
			if (!(0 == i && i == range)) {
				if (i == range) {
					i = 0;
					range--;
				} else {
					i++;
				}
			}
		}
	}
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
package simple.narrowKonv;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		NarrowKonv.loop(args.length);
	}

}


package simple.narrowKonv;

public class NarrowKonv {

	public static void loop(int i) {
		int range = 20;
		while (0 <= i && i <= range) {
			if (!(0 == i && i == range)) {
				if (i == range) {
					i = 0;
					range--;
				} else {
					i++;
				}
			}
		}
	}
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
simple.narrowKonv.Main.main([Ljava/lang/String;)V: Graph of 51 nodes with 1 SCC.





----------------------------------------

(5) JBCNonTerm (COMPLETE)
Reached a loop using the following run: 

0:<simple.narrowKonv.Main.main||0: load ADDR args||args: a144|| ->
	a144([java.lang.String...]): length 1 -->{java.lang.Object...}
YES:  (JL1)
1:<simple.narrowKonv.Main.main||1: arraylength|| - ||a144>
	a144([java.lang.String...]): length 1 -->{java.lang.Object...}
YES:  (JL1)
2:<simple.narrowKonv.Main.main||2: simple.narrowKonv.NarrowKonv.loop(I)V|| - ||1>
YES:  (JL1)
3:<simple.narrowKonv.NarrowKonv.loop||0: push 20||i: 1|| ->
<simple.narrowKonv.Main.main||2: simple.narrowKonv.NarrowKonv.loop|| - || ->
YES:  (JL1)
4:<simple.narrowKonv.NarrowKonv.loop||2: store INT to range||i: 1||20>
<simple.narrowKonv.Main.main||2: simple.narrowKonv.NarrowKonv.loop|| - || ->
YES:  (JL1)
5:<simple.narrowKonv.NarrowKonv.loop||3: push 0||i: 1, range: 20|| ->
<simple.narrowKonv.Main.main||2: simple.narrowKonv.NarrowKonv.loop|| - || ->
YES:  (JL1)
Start state of loop: 

<simple.narrowKonv.NarrowKonv.loop||3: push 0||i: i86, range: i87|| ->
[a14(lv_0_0)]
<simple.narrowKonv.Main.main||2: simple.narrowKonv.NarrowKonv.loop|| - || ->
	i86: [0,+inf)(l1)
	i87: #
	i64: [0,+inf)(l1)
	a14([java.lang.String...]): length i64 -->{java.lang.Object...}
YES:  (JL1)


In the loop head node, references [i86, i87] were interesting.

All methods calls in the loop body are side-effect free, hence they can be ignored.

By SMT, we could prove

((0 <= initial_i86 and 0 <= initial_i64) and ((((0 = res_i86 and 0 = res_i87 and path1_i86 = initial_i86 and path1_i87 = initial_i87) and (0 <= path1_i86 and path1_i86 <= path1_i87 and path1_i86 <= path1_i87 and T and path1_i86 = 0 and T and path1_i87 = 0)) or ((path2_i87 = path2_i92 and path2_i86 = path2_i91 and path2_i96 = (path2_i91 + 1) and path2_i96 = res_i86 and path2_i92 = res_i87 and path2_i86 = initial_i86 and path2_i87 = initial_i87) and (0 <= path2_i86 and path2_i86 <= path2_i87 and path2_i86 <= path2_i87 and T and 0 = 0 and 0 < path2_i91 and path2_i91 != path2_i92 and path2_i91 < path2_i92)) or ((path3_i87 = path3_i92 and path3_i86 = path3_i91 and path3_i99 = (path3_i92 + -1) and 0 = res_i86 and path3_i99 = res_i87 and path3_i86 = initial_i86 and path3_i87 = initial_i87) and (0 <= path3_i86 and path3_i86 <= path3_i87 and path3_i86 <= path3_i87 and T and 0 = 0 and 0 < path3_i91 and path3_i91 = path3_i92 and path3_i92 = path3_i92)) or ((path4_i87 = path4_i93 and 1 = res_i86 and path4_i93 = res_i87 and path4_i86 = initial_i86 and path4_i87 = initial_i87) and (0 <= path4_i86 and path4_i86 <= path4_i87 and path4_i86 <= path4_i87 and T and path4_i86 = 0 and T and 0 = 0 and 0 < path4_i93 and 0 < path4_i93)) or ((path2_i87 = path2_i92 and path2_i86 = path2_i91 and path2_i96 = (path2_i91 + 1) and path2_i96 = res_i86 and path2_i92 = res_i87 and path2_i86 = initial_i86 and path2_i87 = initial_i87) and (0 <= path2_i86 and path2_i86 <= path2_i87 and path2_i86 <= path2_i87 and T and 0 = 0 and 0 < path2_i91 and path2_i91 < path2_i92 and path2_i91 < path2_i92)) or ((path2_i87 = path2_i92 and path2_i86 = path2_i91 and path2_i96 = (path2_i91 + 1) and path2_i96 = res_i86 and path2_i92 = res_i87 and path2_i86 = initial_i86 and path2_i87 = initial_i87) and (0 <= path2_i86 and path2_i86 <= path2_i87 and path2_i86 <= path2_i87 and T and 0 = 0 and 0 < path2_i91 and path2_i91 < path2_i92 and path2_i91 > path2_i92))) and (((res_i86 = res1_i86 and res_i87 = res1_i87) and !(0 <= res1_i86 and res1_i86 <= res1_i87 and res1_i86 <= res1_i87 and T and res1_i86 = 0 and T and res1_i87 = 0)) and ((res2_i87 = res2_i92 and res2_i86 = res2_i91 and res2_i96 = (res2_i91 + 1) and res_i86 = res2_i86 and res_i87 = res2_i87) and !(0 <= res2_i86 and res2_i86 <= res2_i87 and res2_i86 <= res2_i87 and T and 0 = 0 and 0 < res2_i91 and res2_i91 != res2_i92 and res2_i91 < res2_i92)) and ((res3_i87 = res3_i92 and res3_i86 = res3_i91 and res3_i99 = (res3_i92 + -1) and res_i86 = res3_i86 and res_i87 = res3_i87) and !(0 <= res3_i86 and res3_i86 <= res3_i87 and res3_i86 <= res3_i87 and T and 0 = 0 and 0 < res3_i91 and res3_i91 = res3_i92 and res3_i92 = res3_i92)) and ((res4_i87 = res4_i93 and res_i86 = res4_i86 and res_i87 = res4_i87) and !(0 <= res4_i86 and res4_i86 <= res4_i87 and res4_i86 <= res4_i87 and T and res4_i86 = 0 and T and 0 = 0 and 0 < res4_i93 and 0 < res4_i93)) and ((res2_i87 = res2_i92 and res2_i86 = res2_i91 and res2_i96 = (res2_i91 + 1) and res_i86 = res2_i86 and res_i87 = res2_i87) and !(0 <= res2_i86 and res2_i86 <= res2_i87 and res2_i86 <= res2_i87 and T and 0 = 0 and 0 < res2_i91 and res2_i91 < res2_i92 and res2_i91 < res2_i92)) and ((res2_i87 = res2_i92 and res2_i86 = res2_i91 and res2_i96 = (res2_i91 + 1) and res_i86 = res2_i86 and res_i87 = res2_i87) and !(0 <= res2_i86 and res2_i86 <= res2_i87 and res2_i86 <= res2_i87 and T and 0 = 0 and 0 < res2_i91 and res2_i91 < res2_i92 and res2_i91 > res2_i92)))))

to be UNSAT. Consequently, the loop will not terminate.
----------------------------------------

(6)
NO
