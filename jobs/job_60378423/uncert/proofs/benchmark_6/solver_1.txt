YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/Buu7z.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 188 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) JBCTerminationSCC
(7) SCCToIRSProof [SOUND, 86 ms]
(8) IRSwT
(9) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
(10) IRSwT
(11) IRSwTTerminationDigraphProof [EQUIVALENT, 63 ms]
(12) IRSwT
(13) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(14) IRSwT
(15) TempFilterProof [SOUND, 10 ms]
(16) IntTRS
(17) PolynomialOrderProcessor [EQUIVALENT, 0 ms]
(18) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class CountUpRound{
  public static int round (int x) {

    if (x % 2 == 0) return x;
    else return x+1;
  }


  public static void main(String[] args) {
    Random.args = args;
    int x = Random.random();
    int y = Random.random();



    while (x > y) {

      y = round(y+1);

    }


  }

}


public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
    String string = args[index];
    index++;
    return string.length();
  }
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class CountUpRound{
  public static int round (int x) {

    if (x % 2 == 0) return x;
    else return x+1;
  }


  public static void main(String[] args) {
    Random.args = args;
    int x = Random.random();
    int y = Random.random();



    while (x > y) {

      y = round(y+1);

    }


  }

}


public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
    String string = args[index];
    index++;
    return string.length();
  }
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
CountUpRound.main([Ljava/lang/String;)V: Graph of 194 nodes with 1 SCC.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 1 SCCs.
----------------------------------------

(6)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: CountUpRound.main([Ljava/lang/String;)V
SCC calls the following helper methods: 
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(7) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 27 IRulesP rules:
f451_0_main_Load(EOS(STATIC_451), i56, i57, i56) -> f452_0_main_LE(EOS(STATIC_452), i56, i57, i56, i57) :|: TRUE
f452_0_main_LE(EOS(STATIC_452), i56, i57, i56, i57) -> f456_0_main_LE(EOS(STATIC_456), i56, i57, i56, i57) :|: i56 > i57
f456_0_main_LE(EOS(STATIC_456), i56, i57, i56, i57) -> f460_0_main_Load(EOS(STATIC_460), i56, i57) :|: i56 > i57
f460_0_main_Load(EOS(STATIC_460), i56, i57) -> f462_0_main_ConstantStackPush(EOS(STATIC_462), i56, i57) :|: TRUE
f462_0_main_ConstantStackPush(EOS(STATIC_462), i56, i57) -> f463_0_main_IntArithmetic(EOS(STATIC_463), i56, i57, 1) :|: TRUE
f463_0_main_IntArithmetic(EOS(STATIC_463), i56, i57, matching1) -> f464_0_main_InvokeMethod(EOS(STATIC_464), i56, i57 + 1) :|: i57 >= 0 && matching1 = 1
f464_0_main_InvokeMethod(EOS(STATIC_464), i56, i60) -> f465_0_round_Load(EOS(STATIC_465), i56, i60) :|: TRUE
f465_0_round_Load(EOS(STATIC_465), i56, i60) -> f466_0_round_ConstantStackPush(EOS(STATIC_466), i56, i60, i60) :|: TRUE
f466_0_round_ConstantStackPush(EOS(STATIC_466), i56, i60, i60) -> f467_0_round_IntArithmetic(EOS(STATIC_467), i56, i60, i60, 2) :|: TRUE
f467_0_round_IntArithmetic(EOS(STATIC_467), i56, i60, i60, matching1) -> f468_0_round_NE(EOS(STATIC_468), i56, i60, i60 % 2) :|: TRUE && matching1 = 2
f468_0_round_NE(EOS(STATIC_468), i56, i60, matching1) -> f472_0_round_NE(EOS(STATIC_472), i56, i60, 1) :|: TRUE && matching1 = 1
f468_0_round_NE(EOS(STATIC_468), i56, i60, matching1) -> f473_0_round_NE(EOS(STATIC_473), i56, i60, 0) :|: TRUE && matching1 = 0
f472_0_round_NE(EOS(STATIC_472), i56, i60, matching1) -> f476_0_round_Load(EOS(STATIC_476), i56, i60) :|: 1 > 0 && matching1 = 1
f476_0_round_Load(EOS(STATIC_476), i56, i60) -> f478_0_round_ConstantStackPush(EOS(STATIC_478), i56, i60) :|: TRUE
f478_0_round_ConstantStackPush(EOS(STATIC_478), i56, i60) -> f480_0_round_IntArithmetic(EOS(STATIC_480), i56, i60, 1) :|: TRUE
f480_0_round_IntArithmetic(EOS(STATIC_480), i56, i60, matching1) -> f482_0_round_Return(EOS(STATIC_482), i56, i60 + 1) :|: i60 > 0 && matching1 = 1
f482_0_round_Return(EOS(STATIC_482), i56, i62) -> f485_0_main_Store(EOS(STATIC_485), i56, i62) :|: TRUE
f485_0_main_Store(EOS(STATIC_485), i56, i62) -> f494_0_main_JMP(EOS(STATIC_494), i56, i62) :|: TRUE
f494_0_main_JMP(EOS(STATIC_494), i56, i62) -> f2179_0_main_Load(EOS(STATIC_2179), i56, i62) :|: TRUE
f2179_0_main_Load(EOS(STATIC_2179), i56, i62) -> f449_0_main_Load(EOS(STATIC_449), i56, i62) :|: TRUE
f449_0_main_Load(EOS(STATIC_449), i56, i57) -> f451_0_main_Load(EOS(STATIC_451), i56, i57, i56) :|: TRUE
f473_0_round_NE(EOS(STATIC_473), i56, i60, matching1) -> f477_0_round_Load(EOS(STATIC_477), i56, i60) :|: TRUE && matching1 = 0
f477_0_round_Load(EOS(STATIC_477), i56, i60) -> f479_0_round_Return(EOS(STATIC_479), i56, i60) :|: TRUE
f479_0_round_Return(EOS(STATIC_479), i56, i60) -> f481_0_main_Store(EOS(STATIC_481), i56, i60) :|: TRUE
f481_0_main_Store(EOS(STATIC_481), i56, i60) -> f483_0_main_JMP(EOS(STATIC_483), i56, i60) :|: TRUE
f483_0_main_JMP(EOS(STATIC_483), i56, i60) -> f490_0_main_Load(EOS(STATIC_490), i56, i60) :|: TRUE
f490_0_main_Load(EOS(STATIC_490), i56, i60) -> f449_0_main_Load(EOS(STATIC_449), i56, i60) :|: TRUE
Combined rules. Obtained 4 IRulesP rules:
f451_0_main_Load(EOS(STATIC_451), i56:0, i57:0, i56:0) -> f451_0_main_Load'(EOS(STATIC_451), i56:0, i57:0, i56:0) :|: i57:0 < i56:0 && i57:0 + 1 - 2 * div = 0 && i57:0 > -1
f451_0_main_Load'(EOS(STATIC_451), i56:0, i57:0, i56:0) -> f451_0_main_Load(EOS(STATIC_451), i56:0, i57:0 + 1, i56:0) :|: i57:0 < i56:0 && i57:0 > -1 && i57:0 + 1 - 2 * div = 0 && i57:0 + 1 - 2 * div < 2 && i57:0 + 1 - 2 * div > -2
f451_0_main_Load(EOS(STATIC_451), i56:0, i57:0, i56:0) -> f451_0_main_Load'(EOS(STATIC_451), i56:0, i57:0, i56:0) :|: i57:0 < i56:0 && i57:0 > -1 && i57:0 + 1 - 2 * div = 1
f451_0_main_Load'(EOS(STATIC_451), i56:0, i57:0, i56:0) -> f451_0_main_Load(EOS(STATIC_451), i56:0, i57:0 + 2, i56:0) :|: i57:0 < i56:0 && i57:0 > -1 && i57:0 + 1 - 2 * div = 1 && i57:0 + 1 - 2 * div < 2 && i57:0 + 1 - 2 * div > -2
Filtered constant ground arguments:
   f451_0_main_Load(x1, x2, x3, x4) -> f451_0_main_Load(x2, x3, x4)
   f451_0_main_Load'(x1, x2, x3, x4) -> f451_0_main_Load'(x2, x3, x4)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f451_0_main_Load(x1, x2, x3) -> f451_0_main_Load(x2, x3)
   f451_0_main_Load'(x1, x2, x3) -> f451_0_main_Load'(x2, x3)
Finished conversion. Obtained 4 rules.P rules:
f451_0_main_Load(i57:0, i56:0) -> f451_0_main_Load'(i57:0, i56:0) :|: i57:0 + 1 - 2 * div = 0 && i57:0 > -1 && i57:0 < i56:0
f451_0_main_Load'(i57:0, i56:0) -> f451_0_main_Load(i57:0 + 1, i56:0) :|: i57:0 > -1 && i57:0 < i56:0 && i57:0 + 1 - 2 * div = 0 && i57:0 + 1 - 2 * div > -2 && i57:0 + 1 - 2 * div < 2
f451_0_main_Load(i57:0, i56:0) -> f451_0_main_Load'(i57:0, i56:0) :|: i57:0 > -1 && i57:0 + 1 - 2 * div = 1 && i57:0 < i56:0
f451_0_main_Load'(i57:0, i56:0) -> f451_0_main_Load(i57:0 + 2, i56:0) :|: i57:0 > -1 && i57:0 < i56:0 && i57:0 + 1 - 2 * div = 1 && i57:0 + 1 - 2 * div > -2 && i57:0 + 1 - 2 * div < 2

----------------------------------------

(8)
Obligation:
Rules:
f451_0_main_Load(x, x1) -> f451_0_main_Load'(x, x1) :|: x + 1 - 2 * x2 = 0 && x > -1 && x < x1
f451_0_main_Load'(x3, x4) -> f451_0_main_Load(x3 + 1, x4) :|: x3 > -1 && x3 < x4 && x3 + 1 - 2 * x5 = 0 && x3 + 1 - 2 * x5 > -2 && x3 + 1 - 2 * x5 < 2
f451_0_main_Load(x6, x7) -> f451_0_main_Load'(x6, x7) :|: x6 > -1 && x6 + 1 - 2 * x8 = 1 && x6 < x7
f451_0_main_Load'(x9, x10) -> f451_0_main_Load(x9 + 2, x10) :|: x9 > -1 && x9 < x10 && x9 + 1 - 2 * x11 = 1 && x9 + 1 - 2 * x11 > -2 && x9 + 1 - 2 * x11 < 2

----------------------------------------

(9) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(10)
Obligation:
Rules:
f451_0_main_Load(x, x1) -> f451_0_main_Load'(x, x1) :|: x + 1 - 2 * x2 = 0 && x > -1 && x < x1
f451_0_main_Load'(x3, x4) -> f451_0_main_Load(arith, x4) :|: x3 > -1 && x3 < x4 && x3 + 1 - 2 * x5 = 0 && x3 + 1 - 2 * x5 > -2 && x3 + 1 - 2 * x5 < 2 && arith = x3 + 1
f451_0_main_Load(x6, x7) -> f451_0_main_Load'(x6, x7) :|: x6 > -1 && x6 + 1 - 2 * x8 = 1 && x6 < x7
f451_0_main_Load'(x12, x13) -> f451_0_main_Load(x14, x13) :|: x12 > -1 && x12 < x13 && x12 + 1 - 2 * x15 = 1 && x12 + 1 - 2 * x15 > -2 && x12 + 1 - 2 * x15 < 2 && x14 = x12 + 2

----------------------------------------

(11) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f451_0_main_Load(x, x1) -> f451_0_main_Load'(x, x1) :|: x + 1 - 2 * x2 = 0 && x > -1 && x < x1
(2) f451_0_main_Load'(x3, x4) -> f451_0_main_Load(arith, x4) :|: x3 > -1 && x3 < x4 && x3 + 1 - 2 * x5 = 0 && x3 + 1 - 2 * x5 > -2 && x3 + 1 - 2 * x5 < 2 && arith = x3 + 1
(3) f451_0_main_Load(x6, x7) -> f451_0_main_Load'(x6, x7) :|: x6 > -1 && x6 + 1 - 2 * x8 = 1 && x6 < x7
(4) f451_0_main_Load'(x12, x13) -> f451_0_main_Load(x14, x13) :|: x12 > -1 && x12 < x13 && x12 + 1 - 2 * x15 = 1 && x12 + 1 - 2 * x15 > -2 && x12 + 1 - 2 * x15 < 2 && x14 = x12 + 2

Arcs:
(1) -> (2)
(2) -> (3)
(3) -> (4)
(4) -> (3)

This digraph is fully evaluated!
----------------------------------------

(12)
Obligation:

Termination digraph:
Nodes:
(1) f451_0_main_Load(x6, x7) -> f451_0_main_Load'(x6, x7) :|: x6 > -1 && x6 + 1 - 2 * x8 = 1 && x6 < x7
(2) f451_0_main_Load'(x12, x13) -> f451_0_main_Load(x14, x13) :|: x12 > -1 && x12 < x13 && x12 + 1 - 2 * x15 = 1 && x12 + 1 - 2 * x15 > -2 && x12 + 1 - 2 * x15 < 2 && x14 = x12 + 2

Arcs:
(1) -> (2)
(2) -> (1)

This digraph is fully evaluated!

----------------------------------------

(13) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(14)
Obligation:
Rules:
f451_0_main_Load(x6:0, x7:0) -> f451_0_main_Load(x6:0 + 2, x7:0) :|: x6:0 + 1 - 2 * x8:0 = 1 && x6:0 + 1 - 2 * x15:0 < 2 && x6:0 + 1 - 2 * x15:0 > -2 && x6:0 + 1 - 2 * x15:0 = 1 && x7:0 > x6:0 && x6:0 > -1

----------------------------------------

(15) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f451_0_main_Load(INTEGER, INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(16)
Obligation:
Rules:
f451_0_main_Load(x6:0, x7:0) -> f451_0_main_Load(c, x7:0) :|: c = x6:0 + 2 && (x6:0 + 1 - 2 * x8:0 = 1 && x6:0 + 1 - 2 * x15:0 < 2 && x6:0 + 1 - 2 * x15:0 > -2 && x6:0 + 1 - 2 * x15:0 = 1 && x7:0 > x6:0 && x6:0 > -1)

----------------------------------------

(17) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f451_0_main_Load(x, x1)] = -x + x1

The following rules are decreasing:
f451_0_main_Load(x6:0, x7:0) -> f451_0_main_Load(c, x7:0) :|: c = x6:0 + 2 && (x6:0 + 1 - 2 * x8:0 = 1 && x6:0 + 1 - 2 * x15:0 < 2 && x6:0 + 1 - 2 * x15:0 > -2 && x6:0 + 1 - 2 * x15:0 = 1 && x7:0 > x6:0 && x6:0 > -1)
The following rules are bounded:
f451_0_main_Load(x6:0, x7:0) -> f451_0_main_Load(c, x7:0) :|: c = x6:0 + 2 && (x6:0 + 1 - 2 * x8:0 = 1 && x6:0 + 1 - 2 * x15:0 < 2 && x6:0 + 1 - 2 * x15:0 > -2 && x6:0 + 1 - 2 * x15:0 = 1 && x7:0 > x6:0 && x6:0 > -1)

----------------------------------------

(18)
YES
