Input TRS:
    AC symbols: plus union mult
    1: union(X,empty()) -> X
    2: union(empty(),X) -> X
    3: 0(z()) -> z()
    4: and(tt(),X) -> X
    5: mult(z(),X) -> z()
    6: mult(0(X),Y) -> 0(mult(X,Y))
    7: mult(1(X),Y) -> plus(0(mult(X,Y)),Y)
    8: plus(z(),X) -> X
    9: plus(0(X),0(Y)) -> 0(plus(X,Y))
    10: plus(0(X),1(Y)) -> 1(plus(X,Y))
    11: plus(1(X),1(Y)) -> 0(plus(plus(X,Y),1(z())))
    12: prod(empty()) -> 1(z())
    13: prod(singl(X)) -> X
    14: prod(union(A,B)) -> mult(prod(A),prod(B))
    15: sum(empty()) -> 0(z())
    16: sum(singl(X)) -> X
    17: sum(union(A,B)) -> plus(sum(A),sum(B))
Number of strict rules: 17
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #mult(0(X),Y) -> #0(mult(X,Y))
   #2: #mult(0(X),Y) -> #mult(X,Y)
   #3: #plus(0(X),0(Y)) -> #0(plus(X,Y))
   #4: #plus(0(X),0(Y)) -> #plus(X,Y)
   #5: #plus(1(X),1(Y)) -> #0(plus(plus(X,Y),1(z())))
   #6: #plus(1(X),1(Y)) -> #plus(plus(X,Y),1(z()))
   #7: #plus(1(X),1(Y)) -> #plus(X,Y)
   #8: #prod(union(A,B)) -> #mult(prod(A),prod(B))
   #9: #prod(union(A,B)) -> #prod(A)
   #10: #prod(union(A,B)) -> #prod(B)
   #11: #mult(x,mult(y,z)) ->= #mult(mult(x,y),z)
   #12: #mult(x,mult(y,z)) ->= #mult(x,y)
   #13: #mult(1(X),Y) -> #plus(0(mult(X,Y)),Y)
   #14: #mult(1(X),Y) -> #0(mult(X,Y))
   #15: #mult(1(X),Y) -> #mult(X,Y)
   #16: #plus(0(X),1(Y)) -> #plus(X,Y)
   #17: #sum(union(A,B)) -> #plus(sum(A),sum(B))
   #18: #sum(union(A,B)) -> #sum(A)
   #19: #sum(union(A,B)) -> #sum(B)
   #20: #union(x,union(y,z)) ->= #union(union(x,y),z)
   #21: #union(x,union(y,z)) ->= #union(x,y)
   #22: #sum(empty()) -> #0(z())
   #23: #plus(x,plus(y,z)) ->= #plus(plus(x,y),z)
   #24: #plus(x,plus(y,z)) ->= #plus(x,y)
Number of SCCs: 5, DPs: 16, edges: 64
	SCC { #9 #10 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
   #0(x1)	weight: 0
     1(x1)	weight: 0
  prod(x1)	weight: 0
     z()	weight: 0
#prod(x1)	weight: x1
   and(x1,x2)	weight: 0
#plus(x1,x2)	weight: 0
   sum(x1)	weight: 0
  mult(x1,x2)	weight: 0
     0(x1)	weight: 0
 union(x1,x2)	weight: (/ 1 2) + x1 + x2
 singl(x1)	weight: 0
  plus(x1,x2)	weight: 0
 empty()	weight: 0
    tt()	weight: 0
 #sum(x1)	weight: 0
 #and(x1,x2)	weight: 0
#union(x1,x2)	weight: 0
#mult(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #9 #10
Number of SCCs: 4, DPs: 14, edges: 60
	SCC { #18 #19 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
   #0(x1)	weight: 0
     1(x1)	weight: 0
  prod(x1)	weight: 0
     z()	weight: 0
#prod(x1)	weight: 0
   and(x1,x2)	weight: 0
#plus(x1,x2)	weight: 0
   sum(x1)	weight: 0
  mult(x1,x2)	weight: 0
     0(x1)	weight: 0
 union(x1,x2)	weight: (/ 1 2) + x1 + x2
 singl(x1)	weight: 0
  plus(x1,x2)	weight: 0
 empty()	weight: 0
    tt()	weight: 0
 #sum(x1)	weight: x1
 #and(x1,x2)	weight: 0
#union(x1,x2)	weight: 0
#mult(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #18 #19
Number of SCCs: 3, DPs: 12, edges: 56
	SCC { #20 #21 }
Removing DPs: only weak rules.
Number of SCCs: 2, DPs: 12, edges: 56
	SCC { #2 #11 #12 #15 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... succeeded.
   #0(x1)	weight: 0
     1(x1)	weight: max{0, x1}
  prod(x1)	weight: 0
     z()	weight: (/ 1 2)
#prod(x1)	weight: 0
   and(x1,x2)	weight: 0
#plus(x1,x2)	weight: 0
   sum(x1)	weight: 0
  mult(x1,x2)	weight: (/ 1 2) + x1 + x2
     0(x1)	weight: max{0, x1}
 union(x1,x2)	weight: 0
 singl(x1)	weight: 0
  plus(x1,x2)	weight: max{(/ 1 2), max{x2, x1}}
 empty()	weight: 0
    tt()	weight: 0
 #sum(x1)	weight: 0
 #and(x1,x2)	weight: 0
#union(x1,x2)	weight: 0
#mult(x1,x2)	weight: x1 + x2
    Usable rules: { 3 5..11 18 20 }
    Removed DPs: #12
Number of SCCs: 2, DPs: 11, edges: 49
	SCC { #2 #11 #15 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
