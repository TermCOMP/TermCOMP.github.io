Input TRS:
    AC symbols: _or_ _xor_ _and_
    1: U11(tt(),U',U) -> U12(equal(_isNotEqualTo_(U,U'),true()))
    2: U12(tt()) -> false()
    3: U21(tt(),B,U') -> U22(equal(_isNotEqualTo_(B,true()),true()),U')
    4: U22(tt(),U') -> U'
    5: _and_(A,A) -> A
    6: _and_(A,_xor_(B,C)) -> _xor_(_and_(A,B),_and_(A,C))
    7: _and_(false(),A) -> false()
    8: _and_(true(),A) -> A
    9: _implies_(A,B) -> not_(_xor_(A,_and_(A,B)))
    10: _isEqualTo_(U,U') -> U11(tt(),U',U)
    11: _isEqualTo_(U,U) -> true()
    12: _isNotEqualTo_(U,U') -> if_then_else_fi(_isEqualTo_(U,U'),false(),true())
    13: _isNotEqualTo_(U,U) -> false()
    14: _or_(A,B) -> _xor_(_and_(A,B),_xor_(A,B))
    15: _xor_(A,A) -> false()
    16: _xor_(false(),A) -> A
    17: and(tt(),X) -> X
    18: equal(X,X) -> tt()
    19: if_then_else_fi(B,U,U') -> U21(tt(),B,U')
    20: if_then_else_fi(true(),U,U') -> U
    21: not_(A) -> _xor_(A,true())
    22: not_(false()) -> true()
    23: not_(true()) -> false()
Number of strict rules: 23
Direct Order(PosReal,>,Poly) ... failed.
Freezing U11 U21
AC symbols: _or_ _xor_ _and_
1: U11❆1_tt(U',U) -> U12(equal(_isNotEqualTo_(U,U'),true()))
2: U12(tt()) -> false()
3: U21❆1_tt(B,U') -> U22(equal(_isNotEqualTo_(B,true()),true()),U')
4: U22(tt(),U') -> U'
5: _and_(A,A) -> A
6: _and_(A,_xor_(B,C)) -> _xor_(_and_(A,B),_and_(A,C))
7: _and_(false(),A) -> false()
8: _and_(true(),A) -> A
9: _implies_(A,B) -> not_(_xor_(A,_and_(A,B)))
10: _isEqualTo_(U,U') -> U11❆1_tt(U',U)
11: _isEqualTo_(U,U) -> true()
12: _isNotEqualTo_(U,U') -> if_then_else_fi(_isEqualTo_(U,U'),false(),true())
13: _isNotEqualTo_(U,U) -> false()
14: _or_(A,B) -> _xor_(_and_(A,B),_xor_(A,B))
15: _xor_(A,A) -> false()
16: _xor_(false(),A) -> A
17: and(tt(),X) -> X
18: equal(X,X) -> tt()
19: if_then_else_fi(B,U,U') -> U21❆1_tt(B,U')
20: if_then_else_fi(true(),U,U') -> U
21: not_(A) -> _xor_(A,true())
22: not_(false()) -> true()
23: not_(true()) -> false()
24: U21(tt(),_2,_3) ->= U21❆1_tt(_2,_3)
25: U11(tt(),_2,_3) ->= U11❆1_tt(_2,_3)
Number of strict rules: 23
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #_and_(A,_xor_(B,C)) -> #_xor_(_and_(A,B),_and_(A,C))
   #2: #_and_(A,_xor_(B,C)) -> #_and_(A,B)
   #3: #_and_(A,_xor_(B,C)) -> #_and_(A,C)
   #4: #_implies_(A,B) -> #not_(_xor_(A,_and_(A,B)))
   #5: #_implies_(A,B) -> #_xor_(A,_and_(A,B))
   #6: #_implies_(A,B) -> #_and_(A,B)
   #7: #U21(tt(),_2,_3) ->? #U21❆1_tt(_2,_3)
   #8: #_isNotEqualTo_(U,U') -> #if_then_else_fi(_isEqualTo_(U,U'),false(),true())
   #9: #_isNotEqualTo_(U,U') -> #_isEqualTo_(U,U')
   #10: #_or_(A,B) -> #_xor_(_and_(A,B),_xor_(A,B))
   #11: #_or_(A,B) -> #_and_(A,B)
   #12: #_or_(A,B) -> #_xor_(A,B)
   #13: #U11(tt(),_2,_3) ->? #U11❆1_tt(_2,_3)
   #14: #_isEqualTo_(U,U') -> #U11❆1_tt(U',U)
   #15: #_and_(x,_and_(y,z)) ->= #_and_(_and_(x,y),z)
   #16: #_and_(x,_and_(y,z)) ->= #_and_(x,y)
   #17: #_xor_(x,_xor_(y,z)) ->= #_xor_(_xor_(x,y),z)
   #18: #_xor_(x,_xor_(y,z)) ->= #_xor_(x,y)
   #19: #if_then_else_fi(B,U,U') -> #U21❆1_tt(B,U')
   #20: #_or_(x,_or_(y,z)) ->= #_or_(_or_(x,y),z)
   #21: #_or_(x,_or_(y,z)) ->= #_or_(x,y)
   #22: #not_(A) -> #_xor_(A,true())
   #23: #U21❆1_tt(B,U') -> #U22(equal(_isNotEqualTo_(B,true()),true()),U')
   #24: #U21❆1_tt(B,U') -> #equal(_isNotEqualTo_(B,true()),true())
   #25: #U21❆1_tt(B,U') -> #_isNotEqualTo_(B,true())
   #26: #U11❆1_tt(U',U) -> #U12(equal(_isNotEqualTo_(U,U'),true()))
   #27: #U11❆1_tt(U',U) -> #equal(_isNotEqualTo_(U,U'),true())
   #28: #U11❆1_tt(U',U) -> #_isNotEqualTo_(U,U')
Number of SCCs: 4, DPs: 14, edges: 32
	SCC { #17 #18 }
Removing DPs: only weak rules.
Number of SCCs: 3, DPs: 14, edges: 32
	SCC { #20 #21 }
Removing DPs: only weak rules.
Number of SCCs: 2, DPs: 14, edges: 32
	SCC { #2 #3 #15 #16 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... succeeded.
   U21(x1,x2,x3)	status: [x2]	precedence above:
 _and_(x1,x2)	status: {x1,x2}	precedence above: false _xor_
   U11(x1,x2,x3)	status: [x3,x1,x2]	precedence above:
#_isNotEqualTo_(x1,x2)	status: [x2]	precedence above:
  not_(x1)	status: []	precedence above:
#_and_(x1,x2)	status: {x1,x2}	precedence above: _and_ false _xor_
#equal(x1,x2)	status: [x2]	precedence above:
   and(x1,x2)	status: [x2]	precedence above:
  _or_(x1,x2)	status: {}	precedence above:
U21❆1_tt(x1,x2)	status: [x2,x1]	precedence above:
 false()	status: []	precedence above:
   U12(x1)	status: []	precedence above:
U11❆1_tt(x1,x2)	status: [x2]	precedence above:
  true()	status: []	precedence above:
_implies_(x1,x2)	status: [x2]	precedence above:
#_implies_(x1,x2)	status: [x2]	precedence above:
 #U12(x1)	status: []	precedence above:
_isNotEqualTo_(x1,x2)	status: [x2]	precedence above:
#_xor_(x1,x2)	status: {}	precedence above:
 _xor_(x1,x2)	status: {x1,x2}	precedence above: false
#U11❆1_tt(x1,x2)	status: [x1,x2]	precedence above:
#if_then_else_fi(x1,x2,x3)	status: [x1]	precedence above:
#not_(x1)	status: []	precedence above:
#U21❆1_tt(x1,x2)	status: [x1,x2]	precedence above:
 #U11(x1,x2,x3)	status: [x1,x2,x3]	precedence above:
#_isEqualTo_(x1,x2)	status: [x1]	precedence above:
 equal(x1,x2)	status: [x2,x1]	precedence above:
 #U21(x1,x2,x3)	status: [x1,x2,x3]	precedence above:
 #U22(x1,x2)	status: [x1,x2]	precedence above:
    tt()	status: []	precedence above:
#_or_(x1,x2)	status: {}	precedence above:
   U22(x1,x2)	status: [x2]	precedence above:
_isEqualTo_(x1,x2)	status: [x2]	precedence above:
 #and(x1,x2)	status: [x2]	precedence above:
if_then_else_fi(x1,x2,x3)	status: [x1]	precedence above:
    Usable rules: { 5..8 15 16 27 28 }
    Removed DPs: #2 #3 #16
Number of SCCs: 2, DPs: 11, edges: 17
	SCC { #15 }
Removing DPs: only weak rules.
Number of SCCs: 1, DPs: 11, edges: 17
	SCC { #8 #9 #14 #19 #25 #28 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  found.
  #U21❆1_tt(U_{1},U')	-#25->
  #_isNotEqualTo_(U_{1},true())	--->*
  #_isNotEqualTo_(U_{1},true())	-#8->
  #if_then_else_fi(_isEqualTo_(U_{1},true()),false(),true())	--->*
  #if_then_else_fi(_isEqualTo_(U_{1},true()),false(),true())	-#19->
  #U21❆1_tt(_isEqualTo_(U_{1},true()),true())	--->*
  #U21❆1_tt(_isEqualTo_(U_{1},true()),true())
  Looping with: [ U_{1} := _isEqualTo_(U_{1},true()); U' := true(); ]
