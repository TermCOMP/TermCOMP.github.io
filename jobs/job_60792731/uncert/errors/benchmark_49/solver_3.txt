Input TRS:
    AC symbols: or xor and
    1: xor(F(),x) -> x
    2: xor(neg(x),x) -> F()
    3: and(T(),x) -> x
    4: and(F(),x) -> F()
    5: and(x,x) -> x
    6: and(xor(x,y),z) -> xor(and(x,z),and(y,z))
    7: xor(x,x) -> F()
    8: impl(x,y) -> xor(and(x,y),xor(T(),x))
    9: or(x,y) -> xor(and(x,y),xor(x,y))
    10: equiv(x,y) -> xor(xor(T(),y),x)
    11: neg(x) -> xor(T(),x)
Number of strict rules: 11
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #and(xor(x,y),z) -> #xor(and(x,z),and(y,z))
   #2: #and(xor(x,y),z) -> #and(x,z)
   #3: #and(xor(x,y),z) -> #and(y,z)
   #4: #xor(x,xor(y,z)) ->= #xor(xor(x,y),z)
   #5: #xor(x,xor(y,z)) ->= #xor(x,y)
   #6: #or(x,y) -> #xor(and(x,y),xor(x,y))
   #7: #or(x,y) -> #and(x,y)
   #8: #or(x,y) -> #xor(x,y)
   #9: #neg(x) -> #xor(T(),x)
   #10: #or(x,or(y,z)) ->= #or(or(x,y),z)
   #11: #or(x,or(y,z)) ->= #or(x,y)
   #12: #and(x,and(y,z)) ->= #and(and(x,y),z)
   #13: #and(x,and(y,z)) ->= #and(x,y)
   #14: #equiv(x,y) -> #xor(xor(T(),y),x)
   #15: #equiv(x,y) -> #xor(T(),y)
   #16: #impl(x,y) -> #xor(and(x,y),xor(T(),x))
   #17: #impl(x,y) -> #and(x,y)
   #18: #impl(x,y) -> #xor(T(),x)
Number of SCCs: 3, DPs: 8, edges: 24
	SCC { #4 #5 }
Removing DPs: only weak rules.
Number of SCCs: 2, DPs: 8, edges: 24
	SCC { #10 #11 }
Removing DPs: only weak rules.
Number of SCCs: 1, DPs: 8, edges: 24
	SCC { #2 #3 #12 #13 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... succeeded.
     T()	status: []	precedence above:
     F()	status: []	precedence above:
   and(x1,x2)	status: {x1,x2}	precedence above: F xor
#impl(x1,x2)	status: [x2]	precedence above:
 equiv(x1,x2)	status: [x2]	precedence above:
    or(x1,x2)	status: {}	precedence above:
   neg(x1)	status: []	precedence above: F
  impl(x1,x2)	status: [x2]	precedence above:
 #xor(x1,x2)	status: {}	precedence above:
#equiv(x1,x2)	status: [x2]	precedence above:
  #or(x1,x2)	status: {}	precedence above:
 #neg(x1)	status: []	precedence above:
   xor(x1,x2)	status: {x1,x2}	precedence above: F
 #and(x1,x2)	status: {x1,x2}	precedence above: F and xor
    Usable rules: { 1..7 13 14 }
    Removed DPs: #2 #3 #13
Number of SCCs: 1, DPs: 5, edges: 9
	SCC { #12 }
Removing DPs: only weak rules.
Number of SCCs: 0, DPs: 5, edges: 9
Next Dependency Pairs:
   #19: #xor(xor(neg(x),x),†1) -> #xor(F(),†1)
   #20: #and(and(xor(x,y),z),†1) -> #and(xor(and(x,z),and(y,z)),†1)
   #21: #xor(x,xor(y,z)) ->= #xor(xor(x,y),z)
   #22: #xor(x,xor(y,z)) ->= #xor(x,y)
   #23: #or(or(x,y),†1) -> #or(xor(and(x,y),xor(x,y)),†1)
   #24: #or(x,or(y,z)) ->= #or(or(x,y),z)
   #25: #or(x,or(y,z)) ->= #or(x,y)
   #26: #and(x,and(y,z)) ->= #and(and(x,y),z)
   #27: #and(x,and(y,z)) ->= #and(x,y)
   #28: #xor(xor(x,x),†1) -> #xor(F(),†1)
   #29: #and(and(x,x),†1) -> #and(x,†1)
   #30: #and(and(T(),x),†1) -> #and(x,†1)
   #31: #xor(xor(F(),x),†1) -> #xor(x,†1)
   #32: #and(and(F(),x),†1) -> #and(F(),†1)
Number of SCCs: 3, DPs: 14, edges: 70
	SCC { #20 #26 #27 #29 #30 #32 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... succeeded.
     T()	status: []	precedence above:
     F()	status: []	precedence above:
   and(x1,x2)	status: {x1,x2}	precedence above: F xor
#impl(x1,x2)	status: [x2]	precedence above:
 equiv(x1,x2)	status: [x2]	precedence above:
    or(x1,x2)	status: {}	precedence above:
   neg(x1)	status: []	precedence above: F
  impl(x1,x2)	status: [x2]	precedence above:
 #xor(x1,x2)	status: {}	precedence above:
#equiv(x1,x2)	status: [x2]	precedence above:
  #or(x1,x2)	status: {}	precedence above:
 #neg(x1)	status: []	precedence above:
   xor(x1,x2)	status: {x1,x2}	precedence above: F
 #and(x1,x2)	status: {x1,x2}	precedence above: F and xor
    Usable rules: { 1..7 13 14 }
    Removed DPs: #20 #27 #29 #30 #32
Number of SCCs: 3, DPs: 9, edges: 35
	SCC { #26 }
Removing DPs: only weak rules.
Number of SCCs: 2, DPs: 9, edges: 35
	SCC { #19 #21 #22 #28 #31 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     T()	weight: 0
     F()	weight: 0
   and(x1,x2)	weight: (/ 1 8)
#impl(x1,x2)	weight: 0
 equiv(x1,x2)	weight: 0
    or(x1,x2)	weight: 0
   neg(x1)	weight: (/ 1 4)
  impl(x1,x2)	weight: 0
 #xor(x1,x2)	weight: x1 + x2
#equiv(x1,x2)	weight: 0
  #or(x1,x2)	weight: 0
 #neg(x1)	weight: 0
   xor(x1,x2)	weight: (/ 1 4) + x1 + x2
 #and(x1,x2)	weight: 0
    Usable rules: { 1 2 7 13 }
    Removed DPs: #19 #22 #28 #31
Number of SCCs: 3, DPs: 5, edges: 11
	SCC { #21 }
Removing DPs: only weak rules.
Number of SCCs: 2, DPs: 5, edges: 11
	SCC { #23..25 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... succeeded.
     T()	status: []	precedence above:
     F()	status: []	precedence above:
   and(x1,x2)	status: {x1,x2}	precedence above: F xor
#impl(x1,x2)	status: [x2]	precedence above:
 equiv(x1,x2)	status: [x2]	precedence above:
    or(x1,x2)	status: {x1,x2}	precedence above: F and xor
   neg(x1)	status: []	precedence above: F
  impl(x1,x2)	status: [x2]	precedence above:
 #xor(x1,x2)	status: {}	precedence above:
#equiv(x1,x2)	status: [x2]	precedence above:
  #or(x1,x2)	status: {x1,x2}	precedence above: F and or xor
 #neg(x1)	status: []	precedence above:
   xor(x1,x2)	status: {x1,x2}	precedence above: F
 #and(x1,x2)	status: {x1,x2}	precedence above: F and xor
    Usable rules: { 1..7 9 12..14 }
    Removed DPs: #23 #25
Number of SCCs: 3, DPs: 3, edges: 3
	SCC { #24 }
Removing DPs: only weak rules.
Number of SCCs: 2, DPs: 3, edges: 3
