YES

Problem 1: 

(VAR vu95NonEmpty x y z)
(THEORY 
(AC and or xor))
(RULES
and(xor(x,y),z) -> xor(and(x,z),and(y,z))
and(F,x) -> F
and(T,x) -> x
and(x,x) -> x
equiv(x,y) -> xor(xor(T,y),x)
impl(x,y) -> xor(and(x,y),xor(T,x))
neg(x) -> xor(T,x)
or(x,y) -> xor(and(x,y),xor(x,y))
xor(neg(x),x) -> F
xor(F,x) -> x
xor(x,x) -> F
)


Problem 1: 

Dependency Pairs Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
 OR(or(x4,x5),x6) = OR(x4,or(x5,x6))
 OR(x4,x5) = OR(x5,x4)
 XOR(xor(x4,x5),x6) = XOR(x4,xor(x5,x6))
 XOR(x4,x5) = XOR(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(xor(x,y),z),x4) -> AND(x,z)
 AND(and(xor(x,y),z),x4) -> AND(y,z)
 AND(and(xor(x,y),z),x4) -> XOR(and(x,z),and(y,z))
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(T,x),x4) -> AND(x,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
 AND(xor(x,y),z) -> XOR(and(x,z),and(y,z))
 EQUIV(x,y) -> XOR(xor(T,y),x)
 EQUIV(x,y) -> XOR(T,y)
 IMPL(x,y) -> AND(x,y)
 IMPL(x,y) -> XOR(and(x,y),xor(T,x))
 IMPL(x,y) -> XOR(T,x)
 NEG(x) -> XOR(T,x)
 OR(or(x,y),x4) -> AND(x,y)
 OR(or(x,y),x4) -> OR(xor(and(x,y),xor(x,y)),x4)
 OR(or(x,y),x4) -> XOR(and(x,y),xor(x,y))
 OR(or(x,y),x4) -> XOR(x,y)
 OR(x,y) -> AND(x,y)
 OR(x,y) -> XOR(and(x,y),xor(x,y))
 OR(x,y) -> XOR(x,y)
 XOR(xor(neg(x),x),x4) -> XOR(F,x4)
 XOR(xor(F,x),x4) -> XOR(x,x4)
 XOR(xor(x,x),x4) -> XOR(F,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
 OR(or(x4,x5),x6) -> OR(x4,x5)
 OR(x4,or(x5,x6)) -> OR(x5,x6)
 XOR(xor(x4,x5),x6) -> XOR(x4,x5)
 XOR(x4,xor(x5,x6)) -> XOR(x5,x6)

Problem 1: 

SCC Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
 OR(or(x4,x5),x6) = OR(x4,or(x5,x6))
 OR(x4,x5) = OR(x5,x4)
 XOR(xor(x4,x5),x6) = XOR(x4,xor(x5,x6))
 XOR(x4,x5) = XOR(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(xor(x,y),z),x4) -> AND(x,z)
 AND(and(xor(x,y),z),x4) -> AND(y,z)
 AND(and(xor(x,y),z),x4) -> XOR(and(x,z),and(y,z))
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(T,x),x4) -> AND(x,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
 AND(xor(x,y),z) -> XOR(and(x,z),and(y,z))
 EQUIV(x,y) -> XOR(xor(T,y),x)
 EQUIV(x,y) -> XOR(T,y)
 IMPL(x,y) -> AND(x,y)
 IMPL(x,y) -> XOR(and(x,y),xor(T,x))
 IMPL(x,y) -> XOR(T,x)
 NEG(x) -> XOR(T,x)
 OR(or(x,y),x4) -> AND(x,y)
 OR(or(x,y),x4) -> OR(xor(and(x,y),xor(x,y)),x4)
 OR(or(x,y),x4) -> XOR(and(x,y),xor(x,y))
 OR(or(x,y),x4) -> XOR(x,y)
 OR(x,y) -> AND(x,y)
 OR(x,y) -> XOR(and(x,y),xor(x,y))
 OR(x,y) -> XOR(x,y)
 XOR(xor(neg(x),x),x4) -> XOR(F,x4)
 XOR(xor(F,x),x4) -> XOR(x,x4)
 XOR(xor(x,x),x4) -> XOR(F,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
 OR(or(x4,x5),x6) -> OR(x4,x5)
 OR(x4,or(x5,x6)) -> OR(x5,x6)
 XOR(xor(x4,x5),x6) -> XOR(x4,x5)
 XOR(x4,xor(x5,x6)) -> XOR(x5,x6)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 XOR(xor(neg(x),x),x4) -> XOR(F,x4)
 XOR(xor(F,x),x4) -> XOR(x,x4)
 XOR(xor(x,x),x4) -> XOR(F,x4)
-> FAxioms:
 and(and(x4,x5),x6) -> and(x4,and(x5,x6))
 and(x4,x5) -> and(x5,x4)
 or(or(x4,x5),x6) -> or(x4,or(x5,x6))
 or(x4,x5) -> or(x5,x4)
 xor(xor(x4,x5),x6) -> xor(x4,xor(x5,x6))
 xor(x4,x5) -> xor(x5,x4)
 XOR(xor(x4,x5),x6) -> XOR(x4,xor(x5,x6))
 XOR(x4,x5) -> XOR(x5,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
->->-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 XOR(xor(x4,x5),x6) -> XOR(x4,x5)
 XOR(x4,xor(x5,x6)) -> XOR(x5,x6)
->->Cycle:
->->-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(xor(x,y),z),x4) -> AND(x,z)
 AND(and(xor(x,y),z),x4) -> AND(y,z)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(T,x),x4) -> AND(x,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
-> FAxioms:
 and(and(x4,x5),x6) -> and(x4,and(x5,x6))
 and(x4,x5) -> and(x5,x4)
 or(or(x4,x5),x6) -> or(x4,or(x5,x6))
 or(x4,x5) -> or(x5,x4)
 xor(xor(x4,x5),x6) -> xor(x4,xor(x5,x6))
 xor(x4,x5) -> xor(x5,x4)
 AND(and(x4,x5),x6) -> AND(x4,and(x5,x6))
 AND(x4,x5) -> AND(x5,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
->->-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->->Cycle:
->->-> Pairs:
 OR(or(x,y),x4) -> OR(xor(and(x,y),xor(x,y)),x4)
-> FAxioms:
 and(and(x4,x5),x6) -> and(x4,and(x5,x6))
 and(x4,x5) -> and(x5,x4)
 or(or(x4,x5),x6) -> or(x4,or(x5,x6))
 or(x4,x5) -> or(x5,x4)
 xor(xor(x4,x5),x6) -> xor(x4,xor(x5,x6))
 xor(x4,x5) -> xor(x5,x4)
 OR(or(x4,x5),x6) -> OR(x4,or(x5,x6))
 OR(x4,x5) -> OR(x5,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
->->-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 OR(or(x4,x5),x6) -> OR(x4,x5)
 OR(x4,or(x5,x6)) -> OR(x5,x6)


The problem is decomposed in 3 subproblems.

Problem 1.1: 

Reduction Pairs Processor:
-> FAxioms:
 XOR(xor(x4,x5),x6) = XOR(x4,xor(x5,x6))
 XOR(x4,x5) = XOR(x5,x4)
-> Pairs:
 XOR(xor(neg(x),x),x4) -> XOR(F,x4)
 XOR(xor(F,x),x4) -> XOR(x,x4)
 XOR(xor(x,x),x4) -> XOR(F,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Usable Equations:
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> Usable Rules:
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 XOR(xor(x4,x5),x6) -> XOR(x4,x5)
 XOR(x4,xor(x5,x6)) -> XOR(x5,x6)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[and](X1,X2) = 0
[equiv](X1,X2) = 0
[impl](X1,X2) = 0
[neg](X) = 2
[or](X1,X2) = 0
[xor](X1,X2) = X1 + X2
[F] = 0
[T] = 0
[fSNonEmpty] = 0
[AND](X1,X2) = 0
[EQUIV](X1,X2) = 0
[IMPL](X1,X2) = 0
[NEG](X) = 0
[OR](X1,X2) = 0
[XOR](X1,X2) = 2.X1 + 2.X2

Problem 1.1: 

SCC Processor:
-> FAxioms:
 XOR(xor(x4,x5),x6) = XOR(x4,xor(x5,x6))
 XOR(x4,x5) = XOR(x5,x4)
-> Pairs:
 XOR(xor(F,x),x4) -> XOR(x,x4)
 XOR(xor(x,x),x4) -> XOR(F,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 XOR(xor(x4,x5),x6) -> XOR(x4,x5)
 XOR(x4,xor(x5,x6)) -> XOR(x5,x6)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 XOR(xor(F,x),x4) -> XOR(x,x4)
 XOR(xor(x,x),x4) -> XOR(F,x4)
-> FAxioms:
 and(and(x4,x5),x6) -> and(x4,and(x5,x6))
 and(x4,x5) -> and(x5,x4)
 or(or(x4,x5),x6) -> or(x4,or(x5,x6))
 or(x4,x5) -> or(x5,x4)
 xor(xor(x4,x5),x6) -> xor(x4,xor(x5,x6))
 xor(x4,x5) -> xor(x5,x4)
 XOR(xor(x4,x5),x6) -> XOR(x4,xor(x5,x6))
 XOR(x4,x5) -> XOR(x5,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
->->-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 XOR(xor(x4,x5),x6) -> XOR(x4,x5)
 XOR(x4,xor(x5,x6)) -> XOR(x5,x6)

Problem 1.1: 

Reduction Pairs Processor:
-> FAxioms:
 XOR(xor(x4,x5),x6) = XOR(x4,xor(x5,x6))
 XOR(x4,x5) = XOR(x5,x4)
-> Pairs:
 XOR(xor(F,x),x4) -> XOR(x,x4)
 XOR(xor(x,x),x4) -> XOR(F,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Usable Equations:
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> Usable Rules:
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 XOR(xor(x4,x5),x6) -> XOR(x4,x5)
 XOR(x4,xor(x5,x6)) -> XOR(x5,x6)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[and](X1,X2) = 0
[equiv](X1,X2) = 0
[impl](X1,X2) = 0
[neg](X) = 1
[or](X1,X2) = 0
[xor](X1,X2) = X1 + X2 + 2
[F] = 2
[T] = 0
[fSNonEmpty] = 0
[AND](X1,X2) = 0
[EQUIV](X1,X2) = 0
[IMPL](X1,X2) = 0
[NEG](X) = 0
[OR](X1,X2) = 0
[XOR](X1,X2) = 2.X1 + 2.X2

Problem 1.1: 

SCC Processor:
-> FAxioms:
 XOR(xor(x4,x5),x6) = XOR(x4,xor(x5,x6))
 XOR(x4,x5) = XOR(x5,x4)
-> Pairs:
 XOR(xor(x,x),x4) -> XOR(F,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 XOR(xor(x4,x5),x6) -> XOR(x4,x5)
 XOR(x4,xor(x5,x6)) -> XOR(x5,x6)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 XOR(xor(x,x),x4) -> XOR(F,x4)
-> FAxioms:
 and(and(x4,x5),x6) -> and(x4,and(x5,x6))
 and(x4,x5) -> and(x5,x4)
 or(or(x4,x5),x6) -> or(x4,or(x5,x6))
 or(x4,x5) -> or(x5,x4)
 xor(xor(x4,x5),x6) -> xor(x4,xor(x5,x6))
 xor(x4,x5) -> xor(x5,x4)
 XOR(xor(x4,x5),x6) -> XOR(x4,xor(x5,x6))
 XOR(x4,x5) -> XOR(x5,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
->->-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 XOR(xor(x4,x5),x6) -> XOR(x4,x5)
 XOR(x4,xor(x5,x6)) -> XOR(x5,x6)

Problem 1.1: 

Reduction Pairs Processor:
-> FAxioms:
 XOR(xor(x4,x5),x6) = XOR(x4,xor(x5,x6))
 XOR(x4,x5) = XOR(x5,x4)
-> Pairs:
 XOR(xor(x,x),x4) -> XOR(F,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Usable Equations:
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> Usable Rules:
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 XOR(xor(x4,x5),x6) -> XOR(x4,x5)
 XOR(x4,xor(x5,x6)) -> XOR(x5,x6)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[and](X1,X2) = 0
[equiv](X1,X2) = 0
[impl](X1,X2) = 0
[neg](X) = 2
[or](X1,X2) = 0
[xor](X1,X2) = X1 + X2 + 1
[F] = 0
[T] = 0
[fSNonEmpty] = 0
[AND](X1,X2) = 0
[EQUIV](X1,X2) = 0
[IMPL](X1,X2) = 0
[NEG](X) = 0
[OR](X1,X2) = 0
[XOR](X1,X2) = 2.X1 + 2.X2

Problem 1.1: 

SCC Processor:
-> FAxioms:
 XOR(xor(x4,x5),x6) = XOR(x4,xor(x5,x6))
 XOR(x4,x5) = XOR(x5,x4)
-> Pairs:
 Empty
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 XOR(xor(x4,x5),x6) -> XOR(x4,x5)
 XOR(x4,xor(x5,x6)) -> XOR(x5,x6)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Reduction Pairs Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(xor(x,y),z),x4) -> AND(x,z)
 AND(and(xor(x,y),z),x4) -> AND(y,z)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(T,x),x4) -> AND(x,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Usable Equations:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> Usable Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[and](X1,X2) = X1.X2 + X1 + X2
[equiv](X1,X2) = 0
[impl](X1,X2) = 0
[neg](X) = 1
[or](X1,X2) = 0
[xor](X1,X2) = X1 + X2 + 1
[F] = 1
[T] = 1
[fSNonEmpty] = 0
[AND](X1,X2) = X1.X2 + X1 + X2
[EQUIV](X1,X2) = 0
[IMPL](X1,X2) = 0
[NEG](X) = 0
[OR](X1,X2) = 0
[XOR](X1,X2) = 0

Problem 1.2: 

SCC Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(xor(x,y),z),x4) -> AND(y,z)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(T,x),x4) -> AND(x,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(xor(x,y),z),x4) -> AND(y,z)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(T,x),x4) -> AND(x,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
-> FAxioms:
 and(and(x4,x5),x6) -> and(x4,and(x5,x6))
 and(x4,x5) -> and(x5,x4)
 or(or(x4,x5),x6) -> or(x4,or(x5,x6))
 or(x4,x5) -> or(x5,x4)
 xor(xor(x4,x5),x6) -> xor(x4,xor(x5,x6))
 xor(x4,x5) -> xor(x5,x4)
 AND(and(x4,x5),x6) -> AND(x4,and(x5,x6))
 AND(x4,x5) -> AND(x5,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
->->-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)

Problem 1.2: 

Reduction Pairs Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(xor(x,y),z),x4) -> AND(y,z)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(T,x),x4) -> AND(x,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Usable Equations:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> Usable Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[and](X1,X2) = X1.X2 + X1 + X2
[equiv](X1,X2) = 0
[impl](X1,X2) = 0
[neg](X) = 1
[or](X1,X2) = 0
[xor](X1,X2) = X1 + X2 + 1
[F] = 1
[T] = 1
[fSNonEmpty] = 0
[AND](X1,X2) = X1.X2 + X1 + X2
[EQUIV](X1,X2) = 0
[IMPL](X1,X2) = 0
[NEG](X) = 0
[OR](X1,X2) = 0
[XOR](X1,X2) = 0

Problem 1.2: 

SCC Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(T,x),x4) -> AND(x,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(T,x),x4) -> AND(x,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
-> FAxioms:
 and(and(x4,x5),x6) -> and(x4,and(x5,x6))
 and(x4,x5) -> and(x5,x4)
 or(or(x4,x5),x6) -> or(x4,or(x5,x6))
 or(x4,x5) -> or(x5,x4)
 xor(xor(x4,x5),x6) -> xor(x4,xor(x5,x6))
 xor(x4,x5) -> xor(x5,x4)
 AND(and(x4,x5),x6) -> AND(x4,and(x5,x6))
 AND(x4,x5) -> AND(x5,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
->->-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)

Problem 1.2: 

Reduction Pairs Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(T,x),x4) -> AND(x,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Usable Equations:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> Usable Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[and](X1,X2) = X1.X2 + X1 + X2
[equiv](X1,X2) = 0
[impl](X1,X2) = 0
[neg](X) = 1
[or](X1,X2) = 0
[xor](X1,X2) = X1 + X2 + 1
[F] = 1
[T] = 1
[fSNonEmpty] = 0
[AND](X1,X2) = X1.X2 + X1 + X2
[EQUIV](X1,X2) = 0
[IMPL](X1,X2) = 0
[NEG](X) = 0
[OR](X1,X2) = 0
[XOR](X1,X2) = 0

Problem 1.2: 

SCC Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
-> FAxioms:
 and(and(x4,x5),x6) -> and(x4,and(x5,x6))
 and(x4,x5) -> and(x5,x4)
 or(or(x4,x5),x6) -> or(x4,or(x5,x6))
 or(x4,x5) -> or(x5,x4)
 xor(xor(x4,x5),x6) -> xor(x4,xor(x5,x6))
 xor(x4,x5) -> xor(x5,x4)
 AND(and(x4,x5),x6) -> AND(x4,and(x5,x6))
 AND(x4,x5) -> AND(x5,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
->->-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)

Problem 1.2: 

Reduction Pairs Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(x,z)
 AND(xor(x,y),z) -> AND(y,z)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Usable Equations:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> Usable Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[and](X1,X2) = X1.X2 + X1 + X2
[equiv](X1,X2) = 0
[impl](X1,X2) = 0
[neg](X) = 1
[or](X1,X2) = 0
[xor](X1,X2) = X1 + X2 + 1
[F] = 1
[T] = 1
[fSNonEmpty] = 0
[AND](X1,X2) = X1.X2 + X1 + X2
[EQUIV](X1,X2) = 0
[IMPL](X1,X2) = 0
[NEG](X) = 0
[OR](X1,X2) = 0
[XOR](X1,X2) = 0

Problem 1.2: 

SCC Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(y,z)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(y,z)
-> FAxioms:
 and(and(x4,x5),x6) -> and(x4,and(x5,x6))
 and(x4,x5) -> and(x5,x4)
 or(or(x4,x5),x6) -> or(x4,or(x5,x6))
 or(x4,x5) -> or(x5,x4)
 xor(xor(x4,x5),x6) -> xor(x4,xor(x5,x6))
 xor(x4,x5) -> xor(x5,x4)
 AND(and(x4,x5),x6) -> AND(x4,and(x5,x6))
 AND(x4,x5) -> AND(x5,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
->->-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)

Problem 1.2: 

Reduction Pairs Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(x,x),x4) -> AND(x,x4)
 AND(xor(x,y),z) -> AND(y,z)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Usable Equations:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> Usable Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[and](X1,X2) = X1.X2 + X1 + X2
[equiv](X1,X2) = 0
[impl](X1,X2) = 0
[neg](X) = 1
[or](X1,X2) = 0
[xor](X1,X2) = X1 + X2 + 1
[F] = 1
[T] = 1
[fSNonEmpty] = 0
[AND](X1,X2) = X1.X2 + X1 + X2
[EQUIV](X1,X2) = 0
[IMPL](X1,X2) = 0
[NEG](X) = 0
[OR](X1,X2) = 0
[XOR](X1,X2) = 0

Problem 1.2: 

SCC Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(x,x),x4) -> AND(x,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(x,x),x4) -> AND(x,x4)
-> FAxioms:
 and(and(x4,x5),x6) -> and(x4,and(x5,x6))
 and(x4,x5) -> and(x5,x4)
 or(or(x4,x5),x6) -> or(x4,or(x5,x6))
 or(x4,x5) -> or(x5,x4)
 xor(xor(x4,x5),x6) -> xor(x4,xor(x5,x6))
 xor(x4,x5) -> xor(x5,x4)
 AND(and(x4,x5),x6) -> AND(x4,and(x5,x6))
 AND(x4,x5) -> AND(x5,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
->->-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)

Problem 1.2: 

Reduction Pairs Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(xor(x,y),z),x4) -> AND(xor(and(x,z),and(y,z)),x4)
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(x,x),x4) -> AND(x,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Usable Equations:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> Usable Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 3
->Interpretation:
 
[and](X1,X2) = 3/2.X1.X2 + 3/2.X1 + 3/2.X2 + 1/2
[equiv](X1,X2) = 0
[impl](X1,X2) = 0
[neg](X) = 1/2
[or](X1,X2) = 0
[xor](X1,X2) = X1 + X2 + 3
[F] = 0
[T] = 2/3
[fSNonEmpty] = 0
[AND](X1,X2) = 1/2.X1.X2 + 1/2.X1 + 1/2.X2
[EQUIV](X1,X2) = 0
[IMPL](X1,X2) = 0
[NEG](X) = 0
[OR](X1,X2) = 0
[XOR](X1,X2) = 0

Problem 1.2: 

SCC Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(x,x),x4) -> AND(x,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(x,x),x4) -> AND(x,x4)
-> FAxioms:
 and(and(x4,x5),x6) -> and(x4,and(x5,x6))
 and(x4,x5) -> and(x5,x4)
 or(or(x4,x5),x6) -> or(x4,or(x5,x6))
 or(x4,x5) -> or(x5,x4)
 xor(xor(x4,x5),x6) -> xor(x4,xor(x5,x6))
 xor(x4,x5) -> xor(x5,x4)
 AND(and(x4,x5),x6) -> AND(x4,and(x5,x6))
 AND(x4,x5) -> AND(x5,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
->->-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)

Problem 1.2: 

Reduction Pairs Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(F,x),x4) -> AND(F,x4)
 AND(and(x,x),x4) -> AND(x,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Usable Equations:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> Usable Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 3
->Interpretation:
 
[and](X1,X2) = 3.X1.X2 + 3.X1 + 3.X2 + 2
[equiv](X1,X2) = 0
[impl](X1,X2) = 0
[neg](X) = 1/3
[or](X1,X2) = 0
[xor](X1,X2) = X1 + X2 + 3/2
[F] = 1/2
[T] = 3/2
[fSNonEmpty] = 0
[AND](X1,X2) = 1/2.X1.X2 + 1/2.X1 + 1/2.X2
[EQUIV](X1,X2) = 0
[IMPL](X1,X2) = 0
[NEG](X) = 0
[OR](X1,X2) = 0
[XOR](X1,X2) = 0

Problem 1.2: 

SCC Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(x,x),x4) -> AND(x,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(and(x,x),x4) -> AND(x,x4)
-> FAxioms:
 and(and(x4,x5),x6) -> and(x4,and(x5,x6))
 and(x4,x5) -> and(x5,x4)
 or(or(x4,x5),x6) -> or(x4,or(x5,x6))
 or(x4,x5) -> or(x5,x4)
 xor(xor(x4,x5),x6) -> xor(x4,xor(x5,x6))
 xor(x4,x5) -> xor(x5,x4)
 AND(and(x4,x5),x6) -> AND(x4,and(x5,x6))
 AND(x4,x5) -> AND(x5,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
->->-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)

Problem 1.2: 

Reduction Pairs Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 AND(and(x,x),x4) -> AND(x,x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Usable Equations:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> Usable Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 3
->Interpretation:
 
[and](X1,X2) = 3.X1.X2 + 3.X1 + 3.X2 + 2
[equiv](X1,X2) = 0
[impl](X1,X2) = 0
[neg](X) = 2
[or](X1,X2) = 0
[xor](X1,X2) = X1 + X2 + 1
[F] = 0
[T] = 3/2
[fSNonEmpty] = 0
[AND](X1,X2) = 1/2.X1.X2 + 1/2.X1 + 1/2.X2
[EQUIV](X1,X2) = 0
[IMPL](X1,X2) = 0
[NEG](X) = 0
[OR](X1,X2) = 0
[XOR](X1,X2) = 0

Problem 1.2: 

SCC Processor:
-> FAxioms:
 AND(and(x4,x5),x6) = AND(x4,and(x5,x6))
 AND(x4,x5) = AND(x5,x4)
-> Pairs:
 Empty
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 AND(and(x4,x5),x6) -> AND(x4,x5)
 AND(x4,and(x5,x6)) -> AND(x5,x6)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 OR(or(x4,x5),x6) = OR(x4,or(x5,x6))
 OR(x4,x5) = OR(x5,x4)
-> Pairs:
 OR(or(x,y),x4) -> OR(xor(and(x,y),xor(x,y)),x4)
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Usable Equations:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> Usable Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 OR(or(x4,x5),x6) -> OR(x4,x5)
 OR(x4,or(x5,x6)) -> OR(x5,x6)
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 3
->Interpretation:
 
[and](X1,X2) = X1.X2 + X1 + X2
[equiv](X1,X2) = 0
[impl](X1,X2) = 0
[neg](X) = 1/2
[or](X1,X2) = 2.X1.X2 + 3.X1 + 3.X2 + 3
[xor](X1,X2) = X1 + X2 + 1
[F] = 0
[T] = 3/2
[fSNonEmpty] = 0
[AND](X1,X2) = 0
[EQUIV](X1,X2) = 0
[IMPL](X1,X2) = 0
[NEG](X) = 0
[OR](X1,X2) = X1.X2 + 3/2.X1 + 3/2.X2
[XOR](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 OR(or(x4,x5),x6) = OR(x4,or(x5,x6))
 OR(x4,x5) = OR(x5,x4)
-> Pairs:
 Empty
-> EAxioms:
 and(and(x4,x5),x6) = and(x4,and(x5,x6))
 and(x4,x5) = and(x5,x4)
 or(or(x4,x5),x6) = or(x4,or(x5,x6))
 or(x4,x5) = or(x5,x4)
 xor(xor(x4,x5),x6) = xor(x4,xor(x5,x6))
 xor(x4,x5) = xor(x5,x4)
-> Rules:
 and(xor(x,y),z) -> xor(and(x,z),and(y,z))
 and(F,x) -> F
 and(T,x) -> x
 and(x,x) -> x
 equiv(x,y) -> xor(xor(T,y),x)
 impl(x,y) -> xor(and(x,y),xor(T,x))
 neg(x) -> xor(T,x)
 or(x,y) -> xor(and(x,y),xor(x,y))
 xor(neg(x),x) -> F
 xor(F,x) -> x
 xor(x,x) -> F
-> SRules:
 OR(or(x4,x5),x6) -> OR(x4,x5)
 OR(x4,or(x5,x6)) -> OR(x5,x6)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
