YES

Problem 1: 

(VAR vu95NonEmpty t x y z)
(THEORY 
(AC app plus))
(RULES
app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
app(x,app(empty,z)) -> app(empty,z)
app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
app(x,empty) -> empty
eq(num0,num0) -> ftrue
eq(num0,s(x)) -> ffalse
eq(s(x),s(y)) -> eq(x,y)
if(ffalse,x,y) -> y
if(ftrue,x,y) -> x
plus(empty,x) -> x
)


Problem 1: 

Dependency Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
 PLUS(plus(x5,x6),x7) = PLUS(x5,plus(x6,x7))
 PLUS(x5,x6) = PLUS(x6,x5)
-> Pairs:
 APP(app(singl(x),singl(y)),x5) -> APP(if(eq(x,y),singl(x),empty),x5)
 APP(app(singl(x),singl(y)),x5) -> EQ(x,y)
 APP(app(singl(x),singl(y)),x5) -> IF(eq(x,y),singl(x),empty)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,y)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,z)
 APP(app(x,app(plus(y,z),t)),x5) -> PLUS(app(x,y),app(x,z))
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,plus(y,z)),x5) -> PLUS(app(x,y),app(x,z))
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(singl(x),singl(y)) -> EQ(x,y)
 APP(singl(x),singl(y)) -> IF(eq(x,y),singl(x),empty)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,app(plus(y,z),t)) -> PLUS(app(x,y),app(x,z))
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
 APP(x,plus(y,z)) -> PLUS(app(x,y),app(x,z))
 EQ(s(x),s(y)) -> EQ(x,y)
 PLUS(plus(empty,x),x5) -> PLUS(x,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
 PLUS(plus(x5,x6),x7) -> PLUS(x5,x6)
 PLUS(x5,plus(x6,x7)) -> PLUS(x6,x7)

Problem 1: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
 PLUS(plus(x5,x6),x7) = PLUS(x5,plus(x6,x7))
 PLUS(x5,x6) = PLUS(x6,x5)
-> Pairs:
 APP(app(singl(x),singl(y)),x5) -> APP(if(eq(x,y),singl(x),empty),x5)
 APP(app(singl(x),singl(y)),x5) -> EQ(x,y)
 APP(app(singl(x),singl(y)),x5) -> IF(eq(x,y),singl(x),empty)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,y)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,z)
 APP(app(x,app(plus(y,z),t)),x5) -> PLUS(app(x,y),app(x,z))
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,plus(y,z)),x5) -> PLUS(app(x,y),app(x,z))
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(singl(x),singl(y)) -> EQ(x,y)
 APP(singl(x),singl(y)) -> IF(eq(x,y),singl(x),empty)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,app(plus(y,z),t)) -> PLUS(app(x,y),app(x,z))
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
 APP(x,plus(y,z)) -> PLUS(app(x,y),app(x,z))
 EQ(s(x),s(y)) -> EQ(x,y)
 PLUS(plus(empty,x),x5) -> PLUS(x,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
 PLUS(plus(x5,x6),x7) -> PLUS(x5,x6)
 PLUS(x5,plus(x6,x7)) -> PLUS(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 PLUS(plus(empty,x),x5) -> PLUS(x,x5)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 PLUS(plus(x5,x6),x7) -> PLUS(x5,plus(x6,x7))
 PLUS(x5,x6) -> PLUS(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 PLUS(plus(x5,x6),x7) -> PLUS(x5,x6)
 PLUS(x5,plus(x6,x7)) -> PLUS(x6,x7)
->->Cycle:
->->-> Pairs:
 EQ(s(x),s(y)) -> EQ(x,y)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 Empty
->->Cycle:
->->-> Pairs:
 APP(app(singl(x),singl(y)),x5) -> APP(if(eq(x,y),singl(x),empty),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,y)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,z)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)


The problem is decomposed in 3 subproblems.

Problem 1.1: 

Reduction Pairs Processor:
-> FAxioms:
 PLUS(plus(x5,x6),x7) = PLUS(x5,plus(x6,x7))
 PLUS(x5,x6) = PLUS(x6,x5)
-> Pairs:
 PLUS(plus(empty,x),x5) -> PLUS(x,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 plus(empty,x) -> x
-> SRules:
 PLUS(plus(x5,x6),x7) -> PLUS(x5,x6)
 PLUS(x5,plus(x6,x7)) -> PLUS(x6,x7)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[app](X1,X2) = 0
[eq](X1,X2) = 0
[if](X1,X2,X3) = 0
[plus](X1,X2) = X1 + X2
[num0] = 0
[empty] = 2
[fSNonEmpty] = 0
[ffalse] = 0
[s](X) = 0
[singl](X) = 0
[ftrue] = 0
[APP](X1,X2) = 0
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 2.X1 + 2.X2

Problem 1.1: 

SCC Processor:
-> FAxioms:
 PLUS(plus(x5,x6),x7) = PLUS(x5,plus(x6,x7))
 PLUS(x5,x6) = PLUS(x6,x5)
-> Pairs:
 Empty
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 PLUS(plus(x5,x6),x7) -> PLUS(x5,x6)
 PLUS(x5,plus(x6,x7)) -> PLUS(x6,x7)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Subterm Processor:
-> FAxioms:
 Empty
-> Pairs:
 EQ(s(x),s(y)) -> EQ(x,y)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 Empty
->Projection:
 pi(EQ) = [1]

Problem 1.2: 

SCC Processor:
-> FAxioms:
 Empty
-> Pairs:
 Empty
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 Empty
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(singl(x),singl(y)),x5) -> APP(if(eq(x,y),singl(x),empty),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,y)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,z)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[app](X1,X2) = X1.X2 + X1 + X2
[eq](X1,X2) = X1.X2 + X1 + 1
[if](X1,X2,X3) = X2.X3 + X1 + X2 + X3
[plus](X1,X2) = X1 + X2 + 1
[num0] = 0
[empty] = 0
[fSNonEmpty] = 0
[ffalse] = 1
[s](X) = X
[singl](X) = X + 1
[ftrue] = 1
[APP](X1,X2) = X1.X2 + X1 + X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,y)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,z)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,y)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,z)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,y)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,z)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[app](X1,X2) = X1.X2 + X1 + X2
[eq](X1,X2) = X1.X2 + X1 + X2 + 1
[if](X1,X2,X3) = X1.X3 + X2 + 1
[plus](X1,X2) = X1 + X2 + 1
[num0] = 0
[empty] = 1
[fSNonEmpty] = 0
[ffalse] = 1
[s](X) = X + 1
[singl](X) = X.X + X + 1
[ftrue] = 0
[APP](X1,X2) = X1.X2 + X1 + X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,z)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,z)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(x,z)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[app](X1,X2) = X1.X2 + X1 + X2
[eq](X1,X2) = X1.X2 + X2
[if](X1,X2,X3) = X1.X3 + X2
[plus](X1,X2) = X1 + X2 + 1
[num0] = 1
[empty] = 1
[fSNonEmpty] = 0
[ffalse] = 1
[s](X) = X + 1
[singl](X) = X.X + X
[ftrue] = 1
[APP](X1,X2) = X1.X2 + X1 + X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,y)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[app](X1,X2) = X1.X2 + X1 + X2
[eq](X1,X2) = X2 + 1
[if](X1,X2,X3) = X1.X2 + X1.X3 + X2.X3 + X1 + X2
[plus](X1,X2) = X1 + X2 + 1
[num0] = 1
[empty] = 0
[fSNonEmpty] = 0
[ffalse] = 1
[s](X) = X + 1
[singl](X) = X + 1
[ftrue] = 1
[APP](X1,X2) = X1.X2 + X1 + X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,plus(y,z)),x5) -> APP(x,z)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[app](X1,X2) = X1.X2 + X1 + X2
[eq](X1,X2) = X1.X2 + X1 + X2 + 1
[if](X1,X2,X3) = X1.X3 + X2 + 1
[plus](X1,X2) = X1 + X2 + 1
[num0] = 1
[empty] = 1
[fSNonEmpty] = 0
[ffalse] = 1
[s](X) = X
[singl](X) = X.X + X + 1
[ftrue] = 1
[APP](X1,X2) = X1.X2 + X1 + X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,y)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[app](X1,X2) = X1.X2 + X1 + X2
[eq](X1,X2) = X1.X2 + X2
[if](X1,X2,X3) = X1.X3 + X2
[plus](X1,X2) = X1 + X2 + 1
[num0] = 0
[empty] = 1
[fSNonEmpty] = 0
[ffalse] = 1
[s](X) = X + 1
[singl](X) = X.X + X
[ftrue] = 0
[APP](X1,X2) = X1.X2 + X1 + X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,app(plus(y,z),t)) -> APP(x,z)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[app](X1,X2) = X1.X2 + X1 + X2
[eq](X1,X2) = X1.X2 + X1 + X2 + 1
[if](X1,X2,X3) = X1.X3 + X2 + X3
[plus](X1,X2) = X1 + X2 + 1
[num0] = 1
[empty] = 1
[fSNonEmpty] = 0
[ffalse] = 1
[s](X) = X + 1
[singl](X) = X.X + X + 1
[ftrue] = 1
[APP](X1,X2) = X1.X2 + X1 + X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,plus(y,z)) -> APP(x,y)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[app](X1,X2) = X1.X2 + X1 + X2
[eq](X1,X2) = X2
[if](X1,X2,X3) = X1.X2 + X2.X3 + X1 + X2 + X3
[plus](X1,X2) = X1 + X2 + 1
[num0] = 1
[empty] = 1
[fSNonEmpty] = 0
[ffalse] = 1
[s](X) = X + 1
[singl](X) = X.X + X + 1
[ftrue] = 1
[APP](X1,X2) = X1.X2 + X1 + X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,plus(y,z)) -> APP(x,z)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
 APP(x,plus(y,z)) -> APP(x,z)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 1
->Interpretation:
 
[app](X1,X2) = X1.X2 + X1 + X2
[eq](X1,X2) = X1.X2 + X2
[if](X1,X2,X3) = X1.X3 + X2
[plus](X1,X2) = X1 + X2 + 1
[num0] = 1
[empty] = 1
[fSNonEmpty] = 0
[ffalse] = 1
[s](X) = X + 1
[singl](X) = X.X + X
[ftrue] = 1
[APP](X1,X2) = X1.X2 + X1 + X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(app(plus(app(x,y),app(x,z)),t),x5)
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 3
->Interpretation:
 
[app](X1,X2) = 3/2.X1.X2 + 3/2.X1 + 3/2.X2 + 1/2
[eq](X1,X2) = X2 + 2/3
[if](X1,X2,X3) = 2.X1.X2 + 1/3.X1.X3 + 3/2.X2.X3 + 3/2.X1 + 2/3.X2 + 2/3.X3 + 1
[plus](X1,X2) = X1 + X2 + 2
[num0] = 3
[empty] = 0
[fSNonEmpty] = 0
[ffalse] = 3/2
[s](X) = 3/2.X + 3
[singl](X) = 3.X + 3
[ftrue] = 3
[APP](X1,X2) = 1/2.X1.X2 + 1/2.X1 + 1/2.X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(plus(y,z),t)),x5) -> APP(plus(app(x,y),app(x,z)),t)
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 3
->Interpretation:
 
[app](X1,X2) = X1.X2 + 2.X1 + 2.X2 + 2
[eq](X1,X2) = 2
[if](X1,X2,X3) = 3/2.X1.X2.X3 + 3.X1.X2 + 1/2.X1.X3 + 3.X2.X3 + X1 + 1/3.X2 + 1/2.X3
[plus](X1,X2) = X1 + X2 + 2
[num0] = 1
[empty] = 0
[fSNonEmpty] = 0
[ffalse] = 2
[s](X) = X
[singl](X) = 0
[ftrue] = 1
[APP](X1,X2) = 1/2.X1.X2 + X1 + X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,app(empty,z)),x5) -> APP(app(empty,z),x5)
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 3
->Interpretation:
 
[app](X1,X2) = X1.X2 + 2.X1 + 2.X2 + 2
[eq](X1,X2) = 3
[if](X1,X2,X3) = 2/3.X1.X3 + 1/3.X1 + 3/2.X2 + 2.X3 + 3
[plus](X1,X2) = X1 + X2 + 3
[num0] = 2/3
[empty] = 2/3
[fSNonEmpty] = 0
[ffalse] = 3/2
[s](X) = 0
[singl](X) = 3
[ftrue] = 2
[APP](X1,X2) = 1/3.X1.X2 + 2/3.X1 + 2/3.X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,plus(y,z)),x5) -> APP(plus(app(x,y),app(x,z)),x5)
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 3
->Interpretation:
 
[app](X1,X2) = 2.X1.X2 + 2.X1 + 2.X2 + 1
[eq](X1,X2) = 3/2.X2 + 1
[if](X1,X2,X3) = 1/3.X1.X2 + X2.X3 + 1/2.X1 + 3.X2 + 3.X3 + 1
[plus](X1,X2) = X1 + X2 + 3
[num0] = 1/3
[empty] = 0
[fSNonEmpty] = 0
[ffalse] = 1
[s](X) = 3/2.X
[singl](X) = 3.X + 3/2
[ftrue] = 1/3
[APP](X1,X2) = 1/3.X1.X2 + 1/3.X1 + 1/3.X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(app(x,empty),x5) -> APP(empty,x5)
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 3
->Interpretation:
 
[app](X1,X2) = 2.X1.X2 + 3.X1 + 3.X2 + 3
[eq](X1,X2) = 3.X1.X2 + 3/2.X2 + 2
[if](X1,X2,X3) = 3.X1.X3 + 2.X2
[plus](X1,X2) = X1 + X2 + 2
[num0] = 0
[empty] = 3/2
[fSNonEmpty] = 0
[ffalse] = 1
[s](X) = 3.X
[singl](X) = 3.X + 3
[ftrue] = 0
[APP](X1,X2) = 2.X1.X2 + 3.X1 + 3.X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(app(x5,x6),x7) -> APP(x5,x6)
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 3
->Interpretation:
 
[app](X1,X2) = 3.X1.X2 + 3.X1 + 3.X2 + 2
[eq](X1,X2) = 3/2.X1 + 3/2.X2 + 1
[if](X1,X2,X3) = X1.X2.X3 + X1.X3 + 3/2.X2.X3 + 1/3.X1 + X2 + 2.X3 + 1/2
[plus](X1,X2) = X1 + X2 + 2
[num0] = 3
[empty] = 0
[fSNonEmpty] = 0
[ffalse] = 1/3
[s](X) = 2.X + 3/2
[singl](X) = 3/2.X.X + 2.X + 3
[ftrue] = 1/2
[APP](X1,X2) = 2/3.X1.X2 + 2/3.X1 + 2/3.X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> FAxioms:
 app(app(x5,x6),x7) -> app(x5,app(x6,x7))
 app(x5,x6) -> app(x6,x5)
 plus(plus(x5,x6),x7) -> plus(x5,plus(x6,x7))
 plus(x5,x6) -> plus(x6,x5)
 APP(app(x5,x6),x7) -> APP(x5,app(x6,x7))
 APP(x5,x6) -> APP(x6,x5)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
->->-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(x5,app(x6,x7)) -> APP(x6,x7)

Problem 1.3: 

Reduction Pairs Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 APP(x,app(plus(y,z),t)) -> APP(plus(app(x,y),app(x,z)),t)
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Usable Equations:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> Usable Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 3
->Interpretation:
 
[app](X1,X2) = 3.X1.X2 + 3.X1 + 3.X2 + 2
[eq](X1,X2) = 1/2.X1.X2 + 1/3.X1 + 3.X2 + 1/3
[if](X1,X2,X3) = 3/2.X2 + X3
[plus](X1,X2) = X1 + X2 + 2
[num0] = 2
[empty] = 2
[fSNonEmpty] = 0
[ffalse] = 1/3
[s](X) = 3/2.X + 3/2
[singl](X) = 1/3.X.X + 1/3.X
[ftrue] = 0
[APP](X1,X2) = 3.X1.X2 + 3.X1 + 3.X2
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[PLUS](X1,X2) = 0

Problem 1.3: 

SCC Processor:
-> FAxioms:
 APP(app(x5,x6),x7) = APP(x5,app(x6,x7))
 APP(x5,x6) = APP(x6,x5)
-> Pairs:
 Empty
-> EAxioms:
 app(app(x5,x6),x7) = app(x5,app(x6,x7))
 app(x5,x6) = app(x6,x5)
 plus(plus(x5,x6),x7) = plus(x5,plus(x6,x7))
 plus(x5,x6) = plus(x6,x5)
-> Rules:
 app(singl(x),singl(y)) -> if(eq(x,y),singl(x),empty)
 app(x,app(plus(y,z),t)) -> app(plus(app(x,y),app(x,z)),t)
 app(x,app(empty,z)) -> app(empty,z)
 app(x,plus(y,z)) -> plus(app(x,y),app(x,z))
 app(x,empty) -> empty
 eq(num0,num0) -> ftrue
 eq(num0,s(x)) -> ffalse
 eq(s(x),s(y)) -> eq(x,y)
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 plus(empty,x) -> x
-> SRules:
 APP(x5,app(x6,x7)) -> APP(x6,x7)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
