MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/qcpVx.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given ETRS could not be shown:

(0) ETRS
(1) EquationalDependencyPairsProof [EQUIVALENT, 171 ms]
(2) EDP
(3) EDependencyGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) EDP
        (6) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (7) EDP
        (8) EUsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (9) EDP
        (10) PisEmptyProof [EQUIVALENT, 0 ms]
        (11) YES
    (12) EDP
        (13) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (14) EDP
        (15) EUsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (16) EDP
        (17) PisEmptyProof [EQUIVALENT, 0 ms]
        (18) YES
    (19) EDP
        (20) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (21) EDP
        (22) EUsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (23) EDP
        (24) PisEmptyProof [EQUIVALENT, 0 ms]
        (25) YES
    (26) EDP
        (27) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (28) EDP
        (29) EUsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (30) EDP
        (31) PisEmptyProof [EQUIVALENT, 0 ms]
        (32) YES
    (33) EDP
        (34) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (35) EDP
        (36) EUsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (37) EDP
        (38) PisEmptyProof [EQUIVALENT, 0 ms]
        (39) YES
    (40) EDP
        (41) ESharpUsableEquationsProof [EQUIVALENT, 82 ms]
        (42) EDP
        (43) EUsableRulesReductionPairsProof [EQUIVALENT, 63 ms]
        (44) EDP
        (45) ERuleRemovalProof [EQUIVALENT, 0 ms]
        (46) EDP
        (47) EDPPoloProof [EQUIVALENT, 0 ms]
        (48) EDP
        (49) PisEmptyProof [EQUIVALENT, 0 ms]
        (50) YES
    (51) EDP
        (52) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (53) EDP
        (54) EUsableRulesProof [EQUIVALENT, 0 ms]
        (55) EDP
    (56) EDP


----------------------------------------

(0)
Obligation:
Equational rewrite system:
The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))


----------------------------------------

(1) EquationalDependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,DA_STEIN] we result in the following initial EDP problem:
The TRS P consists of the following rules:

   +^1(0(x), 0(y)) -> 0^1(+(x, y))
   +^1(0(x), 0(y)) -> +^1(x, y)
   +^1(0(x), 1(y)) -> +^1(x, y)
   +^1(0(x), j(y)) -> +^1(x, y)
   +^1(1(x), 1(y)) -> +^1(1(#), +(x, y))
   +^1(1(x), 1(y)) -> +^1(x, y)
   +^1(j(x), j(y)) -> +^1(j(#), +(x, y))
   +^1(j(x), j(y)) -> +^1(x, y)
   +^1(1(x), j(y)) -> 0^1(+(x, y))
   +^1(1(x), j(y)) -> +^1(x, y)
   OPP(0(x)) -> 0^1(opp(x))
   OPP(0(x)) -> OPP(x)
   OPP(1(x)) -> OPP(x)
   OPP(j(x)) -> OPP(x)
   -^1(x, y) -> +^1(opp(y), x)
   -^1(x, y) -> OPP(y)
   *^1(0(x), y) -> 0^1(*(x, y))
   *^1(0(x), y) -> *^1(x, y)
   *^1(1(x), y) -> +^1(0(*(x, y)), y)
   *^1(1(x), y) -> 0^1(*(x, y))
   *^1(1(x), y) -> *^1(x, y)
   *^1(j(x), y) -> -^1(0(*(x, y)), y)
   *^1(j(x), y) -> 0^1(*(x, y))
   *^1(j(x), y) -> *^1(x, y)
   ABS(x) -> TEST_ABS_POS(x, x)
   TEST_ABS_POS(0(x), y) -> TEST_ABS_POS(x, y)
   TEST_ABS_POS(1(x), y) -> TEST_ABS_POS(x, y)
   TEST_ABS_POS(j(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_NEG(#, x) -> OPP(x)
   TEST_ABS_NEG(0(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_NEG(1(x), y) -> TEST_ABS_POS(x, y)
   TEST_ABS_NEG(j(x), y) -> TEST_ABS_NEG(x, y)
   SIGNE(0(x)) -> SIGNE(x)
   SIGNE(1(x)) -> TEST_SIGNE_POS(x)
   SIGNE(j(x)) -> TEST_SIGNE_NEG(x)
   TEST_SIGNE_POS(0(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_POS(1(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_POS(j(x)) -> TEST_SIGNE_NEG(x)
   TEST_SIGNE_NEG(0(x)) -> TEST_SIGNE_NEG(x)
   TEST_SIGNE_NEG(1(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_NEG(j(x)) -> TEST_SIGNE_NEG(x)
   MIN(x, y) -> TEST_MIN_POS(-(abs(y), abs(x)), x, y)
   MIN(x, y) -> -^1(abs(y), abs(x))
   MIN(x, y) -> ABS(y)
   MIN(x, y) -> ABS(x)
   MIN'(x, y) -> TEST_MIN_POS(-(abs(1(y)), abs(1(x))), x, y)
   MIN'(x, y) -> -^1(abs(1(y)), abs(1(x)))
   MIN'(x, y) -> ABS(1(y))
   MIN'(x, y) -> ABS(1(x))
   MIN''(x, y) -> TEST_MIN_POS(-(abs(j(y)), abs(j(x))), x, y)
   MIN''(x, y) -> -^1(abs(j(y)), abs(j(x)))
   MIN''(x, y) -> ABS(j(y))
   MIN''(x, y) -> ABS(j(x))
   TEST_MIN_POS(0(x), y, z) -> TEST_MIN_POS(x, y, z)
   TEST_MIN_POS(1(x), y, z) -> TEST_MIN_POS(x, y, z)
   TEST_MIN_POS(j(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_NEG(0(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_NEG(1(x), y, z) -> TEST_MIN_POS(x, y, z)
   TEST_MIN_NEG(j(x), y, z) -> TEST_MIN_NEG(x, y, z)
   F(x, #) -> SIGNE(x)
   F(0(x), 0(y)) -> F(x, y)
   F(0(x), 1(y)) -> 0^1(f(x, 1(y)))
   F(0(x), 1(y)) -> F(x, 1(y))
   F(0(x), j(y)) -> 0^1(f(x, j(y)))
   F(0(x), j(y)) -> F(x, j(y))
   F(1(x), 0(y)) -> F(1(x), y)
   F(1(x), 1(y)) -> +^1(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   F(1(x), 1(y)) -> 0^1(f(-(x, min'(x, y)), 1(y)))
   F(1(x), 1(y)) -> F(-(x, min'(x, y)), 1(y))
   F(1(x), 1(y)) -> -^1(x, min'(x, y))
   F(1(x), 1(y)) -> MIN'(x, y)
   F(1(x), 1(y)) -> F(min(1(x), 1(y)), -(x, y))
   F(1(x), 1(y)) -> MIN(1(x), 1(y))
   F(1(x), 1(y)) -> -^1(x, y)
   F(1(x), j(y)) -> +^1(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   F(1(x), j(y)) -> 0^1(f(+(min''(opp(x), y), x), j(y)))
   F(1(x), j(y)) -> F(+(min''(opp(x), y), x), j(y))
   F(1(x), j(y)) -> +^1(min''(opp(x), y), x)
   F(1(x), j(y)) -> MIN''(opp(x), y)
   F(1(x), j(y)) -> OPP(x)
   F(1(x), j(y)) -> F(min(1(x), 1(opp(y))), +(x, y))
   F(1(x), j(y)) -> MIN(1(x), 1(opp(y)))
   F(1(x), j(y)) -> OPP(y)
   F(1(x), j(y)) -> +^1(x, y)
   F(j(x), 0(y)) -> F(j(x), y)
   F(j(x), 1(y)) -> +^1(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   F(j(x), 1(y)) -> 0^1(f(+(min'(opp(x), y), x), 1(y)))
   F(j(x), 1(y)) -> F(+(min'(opp(x), y), x), 1(y))
   F(j(x), 1(y)) -> +^1(min'(opp(x), y), x)
   F(j(x), 1(y)) -> MIN'(opp(x), y)
   F(j(x), 1(y)) -> OPP(x)
   F(j(x), 1(y)) -> F(min(j(x), j(opp(y))), +(x, y))
   F(j(x), 1(y)) -> MIN(j(x), j(opp(y)))
   F(j(x), 1(y)) -> OPP(y)
   F(j(x), 1(y)) -> +^1(x, y)
   F(j(x), j(y)) -> +^1(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   F(j(x), j(y)) -> 0^1(f(-(x, min''(x, y)), j(y)))
   F(j(x), j(y)) -> F(-(x, min''(x, y)), j(y))
   F(j(x), j(y)) -> -^1(x, min''(x, y))
   F(j(x), j(y)) -> MIN''(x, y)
   F(j(x), j(y)) -> F(min(j(x), j(y)), -(x, y))
   F(j(x), j(y)) -> MIN(j(x), j(y))
   F(j(x), j(y)) -> -^1(x, y)
   RAT(x, y) -> *^1(signe(y), f(x, y))
   RAT(x, y) -> SIGNE(y)
   RAT(x, y) -> F(x, y)
   RAT(x, y) -> *^1(signe(y), f(y, x))
   RAT(x, y) -> F(y, x)
   +_Q^1(irred(x, y), irred(u, v)) -> +^1(*(x, v), *(y, u))
   +_Q^1(irred(x, y), irred(u, v)) -> *^1(x, v)
   +_Q^1(irred(x, y), irred(u, v)) -> *^1(y, u)
   +_Q^1(irred(x, y), irred(u, v)) -> *^1(y, v)
   *_Q^1(irred(x, y), irred(u, v)) -> RAT(*(x, u), *(y, v))
   *_Q^1(irred(x, y), irred(u, v)) -> *^1(x, u)
   *_Q^1(irred(x, y), irred(u, v)) -> *^1(y, v)
   *^1(*(#, x), ext) -> *^1(#, ext)
   *^1(*(0(x), y), ext) -> *^1(0(*(x, y)), ext)
   *^1(*(0(x), y), ext) -> 0^1(*(x, y))
   *^1(*(0(x), y), ext) -> *^1(x, y)
   *^1(*(1(x), y), ext) -> *^1(+(0(*(x, y)), y), ext)
   *^1(*(1(x), y), ext) -> +^1(0(*(x, y)), y)
   *^1(*(1(x), y), ext) -> 0^1(*(x, y))
   *^1(*(1(x), y), ext) -> *^1(x, y)
   *^1(*(j(x), y), ext) -> *^1(-(0(*(x, y)), y), ext)
   *^1(*(j(x), y), ext) -> -^1(0(*(x, y)), y)
   *^1(*(j(x), y), ext) -> 0^1(*(x, y))
   *^1(*(j(x), y), ext) -> *^1(x, y)
   +^1(+(0(x), 0(y)), ext) -> +^1(0(+(x, y)), ext)
   +^1(+(0(x), 0(y)), ext) -> 0^1(+(x, y))
   +^1(+(0(x), 0(y)), ext) -> +^1(x, y)
   +^1(+(0(x), 1(y)), ext) -> +^1(1(+(x, y)), ext)
   +^1(+(0(x), 1(y)), ext) -> +^1(x, y)
   +^1(+(0(x), j(y)), ext) -> +^1(j(+(x, y)), ext)
   +^1(+(0(x), j(y)), ext) -> +^1(x, y)
   +^1(+(1(x), 1(y)), ext) -> +^1(j(+(1(#), +(x, y))), ext)
   +^1(+(1(x), 1(y)), ext) -> +^1(1(#), +(x, y))
   +^1(+(1(x), 1(y)), ext) -> +^1(x, y)
   +^1(+(j(x), j(y)), ext) -> +^1(1(+(j(#), +(x, y))), ext)
   +^1(+(j(x), j(y)), ext) -> +^1(j(#), +(x, y))
   +^1(+(j(x), j(y)), ext) -> +^1(x, y)
   +^1(+(1(x), j(y)), ext) -> +^1(0(+(x, y)), ext)
   +^1(+(1(x), j(y)), ext) -> 0^1(+(x, y))
   +^1(+(1(x), j(y)), ext) -> +^1(x, y)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

The set E# consists of the following equations:

   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

We have to consider all minimal (P,E#,R,E)-chains

----------------------------------------

(2)
Obligation:
The TRS P consists of the following rules:

   +^1(0(x), 0(y)) -> 0^1(+(x, y))
   +^1(0(x), 0(y)) -> +^1(x, y)
   +^1(0(x), 1(y)) -> +^1(x, y)
   +^1(0(x), j(y)) -> +^1(x, y)
   +^1(1(x), 1(y)) -> +^1(1(#), +(x, y))
   +^1(1(x), 1(y)) -> +^1(x, y)
   +^1(j(x), j(y)) -> +^1(j(#), +(x, y))
   +^1(j(x), j(y)) -> +^1(x, y)
   +^1(1(x), j(y)) -> 0^1(+(x, y))
   +^1(1(x), j(y)) -> +^1(x, y)
   OPP(0(x)) -> 0^1(opp(x))
   OPP(0(x)) -> OPP(x)
   OPP(1(x)) -> OPP(x)
   OPP(j(x)) -> OPP(x)
   -^1(x, y) -> +^1(opp(y), x)
   -^1(x, y) -> OPP(y)
   *^1(0(x), y) -> 0^1(*(x, y))
   *^1(0(x), y) -> *^1(x, y)
   *^1(1(x), y) -> +^1(0(*(x, y)), y)
   *^1(1(x), y) -> 0^1(*(x, y))
   *^1(1(x), y) -> *^1(x, y)
   *^1(j(x), y) -> -^1(0(*(x, y)), y)
   *^1(j(x), y) -> 0^1(*(x, y))
   *^1(j(x), y) -> *^1(x, y)
   ABS(x) -> TEST_ABS_POS(x, x)
   TEST_ABS_POS(0(x), y) -> TEST_ABS_POS(x, y)
   TEST_ABS_POS(1(x), y) -> TEST_ABS_POS(x, y)
   TEST_ABS_POS(j(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_NEG(#, x) -> OPP(x)
   TEST_ABS_NEG(0(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_NEG(1(x), y) -> TEST_ABS_POS(x, y)
   TEST_ABS_NEG(j(x), y) -> TEST_ABS_NEG(x, y)
   SIGNE(0(x)) -> SIGNE(x)
   SIGNE(1(x)) -> TEST_SIGNE_POS(x)
   SIGNE(j(x)) -> TEST_SIGNE_NEG(x)
   TEST_SIGNE_POS(0(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_POS(1(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_POS(j(x)) -> TEST_SIGNE_NEG(x)
   TEST_SIGNE_NEG(0(x)) -> TEST_SIGNE_NEG(x)
   TEST_SIGNE_NEG(1(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_NEG(j(x)) -> TEST_SIGNE_NEG(x)
   MIN(x, y) -> TEST_MIN_POS(-(abs(y), abs(x)), x, y)
   MIN(x, y) -> -^1(abs(y), abs(x))
   MIN(x, y) -> ABS(y)
   MIN(x, y) -> ABS(x)
   MIN'(x, y) -> TEST_MIN_POS(-(abs(1(y)), abs(1(x))), x, y)
   MIN'(x, y) -> -^1(abs(1(y)), abs(1(x)))
   MIN'(x, y) -> ABS(1(y))
   MIN'(x, y) -> ABS(1(x))
   MIN''(x, y) -> TEST_MIN_POS(-(abs(j(y)), abs(j(x))), x, y)
   MIN''(x, y) -> -^1(abs(j(y)), abs(j(x)))
   MIN''(x, y) -> ABS(j(y))
   MIN''(x, y) -> ABS(j(x))
   TEST_MIN_POS(0(x), y, z) -> TEST_MIN_POS(x, y, z)
   TEST_MIN_POS(1(x), y, z) -> TEST_MIN_POS(x, y, z)
   TEST_MIN_POS(j(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_NEG(0(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_NEG(1(x), y, z) -> TEST_MIN_POS(x, y, z)
   TEST_MIN_NEG(j(x), y, z) -> TEST_MIN_NEG(x, y, z)
   F(x, #) -> SIGNE(x)
   F(0(x), 0(y)) -> F(x, y)
   F(0(x), 1(y)) -> 0^1(f(x, 1(y)))
   F(0(x), 1(y)) -> F(x, 1(y))
   F(0(x), j(y)) -> 0^1(f(x, j(y)))
   F(0(x), j(y)) -> F(x, j(y))
   F(1(x), 0(y)) -> F(1(x), y)
   F(1(x), 1(y)) -> +^1(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   F(1(x), 1(y)) -> 0^1(f(-(x, min'(x, y)), 1(y)))
   F(1(x), 1(y)) -> F(-(x, min'(x, y)), 1(y))
   F(1(x), 1(y)) -> -^1(x, min'(x, y))
   F(1(x), 1(y)) -> MIN'(x, y)
   F(1(x), 1(y)) -> F(min(1(x), 1(y)), -(x, y))
   F(1(x), 1(y)) -> MIN(1(x), 1(y))
   F(1(x), 1(y)) -> -^1(x, y)
   F(1(x), j(y)) -> +^1(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   F(1(x), j(y)) -> 0^1(f(+(min''(opp(x), y), x), j(y)))
   F(1(x), j(y)) -> F(+(min''(opp(x), y), x), j(y))
   F(1(x), j(y)) -> +^1(min''(opp(x), y), x)
   F(1(x), j(y)) -> MIN''(opp(x), y)
   F(1(x), j(y)) -> OPP(x)
   F(1(x), j(y)) -> F(min(1(x), 1(opp(y))), +(x, y))
   F(1(x), j(y)) -> MIN(1(x), 1(opp(y)))
   F(1(x), j(y)) -> OPP(y)
   F(1(x), j(y)) -> +^1(x, y)
   F(j(x), 0(y)) -> F(j(x), y)
   F(j(x), 1(y)) -> +^1(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   F(j(x), 1(y)) -> 0^1(f(+(min'(opp(x), y), x), 1(y)))
   F(j(x), 1(y)) -> F(+(min'(opp(x), y), x), 1(y))
   F(j(x), 1(y)) -> +^1(min'(opp(x), y), x)
   F(j(x), 1(y)) -> MIN'(opp(x), y)
   F(j(x), 1(y)) -> OPP(x)
   F(j(x), 1(y)) -> F(min(j(x), j(opp(y))), +(x, y))
   F(j(x), 1(y)) -> MIN(j(x), j(opp(y)))
   F(j(x), 1(y)) -> OPP(y)
   F(j(x), 1(y)) -> +^1(x, y)
   F(j(x), j(y)) -> +^1(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   F(j(x), j(y)) -> 0^1(f(-(x, min''(x, y)), j(y)))
   F(j(x), j(y)) -> F(-(x, min''(x, y)), j(y))
   F(j(x), j(y)) -> -^1(x, min''(x, y))
   F(j(x), j(y)) -> MIN''(x, y)
   F(j(x), j(y)) -> F(min(j(x), j(y)), -(x, y))
   F(j(x), j(y)) -> MIN(j(x), j(y))
   F(j(x), j(y)) -> -^1(x, y)
   RAT(x, y) -> *^1(signe(y), f(x, y))
   RAT(x, y) -> SIGNE(y)
   RAT(x, y) -> F(x, y)
   RAT(x, y) -> *^1(signe(y), f(y, x))
   RAT(x, y) -> F(y, x)
   +_Q^1(irred(x, y), irred(u, v)) -> +^1(*(x, v), *(y, u))
   +_Q^1(irred(x, y), irred(u, v)) -> *^1(x, v)
   +_Q^1(irred(x, y), irred(u, v)) -> *^1(y, u)
   +_Q^1(irred(x, y), irred(u, v)) -> *^1(y, v)
   *_Q^1(irred(x, y), irred(u, v)) -> RAT(*(x, u), *(y, v))
   *_Q^1(irred(x, y), irred(u, v)) -> *^1(x, u)
   *_Q^1(irred(x, y), irred(u, v)) -> *^1(y, v)
   *^1(*(#, x), ext) -> *^1(#, ext)
   *^1(*(0(x), y), ext) -> *^1(0(*(x, y)), ext)
   *^1(*(0(x), y), ext) -> 0^1(*(x, y))
   *^1(*(0(x), y), ext) -> *^1(x, y)
   *^1(*(1(x), y), ext) -> *^1(+(0(*(x, y)), y), ext)
   *^1(*(1(x), y), ext) -> +^1(0(*(x, y)), y)
   *^1(*(1(x), y), ext) -> 0^1(*(x, y))
   *^1(*(1(x), y), ext) -> *^1(x, y)
   *^1(*(j(x), y), ext) -> *^1(-(0(*(x, y)), y), ext)
   *^1(*(j(x), y), ext) -> -^1(0(*(x, y)), y)
   *^1(*(j(x), y), ext) -> 0^1(*(x, y))
   *^1(*(j(x), y), ext) -> *^1(x, y)
   +^1(+(0(x), 0(y)), ext) -> +^1(0(+(x, y)), ext)
   +^1(+(0(x), 0(y)), ext) -> 0^1(+(x, y))
   +^1(+(0(x), 0(y)), ext) -> +^1(x, y)
   +^1(+(0(x), 1(y)), ext) -> +^1(1(+(x, y)), ext)
   +^1(+(0(x), 1(y)), ext) -> +^1(x, y)
   +^1(+(0(x), j(y)), ext) -> +^1(j(+(x, y)), ext)
   +^1(+(0(x), j(y)), ext) -> +^1(x, y)
   +^1(+(1(x), 1(y)), ext) -> +^1(j(+(1(#), +(x, y))), ext)
   +^1(+(1(x), 1(y)), ext) -> +^1(1(#), +(x, y))
   +^1(+(1(x), 1(y)), ext) -> +^1(x, y)
   +^1(+(j(x), j(y)), ext) -> +^1(1(+(j(#), +(x, y))), ext)
   +^1(+(j(x), j(y)), ext) -> +^1(j(#), +(x, y))
   +^1(+(j(x), j(y)), ext) -> +^1(x, y)
   +^1(+(1(x), j(y)), ext) -> +^1(0(+(x, y)), ext)
   +^1(+(1(x), j(y)), ext) -> 0^1(+(x, y))
   +^1(+(1(x), j(y)), ext) -> +^1(x, y)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

The set E# consists of the following equations:

   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(3) EDependencyGraphProof (EQUIVALENT)
The approximation of the Equational Dependency Graph [DA_STEIN] contains 8 SCCs with 76 less nodes.
----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
The TRS P consists of the following rules:

   TEST_MIN_POS(0(x), y, z) -> TEST_MIN_POS(x, y, z)
   TEST_MIN_NEG(0(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_POS(1(x), y, z) -> TEST_MIN_POS(x, y, z)
   TEST_MIN_POS(j(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_NEG(j(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_NEG(1(x), y, z) -> TEST_MIN_POS(x, y, z)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

The set E# consists of the following equations:

   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(6) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

----------------------------------------

(7)
Obligation:
The TRS P consists of the following rules:

   TEST_MIN_POS(0(x), y, z) -> TEST_MIN_POS(x, y, z)
   TEST_MIN_NEG(0(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_POS(1(x), y, z) -> TEST_MIN_POS(x, y, z)
   TEST_MIN_POS(j(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_NEG(j(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_NEG(1(x), y, z) -> TEST_MIN_POS(x, y, z)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(8) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules can be oriented non-strictly, the  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   TEST_MIN_POS(0(x), y, z) -> TEST_MIN_POS(x, y, z)
   TEST_MIN_NEG(0(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_POS(1(x), y, z) -> TEST_MIN_POS(x, y, z)
   TEST_MIN_POS(j(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_NEG(j(x), y, z) -> TEST_MIN_NEG(x, y, z)
   TEST_MIN_NEG(1(x), y, z) -> TEST_MIN_POS(x, y, z)
The following rules are removed from R:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)
The following equations are removed from E:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(0(x_1)) = 3*x_1
   POL(1(x_1)) = 3*x_1
   POL(TEST_MIN_NEG(x_1, x_2, x_3)) = 2*x_1 + x_2 + x_3
   POL(TEST_MIN_POS(x_1, x_2, x_3)) = x_1 + x_2 + x_3
   POL(j(x_1)) = 3*x_1


----------------------------------------

(9)
Obligation:
P is empty.
R is empty.
E is empty.
E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(10) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(11)
YES

----------------------------------------

(12)
Obligation:
The TRS P consists of the following rules:

   TEST_SIGNE_NEG(0(x)) -> TEST_SIGNE_NEG(x)
   TEST_SIGNE_POS(1(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_NEG(1(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_POS(0(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_POS(j(x)) -> TEST_SIGNE_NEG(x)
   TEST_SIGNE_NEG(j(x)) -> TEST_SIGNE_NEG(x)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

The set E# consists of the following equations:

   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(13) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

----------------------------------------

(14)
Obligation:
The TRS P consists of the following rules:

   TEST_SIGNE_NEG(0(x)) -> TEST_SIGNE_NEG(x)
   TEST_SIGNE_POS(1(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_NEG(1(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_POS(0(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_POS(j(x)) -> TEST_SIGNE_NEG(x)
   TEST_SIGNE_NEG(j(x)) -> TEST_SIGNE_NEG(x)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(15) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules can be oriented non-strictly, the  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   TEST_SIGNE_NEG(0(x)) -> TEST_SIGNE_NEG(x)
   TEST_SIGNE_POS(1(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_NEG(1(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_POS(0(x)) -> TEST_SIGNE_POS(x)
   TEST_SIGNE_POS(j(x)) -> TEST_SIGNE_NEG(x)
   TEST_SIGNE_NEG(j(x)) -> TEST_SIGNE_NEG(x)
The following rules are removed from R:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)
The following equations are removed from E:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(0(x_1)) = 3*x_1
   POL(1(x_1)) = 3*x_1
   POL(TEST_SIGNE_NEG(x_1)) = x_1
   POL(TEST_SIGNE_POS(x_1)) = 2*x_1
   POL(j(x_1)) = 3*x_1


----------------------------------------

(16)
Obligation:
P is empty.
R is empty.
E is empty.
E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(17) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(18)
YES

----------------------------------------

(19)
Obligation:
The TRS P consists of the following rules:

   SIGNE(0(x)) -> SIGNE(x)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

The set E# consists of the following equations:

   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(20) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

----------------------------------------

(21)
Obligation:
The TRS P consists of the following rules:

   SIGNE(0(x)) -> SIGNE(x)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(22) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules can be oriented non-strictly, the  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   SIGNE(0(x)) -> SIGNE(x)
The following rules are removed from R:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)
The following equations are removed from E:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(0(x_1)) = 3*x_1
   POL(SIGNE(x_1)) = 3*x_1


----------------------------------------

(23)
Obligation:
P is empty.
R is empty.
E is empty.
E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(24) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(25)
YES

----------------------------------------

(26)
Obligation:
The TRS P consists of the following rules:

   OPP(j(x)) -> OPP(x)
   OPP(0(x)) -> OPP(x)
   OPP(1(x)) -> OPP(x)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

The set E# consists of the following equations:

   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(27) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

----------------------------------------

(28)
Obligation:
The TRS P consists of the following rules:

   OPP(j(x)) -> OPP(x)
   OPP(0(x)) -> OPP(x)
   OPP(1(x)) -> OPP(x)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(29) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules can be oriented non-strictly, the  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   OPP(j(x)) -> OPP(x)
   OPP(0(x)) -> OPP(x)
   OPP(1(x)) -> OPP(x)
The following rules are removed from R:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)
The following equations are removed from E:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(0(x_1)) = 3*x_1
   POL(1(x_1)) = x_1
   POL(OPP(x_1)) = 2*x_1
   POL(j(x_1)) = 3*x_1


----------------------------------------

(30)
Obligation:
P is empty.
R is empty.
E is empty.
E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(31) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(32)
YES

----------------------------------------

(33)
Obligation:
The TRS P consists of the following rules:

   TEST_ABS_NEG(1(x), y) -> TEST_ABS_POS(x, y)
   TEST_ABS_POS(j(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_NEG(0(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_POS(1(x), y) -> TEST_ABS_POS(x, y)
   TEST_ABS_NEG(j(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_POS(0(x), y) -> TEST_ABS_POS(x, y)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

The set E# consists of the following equations:

   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(34) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

----------------------------------------

(35)
Obligation:
The TRS P consists of the following rules:

   TEST_ABS_NEG(1(x), y) -> TEST_ABS_POS(x, y)
   TEST_ABS_POS(j(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_NEG(0(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_POS(1(x), y) -> TEST_ABS_POS(x, y)
   TEST_ABS_NEG(j(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_POS(0(x), y) -> TEST_ABS_POS(x, y)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(36) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules can be oriented non-strictly, the  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   TEST_ABS_NEG(1(x), y) -> TEST_ABS_POS(x, y)
   TEST_ABS_POS(j(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_NEG(0(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_POS(1(x), y) -> TEST_ABS_POS(x, y)
   TEST_ABS_NEG(j(x), y) -> TEST_ABS_NEG(x, y)
   TEST_ABS_POS(0(x), y) -> TEST_ABS_POS(x, y)
The following rules are removed from R:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)
The following equations are removed from E:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(0(x_1)) = 3*x_1
   POL(1(x_1)) = 3*x_1
   POL(TEST_ABS_NEG(x_1, x_2)) = x_1 + x_2
   POL(TEST_ABS_POS(x_1, x_2)) = 2*x_1 + x_2
   POL(j(x_1)) = 3*x_1


----------------------------------------

(37)
Obligation:
P is empty.
R is empty.
E is empty.
E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(38) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(39)
YES

----------------------------------------

(40)
Obligation:
The TRS P consists of the following rules:

   +^1(+(0(x), j(y)), ext) -> +^1(j(+(x, y)), ext)
   +^1(+(j(x), j(y)), ext) -> +^1(j(#), +(x, y))
   +^1(+(j(x), j(y)), ext) -> +^1(x, y)
   +^1(1(x), 1(y)) -> +^1(1(#), +(x, y))
   +^1(+(1(x), 1(y)), ext) -> +^1(x, y)
   +^1(+(0(x), 0(y)), ext) -> +^1(x, y)
   +^1(+(0(x), 1(y)), ext) -> +^1(1(+(x, y)), ext)
   +^1(0(x), 1(y)) -> +^1(x, y)
   +^1(+(1(x), j(y)), ext) -> +^1(0(+(x, y)), ext)
   +^1(j(x), j(y)) -> +^1(x, y)
   +^1(+(1(x), 1(y)), ext) -> +^1(1(#), +(x, y))
   +^1(j(x), j(y)) -> +^1(j(#), +(x, y))
   +^1(+(1(x), j(y)), ext) -> +^1(x, y)
   +^1(+(1(x), 1(y)), ext) -> +^1(j(+(1(#), +(x, y))), ext)
   +^1(1(x), 1(y)) -> +^1(x, y)
   +^1(+(0(x), 1(y)), ext) -> +^1(x, y)
   +^1(0(x), 0(y)) -> +^1(x, y)
   +^1(+(0(x), 0(y)), ext) -> +^1(0(+(x, y)), ext)
   +^1(0(x), j(y)) -> +^1(x, y)
   +^1(+(0(x), j(y)), ext) -> +^1(x, y)
   +^1(1(x), j(y)) -> +^1(x, y)
   +^1(+(j(x), j(y)), ext) -> +^1(1(+(j(#), +(x, y))), ext)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

The set E# consists of the following equations:

   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(41) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))

----------------------------------------

(42)
Obligation:
The TRS P consists of the following rules:

   +^1(+(0(x), j(y)), ext) -> +^1(j(+(x, y)), ext)
   +^1(+(j(x), j(y)), ext) -> +^1(j(#), +(x, y))
   +^1(+(j(x), j(y)), ext) -> +^1(x, y)
   +^1(1(x), 1(y)) -> +^1(1(#), +(x, y))
   +^1(+(1(x), 1(y)), ext) -> +^1(x, y)
   +^1(+(0(x), 0(y)), ext) -> +^1(x, y)
   +^1(+(0(x), 1(y)), ext) -> +^1(1(+(x, y)), ext)
   +^1(0(x), 1(y)) -> +^1(x, y)
   +^1(+(1(x), j(y)), ext) -> +^1(0(+(x, y)), ext)
   +^1(j(x), j(y)) -> +^1(x, y)
   +^1(+(1(x), 1(y)), ext) -> +^1(1(#), +(x, y))
   +^1(j(x), j(y)) -> +^1(j(#), +(x, y))
   +^1(+(1(x), j(y)), ext) -> +^1(x, y)
   +^1(+(1(x), 1(y)), ext) -> +^1(j(+(1(#), +(x, y))), ext)
   +^1(1(x), 1(y)) -> +^1(x, y)
   +^1(+(0(x), 1(y)), ext) -> +^1(x, y)
   +^1(0(x), 0(y)) -> +^1(x, y)
   +^1(+(0(x), 0(y)), ext) -> +^1(0(+(x, y)), ext)
   +^1(0(x), j(y)) -> +^1(x, y)
   +^1(+(0(x), j(y)), ext) -> +^1(x, y)
   +^1(1(x), j(y)) -> +^1(x, y)
   +^1(+(j(x), j(y)), ext) -> +^1(1(+(j(#), +(x, y))), ext)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

The set E# consists of the following equations:

   +^1(+(x, y), z) == +^1(x, +(y, z))
   +^1(x, y) == +^1(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(43) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules can be oriented non-strictly, the  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
The following equations are removed from E:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   *(*(x, y), z) == *(x, *(y, z))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(#) = 0
   POL(+(x_1, x_2)) = x_1 + x_2
   POL(+^1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(0(x_1)) = x_1
   POL(1(x_1)) = x_1
   POL(j(x_1)) = x_1


----------------------------------------

(44)
Obligation:
The TRS P consists of the following rules:

   +^1(+(0(x), j(y)), ext) -> +^1(j(+(x, y)), ext)
   +^1(+(j(x), j(y)), ext) -> +^1(j(#), +(x, y))
   +^1(+(j(x), j(y)), ext) -> +^1(x, y)
   +^1(1(x), 1(y)) -> +^1(1(#), +(x, y))
   +^1(+(1(x), 1(y)), ext) -> +^1(x, y)
   +^1(+(0(x), 0(y)), ext) -> +^1(x, y)
   +^1(+(0(x), 1(y)), ext) -> +^1(1(+(x, y)), ext)
   +^1(0(x), 1(y)) -> +^1(x, y)
   +^1(+(1(x), j(y)), ext) -> +^1(0(+(x, y)), ext)
   +^1(j(x), j(y)) -> +^1(x, y)
   +^1(+(1(x), 1(y)), ext) -> +^1(1(#), +(x, y))
   +^1(j(x), j(y)) -> +^1(j(#), +(x, y))
   +^1(+(1(x), j(y)), ext) -> +^1(x, y)
   +^1(+(1(x), 1(y)), ext) -> +^1(j(+(1(#), +(x, y))), ext)
   +^1(1(x), 1(y)) -> +^1(x, y)
   +^1(+(0(x), 1(y)), ext) -> +^1(x, y)
   +^1(0(x), 0(y)) -> +^1(x, y)
   +^1(+(0(x), 0(y)), ext) -> +^1(0(+(x, y)), ext)
   +^1(0(x), j(y)) -> +^1(x, y)
   +^1(+(0(x), j(y)), ext) -> +^1(x, y)
   +^1(1(x), j(y)) -> +^1(x, y)
   +^1(+(j(x), j(y)), ext) -> +^1(1(+(j(#), +(x, y))), ext)

The TRS R consists of the following rules:

   +(0(x), 1(y)) -> 1(+(x, y))
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(1(x), j(y)) -> 0(+(x, y))
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   0(#) -> #
   +(0(x), j(y)) -> j(+(x, y))
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)
   +(0(x), 0(y)) -> 0(+(x, y))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(#, x) -> x
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))

The set E consists of the following equations:

   +(+(x, y), z) == +(x, +(y, z))
   +(x, y) == +(y, x)

The set E# consists of the following equations:

   +^1(+(x, y), z) == +^1(x, +(y, z))
   +^1(x, y) == +^1(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(45) ERuleRemovalProof (EQUIVALENT)
By using the rule removal processor [DA_STEIN] with the following polynomial ordering [POLO], at least one Dependency Pair or term rewrite system rule of this EDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   +^1(+(0(x), j(y)), ext) -> +^1(j(+(x, y)), ext)
   +^1(+(j(x), j(y)), ext) -> +^1(j(#), +(x, y))
   +^1(+(j(x), j(y)), ext) -> +^1(x, y)
   +^1(1(x), 1(y)) -> +^1(1(#), +(x, y))
   +^1(+(1(x), 1(y)), ext) -> +^1(x, y)
   +^1(+(0(x), 0(y)), ext) -> +^1(x, y)
   +^1(+(0(x), 1(y)), ext) -> +^1(1(+(x, y)), ext)
   +^1(0(x), 1(y)) -> +^1(x, y)
   +^1(+(1(x), j(y)), ext) -> +^1(0(+(x, y)), ext)
   +^1(j(x), j(y)) -> +^1(x, y)
   +^1(+(1(x), 1(y)), ext) -> +^1(1(#), +(x, y))
   +^1(j(x), j(y)) -> +^1(j(#), +(x, y))
   +^1(+(1(x), j(y)), ext) -> +^1(x, y)
   +^1(1(x), 1(y)) -> +^1(x, y)
   +^1(+(0(x), 1(y)), ext) -> +^1(x, y)
   +^1(0(x), 0(y)) -> +^1(x, y)
   +^1(+(0(x), 0(y)), ext) -> +^1(0(+(x, y)), ext)
   +^1(0(x), j(y)) -> +^1(x, y)
   +^1(+(0(x), j(y)), ext) -> +^1(x, y)
   +^1(1(x), j(y)) -> +^1(x, y)

Strictly oriented rules of the TRS R:

   +(0(x), 1(y)) -> 1(+(x, y))
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(1(x), j(y)) -> 0(+(x, y))
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   0(#) -> #
   +(0(x), j(y)) -> j(+(x, y))
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)
   +(0(x), 0(y)) -> 0(+(x, y))

Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(#) = 0
   POL(+(x_1, x_2)) = x_1 + x_2
   POL(+^1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(0(x_1)) = 2 + x_1
   POL(1(x_1)) = 2 + x_1
   POL(j(x_1)) = 2 + x_1


----------------------------------------

(46)
Obligation:
The TRS P consists of the following rules:

   +^1(+(1(x), 1(y)), ext) -> +^1(j(+(1(#), +(x, y))), ext)
   +^1(+(j(x), j(y)), ext) -> +^1(1(+(j(#), +(x, y))), ext)

The TRS R consists of the following rules:

   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(#, x) -> x
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))

The set E consists of the following equations:

   +(+(x, y), z) == +(x, +(y, z))
   +(x, y) == +(y, x)

The set E# consists of the following equations:

   +^1(+(x, y), z) == +^1(x, +(y, z))
   +^1(x, y) == +^1(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(47) EDPPoloProof (EQUIVALENT)
We use the reduction pair processor [DA_STEIN] with a polynomial ordering [POLO]. All Dependency Pairs of this DP problem can be strictly oriented.


   +^1(+(1(x), 1(y)), ext) -> +^1(j(+(1(#), +(x, y))), ext)
   +^1(+(j(x), j(y)), ext) -> +^1(1(+(j(#), +(x, y))), ext)
With the implicit AFS we had to orient the following set of usable rules of R non-strictly.


   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(#, x) -> x
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
We had to orient the following equations of E# equivalently.


   +^1(+(x, y), z) == +^1(x, +(y, z))
   +^1(x, y) == +^1(y, x)
With the implicit AFS we had to orient the following usable equations of E equivalently.


   +(+(x, y), z) == +(x, +(y, z))
   +(x, y) == +(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(#) = 0
   POL(+(x_1, x_2)) = 1 + x_1 + x_2
   POL(+^1(x_1, x_2)) = x_1 + x_2
   POL(1(x_1)) = 0
   POL(j(x_1)) = 0


----------------------------------------

(48)
Obligation:
P is empty.
The TRS R consists of the following rules:

   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(#, x) -> x
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))

The set E consists of the following equations:

   +(+(x, y), z) == +(x, +(y, z))
   +(x, y) == +(y, x)

The set E# consists of the following equations:

   +^1(+(x, y), z) == +^1(x, +(y, z))
   +^1(x, y) == +^1(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(49) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(50)
YES

----------------------------------------

(51)
Obligation:
The TRS P consists of the following rules:

   F(1(x), j(y)) -> F(+(min''(opp(x), y), x), j(y))
   F(1(x), 0(y)) -> F(1(x), y)
   F(j(x), 1(y)) -> F(min(j(x), j(opp(y))), +(x, y))
   F(0(x), 1(y)) -> F(x, 1(y))
   F(1(x), 1(y)) -> F(min(1(x), 1(y)), -(x, y))
   F(j(x), j(y)) -> F(min(j(x), j(y)), -(x, y))
   F(j(x), 1(y)) -> F(+(min'(opp(x), y), x), 1(y))
   F(j(x), j(y)) -> F(-(x, min''(x, y)), j(y))
   F(1(x), j(y)) -> F(min(1(x), 1(opp(y))), +(x, y))
   F(1(x), 1(y)) -> F(-(x, min'(x, y)), 1(y))
   F(j(x), 0(y)) -> F(j(x), y)
   F(0(x), 0(y)) -> F(x, y)
   F(0(x), j(y)) -> F(x, j(y))

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

The set E# consists of the following equations:

   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(52) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

----------------------------------------

(53)
Obligation:
The TRS P consists of the following rules:

   F(1(x), j(y)) -> F(+(min''(opp(x), y), x), j(y))
   F(1(x), 0(y)) -> F(1(x), y)
   F(j(x), 1(y)) -> F(min(j(x), j(opp(y))), +(x, y))
   F(0(x), 1(y)) -> F(x, 1(y))
   F(1(x), 1(y)) -> F(min(1(x), 1(y)), -(x, y))
   F(j(x), j(y)) -> F(min(j(x), j(y)), -(x, y))
   F(j(x), 1(y)) -> F(+(min'(opp(x), y), x), 1(y))
   F(j(x), j(y)) -> F(-(x, min''(x, y)), j(y))
   F(1(x), j(y)) -> F(min(1(x), 1(opp(y))), +(x, y))
   F(1(x), 1(y)) -> F(-(x, min'(x, y)), 1(y))
   F(j(x), 0(y)) -> F(j(x), y)
   F(0(x), 0(y)) -> F(x, y)
   F(0(x), j(y)) -> F(x, j(y))

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(54) EUsableRulesProof (EQUIVALENT)
We use the usable rules and equations processor [DA_STEIN] to delete all non-usable rules from R and all non-usable equations from E, but we lose minimality and add the following 2 Ce-rules:
   c(x, y) -> x
   c(x, y) -> y

----------------------------------------

(55)
Obligation:
The TRS P consists of the following rules:

   F(1(x), j(y)) -> F(+(min''(opp(x), y), x), j(y))
   F(1(x), 0(y)) -> F(1(x), y)
   F(j(x), 1(y)) -> F(min(j(x), j(opp(y))), +(x, y))
   F(0(x), 1(y)) -> F(x, 1(y))
   F(1(x), 1(y)) -> F(min(1(x), 1(y)), -(x, y))
   F(j(x), j(y)) -> F(min(j(x), j(y)), -(x, y))
   F(j(x), 1(y)) -> F(+(min'(opp(x), y), x), 1(y))
   F(j(x), j(y)) -> F(-(x, min''(x, y)), j(y))
   F(1(x), j(y)) -> F(min(1(x), 1(opp(y))), +(x, y))
   F(1(x), 1(y)) -> F(-(x, min'(x, y)), 1(y))
   F(j(x), 0(y)) -> F(j(x), y)
   F(0(x), 0(y)) -> F(x, y)
   F(0(x), j(y)) -> F(x, j(y))

The TRS R consists of the following rules:

   opp(1(x)) -> j(opp(x))
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   test_min_pos(#, x, y) -> x
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   +(1(x), j(y)) -> 0(+(x, y))
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   0(#) -> #
   +(0(x), j(y)) -> j(+(x, y))
   +(0(x), 0(y)) -> 0(+(x, y))
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   opp(0(x)) -> 0(opp(x))
   -(x, y) -> +(opp(y), x)
   +(#, x) -> x
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   test_abs_pos(#, x) -> x
   +(0(x), 1(y)) -> 1(+(x, y))
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   opp(#) -> #
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(#, x, y) -> y
   opp(j(x)) -> 1(opp(x))
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   c(x, y) -> x
   c(x, y) -> y

The set E consists of the following equations:

   +(+(x, y), z) == +(x, +(y, z))
   +(x, y) == +(y, x)

E# is empty.
We have to consider all (P,E#,R,E)-chains
----------------------------------------

(56)
Obligation:
The TRS P consists of the following rules:

   *^1(*(#, x), ext) -> *^1(#, ext)
   *^1(*(1(x), y), ext) -> *^1(+(0(*(x, y)), y), ext)
   *^1(*(0(x), y), ext) -> *^1(x, y)
   *^1(*(j(x), y), ext) -> *^1(x, y)
   *^1(1(x), y) -> *^1(x, y)
   *^1(j(x), y) -> *^1(x, y)
   *^1(*(j(x), y), ext) -> *^1(-(0(*(x, y)), y), ext)
   *^1(0(x), y) -> *^1(x, y)
   *^1(*(0(x), y), ext) -> *^1(0(*(x, y)), ext)
   *^1(*(1(x), y), ext) -> *^1(x, y)

The TRS R consists of the following rules:

   0(#) -> #
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(0(x), j(y)) -> j(+(x, y))
   +(1(x), 1(y)) -> j(+(1(#), +(x, y)))
   +(j(x), j(y)) -> 1(+(j(#), +(x, y)))
   +(1(x), j(y)) -> 0(+(x, y))
   opp(#) -> #
   opp(0(x)) -> 0(opp(x))
   opp(1(x)) -> j(opp(x))
   opp(j(x)) -> 1(opp(x))
   -(x, y) -> +(opp(y), x)
   *(#, x) -> #
   *(0(x), y) -> 0(*(x, y))
   *(1(x), y) -> +(0(*(x, y)), y)
   *(j(x), y) -> -(0(*(x, y)), y)
   abs(x) -> test_abs_pos(x, x)
   test_abs_pos(#, x) -> x
   test_abs_pos(0(x), y) -> test_abs_pos(x, y)
   test_abs_pos(1(x), y) -> test_abs_pos(x, y)
   test_abs_pos(j(x), y) -> test_abs_neg(x, y)
   test_abs_neg(#, x) -> opp(x)
   test_abs_neg(0(x), y) -> test_abs_neg(x, y)
   test_abs_neg(1(x), y) -> test_abs_pos(x, y)
   test_abs_neg(j(x), y) -> test_abs_neg(x, y)
   signe(#) -> #
   signe(0(x)) -> signe(x)
   signe(1(x)) -> test_signe_pos(x)
   signe(j(x)) -> test_signe_neg(x)
   test_signe_pos(#) -> 1(#)
   test_signe_pos(0(x)) -> test_signe_pos(x)
   test_signe_pos(1(x)) -> test_signe_pos(x)
   test_signe_pos(j(x)) -> test_signe_neg(x)
   test_signe_neg(#) -> j(#)
   test_signe_neg(0(x)) -> test_signe_neg(x)
   test_signe_neg(1(x)) -> test_signe_pos(x)
   test_signe_neg(j(x)) -> test_signe_neg(x)
   min(x, y) -> test_min_pos(-(abs(y), abs(x)), x, y)
   min'(x, y) -> test_min_pos(-(abs(1(y)), abs(1(x))), x, y)
   min''(x, y) -> test_min_pos(-(abs(j(y)), abs(j(x))), x, y)
   test_min_pos(#, x, y) -> x
   test_min_pos(0(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_pos(j(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(#, x, y) -> y
   test_min_neg(0(x), y, z) -> test_min_neg(x, y, z)
   test_min_neg(1(x), y, z) -> test_min_pos(x, y, z)
   test_min_neg(j(x), y, z) -> test_min_neg(x, y, z)
   f(#, x) -> #
   f(x, #) -> signe(x)
   f(0(x), 0(y)) -> f(x, y)
   f(0(x), 1(y)) -> 0(f(x, 1(y)))
   f(0(x), j(y)) -> 0(f(x, j(y)))
   f(1(x), 0(y)) -> f(1(x), y)
   f(1(x), 1(y)) -> +(0(f(-(x, min'(x, y)), 1(y))), f(min(1(x), 1(y)), -(x, y)))
   f(1(x), j(y)) -> +(0(f(+(min''(opp(x), y), x), j(y))), f(min(1(x), 1(opp(y))), +(x, y)))
   f(j(x), 0(y)) -> f(j(x), y)
   f(j(x), 1(y)) -> +(0(f(+(min'(opp(x), y), x), 1(y))), f(min(j(x), j(opp(y))), +(x, y)))
   f(j(x), j(y)) -> +(0(f(-(x, min''(x, y)), j(y))), f(min(j(x), j(y)), -(x, y)))
   rat(x, y) -> irred(*(signe(y), f(x, y)), *(signe(y), f(y, x)))
   +_Q(irred(x, y), irred(u, v)) -> irred(+(*(x, v), *(y, u)), *(y, v))
   *_Q(irred(x, y), irred(u, v)) -> rat(*(x, u), *(y, v))
   *(*(#, x), ext) -> *(#, ext)
   *(*(0(x), y), ext) -> *(0(*(x, y)), ext)
   *(*(1(x), y), ext) -> *(+(0(*(x, y)), y), ext)
   *(*(j(x), y), ext) -> *(-(0(*(x, y)), y), ext)
   +(+(0(x), 0(y)), ext) -> +(0(+(x, y)), ext)
   +(+(0(x), 1(y)), ext) -> +(1(+(x, y)), ext)
   +(+(0(x), j(y)), ext) -> +(j(+(x, y)), ext)
   +(+(1(x), 1(y)), ext) -> +(j(+(1(#), +(x, y))), ext)
   +(+(j(x), j(y)), ext) -> +(1(+(j(#), +(x, y))), ext)
   +(+(1(x), j(y)), ext) -> +(0(+(x, y)), ext)

The set E consists of the following equations:

   *_Q(x, y) == *_Q(y, x)
   +_Q(x, y) == +_Q(y, x)
   *(x, y) == *(y, x)
   +(x, y) == +(y, x)
   *(*(x, y), z) == *(x, *(y, z))
   +(+(x, y), z) == +(x, +(y, z))

The set E# consists of the following equations:

   *_Q^1(x, y) == *_Q^1(y, x)
   +_Q^1(x, y) == +_Q^1(y, x)
   *^1(x, y) == *^1(y, x)
   +^1(x, y) == +^1(y, x)
   *^1(*(x, y), z) == *^1(x, *(y, z))
   +^1(+(x, y), z) == +^1(x, +(y, z))

We have to consider all minimal (P,E#,R,E)-chains