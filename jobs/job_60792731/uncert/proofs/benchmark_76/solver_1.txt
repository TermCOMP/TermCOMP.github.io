MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/5EGQn.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given ETRS could not be shown:

(0) ETRS
(1) EquationalDependencyPairsProof [EQUIVALENT, 0 ms]
(2) EDP
(3) EDependencyGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) EDP
        (6) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (7) EDP
        (8) EUsableRulesReductionPairsProof [EQUIVALENT, 39 ms]
        (9) EDP
        (10) PisEmptyProof [EQUIVALENT, 0 ms]
        (11) YES
    (12) EDP
        (13) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (14) EDP
        (15) EUsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (16) EDP
        (17) EDependencyGraphProof [EQUIVALENT, 0 ms]
        (18) TRUE
    (19) EDP
        (20) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (21) EDP
        (22) EUsableRulesProof [EQUIVALENT, 0 ms]
        (23) EDP
    (24) EDP
    (25) EDP
    (26) EDP


----------------------------------------

(0)
Obligation:
Equational rewrite system:
The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)


----------------------------------------

(1) EquationalDependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,DA_STEIN] we result in the following initial EDP problem:
The TRS P consists of the following rules:

   U11^1(tt, M, N) -> U12^1(tt, M, N)
   U12^1(tt, M, N) -> _+_^1(N, _+_(M, _*_(N, M)))
   U12^1(tt, M, N) -> _+_^1(M, _*_(N, M))
   U12^1(tt, M, N) -> _*_^1(N, M)
   U21^1(tt, M, N) -> U22^1(tt, M, N)
   U22^1(tt, M, N) -> _+_^1(N, M)
   U31^1(tt, M, N) -> U32^1(tt, M, N)
   U32^1(tt, M, N) -> _>_^1(M, N)
   U41^1(tt, M, N) -> U42^1(tt, M, N)
   U42^1(tt, M, N) -> _>_^1(N, M)
   U51^1(tt, M, N) -> U52^1(tt, M, N)
   U52^1(tt, M, N) -> D(N, M)
   U61^1(tt, M', N') -> U62^1(tt, M', N')
   U62^1(tt, M', N') -> U63^1(equal(_>_(N', M'), true), M', N')
   U62^1(tt, M', N') -> EQUAL(_>_(N', M'), true)
   U62^1(tt, M', N') -> _>_^1(N', M')
   U63^1(tt, M', N') -> GCD(d(N', M'), M')
   U63^1(tt, M', N') -> D(N', M')
   U71^1(tt, M', N) -> U72^1(tt, M', N)
   U72^1(tt, M', N) -> U73^1(equal(_>_(M', N), true))
   U72^1(tt, M', N) -> EQUAL(_>_(M', N), true)
   U72^1(tt, M', N) -> _>_^1(M', N)
   U81^1(tt, M', N) -> U82^1(tt, M', N)
   U82^1(tt, M', N) -> U83^1(equal(_>_(N, M'), true), M', N)
   U82^1(tt, M', N) -> EQUAL(_>_(N, M'), true)
   U82^1(tt, M', N) -> _>_^1(N, M')
   U83^1(tt, M', N) -> QUOT(d(N, M'), M')
   U83^1(tt, M', N) -> D(N, M')
   _*_^1(s_(N), s_(M)) -> U11^1(tt, M, N)
   _+_^1(s_(N), s_(M)) -> U21^1(tt, M, N)
   _<_^1(N, M) -> U31^1(tt, M, N)
   _>_^1(s_(N), s_(M)) -> U41^1(tt, M, N)
   D(s_(N), s_(M)) -> U51^1(tt, M, N)
   GCD(N', M') -> U61^1(tt, M', N')
   QUOT(N, M') -> U71^1(tt, M', N)
   QUOT(N, M') -> U81^1(tt, M', N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains

----------------------------------------

(2)
Obligation:
The TRS P consists of the following rules:

   U11^1(tt, M, N) -> U12^1(tt, M, N)
   U12^1(tt, M, N) -> _+_^1(N, _+_(M, _*_(N, M)))
   U12^1(tt, M, N) -> _+_^1(M, _*_(N, M))
   U12^1(tt, M, N) -> _*_^1(N, M)
   U21^1(tt, M, N) -> U22^1(tt, M, N)
   U22^1(tt, M, N) -> _+_^1(N, M)
   U31^1(tt, M, N) -> U32^1(tt, M, N)
   U32^1(tt, M, N) -> _>_^1(M, N)
   U41^1(tt, M, N) -> U42^1(tt, M, N)
   U42^1(tt, M, N) -> _>_^1(N, M)
   U51^1(tt, M, N) -> U52^1(tt, M, N)
   U52^1(tt, M, N) -> D(N, M)
   U61^1(tt, M', N') -> U62^1(tt, M', N')
   U62^1(tt, M', N') -> U63^1(equal(_>_(N', M'), true), M', N')
   U62^1(tt, M', N') -> EQUAL(_>_(N', M'), true)
   U62^1(tt, M', N') -> _>_^1(N', M')
   U63^1(tt, M', N') -> GCD(d(N', M'), M')
   U63^1(tt, M', N') -> D(N', M')
   U71^1(tt, M', N) -> U72^1(tt, M', N)
   U72^1(tt, M', N) -> U73^1(equal(_>_(M', N), true))
   U72^1(tt, M', N) -> EQUAL(_>_(M', N), true)
   U72^1(tt, M', N) -> _>_^1(M', N)
   U81^1(tt, M', N) -> U82^1(tt, M', N)
   U82^1(tt, M', N) -> U83^1(equal(_>_(N, M'), true), M', N)
   U82^1(tt, M', N) -> EQUAL(_>_(N, M'), true)
   U82^1(tt, M', N) -> _>_^1(N, M')
   U83^1(tt, M', N) -> QUOT(d(N, M'), M')
   U83^1(tt, M', N) -> D(N, M')
   _*_^1(s_(N), s_(M)) -> U11^1(tt, M, N)
   _+_^1(s_(N), s_(M)) -> U21^1(tt, M, N)
   _<_^1(N, M) -> U31^1(tt, M, N)
   _>_^1(s_(N), s_(M)) -> U41^1(tt, M, N)
   D(s_(N), s_(M)) -> U51^1(tt, M, N)
   GCD(N', M') -> U61^1(tt, M', N')
   QUOT(N, M') -> U71^1(tt, M', N)
   QUOT(N, M') -> U81^1(tt, M', N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(3) EDependencyGraphProof (EQUIVALENT)
The approximation of the Equational Dependency Graph [DA_STEIN] contains 6 SCCs with 16 less nodes.
----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
The TRS P consists of the following rules:

   U51^1(tt, M, N) -> U52^1(tt, M, N)
   D(s_(N), s_(M)) -> U51^1(tt, M, N)
   U52^1(tt, M, N) -> D(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(6) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(7)
Obligation:
The TRS P consists of the following rules:

   U51^1(tt, M, N) -> U52^1(tt, M, N)
   D(s_(N), s_(M)) -> U51^1(tt, M, N)
   U52^1(tt, M, N) -> D(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   D(x, y) == D(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(8) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the improved usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding improved usable rules can be oriented non-strictly, the improved  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and improved usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   U51^1(tt, M, N) -> U52^1(tt, M, N)
   D(s_(N), s_(M)) -> U51^1(tt, M, N)
   U52^1(tt, M, N) -> D(N, M)
The following rules are removed from R:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)
The following equations are removed from E:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(D(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(U51^1(x_1, x_2, x_3)) = 3 + 2*x_1 + 2*x_2 + 2*x_3
   POL(U52^1(x_1, x_2, x_3)) = 2 + 2*x_1 + 2*x_2 + 2*x_3
   POL(s_(x_1)) = 2 + 2*x_1
   POL(tt) = 0


----------------------------------------

(9)
Obligation:
P is empty.
R is empty.
E is empty.
The set E# consists of the following equations:

   D(x, y) == D(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(10) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(11)
YES

----------------------------------------

(12)
Obligation:
The TRS P consists of the following rules:

   U42^1(tt, M, N) -> _>_^1(N, M)
   _>_^1(s_(N), s_(M)) -> U41^1(tt, M, N)
   U41^1(tt, M, N) -> U42^1(tt, M, N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(13) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(14)
Obligation:
The TRS P consists of the following rules:

   U42^1(tt, M, N) -> _>_^1(N, M)
   _>_^1(s_(N), s_(M)) -> U41^1(tt, M, N)
   U41^1(tt, M, N) -> U42^1(tt, M, N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(15) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the improved usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding improved usable rules can be oriented non-strictly, the improved  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and improved usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   _>_^1(s_(N), s_(M)) -> U41^1(tt, M, N)
   U41^1(tt, M, N) -> U42^1(tt, M, N)
The following rules are removed from R:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)
The following equations are removed from E:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(U41^1(x_1, x_2, x_3)) = 2 + 2*x_1 + 2*x_2 + 3*x_3
   POL(U42^1(x_1, x_2, x_3)) = 2*x_1 + x_2 + 3*x_3
   POL(_>_^1(x_1, x_2)) = 2 + 3*x_1 + x_2
   POL(s_(x_1)) = 2 + 3*x_1
   POL(tt) = 1


----------------------------------------

(16)
Obligation:
The TRS P consists of the following rules:

   U42^1(tt, M, N) -> _>_^1(N, M)

R is empty.
E is empty.
E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(17) EDependencyGraphProof (EQUIVALENT)
The approximation of the Equational Dependency Graph [DA_STEIN] contains 0 SCCs with 1 less node.
----------------------------------------

(18)
TRUE

----------------------------------------

(19)
Obligation:
The TRS P consists of the following rules:

   U82^1(tt, M', N) -> U83^1(equal(_>_(N, M'), true), M', N)
   QUOT(N, M') -> U81^1(tt, M', N)
   U81^1(tt, M', N) -> U82^1(tt, M', N)
   U83^1(tt, M', N) -> QUOT(d(N, M'), M')

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(20) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(21)
Obligation:
The TRS P consists of the following rules:

   U82^1(tt, M', N) -> U83^1(equal(_>_(N, M'), true), M', N)
   QUOT(N, M') -> U81^1(tt, M', N)
   U81^1(tt, M', N) -> U82^1(tt, M', N)
   U83^1(tt, M', N) -> QUOT(d(N, M'), M')

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(22) EUsableRulesProof (EQUIVALENT)
We use the improved usable rules and equations processor [DA_STEIN] to delete all non-usable rules from R and all non-usable equations from E, but we lose minimality and add the following 2 Ce-rules:
   c(x, y) -> x
   c(x, y) -> y

----------------------------------------

(23)
Obligation:
The TRS P consists of the following rules:

   U82^1(tt, M', N) -> U83^1(equal(_>_(N, M'), true), M', N)
   QUOT(N, M') -> U81^1(tt, M', N)
   U81^1(tt, M', N) -> U82^1(tt, M', N)
   U83^1(tt, M', N) -> QUOT(d(N, M'), M')

The TRS R consists of the following rules:

   equal(X, X) -> tt
   _>_(0, M) -> false
   U42(tt, M, N) -> _>_(N, M)
   U41(tt, M, N) -> U42(tt, M, N)
   d(s_(N), s_(M)) -> U51(tt, M, N)
   U51(tt, M, N) -> U52(tt, M, N)
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   _>_(N', 0) -> true
   U52(tt, M, N) -> d(N, M)
   d(0, N) -> N
   c(x, y) -> x
   c(x, y) -> y

The set E consists of the following equations:

   d(x, y) == d(y, x)

E# is empty.
We have to consider all (P,E#,R,E)-chains
----------------------------------------

(24)
Obligation:
The TRS P consists of the following rules:

   U62^1(tt, M', N') -> U63^1(equal(_>_(N', M'), true), M', N')
   GCD(N', M') -> U61^1(tt, M', N')
   U61^1(tt, M', N') -> U62^1(tt, M', N')
   U63^1(tt, M', N') -> GCD(d(N', M'), M')

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(25)
Obligation:
The TRS P consists of the following rules:

   _+_^1(s_(N), s_(M)) -> U21^1(tt, M, N)
   U21^1(tt, M, N) -> U22^1(tt, M, N)
   U22^1(tt, M, N) -> _+_^1(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(26)
Obligation:
The TRS P consists of the following rules:

   U12^1(tt, M, N) -> _*_^1(N, M)
   _*_^1(s_(N), s_(M)) -> U11^1(tt, M, N)
   U11^1(tt, M, N) -> U12^1(tt, M, N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M, N) -> U12(tt, M, N)
   U12(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U21(tt, M, N) -> U22(tt, M, N)
   U22(tt, M, N) -> s_(s_(_+_(N, M)))
   U31(tt, M, N) -> U32(tt, M, N)
   U32(tt, M, N) -> _>_(M, N)
   U41(tt, M, N) -> U42(tt, M, N)
   U42(tt, M, N) -> _>_(N, M)
   U51(tt, M, N) -> U52(tt, M, N)
   U52(tt, M, N) -> d(N, M)
   U61(tt, M', N') -> U62(tt, M', N')
   U62(tt, M', N') -> U63(equal(_>_(N', M'), true), M', N')
   U63(tt, M', N') -> gcd(d(N', M'), M')
   U71(tt, M', N) -> U72(tt, M', N)
   U72(tt, M', N) -> U73(equal(_>_(M', N), true))
   U73(tt) -> 0
   U81(tt, M', N) -> U82(tt, M', N)
   U82(tt, M', N) -> U83(equal(_>_(N, M'), true), M', N)
   U83(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> U11(tt, M, N)
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> U21(tt, M, N)
   _<_(N, M) -> U31(tt, M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> U41(tt, M, N)
   d(0, N) -> N
   d(s_(N), s_(M)) -> U51(tt, M, N)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U61(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U71(tt, M', N)
   quot(N, M') -> U81(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains