YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/QWZCh.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given ETRS could be proven:

(0) ETRS
(1) EquationalDependencyPairsProof [EQUIVALENT, 0 ms]
(2) EDP
(3) EDependencyGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) EDP
        (6) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (7) EDP
        (8) EUsableRulesReductionPairsProof [EQUIVALENT, 10 ms]
        (9) EDP
        (10) EDependencyGraphProof [EQUIVALENT, 0 ms]
        (11) TRUE
    (12) EDP
        (13) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (14) EDP
        (15) EDPPoloProof [EQUIVALENT, 11 ms]
        (16) EDP
        (17) PisEmptyProof [EQUIVALENT, 0 ms]
        (18) YES
    (19) EDP
        (20) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (21) EDP
        (22) EDPPoloProof [EQUIVALENT, 127 ms]
        (23) EDP
        (24) EDependencyGraphProof [EQUIVALENT, 0 ms]
        (25) EDP
        (26) EDPPoloProof [EQUIVALENT, 185 ms]
        (27) EDP
        (28) PisEmptyProof [EQUIVALENT, 0 ms]
        (29) YES
    (30) EDP
        (31) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (32) EDP
        (33) EDPPoloProof [EQUIVALENT, 308 ms]
        (34) EDP
        (35) PisEmptyProof [EQUIVALENT, 0 ms]
        (36) YES


----------------------------------------

(0)
Obligation:
Equational rewrite system:
The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))


----------------------------------------

(1) EquationalDependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,DA_STEIN] we result in the following initial EDP problem:
The TRS P consists of the following rules:

   U101^1(tt, A, B) -> U102^1(isBool(B), A, B)
   U101^1(tt, A, B) -> ISBOOL(B)
   U102^1(tt, A, B) -> _XOR_(_and_(A, B), _xor_(A, B))
   U102^1(tt, A, B) -> _AND_(A, B)
   U102^1(tt, A, B) -> _XOR_(A, B)
   U131^1(tt, B, U', U) -> U132^1(isS(U'), B, U', U)
   U132^1(tt, B, U', U) -> U133^1(isS(U), B, U')
   U133^1(tt, B, U') -> U134^1(equal(_isNotEqualTo_(B, true), true), U')
   U133^1(tt, B, U') -> EQUAL(_isNotEqualTo_(B, true), true)
   U133^1(tt, B, U') -> _ISNOTEQUALTO_(B, true)
   U141^1(tt, U) -> U142^1(isS(U), U)
   U151^1(tt, V2) -> U152^1(isBool(V2))
   U151^1(tt, V2) -> ISBOOL(V2)
   U161^1(tt, V2) -> U162^1(isBool(V2))
   U161^1(tt, V2) -> ISBOOL(V2)
   U171^1(tt, V2) -> U172^1(isUniversal(V2))
   U181^1(tt, V2) -> U182^1(isUniversal(V2))
   U191^1(tt, V2) -> U192^1(isBool(V2))
   U191^1(tt, V2) -> ISBOOL(V2)
   U201^1(tt, V2) -> U202^1(isBool(V2))
   U201^1(tt, V2) -> ISBOOL(V2)
   U21^1(tt, A, B, C) -> U22^1(isBool(B), A, B, C)
   U21^1(tt, A, B, C) -> ISBOOL(B)
   U22^1(tt, A, B, C) -> U23^1(isBool(C), A, B, C)
   U22^1(tt, A, B, C) -> ISBOOL(C)
   U221^1(tt, A) -> _XOR_(A, true)
   U23^1(tt, A, B, C) -> _XOR_(_and_(A, B), _and_(A, C))
   U23^1(tt, A, B, C) -> _AND_(A, B)
   U23^1(tt, A, B, C) -> _AND_(A, C)
   U51^1(tt, A, B) -> U52^1(isBool(B), A, B)
   U51^1(tt, A, B) -> ISBOOL(B)
   U52^1(tt, A, B) -> NOT_(_xor_(A, _and_(A, B)))
   U52^1(tt, A, B) -> _XOR_(A, _and_(A, B))
   U52^1(tt, A, B) -> _AND_(A, B)
   U61^1(tt, U', U) -> U62^1(isS(U), U', U)
   U62^1(tt, U', U) -> U63^1(equal(_isNotEqualTo_(U, U'), true))
   U62^1(tt, U', U) -> EQUAL(_isNotEqualTo_(U, U'), true)
   U62^1(tt, U', U) -> _ISNOTEQUALTO_(U, U')
   U81^1(tt, U', U) -> U82^1(isS(U), U', U)
   U82^1(tt, U', U) -> IF_THEN_ELSE_FI(_isEqualTo_(U, U'), false, true)
   U82^1(tt, U', U) -> _ISEQUALTO_(U, U')
   _AND_(A, A) -> U11^1(isBool(A), A)
   _AND_(A, A) -> ISBOOL(A)
   _AND_(A, _xor_(B, C)) -> U21^1(isBool(A), A, B, C)
   _AND_(A, _xor_(B, C)) -> ISBOOL(A)
   _AND_(false, A) -> U31^1(isBool(A))
   _AND_(false, A) -> ISBOOL(A)
   _AND_(true, A) -> U41^1(isBool(A), A)
   _AND_(true, A) -> ISBOOL(A)
   _IMPLIES_(A, B) -> U51^1(isBool(A), A, B)
   _IMPLIES_(A, B) -> ISBOOL(A)
   _ISEQUALTO_(U, U') -> U61^1(isS(U'), U', U)
   _ISEQUALTO_(U, U) -> U71^1(isS(U))
   _ISNOTEQUALTO_(U, U') -> U81^1(isS(U'), U', U)
   _ISNOTEQUALTO_(U, U) -> U91^1(isS(U))
   _OR_(A, B) -> U101^1(isBool(A), A, B)
   _OR_(A, B) -> ISBOOL(A)
   _XOR_(A, A) -> U111^1(isBool(A))
   _XOR_(A, A) -> ISBOOL(A)
   _XOR_(false, A) -> U121^1(isBool(A), A)
   _XOR_(false, A) -> ISBOOL(A)
   IF_THEN_ELSE_FI(B, U, U') -> U131^1(isBool(B), B, U', U)
   IF_THEN_ELSE_FI(B, U, U') -> ISBOOL(B)
   IF_THEN_ELSE_FI(true, U, U') -> U141^1(isS(U'), U)
   ISBOOL(_and_(V1, V2)) -> U151^1(isBool(V1), V2)
   ISBOOL(_and_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_implies_(V1, V2)) -> U161^1(isBool(V1), V2)
   ISBOOL(_implies_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_isEqualTo_(V1, V2)) -> U171^1(isUniversal(V1), V2)
   ISBOOL(_isNotEqualTo_(V1, V2)) -> U181^1(isUniversal(V1), V2)
   ISBOOL(_or_(V1, V2)) -> U191^1(isBool(V1), V2)
   ISBOOL(_or_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_xor_(V1, V2)) -> U201^1(isBool(V1), V2)
   ISBOOL(_xor_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(not_(V1)) -> U211^1(isBool(V1))
   ISBOOL(not_(V1)) -> ISBOOL(V1)
   NOT_(A) -> U221^1(isBool(A), A)
   NOT_(A) -> ISBOOL(A)
   _AND_(_and_(A, A), ext) -> _AND_(U11(isBool(A), A), ext)
   _AND_(_and_(A, A), ext) -> U11^1(isBool(A), A)
   _AND_(_and_(A, A), ext) -> ISBOOL(A)
   _AND_(_and_(A, _xor_(B, C)), ext) -> _AND_(U21(isBool(A), A, B, C), ext)
   _AND_(_and_(A, _xor_(B, C)), ext) -> U21^1(isBool(A), A, B, C)
   _AND_(_and_(A, _xor_(B, C)), ext) -> ISBOOL(A)
   _AND_(_and_(false, A), ext) -> _AND_(U31(isBool(A)), ext)
   _AND_(_and_(false, A), ext) -> U31^1(isBool(A))
   _AND_(_and_(false, A), ext) -> ISBOOL(A)
   _AND_(_and_(true, A), ext) -> _AND_(U41(isBool(A), A), ext)
   _AND_(_and_(true, A), ext) -> U41^1(isBool(A), A)
   _AND_(_and_(true, A), ext) -> ISBOOL(A)
   _OR_(_or_(A, B), ext) -> _OR_(U101(isBool(A), A, B), ext)
   _OR_(_or_(A, B), ext) -> U101^1(isBool(A), A, B)
   _OR_(_or_(A, B), ext) -> ISBOOL(A)
   _XOR_(_xor_(A, A), ext) -> _XOR_(U111(isBool(A)), ext)
   _XOR_(_xor_(A, A), ext) -> U111^1(isBool(A))
   _XOR_(_xor_(A, A), ext) -> ISBOOL(A)
   _XOR_(_xor_(false, A), ext) -> _XOR_(U121(isBool(A), A), ext)
   _XOR_(_xor_(false, A), ext) -> U121^1(isBool(A), A)
   _XOR_(_xor_(false, A), ext) -> ISBOOL(A)

The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _AND_(x, y) == _AND_(y, x)
   _OR_(x, y) == _OR_(y, x)
   _XOR_(x, y) == _XOR_(y, x)
   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _OR_(_or_(x, y), z) == _OR_(x, _or_(y, z))
   _XOR_(_xor_(x, y), z) == _XOR_(x, _xor_(y, z))

We have to consider all minimal (P,E#,R,E)-chains

----------------------------------------

(2)
Obligation:
The TRS P consists of the following rules:

   U101^1(tt, A, B) -> U102^1(isBool(B), A, B)
   U101^1(tt, A, B) -> ISBOOL(B)
   U102^1(tt, A, B) -> _XOR_(_and_(A, B), _xor_(A, B))
   U102^1(tt, A, B) -> _AND_(A, B)
   U102^1(tt, A, B) -> _XOR_(A, B)
   U131^1(tt, B, U', U) -> U132^1(isS(U'), B, U', U)
   U132^1(tt, B, U', U) -> U133^1(isS(U), B, U')
   U133^1(tt, B, U') -> U134^1(equal(_isNotEqualTo_(B, true), true), U')
   U133^1(tt, B, U') -> EQUAL(_isNotEqualTo_(B, true), true)
   U133^1(tt, B, U') -> _ISNOTEQUALTO_(B, true)
   U141^1(tt, U) -> U142^1(isS(U), U)
   U151^1(tt, V2) -> U152^1(isBool(V2))
   U151^1(tt, V2) -> ISBOOL(V2)
   U161^1(tt, V2) -> U162^1(isBool(V2))
   U161^1(tt, V2) -> ISBOOL(V2)
   U171^1(tt, V2) -> U172^1(isUniversal(V2))
   U181^1(tt, V2) -> U182^1(isUniversal(V2))
   U191^1(tt, V2) -> U192^1(isBool(V2))
   U191^1(tt, V2) -> ISBOOL(V2)
   U201^1(tt, V2) -> U202^1(isBool(V2))
   U201^1(tt, V2) -> ISBOOL(V2)
   U21^1(tt, A, B, C) -> U22^1(isBool(B), A, B, C)
   U21^1(tt, A, B, C) -> ISBOOL(B)
   U22^1(tt, A, B, C) -> U23^1(isBool(C), A, B, C)
   U22^1(tt, A, B, C) -> ISBOOL(C)
   U221^1(tt, A) -> _XOR_(A, true)
   U23^1(tt, A, B, C) -> _XOR_(_and_(A, B), _and_(A, C))
   U23^1(tt, A, B, C) -> _AND_(A, B)
   U23^1(tt, A, B, C) -> _AND_(A, C)
   U51^1(tt, A, B) -> U52^1(isBool(B), A, B)
   U51^1(tt, A, B) -> ISBOOL(B)
   U52^1(tt, A, B) -> NOT_(_xor_(A, _and_(A, B)))
   U52^1(tt, A, B) -> _XOR_(A, _and_(A, B))
   U52^1(tt, A, B) -> _AND_(A, B)
   U61^1(tt, U', U) -> U62^1(isS(U), U', U)
   U62^1(tt, U', U) -> U63^1(equal(_isNotEqualTo_(U, U'), true))
   U62^1(tt, U', U) -> EQUAL(_isNotEqualTo_(U, U'), true)
   U62^1(tt, U', U) -> _ISNOTEQUALTO_(U, U')
   U81^1(tt, U', U) -> U82^1(isS(U), U', U)
   U82^1(tt, U', U) -> IF_THEN_ELSE_FI(_isEqualTo_(U, U'), false, true)
   U82^1(tt, U', U) -> _ISEQUALTO_(U, U')
   _AND_(A, A) -> U11^1(isBool(A), A)
   _AND_(A, A) -> ISBOOL(A)
   _AND_(A, _xor_(B, C)) -> U21^1(isBool(A), A, B, C)
   _AND_(A, _xor_(B, C)) -> ISBOOL(A)
   _AND_(false, A) -> U31^1(isBool(A))
   _AND_(false, A) -> ISBOOL(A)
   _AND_(true, A) -> U41^1(isBool(A), A)
   _AND_(true, A) -> ISBOOL(A)
   _IMPLIES_(A, B) -> U51^1(isBool(A), A, B)
   _IMPLIES_(A, B) -> ISBOOL(A)
   _ISEQUALTO_(U, U') -> U61^1(isS(U'), U', U)
   _ISEQUALTO_(U, U) -> U71^1(isS(U))
   _ISNOTEQUALTO_(U, U') -> U81^1(isS(U'), U', U)
   _ISNOTEQUALTO_(U, U) -> U91^1(isS(U))
   _OR_(A, B) -> U101^1(isBool(A), A, B)
   _OR_(A, B) -> ISBOOL(A)
   _XOR_(A, A) -> U111^1(isBool(A))
   _XOR_(A, A) -> ISBOOL(A)
   _XOR_(false, A) -> U121^1(isBool(A), A)
   _XOR_(false, A) -> ISBOOL(A)
   IF_THEN_ELSE_FI(B, U, U') -> U131^1(isBool(B), B, U', U)
   IF_THEN_ELSE_FI(B, U, U') -> ISBOOL(B)
   IF_THEN_ELSE_FI(true, U, U') -> U141^1(isS(U'), U)
   ISBOOL(_and_(V1, V2)) -> U151^1(isBool(V1), V2)
   ISBOOL(_and_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_implies_(V1, V2)) -> U161^1(isBool(V1), V2)
   ISBOOL(_implies_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_isEqualTo_(V1, V2)) -> U171^1(isUniversal(V1), V2)
   ISBOOL(_isNotEqualTo_(V1, V2)) -> U181^1(isUniversal(V1), V2)
   ISBOOL(_or_(V1, V2)) -> U191^1(isBool(V1), V2)
   ISBOOL(_or_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_xor_(V1, V2)) -> U201^1(isBool(V1), V2)
   ISBOOL(_xor_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(not_(V1)) -> U211^1(isBool(V1))
   ISBOOL(not_(V1)) -> ISBOOL(V1)
   NOT_(A) -> U221^1(isBool(A), A)
   NOT_(A) -> ISBOOL(A)
   _AND_(_and_(A, A), ext) -> _AND_(U11(isBool(A), A), ext)
   _AND_(_and_(A, A), ext) -> U11^1(isBool(A), A)
   _AND_(_and_(A, A), ext) -> ISBOOL(A)
   _AND_(_and_(A, _xor_(B, C)), ext) -> _AND_(U21(isBool(A), A, B, C), ext)
   _AND_(_and_(A, _xor_(B, C)), ext) -> U21^1(isBool(A), A, B, C)
   _AND_(_and_(A, _xor_(B, C)), ext) -> ISBOOL(A)
   _AND_(_and_(false, A), ext) -> _AND_(U31(isBool(A)), ext)
   _AND_(_and_(false, A), ext) -> U31^1(isBool(A))
   _AND_(_and_(false, A), ext) -> ISBOOL(A)
   _AND_(_and_(true, A), ext) -> _AND_(U41(isBool(A), A), ext)
   _AND_(_and_(true, A), ext) -> U41^1(isBool(A), A)
   _AND_(_and_(true, A), ext) -> ISBOOL(A)
   _OR_(_or_(A, B), ext) -> _OR_(U101(isBool(A), A, B), ext)
   _OR_(_or_(A, B), ext) -> U101^1(isBool(A), A, B)
   _OR_(_or_(A, B), ext) -> ISBOOL(A)
   _XOR_(_xor_(A, A), ext) -> _XOR_(U111(isBool(A)), ext)
   _XOR_(_xor_(A, A), ext) -> U111^1(isBool(A))
   _XOR_(_xor_(A, A), ext) -> ISBOOL(A)
   _XOR_(_xor_(false, A), ext) -> _XOR_(U121(isBool(A), A), ext)
   _XOR_(_xor_(false, A), ext) -> U121^1(isBool(A), A)
   _XOR_(_xor_(false, A), ext) -> ISBOOL(A)

The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _AND_(x, y) == _AND_(y, x)
   _OR_(x, y) == _OR_(y, x)
   _XOR_(x, y) == _XOR_(y, x)
   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _OR_(_or_(x, y), z) == _OR_(x, _or_(y, z))
   _XOR_(_xor_(x, y), z) == _XOR_(x, _xor_(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(3) EDependencyGraphProof (EQUIVALENT)
The approximation of the Equational Dependency Graph [DA_STEIN] contains 4 SCCs with 73 less nodes.
----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
The TRS P consists of the following rules:

   U161^1(tt, V2) -> ISBOOL(V2)
   ISBOOL(_and_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_implies_(V1, V2)) -> U161^1(isBool(V1), V2)
   ISBOOL(_xor_(V1, V2)) -> U201^1(isBool(V1), V2)
   U151^1(tt, V2) -> ISBOOL(V2)
   ISBOOL(not_(V1)) -> ISBOOL(V1)
   ISBOOL(_or_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_implies_(V1, V2)) -> ISBOOL(V1)
   U201^1(tt, V2) -> ISBOOL(V2)
   ISBOOL(_or_(V1, V2)) -> U191^1(isBool(V1), V2)
   ISBOOL(_and_(V1, V2)) -> U151^1(isBool(V1), V2)
   U191^1(tt, V2) -> ISBOOL(V2)
   ISBOOL(_xor_(V1, V2)) -> ISBOOL(V1)

The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _AND_(x, y) == _AND_(y, x)
   _OR_(x, y) == _OR_(y, x)
   _XOR_(x, y) == _XOR_(y, x)
   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _OR_(_or_(x, y), z) == _OR_(x, _or_(y, z))
   _XOR_(_xor_(x, y), z) == _XOR_(x, _xor_(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(6) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _AND_(x, y) == _AND_(y, x)
   _OR_(x, y) == _OR_(y, x)
   _XOR_(x, y) == _XOR_(y, x)
   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _OR_(_or_(x, y), z) == _OR_(x, _or_(y, z))
   _XOR_(_xor_(x, y), z) == _XOR_(x, _xor_(y, z))

----------------------------------------

(7)
Obligation:
The TRS P consists of the following rules:

   U161^1(tt, V2) -> ISBOOL(V2)
   ISBOOL(_and_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_implies_(V1, V2)) -> U161^1(isBool(V1), V2)
   ISBOOL(_xor_(V1, V2)) -> U201^1(isBool(V1), V2)
   U151^1(tt, V2) -> ISBOOL(V2)
   ISBOOL(not_(V1)) -> ISBOOL(V1)
   ISBOOL(_or_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_implies_(V1, V2)) -> ISBOOL(V1)
   U201^1(tt, V2) -> ISBOOL(V2)
   ISBOOL(_or_(V1, V2)) -> U191^1(isBool(V1), V2)
   ISBOOL(_and_(V1, V2)) -> U151^1(isBool(V1), V2)
   U191^1(tt, V2) -> ISBOOL(V2)
   ISBOOL(_xor_(V1, V2)) -> ISBOOL(V1)

The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(8) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules can be oriented non-strictly, the  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   ISBOOL(_and_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_implies_(V1, V2)) -> U161^1(isBool(V1), V2)
   ISBOOL(_xor_(V1, V2)) -> U201^1(isBool(V1), V2)
   ISBOOL(not_(V1)) -> ISBOOL(V1)
   ISBOOL(_or_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_implies_(V1, V2)) -> ISBOOL(V1)
   ISBOOL(_or_(V1, V2)) -> U191^1(isBool(V1), V2)
   ISBOOL(_and_(V1, V2)) -> U151^1(isBool(V1), V2)
   ISBOOL(_xor_(V1, V2)) -> ISBOOL(V1)
The following rules are removed from R:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U171(tt, V2) -> U172(isUniversal(V2))
   U201(tt, V2) -> U202(isBool(V2))
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)
The following equations are removed from E:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(ISBOOL(x_1)) = 2*x_1
   POL(U151(x_1, x_2)) = 2*x_1 + 3*x_2
   POL(U151^1(x_1, x_2)) = 2*x_1 + 3*x_2
   POL(U152(x_1)) = x_1
   POL(U161(x_1, x_2)) = 2*x_1 + 3*x_2
   POL(U161^1(x_1, x_2)) = 2*x_1 + 3*x_2
   POL(U162(x_1)) = x_1
   POL(U171(x_1, x_2)) = 2 + 2*x_1 + 3*x_2
   POL(U172(x_1)) = x_1
   POL(U181(x_1, x_2)) = 2*x_1 + 3*x_2
   POL(U182(x_1)) = x_1
   POL(U191(x_1, x_2)) = 2*x_1 + 3*x_2
   POL(U191^1(x_1, x_2)) = 2*x_1 + 3*x_2
   POL(U192(x_1)) = x_1
   POL(U201(x_1, x_2)) = 1 + 2*x_1 + 3*x_2
   POL(U201^1(x_1, x_2)) = 2*x_1 + 3*x_2
   POL(U202(x_1)) = x_1
   POL(U211(x_1)) = 2*x_1
   POL(_and_(x_1, x_2)) = 2 + 3*x_1 + 3*x_2
   POL(_implies_(x_1, x_2)) = 3 + 3*x_1 + 3*x_2
   POL(_isEqualTo_(x_1, x_2)) = 2 + 3*x_1 + 3*x_2
   POL(_isNotEqualTo_(x_1, x_2)) = 1 + 3*x_1 + 3*x_2
   POL(_or_(x_1, x_2)) = 3*x_1 + 3*x_2
   POL(_xor_(x_1, x_2)) = 1 + 3*x_1 + 3*x_2
   POL(false) = 0
   POL(isBool(x_1)) = 2*x_1
   POL(isUniversal(x_1)) = 2*x_1
   POL(not_(x_1)) = 3 + 3*x_1
   POL(true) = 0
   POL(tt) = 0


----------------------------------------

(9)
Obligation:
The TRS P consists of the following rules:

   U161^1(tt, V2) -> ISBOOL(V2)
   U151^1(tt, V2) -> ISBOOL(V2)
   U201^1(tt, V2) -> ISBOOL(V2)
   U191^1(tt, V2) -> ISBOOL(V2)

The TRS R consists of the following rules:

   U162(tt) -> tt
   U202(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U161(tt, V2) -> U162(isBool(V2))
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U172(tt) -> tt
   U192(tt) -> tt
   U182(tt) -> tt
   U211(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))

E is empty.
E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(10) EDependencyGraphProof (EQUIVALENT)
The approximation of the Equational Dependency Graph [DA_STEIN] contains 0 SCCs with 4 less nodes.
----------------------------------------

(11)
TRUE

----------------------------------------

(12)
Obligation:
The TRS P consists of the following rules:

   _XOR_(_xor_(A, A), ext) -> _XOR_(U111(isBool(A)), ext)
   _XOR_(_xor_(false, A), ext) -> _XOR_(U121(isBool(A), A), ext)

The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _AND_(x, y) == _AND_(y, x)
   _OR_(x, y) == _OR_(y, x)
   _XOR_(x, y) == _XOR_(y, x)
   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _OR_(_or_(x, y), z) == _OR_(x, _or_(y, z))
   _XOR_(_xor_(x, y), z) == _XOR_(x, _xor_(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(13) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _AND_(x, y) == _AND_(y, x)
   _OR_(x, y) == _OR_(y, x)
   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _OR_(_or_(x, y), z) == _OR_(x, _or_(y, z))

----------------------------------------

(14)
Obligation:
The TRS P consists of the following rules:

   _XOR_(_xor_(A, A), ext) -> _XOR_(U111(isBool(A)), ext)
   _XOR_(_xor_(false, A), ext) -> _XOR_(U121(isBool(A), A), ext)

The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _XOR_(x, y) == _XOR_(y, x)
   _XOR_(_xor_(x, y), z) == _XOR_(x, _xor_(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(15) EDPPoloProof (EQUIVALENT)
We use the reduction pair processor [DA_STEIN] with a polynomial ordering [POLO]. All Dependency Pairs of this DP problem can be strictly oriented.


   _XOR_(_xor_(A, A), ext) -> _XOR_(U111(isBool(A)), ext)
   _XOR_(_xor_(false, A), ext) -> _XOR_(U121(isBool(A), A), ext)
With the implicit AFS we had to orient the following set of usable rules of R non-strictly.


   U111(tt) -> false
   _xor_(false, A) -> U121(isBool(A), A)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   U121(tt, A) -> A
We had to orient the following equations of E# equivalently.


   _XOR_(x, y) == _XOR_(y, x)
   _XOR_(_xor_(x, y), z) == _XOR_(x, _xor_(y, z))
With the implicit AFS we had to orient the following usable equations of E equivalently.


   _xor_(x, y) == _xor_(y, x)
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(U111(x_1)) = 1
   POL(U121(x_1, x_2)) = x_2
   POL(U151(x_1, x_2)) = 3 + 3*x_2
   POL(U152(x_1)) = 3
   POL(U161(x_1, x_2)) = 3 + 3*x_2
   POL(U162(x_1)) = 3
   POL(U171(x_1, x_2)) = 3 + 3*x_2
   POL(U172(x_1)) = 3
   POL(U181(x_1, x_2)) = 3 + 3*x_2
   POL(U182(x_1)) = 3
   POL(U191(x_1, x_2)) = 3 + 3*x_2
   POL(U192(x_1)) = 3
   POL(U201(x_1, x_2)) = 3 + 3*x_2
   POL(U202(x_1)) = 3
   POL(U211(x_1)) = 3
   POL(_XOR_(x_1, x_2)) = x_1 + x_2
   POL(_and_(x_1, x_2)) = 0
   POL(_implies_(x_1, x_2)) = 0
   POL(_isEqualTo_(x_1, x_2)) = 0
   POL(_isNotEqualTo_(x_1, x_2)) = 0
   POL(_or_(x_1, x_2)) = 0
   POL(_xor_(x_1, x_2)) = 2 + x_1 + x_2
   POL(false) = 1
   POL(isBool(x_1)) = 0
   POL(isUniversal(x_1)) = 0
   POL(not_(x_1)) = 0
   POL(true) = 0
   POL(tt) = 0


----------------------------------------

(16)
Obligation:
P is empty.
The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _XOR_(x, y) == _XOR_(y, x)
   _XOR_(_xor_(x, y), z) == _XOR_(x, _xor_(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(17) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(18)
YES

----------------------------------------

(19)
Obligation:
The TRS P consists of the following rules:

   _AND_(_and_(A, _xor_(B, C)), ext) -> _AND_(U21(isBool(A), A, B, C), ext)
   _AND_(_and_(A, A), ext) -> _AND_(U11(isBool(A), A), ext)
   _AND_(_and_(A, _xor_(B, C)), ext) -> U21^1(isBool(A), A, B, C)
   _AND_(_and_(false, A), ext) -> _AND_(U31(isBool(A)), ext)
   U23^1(tt, A, B, C) -> _AND_(A, C)
   _AND_(_and_(true, A), ext) -> _AND_(U41(isBool(A), A), ext)
   U21^1(tt, A, B, C) -> U22^1(isBool(B), A, B, C)
   U22^1(tt, A, B, C) -> U23^1(isBool(C), A, B, C)
   U23^1(tt, A, B, C) -> _AND_(A, B)
   _AND_(A, _xor_(B, C)) -> U21^1(isBool(A), A, B, C)

The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _AND_(x, y) == _AND_(y, x)
   _OR_(x, y) == _OR_(y, x)
   _XOR_(x, y) == _XOR_(y, x)
   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _OR_(_or_(x, y), z) == _OR_(x, _or_(y, z))
   _XOR_(_xor_(x, y), z) == _XOR_(x, _xor_(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(20) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _OR_(x, y) == _OR_(y, x)
   _XOR_(x, y) == _XOR_(y, x)
   _OR_(_or_(x, y), z) == _OR_(x, _or_(y, z))
   _XOR_(_xor_(x, y), z) == _XOR_(x, _xor_(y, z))

----------------------------------------

(21)
Obligation:
The TRS P consists of the following rules:

   _AND_(_and_(A, _xor_(B, C)), ext) -> _AND_(U21(isBool(A), A, B, C), ext)
   _AND_(_and_(A, A), ext) -> _AND_(U11(isBool(A), A), ext)
   _AND_(_and_(A, _xor_(B, C)), ext) -> U21^1(isBool(A), A, B, C)
   _AND_(_and_(false, A), ext) -> _AND_(U31(isBool(A)), ext)
   U23^1(tt, A, B, C) -> _AND_(A, C)
   _AND_(_and_(true, A), ext) -> _AND_(U41(isBool(A), A), ext)
   U21^1(tt, A, B, C) -> U22^1(isBool(B), A, B, C)
   U22^1(tt, A, B, C) -> U23^1(isBool(C), A, B, C)
   U23^1(tt, A, B, C) -> _AND_(A, B)
   _AND_(A, _xor_(B, C)) -> U21^1(isBool(A), A, B, C)

The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _AND_(x, y) == _AND_(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(22) EDPPoloProof (EQUIVALENT)
We use the reduction pair processor [DA_STEIN] with a polynomial ordering [POLO]. The following set of Dependency Pairs of this DP problem can be strictly oriented.


   _AND_(_and_(A, _xor_(B, C)), ext) -> U21^1(isBool(A), A, B, C)
   _AND_(_and_(true, A), ext) -> _AND_(U41(isBool(A), A), ext)
   _AND_(A, _xor_(B, C)) -> U21^1(isBool(A), A, B, C)
The remaining Dependency Pairs were at least non-strictly oriented.


   _AND_(_and_(A, _xor_(B, C)), ext) -> _AND_(U21(isBool(A), A, B, C), ext)
   _AND_(_and_(A, A), ext) -> _AND_(U11(isBool(A), A), ext)
   _AND_(_and_(false, A), ext) -> _AND_(U31(isBool(A)), ext)
   U23^1(tt, A, B, C) -> _AND_(A, C)
   U21^1(tt, A, B, C) -> U22^1(isBool(B), A, B, C)
   U22^1(tt, A, B, C) -> U23^1(isBool(C), A, B, C)
   U23^1(tt, A, B, C) -> _AND_(A, B)
With the implicit AFS we had to orient the following set of usable rules of R non-strictly.


   U202(tt) -> tt
   _xor_(false, A) -> U121(isBool(A), A)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   U191(tt, V2) -> U192(isBool(V2))
   U171(tt, V2) -> U172(isUniversal(V2))
   U182(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(true) -> tt
   isBool(not_(V1)) -> U211(isBool(V1))
   isBool(false) -> tt
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   U121(tt, A) -> A
   U151(tt, V2) -> U152(isBool(V2))
   U192(tt) -> tt
   U41(tt, A) -> A
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U172(tt) -> tt
   U211(tt) -> tt
   U11(tt, A) -> A
   U152(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U31(tt) -> false
   U162(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U181(tt, V2) -> U182(isUniversal(V2))
   _and_(false, A) -> U31(isBool(A))
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(A, A) -> U11(isBool(A), A)
   _and_(true, A) -> U41(isBool(A), A)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   U111(tt) -> false
We had to orient the following equations of E# equivalently.


   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _AND_(x, y) == _AND_(y, x)
With the implicit AFS we had to orient the following usable equations of E equivalently.


   _xor_(x, y) == _xor_(y, x)
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _and_(x, y) == _and_(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(U11(x_1, x_2)) = x_2
   POL(U111(x_1)) = 0
   POL(U121(x_1, x_2)) = x_1 + x_1*x_2
   POL(U151(x_1, x_2)) = x_1
   POL(U152(x_1)) = x_1^2
   POL(U161(x_1, x_2)) = x_1
   POL(U162(x_1)) = x_1^2
   POL(U171(x_1, x_2)) = x_1
   POL(U172(x_1)) = x_1
   POL(U181(x_1, x_2)) = 1
   POL(U182(x_1)) = x_1
   POL(U191(x_1, x_2)) = x_1
   POL(U192(x_1)) = x_1^2
   POL(U201(x_1, x_2)) = x_1
   POL(U202(x_1)) = 1
   POL(U21(x_1, x_2, x_3, x_4)) = x_1 + x_1*x_2 + x_1*x_3 + x_2 + x_2*x_3 + x_2*x_4 + x_4
   POL(U211(x_1)) = x_1^2
   POL(U21^1(x_1, x_2, x_3, x_4)) = x_1*x_2*x_3 + x_1*x_2*x_4 + x_1*x_3 + x_1*x_4 + x_2
   POL(U22(x_1, x_2, x_3, x_4)) = 1 + x_1*x_2 + x_1*x_2*x_3 + x_1*x_3 + x_1*x_4 + x_2 + x_2*x_4
   POL(U22^1(x_1, x_2, x_3, x_4)) = x_1*x_2*x_3 + x_2 + x_2*x_4 + x_3 + x_4
   POL(U23(x_1, x_2, x_3, x_4)) = 1 + x_1*x_2 + x_2 + x_2*x_3 + x_2*x_4 + x_3 + x_4
   POL(U23^1(x_1, x_2, x_3, x_4)) = x_1*x_4 + x_2 + x_2*x_3 + x_2*x_4 + x_3
   POL(U31(x_1)) = 0
   POL(U41(x_1, x_2)) = x_2
   POL(_AND_(x_1, x_2)) = x_1 + x_1*x_2 + x_2
   POL(_and_(x_1, x_2)) = x_1 + x_1*x_2 + x_2
   POL(_implies_(x_1, x_2)) = 1 + x_1 + x_1*x_2 + x_2
   POL(_isEqualTo_(x_1, x_2)) = 1 + x_1 + x_1*x_2 + x_2
   POL(_isNotEqualTo_(x_1, x_2)) = 1 + x_1 + x_1*x_2 + x_2
   POL(_or_(x_1, x_2)) = 1 + x_1 + x_1*x_2 + x_2
   POL(_xor_(x_1, x_2)) = 1 + x_1 + x_2
   POL(false) = 0
   POL(isBool(x_1)) = 1
   POL(isUniversal(x_1)) = 1
   POL(not_(x_1)) = 0
   POL(true) = 1
   POL(tt) = 1


----------------------------------------

(23)
Obligation:
The TRS P consists of the following rules:

   _AND_(_and_(A, _xor_(B, C)), ext) -> _AND_(U21(isBool(A), A, B, C), ext)
   _AND_(_and_(A, A), ext) -> _AND_(U11(isBool(A), A), ext)
   _AND_(_and_(false, A), ext) -> _AND_(U31(isBool(A)), ext)
   U23^1(tt, A, B, C) -> _AND_(A, C)
   U21^1(tt, A, B, C) -> U22^1(isBool(B), A, B, C)
   U22^1(tt, A, B, C) -> U23^1(isBool(C), A, B, C)
   U23^1(tt, A, B, C) -> _AND_(A, B)

The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _AND_(x, y) == _AND_(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(24) EDependencyGraphProof (EQUIVALENT)
The approximation of the Equational Dependency Graph [DA_STEIN] contains 1 SCC with 4 less nodes.
----------------------------------------

(25)
Obligation:
The TRS P consists of the following rules:

   _AND_(_and_(A, _xor_(B, C)), ext) -> _AND_(U21(isBool(A), A, B, C), ext)
   _AND_(_and_(A, A), ext) -> _AND_(U11(isBool(A), A), ext)
   _AND_(_and_(false, A), ext) -> _AND_(U31(isBool(A)), ext)

The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _AND_(x, y) == _AND_(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(26) EDPPoloProof (EQUIVALENT)
We use the reduction pair processor [DA_STEIN] with a polynomial ordering [POLO]. All Dependency Pairs of this DP problem can be strictly oriented.


   _AND_(_and_(A, _xor_(B, C)), ext) -> _AND_(U21(isBool(A), A, B, C), ext)
   _AND_(_and_(A, A), ext) -> _AND_(U11(isBool(A), A), ext)
   _AND_(_and_(false, A), ext) -> _AND_(U31(isBool(A)), ext)
With the implicit AFS we had to orient the following set of usable rules of R non-strictly.


   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U151(tt, V2) -> U152(isBool(V2))
   U201(tt, V2) -> U202(isBool(V2))
   U192(tt) -> tt
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U11(tt, A) -> A
   U171(tt, V2) -> U172(isUniversal(V2))
   U202(tt) -> tt
   U31(tt) -> false
   U191(tt, V2) -> U192(isBool(V2))
   U41(tt, A) -> A
   U172(tt) -> tt
   U111(tt) -> false
   U182(tt) -> tt
   _xor_(false, A) -> U121(isBool(A), A)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _and_(false, A) -> U31(isBool(A))
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(A, A) -> U11(isBool(A), A)
   _and_(true, A) -> U41(isBool(A), A)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   U181(tt, V2) -> U182(isUniversal(V2))
   U152(tt) -> tt
   U121(tt, A) -> A
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(true) -> tt
   isBool(not_(V1)) -> U211(isBool(V1))
   isBool(false) -> tt
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U162(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
We had to orient the following equations of E# equivalently.


   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _AND_(x, y) == _AND_(y, x)
With the implicit AFS we had to orient the following usable equations of E equivalently.


   _xor_(x, y) == _xor_(y, x)
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _and_(x, y) == _and_(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(U11(x_1, x_2)) = 1 + 2*x_1*x_2
   POL(U111(x_1)) = 0
   POL(U121(x_1, x_2)) = x_2
   POL(U151(x_1, x_2)) = 2
   POL(U152(x_1)) = 2
   POL(U161(x_1, x_2)) = x_1
   POL(U162(x_1)) = 2
   POL(U171(x_1, x_2)) = 0
   POL(U172(x_1)) = 2*x_1
   POL(U181(x_1, x_2)) = 0
   POL(U182(x_1)) = 2*x_1
   POL(U191(x_1, x_2)) = x_1
   POL(U192(x_1)) = x_1
   POL(U201(x_1, x_2)) = 2
   POL(U202(x_1)) = 2
   POL(U21(x_1, x_2, x_3, x_4)) = 3 + 2*x_1 + 2*x_1*x_2 + x_1*x_3 + x_2 + x_2*x_3 + x_2*x_4 + 2*x_4
   POL(U211(x_1)) = 2
   POL(U22(x_1, x_2, x_3, x_4)) = 3 + 2*x_1 + 2*x_1*x_2 + x_1*x_3 + x_2 + x_2*x_3 + x_2*x_4 + 2*x_4
   POL(U23(x_1, x_2, x_3, x_4)) = 3 + 2*x_1 + 2*x_1*x_2 + x_1*x_3 + x_2 + x_2*x_3 + x_2*x_4 + 2*x_4
   POL(U31(x_1)) = 0
   POL(U41(x_1, x_2)) = x_2
   POL(_AND_(x_1, x_2)) = 2*x_1 + x_1*x_2 + 2*x_2
   POL(_and_(x_1, x_2)) = 2 + 2*x_1 + x_1*x_2 + 2*x_2
   POL(_implies_(x_1, x_2)) = 0
   POL(_isEqualTo_(x_1, x_2)) = 0
   POL(_isNotEqualTo_(x_1, x_2)) = 0
   POL(_or_(x_1, x_2)) = 0
   POL(_xor_(x_1, x_2)) = 3 + x_1 + x_2
   POL(false) = 0
   POL(isBool(x_1)) = 2
   POL(isUniversal(x_1)) = 0
   POL(not_(x_1)) = 0
   POL(true) = 2
   POL(tt) = 2


----------------------------------------

(27)
Obligation:
P is empty.
The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _AND_(x, y) == _AND_(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(28) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(29)
YES

----------------------------------------

(30)
Obligation:
The TRS P consists of the following rules:

   _OR_(_or_(A, B), ext) -> _OR_(U101(isBool(A), A, B), ext)

The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _AND_(x, y) == _AND_(y, x)
   _OR_(x, y) == _OR_(y, x)
   _XOR_(x, y) == _XOR_(y, x)
   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _OR_(_or_(x, y), z) == _OR_(x, _or_(y, z))
   _XOR_(_xor_(x, y), z) == _XOR_(x, _xor_(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(31) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _AND_(x, y) == _AND_(y, x)
   _XOR_(x, y) == _XOR_(y, x)
   _AND_(_and_(x, y), z) == _AND_(x, _and_(y, z))
   _XOR_(_xor_(x, y), z) == _XOR_(x, _xor_(y, z))

----------------------------------------

(32)
Obligation:
The TRS P consists of the following rules:

   _OR_(_or_(A, B), ext) -> _OR_(U101(isBool(A), A, B), ext)

The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _OR_(x, y) == _OR_(y, x)
   _OR_(_or_(x, y), z) == _OR_(x, _or_(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(33) EDPPoloProof (EQUIVALENT)
We use the reduction pair processor [DA_STEIN] with a polynomial ordering [POLO]. All Dependency Pairs of this DP problem can be strictly oriented.


   _OR_(_or_(A, B), ext) -> _OR_(U101(isBool(A), A, B), ext)
With the implicit AFS we had to orient the following set of usable rules of R non-strictly.


   U182(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U151(tt, V2) -> U152(isBool(V2))
   U201(tt, V2) -> U202(isBool(V2))
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(true) -> tt
   isBool(not_(V1)) -> U211(isBool(V1))
   isBool(false) -> tt
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _or_(A, B) -> U101(isBool(A), A, B)
   U111(tt) -> false
   U192(tt) -> tt
   U121(tt, A) -> A
   U172(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U171(tt, V2) -> U172(isUniversal(V2))
   U162(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U211(tt) -> tt
   U202(tt) -> tt
   U41(tt, A) -> A
   _and_(false, A) -> U31(isBool(A))
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(A, A) -> U11(isBool(A), A)
   _and_(true, A) -> U41(isBool(A), A)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   U31(tt) -> false
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U152(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U11(tt, A) -> A
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   _xor_(false, A) -> U121(isBool(A), A)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U101(tt, A, B) -> U102(isBool(B), A, B)
We had to orient the following equations of E# equivalently.


   _OR_(x, y) == _OR_(y, x)
   _OR_(_or_(x, y), z) == _OR_(x, _or_(y, z))
With the implicit AFS we had to orient the following usable equations of E equivalently.


   _or_(x, y) == _or_(y, x)
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _and_(x, y) == _and_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(U101(x_1, x_2, x_3)) = x_2 + 2*x_2*x_3 + x_3
   POL(U102(x_1, x_2, x_3)) = x_2 + 2*x_2*x_3 + x_3
   POL(U11(x_1, x_2)) = x_1*x_2
   POL(U111(x_1)) = x_1
   POL(U121(x_1, x_2)) = x_2
   POL(U151(x_1, x_2)) = 2*x_1*x_2
   POL(U152(x_1)) = x_1
   POL(U161(x_1, x_2)) = 2*x_2
   POL(U162(x_1)) = x_1
   POL(U171(x_1, x_2)) = 0
   POL(U172(x_1)) = 2*x_1^2
   POL(U181(x_1, x_2)) = 0
   POL(U182(x_1)) = x_1^2
   POL(U191(x_1, x_2)) = 2 + x_1*x_2
   POL(U192(x_1)) = 2
   POL(U201(x_1, x_2)) = x_1
   POL(U202(x_1)) = 1
   POL(U21(x_1, x_2, x_3, x_4)) = 2*x_2*x_3 + 2*x_2*x_4
   POL(U211(x_1)) = 1
   POL(U22(x_1, x_2, x_3, x_4)) = 2*x_2*x_3 + 2*x_2*x_4
   POL(U23(x_1, x_2, x_3, x_4)) = 2*x_2*x_3 + 2*x_2*x_4
   POL(U31(x_1)) = x_1
   POL(U41(x_1, x_2)) = x_2
   POL(_OR_(x_1, x_2)) = x_1 + x_1*x_2 + x_2
   POL(_and_(x_1, x_2)) = 2*x_1*x_2
   POL(_implies_(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(_isEqualTo_(x_1, x_2)) = 3*x_1*x_2 + 2*x_2
   POL(_isNotEqualTo_(x_1, x_2)) = 1 + x_1 + 2*x_1*x_2 + 2*x_2
   POL(_or_(x_1, x_2)) = 1 + 2*x_1 + 2*x_1*x_2 + 2*x_2
   POL(_xor_(x_1, x_2)) = x_1 + x_2
   POL(false) = 1
   POL(isBool(x_1)) = 2*x_1
   POL(isUniversal(x_1)) = 0
   POL(not_(x_1)) = 1 + x_1^2
   POL(true) = 2
   POL(tt) = 1


----------------------------------------

(34)
Obligation:
P is empty.
The TRS R consists of the following rules:

   U101(tt, A, B) -> U102(isBool(B), A, B)
   U102(tt, A, B) -> _xor_(_and_(A, B), _xor_(A, B))
   U11(tt, A) -> A
   U111(tt) -> false
   U121(tt, A) -> A
   U131(tt, B, U', U) -> U132(isS(U'), B, U', U)
   U132(tt, B, U', U) -> U133(isS(U), B, U')
   U133(tt, B, U') -> U134(equal(_isNotEqualTo_(B, true), true), U')
   U134(tt, U') -> U'
   U141(tt, U) -> U142(isS(U), U)
   U142(tt, U) -> U
   U151(tt, V2) -> U152(isBool(V2))
   U152(tt) -> tt
   U161(tt, V2) -> U162(isBool(V2))
   U162(tt) -> tt
   U171(tt, V2) -> U172(isUniversal(V2))
   U172(tt) -> tt
   U181(tt, V2) -> U182(isUniversal(V2))
   U182(tt) -> tt
   U191(tt, V2) -> U192(isBool(V2))
   U192(tt) -> tt
   U201(tt, V2) -> U202(isBool(V2))
   U202(tt) -> tt
   U21(tt, A, B, C) -> U22(isBool(B), A, B, C)
   U211(tt) -> tt
   U22(tt, A, B, C) -> U23(isBool(C), A, B, C)
   U221(tt, A) -> _xor_(A, true)
   U23(tt, A, B, C) -> _xor_(_and_(A, B), _and_(A, C))
   U31(tt) -> false
   U41(tt, A) -> A
   U51(tt, A, B) -> U52(isBool(B), A, B)
   U52(tt, A, B) -> not_(_xor_(A, _and_(A, B)))
   U61(tt, U', U) -> U62(isS(U), U', U)
   U62(tt, U', U) -> U63(equal(_isNotEqualTo_(U, U'), true))
   U63(tt) -> false
   U71(tt) -> true
   U81(tt, U', U) -> U82(isS(U), U', U)
   U82(tt, U', U) -> if_then_else_fi(_isEqualTo_(U, U'), false, true)
   U91(tt) -> false
   _and_(A, A) -> U11(isBool(A), A)
   _and_(A, _xor_(B, C)) -> U21(isBool(A), A, B, C)
   _and_(false, A) -> U31(isBool(A))
   _and_(true, A) -> U41(isBool(A), A)
   _implies_(A, B) -> U51(isBool(A), A, B)
   _isEqualTo_(U, U') -> U61(isS(U'), U', U)
   _isEqualTo_(U, U) -> U71(isS(U))
   _isNotEqualTo_(U, U') -> U81(isS(U'), U', U)
   _isNotEqualTo_(U, U) -> U91(isS(U))
   _or_(A, B) -> U101(isBool(A), A, B)
   _xor_(A, A) -> U111(isBool(A))
   _xor_(false, A) -> U121(isBool(A), A)
   equal(X, X) -> tt
   if_then_else_fi(B, U, U') -> U131(isBool(B), B, U', U)
   if_then_else_fi(true, U, U') -> U141(isS(U'), U)
   isBool(false) -> tt
   isBool(true) -> tt
   isBool(_and_(V1, V2)) -> U151(isBool(V1), V2)
   isBool(_implies_(V1, V2)) -> U161(isBool(V1), V2)
   isBool(_isEqualTo_(V1, V2)) -> U171(isUniversal(V1), V2)
   isBool(_isNotEqualTo_(V1, V2)) -> U181(isUniversal(V1), V2)
   isBool(_or_(V1, V2)) -> U191(isBool(V1), V2)
   isBool(_xor_(V1, V2)) -> U201(isBool(V1), V2)
   isBool(not_(V1)) -> U211(isBool(V1))
   not_(A) -> U221(isBool(A), A)
   not_(false) -> true
   not_(true) -> false
   _and_(_and_(A, A), ext) -> _and_(U11(isBool(A), A), ext)
   _and_(_and_(A, _xor_(B, C)), ext) -> _and_(U21(isBool(A), A, B, C), ext)
   _and_(_and_(false, A), ext) -> _and_(U31(isBool(A)), ext)
   _and_(_and_(true, A), ext) -> _and_(U41(isBool(A), A), ext)
   _or_(_or_(A, B), ext) -> _or_(U101(isBool(A), A, B), ext)
   _xor_(_xor_(A, A), ext) -> _xor_(U111(isBool(A)), ext)
   _xor_(_xor_(false, A), ext) -> _xor_(U121(isBool(A), A), ext)

The set E consists of the following equations:

   _and_(x, y) == _and_(y, x)
   _or_(x, y) == _or_(y, x)
   _xor_(x, y) == _xor_(y, x)
   _and_(_and_(x, y), z) == _and_(x, _and_(y, z))
   _or_(_or_(x, y), z) == _or_(x, _or_(y, z))
   _xor_(_xor_(x, y), z) == _xor_(x, _xor_(y, z))

The set E# consists of the following equations:

   _OR_(x, y) == _OR_(y, x)
   _OR_(_or_(x, y), z) == _OR_(x, _or_(y, z))

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(35) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(36)
YES
