MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/T4yQ0.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given ETRS could not be shown:

(0) ETRS
(1) EquationalDependencyPairsProof [EQUIVALENT, 0 ms]
(2) EDP
(3) EDependencyGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) EDP
        (6) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (7) EDP
        (8) EUsableRulesReductionPairsProof [EQUIVALENT, 39 ms]
        (9) EDP
        (10) PisEmptyProof [EQUIVALENT, 0 ms]
        (11) YES
    (12) EDP
        (13) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (14) EDP
        (15) EUsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (16) EDP
        (17) PisEmptyProof [EQUIVALENT, 0 ms]
        (18) YES
    (19) EDP
        (20) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (21) EDP
        (22) EUsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (23) EDP
        (24) PisEmptyProof [EQUIVALENT, 0 ms]
        (25) YES
    (26) EDP
        (27) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (28) EDP
        (29) EUsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (30) EDP
        (31) PisEmptyProof [EQUIVALENT, 0 ms]
        (32) YES
    (33) EDP
        (34) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (35) EDP
        (36) EUsableRulesProof [EQUIVALENT, 0 ms]
        (37) EDP
    (38) EDP


----------------------------------------

(0)
Obligation:
Equational rewrite system:
The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)


----------------------------------------

(1) EquationalDependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,DA_STEIN] we result in the following initial EDP problem:
The TRS P consists of the following rules:

   U11^1(tt, M', N') -> U12^1(equal(_>_(N', M'), true), M', N')
   U11^1(tt, M', N') -> EQUAL(_>_(N', M'), true)
   U11^1(tt, M', N') -> _>_^1(N', M')
   U12^1(tt, M', N') -> GCD(d(N', M'), M')
   U12^1(tt, M', N') -> D(N', M')
   U21^1(tt, M', N) -> U22^1(equal(_>_(M', N), true))
   U21^1(tt, M', N) -> EQUAL(_>_(M', N), true)
   U21^1(tt, M', N) -> _>_^1(M', N)
   U31^1(tt, M', N) -> U32^1(equal(_>_(N, M'), true), M', N)
   U31^1(tt, M', N) -> EQUAL(_>_(N, M'), true)
   U31^1(tt, M', N) -> _>_^1(N, M')
   U32^1(tt, M', N) -> QUOT(d(N, M'), M')
   U32^1(tt, M', N) -> D(N, M')
   _*_^1(s_(N), s_(M)) -> _+_^1(N, _+_(M, _*_(N, M)))
   _*_^1(s_(N), s_(M)) -> _+_^1(M, _*_(N, M))
   _*_^1(s_(N), s_(M)) -> _*_^1(N, M)
   _+_^1(s_(N), s_(M)) -> _+_^1(N, M)
   _<_^1(N, M) -> _>_^1(M, N)
   _>_^1(s_(N), s_(M)) -> _>_^1(N, M)
   D(s_(N), s_(M)) -> D(N, M)
   GCD(N', M') -> U11^1(tt, M', N')
   QUOT(N, M') -> U21^1(tt, M', N)
   QUOT(N, M') -> U31^1(tt, M', N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains

----------------------------------------

(2)
Obligation:
The TRS P consists of the following rules:

   U11^1(tt, M', N') -> U12^1(equal(_>_(N', M'), true), M', N')
   U11^1(tt, M', N') -> EQUAL(_>_(N', M'), true)
   U11^1(tt, M', N') -> _>_^1(N', M')
   U12^1(tt, M', N') -> GCD(d(N', M'), M')
   U12^1(tt, M', N') -> D(N', M')
   U21^1(tt, M', N) -> U22^1(equal(_>_(M', N), true))
   U21^1(tt, M', N) -> EQUAL(_>_(M', N), true)
   U21^1(tt, M', N) -> _>_^1(M', N)
   U31^1(tt, M', N) -> U32^1(equal(_>_(N, M'), true), M', N)
   U31^1(tt, M', N) -> EQUAL(_>_(N, M'), true)
   U31^1(tt, M', N) -> _>_^1(N, M')
   U32^1(tt, M', N) -> QUOT(d(N, M'), M')
   U32^1(tt, M', N) -> D(N, M')
   _*_^1(s_(N), s_(M)) -> _+_^1(N, _+_(M, _*_(N, M)))
   _*_^1(s_(N), s_(M)) -> _+_^1(M, _*_(N, M))
   _*_^1(s_(N), s_(M)) -> _*_^1(N, M)
   _+_^1(s_(N), s_(M)) -> _+_^1(N, M)
   _<_^1(N, M) -> _>_^1(M, N)
   _>_^1(s_(N), s_(M)) -> _>_^1(N, M)
   D(s_(N), s_(M)) -> D(N, M)
   GCD(N', M') -> U11^1(tt, M', N')
   QUOT(N, M') -> U21^1(tt, M', N)
   QUOT(N, M') -> U31^1(tt, M', N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(3) EDependencyGraphProof (EQUIVALENT)
The approximation of the Equational Dependency Graph [DA_STEIN] contains 6 SCCs with 13 less nodes.
----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
The TRS P consists of the following rules:

   D(s_(N), s_(M)) -> D(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(6) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(7)
Obligation:
The TRS P consists of the following rules:

   D(s_(N), s_(M)) -> D(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   D(x, y) == D(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(8) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the improved usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding improved usable rules can be oriented non-strictly, the improved  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and improved usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   D(s_(N), s_(M)) -> D(N, M)
The following rules are removed from R:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)
The following equations are removed from E:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(D(x_1, x_2)) = 3*x_1 + 3*x_2
   POL(s_(x_1)) = 3*x_1


----------------------------------------

(9)
Obligation:
P is empty.
R is empty.
E is empty.
The set E# consists of the following equations:

   D(x, y) == D(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(10) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(11)
YES

----------------------------------------

(12)
Obligation:
The TRS P consists of the following rules:

   _>_^1(s_(N), s_(M)) -> _>_^1(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(13) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(14)
Obligation:
The TRS P consists of the following rules:

   _>_^1(s_(N), s_(M)) -> _>_^1(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(15) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the improved usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding improved usable rules can be oriented non-strictly, the improved  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and improved usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   _>_^1(s_(N), s_(M)) -> _>_^1(N, M)
The following rules are removed from R:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)
The following equations are removed from E:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(_>_^1(x_1, x_2)) = 3*x_1 + 3*x_2
   POL(s_(x_1)) = x_1


----------------------------------------

(16)
Obligation:
P is empty.
R is empty.
E is empty.
E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(17) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(18)
YES

----------------------------------------

(19)
Obligation:
The TRS P consists of the following rules:

   _+_^1(s_(N), s_(M)) -> _+_^1(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(20) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _*_^1(x, y) == _*_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(21)
Obligation:
The TRS P consists of the following rules:

   _+_^1(s_(N), s_(M)) -> _+_^1(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _+_^1(x, y) == _+_^1(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(22) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the improved usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding improved usable rules can be oriented non-strictly, the improved  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and improved usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   _+_^1(s_(N), s_(M)) -> _+_^1(N, M)
The following rules are removed from R:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)
The following equations are removed from E:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(_+_^1(x_1, x_2)) = 3*x_1 + 3*x_2
   POL(s_(x_1)) = 3*x_1


----------------------------------------

(23)
Obligation:
P is empty.
R is empty.
E is empty.
The set E# consists of the following equations:

   _+_^1(x, y) == _+_^1(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(24) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(25)
YES

----------------------------------------

(26)
Obligation:
The TRS P consists of the following rules:

   _*_^1(s_(N), s_(M)) -> _*_^1(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(27) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(28)
Obligation:
The TRS P consists of the following rules:

   _*_^1(s_(N), s_(M)) -> _*_^1(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(29) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the improved usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding improved usable rules can be oriented non-strictly, the improved  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and improved usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   _*_^1(s_(N), s_(M)) -> _*_^1(N, M)
The following rules are removed from R:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)
The following equations are removed from E:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(_*_^1(x_1, x_2)) = 3*x_1 + 3*x_2
   POL(s_(x_1)) = 3*x_1


----------------------------------------

(30)
Obligation:
P is empty.
R is empty.
E is empty.
The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(31) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(32)
YES

----------------------------------------

(33)
Obligation:
The TRS P consists of the following rules:

   U31^1(tt, M', N) -> U32^1(equal(_>_(N, M'), true), M', N)
   QUOT(N, M') -> U31^1(tt, M', N)
   U32^1(tt, M', N) -> QUOT(d(N, M'), M')

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(34) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(35)
Obligation:
The TRS P consists of the following rules:

   U31^1(tt, M', N) -> U32^1(equal(_>_(N, M'), true), M', N)
   QUOT(N, M') -> U31^1(tt, M', N)
   U32^1(tt, M', N) -> QUOT(d(N, M'), M')

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(36) EUsableRulesProof (EQUIVALENT)
We use the improved usable rules and equations processor [DA_STEIN] to delete all non-usable rules from R and all non-usable equations from E, but we lose minimality and add the following 2 Ce-rules:
   c(x, y) -> x
   c(x, y) -> y

----------------------------------------

(37)
Obligation:
The TRS P consists of the following rules:

   U31^1(tt, M', N) -> U32^1(equal(_>_(N, M'), true), M', N)
   QUOT(N, M') -> U31^1(tt, M', N)
   U32^1(tt, M', N) -> QUOT(d(N, M'), M')

The TRS R consists of the following rules:

   equal(X, X) -> tt
   _>_(0, M) -> false
   d(s_(N), s_(M)) -> d(N, M)
   _>_(s_(N), s_(M)) -> _>_(N, M)
   _>_(N', 0) -> true
   d(0, N) -> N
   c(x, y) -> x
   c(x, y) -> y

The set E consists of the following equations:

   d(x, y) == d(y, x)

E# is empty.
We have to consider all (P,E#,R,E)-chains
----------------------------------------

(38)
Obligation:
The TRS P consists of the following rules:

   U11^1(tt, M', N') -> U12^1(equal(_>_(N', M'), true), M', N')
   U12^1(tt, M', N') -> GCD(d(N', M'), M')
   GCD(N', M') -> U11^1(tt, M', N')

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U11(tt, M', N') -> U12(equal(_>_(N', M'), true), M', N')
   U12(tt, M', N') -> gcd(d(N', M'), M')
   U21(tt, M', N) -> U22(equal(_>_(M', N), true))
   U22(tt) -> 0
   U31(tt, M', N) -> U32(equal(_>_(N, M'), true), M', N)
   U32(tt, M', N) -> s_(quot(d(N, M'), M'))
   _*_(N, 0) -> 0
   _*_(s_(N), s_(M)) -> s_(_+_(N, _+_(M, _*_(N, M))))
   _+_(N, 0) -> N
   _+_(s_(N), s_(M)) -> s_(s_(_+_(N, M)))
   _<_(N, M) -> _>_(M, N)
   _>_(0, M) -> false
   _>_(N', 0) -> true
   _>_(s_(N), s_(M)) -> _>_(N, M)
   and(tt, X) -> X
   d(0, N) -> N
   d(s_(N), s_(M)) -> d(N, M)
   equal(X, X) -> tt
   gcd(0, N) -> 0
   gcd(N', M') -> U11(tt, M', N')
   gcd(N', N') -> N'
   p_(s_(N)) -> N
   quot(M', M') -> s_(0)
   quot(N, M') -> U21(tt, M', N)
   quot(N, M') -> U31(tt, M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains