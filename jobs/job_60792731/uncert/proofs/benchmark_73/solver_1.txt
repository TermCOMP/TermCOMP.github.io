MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/FhOFl.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given ETRS could not be shown:

(0) ETRS
(1) EquationalDependencyPairsProof [EQUIVALENT, 0 ms]
(2) EDP
(3) EDependencyGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) EDP
        (6) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (7) EDP
        (8) EUsableRulesReductionPairsProof [EQUIVALENT, 29 ms]
        (9) EDP
        (10) EDependencyGraphProof [EQUIVALENT, 0 ms]
        (11) TRUE
    (12) EDP
        (13) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (14) EDP
        (15) EUsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (16) EDP
        (17) EDependencyGraphProof [EQUIVALENT, 0 ms]
        (18) TRUE
    (19) EDP
        (20) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (21) EDP
        (22) EUsableRulesReductionPairsProof [EQUIVALENT, 17 ms]
        (23) EDP
        (24) EDependencyGraphProof [EQUIVALENT, 0 ms]
        (25) TRUE
    (26) EDP
        (27) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (28) EDP
        (29) EUsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (30) EDP
        (31) PisEmptyProof [EQUIVALENT, 0 ms]
        (32) YES
    (33) EDP
        (34) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (35) EDP
        (36) EUsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
        (37) EDP
        (38) PisEmptyProof [EQUIVALENT, 0 ms]
        (39) YES
    (40) EDP
        (41) ESharpUsableEquationsProof [EQUIVALENT, 0 ms]
        (42) EDP
        (43) EUsableRulesProof [EQUIVALENT, 0 ms]
        (44) EDP
    (45) EDP


----------------------------------------

(0)
Obligation:
Equational rewrite system:
The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)


----------------------------------------

(1) EquationalDependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,DA_STEIN] we result in the following initial EDP problem:
The TRS P consists of the following rules:

   U101^1(tt, M, N) -> D(N, M)
   U121^1(tt, M', N') -> U122^1(equal(_>_(N', M'), true), M', N')
   U121^1(tt, M', N') -> EQUAL(_>_(N', M'), true)
   U121^1(tt, M', N') -> _>_^1(N', M')
   U122^1(tt, M', N') -> GCD(d(N', M'), M')
   U122^1(tt, M', N') -> D(N', M')
   U161^1(tt, M', N) -> U162^1(equal(_>_(M', N), true))
   U161^1(tt, M', N) -> EQUAL(_>_(M', N), true)
   U161^1(tt, M', N) -> _>_^1(M', N)
   U171^1(tt, M', N) -> U172^1(equal(_>_(N, M'), true), M', N)
   U171^1(tt, M', N) -> EQUAL(_>_(N, M'), true)
   U171^1(tt, M', N) -> _>_^1(N, M')
   U172^1(tt, M', N) -> QUOT(d(N, M'), M')
   U172^1(tt, M', N) -> D(N, M')
   U21^1(tt, M, N) -> _+_^1(N, _+_(M, _*_(N, M)))
   U21^1(tt, M, N) -> _+_^1(M, _*_(N, M))
   U21^1(tt, M, N) -> _*_^1(N, M)
   U41^1(tt, M, N) -> _+_^1(N, M)
   U51^1(tt, M, N) -> _>_^1(M, N)
   U81^1(tt, M, N) -> _>_^1(N, M)
   _*_^1(N, 0) -> U11^1(isNat(N))
   _*_^1(N, 0) -> ISNAT(N)
   _*_^1(s_(N), s_(M)) -> U21^1(and(isNat(M), isNat(N)), M, N)
   _*_^1(s_(N), s_(M)) -> AND(isNat(M), isNat(N))
   _*_^1(s_(N), s_(M)) -> ISNAT(M)
   _*_^1(s_(N), s_(M)) -> ISNAT(N)
   _+_^1(N, 0) -> U31^1(isNat(N), N)
   _+_^1(N, 0) -> ISNAT(N)
   _+_^1(s_(N), s_(M)) -> U41^1(and(isNat(M), isNat(N)), M, N)
   _+_^1(s_(N), s_(M)) -> AND(isNat(M), isNat(N))
   _+_^1(s_(N), s_(M)) -> ISNAT(M)
   _+_^1(s_(N), s_(M)) -> ISNAT(N)
   _<_^1(N, M) -> U51^1(and(isNat(M), isNat(N)), M, N)
   _<_^1(N, M) -> AND(isNat(M), isNat(N))
   _<_^1(N, M) -> ISNAT(M)
   _<_^1(N, M) -> ISNAT(N)
   _>_^1(0, M) -> U61^1(isNat(M))
   _>_^1(0, M) -> ISNAT(M)
   _>_^1(N', 0) -> U71^1(isNzNat(N'))
   _>_^1(N', 0) -> ISNZNAT(N')
   _>_^1(s_(N), s_(M)) -> U81^1(and(isNat(M), isNat(N)), M, N)
   _>_^1(s_(N), s_(M)) -> AND(isNat(M), isNat(N))
   _>_^1(s_(N), s_(M)) -> ISNAT(M)
   _>_^1(s_(N), s_(M)) -> ISNAT(N)
   D(0, N) -> U91^1(isNat(N), N)
   D(0, N) -> ISNAT(N)
   D(s_(N), s_(M)) -> U101^1(and(isNat(M), isNat(N)), M, N)
   D(s_(N), s_(M)) -> AND(isNat(M), isNat(N))
   D(s_(N), s_(M)) -> ISNAT(M)
   D(s_(N), s_(M)) -> ISNAT(N)
   GCD(0, N) -> U111^1(isNat(N))
   GCD(0, N) -> ISNAT(N)
   GCD(N', M') -> U121^1(and(isNzNat(M'), isNzNat(N')), M', N')
   GCD(N', M') -> AND(isNzNat(M'), isNzNat(N'))
   GCD(N', M') -> ISNZNAT(M')
   GCD(N', M') -> ISNZNAT(N')
   GCD(N', N') -> U131^1(isNzNat(N'), N')
   GCD(N', N') -> ISNZNAT(N')
   ISBOOLEAN(_<_(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISBOOLEAN(_<_(V1, V2)) -> ISNAT(V1)
   ISBOOLEAN(_<_(V1, V2)) -> ISNAT(V2)
   ISBOOLEAN(_>_(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISBOOLEAN(_>_(V1, V2)) -> ISNAT(V1)
   ISBOOLEAN(_>_(V1, V2)) -> ISNAT(V2)
   ISNAT(V) -> ISNZNAT(V)
   ISNAT(_*_(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(_*_(V1, V2)) -> ISNAT(V1)
   ISNAT(_*_(V1, V2)) -> ISNAT(V2)
   ISNAT(_+_(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(_+_(V1, V2)) -> ISNAT(V1)
   ISNAT(_+_(V1, V2)) -> ISNAT(V2)
   ISNAT(d(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(d(V1, V2)) -> ISNAT(V1)
   ISNAT(d(V1, V2)) -> ISNAT(V2)
   ISNAT(gcd(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(gcd(V1, V2)) -> ISNAT(V1)
   ISNAT(gcd(V1, V2)) -> ISNAT(V2)
   ISNAT(p_(V1)) -> ISNZNAT(V1)
   ISNAT(quot(V1, V2)) -> AND(isNat(V1), isNzNat(V2))
   ISNAT(quot(V1, V2)) -> ISNAT(V1)
   ISNAT(quot(V1, V2)) -> ISNZNAT(V2)
   ISNZNAT(_*_(V1, V2)) -> AND(isNzNat(V1), isNzNat(V2))
   ISNZNAT(_*_(V1, V2)) -> ISNZNAT(V1)
   ISNZNAT(_*_(V1, V2)) -> ISNZNAT(V2)
   ISNZNAT(gcd(V1, V2)) -> AND(isNzNat(V1), isNzNat(V2))
   ISNZNAT(gcd(V1, V2)) -> ISNZNAT(V1)
   ISNZNAT(gcd(V1, V2)) -> ISNZNAT(V2)
   ISNZNAT(s_(V1)) -> ISNAT(V1)
   P_(s_(N)) -> U141^1(isNat(N), N)
   P_(s_(N)) -> ISNAT(N)
   QUOT(M', M') -> U151^1(isNzNat(M'))
   QUOT(M', M') -> ISNZNAT(M')
   QUOT(N, M') -> U161^1(and(isNzNat(M'), isNat(N)), M', N)
   QUOT(N, M') -> AND(isNzNat(M'), isNat(N))
   QUOT(N, M') -> ISNZNAT(M')
   QUOT(N, M') -> ISNAT(N)
   QUOT(N, M') -> U171^1(and(isNzNat(M'), isNat(N)), M', N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains

----------------------------------------

(2)
Obligation:
The TRS P consists of the following rules:

   U101^1(tt, M, N) -> D(N, M)
   U121^1(tt, M', N') -> U122^1(equal(_>_(N', M'), true), M', N')
   U121^1(tt, M', N') -> EQUAL(_>_(N', M'), true)
   U121^1(tt, M', N') -> _>_^1(N', M')
   U122^1(tt, M', N') -> GCD(d(N', M'), M')
   U122^1(tt, M', N') -> D(N', M')
   U161^1(tt, M', N) -> U162^1(equal(_>_(M', N), true))
   U161^1(tt, M', N) -> EQUAL(_>_(M', N), true)
   U161^1(tt, M', N) -> _>_^1(M', N)
   U171^1(tt, M', N) -> U172^1(equal(_>_(N, M'), true), M', N)
   U171^1(tt, M', N) -> EQUAL(_>_(N, M'), true)
   U171^1(tt, M', N) -> _>_^1(N, M')
   U172^1(tt, M', N) -> QUOT(d(N, M'), M')
   U172^1(tt, M', N) -> D(N, M')
   U21^1(tt, M, N) -> _+_^1(N, _+_(M, _*_(N, M)))
   U21^1(tt, M, N) -> _+_^1(M, _*_(N, M))
   U21^1(tt, M, N) -> _*_^1(N, M)
   U41^1(tt, M, N) -> _+_^1(N, M)
   U51^1(tt, M, N) -> _>_^1(M, N)
   U81^1(tt, M, N) -> _>_^1(N, M)
   _*_^1(N, 0) -> U11^1(isNat(N))
   _*_^1(N, 0) -> ISNAT(N)
   _*_^1(s_(N), s_(M)) -> U21^1(and(isNat(M), isNat(N)), M, N)
   _*_^1(s_(N), s_(M)) -> AND(isNat(M), isNat(N))
   _*_^1(s_(N), s_(M)) -> ISNAT(M)
   _*_^1(s_(N), s_(M)) -> ISNAT(N)
   _+_^1(N, 0) -> U31^1(isNat(N), N)
   _+_^1(N, 0) -> ISNAT(N)
   _+_^1(s_(N), s_(M)) -> U41^1(and(isNat(M), isNat(N)), M, N)
   _+_^1(s_(N), s_(M)) -> AND(isNat(M), isNat(N))
   _+_^1(s_(N), s_(M)) -> ISNAT(M)
   _+_^1(s_(N), s_(M)) -> ISNAT(N)
   _<_^1(N, M) -> U51^1(and(isNat(M), isNat(N)), M, N)
   _<_^1(N, M) -> AND(isNat(M), isNat(N))
   _<_^1(N, M) -> ISNAT(M)
   _<_^1(N, M) -> ISNAT(N)
   _>_^1(0, M) -> U61^1(isNat(M))
   _>_^1(0, M) -> ISNAT(M)
   _>_^1(N', 0) -> U71^1(isNzNat(N'))
   _>_^1(N', 0) -> ISNZNAT(N')
   _>_^1(s_(N), s_(M)) -> U81^1(and(isNat(M), isNat(N)), M, N)
   _>_^1(s_(N), s_(M)) -> AND(isNat(M), isNat(N))
   _>_^1(s_(N), s_(M)) -> ISNAT(M)
   _>_^1(s_(N), s_(M)) -> ISNAT(N)
   D(0, N) -> U91^1(isNat(N), N)
   D(0, N) -> ISNAT(N)
   D(s_(N), s_(M)) -> U101^1(and(isNat(M), isNat(N)), M, N)
   D(s_(N), s_(M)) -> AND(isNat(M), isNat(N))
   D(s_(N), s_(M)) -> ISNAT(M)
   D(s_(N), s_(M)) -> ISNAT(N)
   GCD(0, N) -> U111^1(isNat(N))
   GCD(0, N) -> ISNAT(N)
   GCD(N', M') -> U121^1(and(isNzNat(M'), isNzNat(N')), M', N')
   GCD(N', M') -> AND(isNzNat(M'), isNzNat(N'))
   GCD(N', M') -> ISNZNAT(M')
   GCD(N', M') -> ISNZNAT(N')
   GCD(N', N') -> U131^1(isNzNat(N'), N')
   GCD(N', N') -> ISNZNAT(N')
   ISBOOLEAN(_<_(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISBOOLEAN(_<_(V1, V2)) -> ISNAT(V1)
   ISBOOLEAN(_<_(V1, V2)) -> ISNAT(V2)
   ISBOOLEAN(_>_(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISBOOLEAN(_>_(V1, V2)) -> ISNAT(V1)
   ISBOOLEAN(_>_(V1, V2)) -> ISNAT(V2)
   ISNAT(V) -> ISNZNAT(V)
   ISNAT(_*_(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(_*_(V1, V2)) -> ISNAT(V1)
   ISNAT(_*_(V1, V2)) -> ISNAT(V2)
   ISNAT(_+_(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(_+_(V1, V2)) -> ISNAT(V1)
   ISNAT(_+_(V1, V2)) -> ISNAT(V2)
   ISNAT(d(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(d(V1, V2)) -> ISNAT(V1)
   ISNAT(d(V1, V2)) -> ISNAT(V2)
   ISNAT(gcd(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(gcd(V1, V2)) -> ISNAT(V1)
   ISNAT(gcd(V1, V2)) -> ISNAT(V2)
   ISNAT(p_(V1)) -> ISNZNAT(V1)
   ISNAT(quot(V1, V2)) -> AND(isNat(V1), isNzNat(V2))
   ISNAT(quot(V1, V2)) -> ISNAT(V1)
   ISNAT(quot(V1, V2)) -> ISNZNAT(V2)
   ISNZNAT(_*_(V1, V2)) -> AND(isNzNat(V1), isNzNat(V2))
   ISNZNAT(_*_(V1, V2)) -> ISNZNAT(V1)
   ISNZNAT(_*_(V1, V2)) -> ISNZNAT(V2)
   ISNZNAT(gcd(V1, V2)) -> AND(isNzNat(V1), isNzNat(V2))
   ISNZNAT(gcd(V1, V2)) -> ISNZNAT(V1)
   ISNZNAT(gcd(V1, V2)) -> ISNZNAT(V2)
   ISNZNAT(s_(V1)) -> ISNAT(V1)
   P_(s_(N)) -> U141^1(isNat(N), N)
   P_(s_(N)) -> ISNAT(N)
   QUOT(M', M') -> U151^1(isNzNat(M'))
   QUOT(M', M') -> ISNZNAT(M')
   QUOT(N, M') -> U161^1(and(isNzNat(M'), isNat(N)), M', N)
   QUOT(N, M') -> AND(isNzNat(M'), isNat(N))
   QUOT(N, M') -> ISNZNAT(M')
   QUOT(N, M') -> ISNAT(N)
   QUOT(N, M') -> U171^1(and(isNzNat(M'), isNat(N)), M', N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(3) EDependencyGraphProof (EQUIVALENT)
The approximation of the Equational Dependency Graph [DA_STEIN] contains 7 SCCs with 66 less nodes.
----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
The TRS P consists of the following rules:

   ISNAT(gcd(V1, V2)) -> ISNAT(V2)
   ISNZNAT(gcd(V1, V2)) -> ISNZNAT(V2)
   ISNAT(d(V1, V2)) -> ISNAT(V1)
   ISNAT(V) -> ISNZNAT(V)
   ISNAT(_+_(V1, V2)) -> ISNAT(V2)
   ISNAT(p_(V1)) -> ISNZNAT(V1)
   ISNAT(_*_(V1, V2)) -> ISNAT(V2)
   ISNAT(quot(V1, V2)) -> ISNZNAT(V2)
   ISNZNAT(s_(V1)) -> ISNAT(V1)
   ISNZNAT(_*_(V1, V2)) -> ISNZNAT(V1)
   ISNZNAT(gcd(V1, V2)) -> ISNZNAT(V1)
   ISNAT(_+_(V1, V2)) -> ISNAT(V1)
   ISNAT(_*_(V1, V2)) -> ISNAT(V1)
   ISNAT(gcd(V1, V2)) -> ISNAT(V1)
   ISNAT(d(V1, V2)) -> ISNAT(V2)
   ISNZNAT(_*_(V1, V2)) -> ISNZNAT(V2)
   ISNAT(quot(V1, V2)) -> ISNAT(V1)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(6) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(7)
Obligation:
The TRS P consists of the following rules:

   ISNAT(gcd(V1, V2)) -> ISNAT(V2)
   ISNZNAT(gcd(V1, V2)) -> ISNZNAT(V2)
   ISNAT(d(V1, V2)) -> ISNAT(V1)
   ISNAT(V) -> ISNZNAT(V)
   ISNAT(_+_(V1, V2)) -> ISNAT(V2)
   ISNAT(p_(V1)) -> ISNZNAT(V1)
   ISNAT(_*_(V1, V2)) -> ISNAT(V2)
   ISNAT(quot(V1, V2)) -> ISNZNAT(V2)
   ISNZNAT(s_(V1)) -> ISNAT(V1)
   ISNZNAT(_*_(V1, V2)) -> ISNZNAT(V1)
   ISNZNAT(gcd(V1, V2)) -> ISNZNAT(V1)
   ISNAT(_+_(V1, V2)) -> ISNAT(V1)
   ISNAT(_*_(V1, V2)) -> ISNAT(V1)
   ISNAT(gcd(V1, V2)) -> ISNAT(V1)
   ISNAT(d(V1, V2)) -> ISNAT(V2)
   ISNZNAT(_*_(V1, V2)) -> ISNZNAT(V2)
   ISNAT(quot(V1, V2)) -> ISNAT(V1)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(8) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the improved usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding improved usable rules can be oriented non-strictly, the improved  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and improved usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   ISNAT(gcd(V1, V2)) -> ISNAT(V2)
   ISNZNAT(gcd(V1, V2)) -> ISNZNAT(V2)
   ISNAT(d(V1, V2)) -> ISNAT(V1)
   ISNAT(_+_(V1, V2)) -> ISNAT(V2)
   ISNAT(p_(V1)) -> ISNZNAT(V1)
   ISNAT(_*_(V1, V2)) -> ISNAT(V2)
   ISNAT(quot(V1, V2)) -> ISNZNAT(V2)
   ISNZNAT(s_(V1)) -> ISNAT(V1)
   ISNZNAT(_*_(V1, V2)) -> ISNZNAT(V1)
   ISNZNAT(gcd(V1, V2)) -> ISNZNAT(V1)
   ISNAT(_+_(V1, V2)) -> ISNAT(V1)
   ISNAT(_*_(V1, V2)) -> ISNAT(V1)
   ISNAT(gcd(V1, V2)) -> ISNAT(V1)
   ISNAT(d(V1, V2)) -> ISNAT(V2)
   ISNZNAT(_*_(V1, V2)) -> ISNZNAT(V2)
   ISNAT(quot(V1, V2)) -> ISNAT(V1)
The following rules are removed from R:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)
The following equations are removed from E:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(ISNAT(x_1)) = x_1
   POL(ISNZNAT(x_1)) = x_1
   POL(_*_(x_1, x_2)) = 3*x_1 + 3*x_2
   POL(_+_(x_1, x_2)) = 3*x_1 + 3*x_2
   POL(d(x_1, x_2)) = 3*x_1 + 3*x_2
   POL(gcd(x_1, x_2)) = 3*x_1 + 3*x_2
   POL(p_(x_1)) = 3*x_1
   POL(quot(x_1, x_2)) = 3*x_1 + 3*x_2
   POL(s_(x_1)) = 3*x_1


----------------------------------------

(9)
Obligation:
The TRS P consists of the following rules:

   ISNAT(V) -> ISNZNAT(V)

R is empty.
E is empty.
E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(10) EDependencyGraphProof (EQUIVALENT)
The approximation of the Equational Dependency Graph [DA_STEIN] contains 0 SCCs with 1 less node.
----------------------------------------

(11)
TRUE

----------------------------------------

(12)
Obligation:
The TRS P consists of the following rules:

   _>_^1(s_(N), s_(M)) -> U81^1(and(isNat(M), isNat(N)), M, N)
   U81^1(tt, M, N) -> _>_^1(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(13) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(14)
Obligation:
The TRS P consists of the following rules:

   _>_^1(s_(N), s_(M)) -> U81^1(and(isNat(M), isNat(N)), M, N)
   U81^1(tt, M, N) -> _>_^1(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(15) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the improved usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding improved usable rules can be oriented non-strictly, the improved  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and improved usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   _>_^1(s_(N), s_(M)) -> U81^1(and(isNat(M), isNat(N)), M, N)
The following rules are removed from R:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)
The following equations are removed from E:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(1) = 0
   POL(2) = 0
   POL(3) = 0
   POL(4) = 0
   POL(5) = 0
   POL(6) = 0
   POL(7) = 0
   POL(U81^1(x_1, x_2, x_3)) = x_1 + 2*x_2 + 2*x_3
   POL(_*_(x_1, x_2)) = 2 + 3*x_1 + 3*x_2
   POL(_+_(x_1, x_2)) = 2 + 3*x_1 + 2*x_2
   POL(_>_^1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(and(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(d(x_1, x_2)) = 2 + 3*x_1 + 3*x_2
   POL(gcd(x_1, x_2)) = 2 + 3*x_1 + 3*x_2
   POL(isNat(x_1)) = x_1
   POL(isNzNat(x_1)) = x_1
   POL(p_(x_1)) = 3*x_1
   POL(quot(x_1, x_2)) = 2 + 2*x_1 + 2*x_2
   POL(s_(x_1)) = 3*x_1
   POL(tt) = 0


----------------------------------------

(16)
Obligation:
The TRS P consists of the following rules:

   U81^1(tt, M, N) -> _>_^1(N, M)

The TRS R consists of the following rules:

   and(tt, X) -> X
   isNat(V) -> isNzNat(V)

E is empty.
E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(17) EDependencyGraphProof (EQUIVALENT)
The approximation of the Equational Dependency Graph [DA_STEIN] contains 0 SCCs with 1 less node.
----------------------------------------

(18)
TRUE

----------------------------------------

(19)
Obligation:
The TRS P consists of the following rules:

   U41^1(tt, M, N) -> _+_^1(N, M)
   _+_^1(s_(N), s_(M)) -> U41^1(and(isNat(M), isNat(N)), M, N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(20) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _*_^1(x, y) == _*_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(21)
Obligation:
The TRS P consists of the following rules:

   U41^1(tt, M, N) -> _+_^1(N, M)
   _+_^1(s_(N), s_(M)) -> U41^1(and(isNat(M), isNat(N)), M, N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _+_^1(x, y) == _+_^1(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(22) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the improved usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding improved usable rules can be oriented non-strictly, the improved  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and improved usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   _+_^1(s_(N), s_(M)) -> U41^1(and(isNat(M), isNat(N)), M, N)
The following rules are removed from R:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)
The following equations are removed from E:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(1) = 0
   POL(2) = 0
   POL(3) = 0
   POL(4) = 0
   POL(5) = 0
   POL(6) = 0
   POL(7) = 0
   POL(U41^1(x_1, x_2, x_3)) = x_1 + 2*x_2 + 2*x_3
   POL(_*_(x_1, x_2)) = 3 + 2*x_1 + 2*x_2
   POL(_+_(x_1, x_2)) = 3 + 2*x_1 + 2*x_2
   POL(_+_^1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(and(x_1, x_2)) = x_1 + x_2
   POL(d(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(gcd(x_1, x_2)) = 3 + 2*x_1 + 2*x_2
   POL(isNat(x_1)) = 2*x_1
   POL(isNzNat(x_1)) = x_1
   POL(p_(x_1)) = 3*x_1
   POL(quot(x_1, x_2)) = 2 + 2*x_1 + 3*x_2
   POL(s_(x_1)) = 3*x_1
   POL(tt) = 0


----------------------------------------

(23)
Obligation:
The TRS P consists of the following rules:

   U41^1(tt, M, N) -> _+_^1(N, M)

The TRS R consists of the following rules:

   and(tt, X) -> X
   isNat(V) -> isNzNat(V)

E is empty.
The set E# consists of the following equations:

   _+_^1(x, y) == _+_^1(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(24) EDependencyGraphProof (EQUIVALENT)
The approximation of the Equational Dependency Graph [DA_STEIN] contains 0 SCCs with 1 less node.
----------------------------------------

(25)
TRUE

----------------------------------------

(26)
Obligation:
The TRS P consists of the following rules:

   _*_^1(s_(N), s_(M)) -> U21^1(and(isNat(M), isNat(N)), M, N)
   U21^1(tt, M, N) -> _*_^1(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(27) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(28)
Obligation:
The TRS P consists of the following rules:

   _*_^1(s_(N), s_(M)) -> U21^1(and(isNat(M), isNat(N)), M, N)
   U21^1(tt, M, N) -> _*_^1(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(29) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the improved usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding improved usable rules can be oriented non-strictly, the improved  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and improved usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   _*_^1(s_(N), s_(M)) -> U21^1(and(isNat(M), isNat(N)), M, N)
   U21^1(tt, M, N) -> _*_^1(N, M)
The following rules are removed from R:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)
The following equations are removed from E:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(0) = 2
   POL(1) = 2
   POL(2) = 2
   POL(3) = 1
   POL(4) = 2
   POL(5) = 2
   POL(6) = 1
   POL(7) = 2
   POL(U21^1(x_1, x_2, x_3)) = 2 + 2*x_1 + 3*x_2 + 3*x_3
   POL(_*_(x_1, x_2)) = 3 + 2*x_1 + 3*x_2
   POL(_*_^1(x_1, x_2)) = 2 + 3*x_1 + 3*x_2
   POL(_+_(x_1, x_2)) = 3 + 2*x_1 + 2*x_2
   POL(and(x_1, x_2)) = 3 + x_1 + 2*x_2
   POL(d(x_1, x_2)) = 3 + 2*x_1 + 3*x_2
   POL(gcd(x_1, x_2)) = 3 + 2*x_1 + 3*x_2
   POL(isNat(x_1)) = x_1
   POL(isNzNat(x_1)) = x_1
   POL(p_(x_1)) = 3*x_1
   POL(quot(x_1, x_2)) = 3 + 2*x_1 + 3*x_2
   POL(s_(x_1)) = 3 + 3*x_1
   POL(tt) = 1


----------------------------------------

(30)
Obligation:
P is empty.
The TRS R consists of the following rules:

   isNat(V) -> isNzNat(V)

E is empty.
The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(31) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(32)
YES

----------------------------------------

(33)
Obligation:
The TRS P consists of the following rules:

   D(s_(N), s_(M)) -> U101^1(and(isNat(M), isNat(N)), M, N)
   U101^1(tt, M, N) -> D(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(34) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(35)
Obligation:
The TRS P consists of the following rules:

   D(s_(N), s_(M)) -> U101^1(and(isNat(M), isNat(N)), M, N)
   U101^1(tt, M, N) -> D(N, M)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   D(x, y) == D(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(36) EUsableRulesReductionPairsProof (EQUIVALENT)
By using the improved usable rules and equations with reduction pair processor [DA_STEIN] with a polynomial ordering [POLO], all dependency pairs and the corresponding improved usable rules can be oriented non-strictly, the improved  usable equations and the esharp equations can be oriented equivalently. All non-usable rules and equations are removed, and those dependency pairs and improved usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   D(s_(N), s_(M)) -> U101^1(and(isNat(M), isNat(N)), M, N)
   U101^1(tt, M, N) -> D(N, M)
The following rules are removed from R:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)
The following equations are removed from E:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(0) = 2
   POL(1) = 2
   POL(2) = 2
   POL(3) = 1
   POL(4) = 2
   POL(5) = 2
   POL(6) = 1
   POL(7) = 2
   POL(D(x_1, x_2)) = 2 + 3*x_1 + 3*x_2
   POL(U101^1(x_1, x_2, x_3)) = 2 + 2*x_1 + 3*x_2 + 3*x_3
   POL(_*_(x_1, x_2)) = 3 + 2*x_1 + 3*x_2
   POL(_+_(x_1, x_2)) = 3 + 2*x_1 + 2*x_2
   POL(and(x_1, x_2)) = 3 + x_1 + 2*x_2
   POL(d(x_1, x_2)) = 3 + 2*x_1 + 3*x_2
   POL(gcd(x_1, x_2)) = 3 + 2*x_1 + 3*x_2
   POL(isNat(x_1)) = x_1
   POL(isNzNat(x_1)) = x_1
   POL(p_(x_1)) = 3*x_1
   POL(quot(x_1, x_2)) = 3 + 2*x_1 + 3*x_2
   POL(s_(x_1)) = 3 + 3*x_1
   POL(tt) = 1


----------------------------------------

(37)
Obligation:
P is empty.
The TRS R consists of the following rules:

   isNat(V) -> isNzNat(V)

E is empty.
The set E# consists of the following equations:

   D(x, y) == D(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(38) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,E#,R,E) chain.
----------------------------------------

(39)
YES

----------------------------------------

(40)
Obligation:
The TRS P consists of the following rules:

   U171^1(tt, M', N) -> U172^1(equal(_>_(N, M'), true), M', N)
   U172^1(tt, M', N) -> QUOT(d(N, M'), M')
   QUOT(N, M') -> U171^1(and(isNzNat(M'), isNat(N)), M', N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(41) ESharpUsableEquationsProof (EQUIVALENT)
We can delete the following equations of E# with the esharp usable equations processor[DA_STEIN]:
   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

----------------------------------------

(42)
Obligation:
The TRS P consists of the following rules:

   U171^1(tt, M', N) -> U172^1(equal(_>_(N, M'), true), M', N)
   U172^1(tt, M', N) -> QUOT(d(N, M'), M')
   QUOT(N, M') -> U171^1(and(isNzNat(M'), isNat(N)), M', N)

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

E# is empty.
We have to consider all minimal (P,E#,R,E)-chains
----------------------------------------

(43) EUsableRulesProof (EQUIVALENT)
We use the improved usable rules and equations processor [DA_STEIN] to delete all non-usable rules from R and all non-usable equations from E, but we lose minimality and add the following 2 Ce-rules:
   c(x, y) -> x
   c(x, y) -> y

----------------------------------------

(44)
Obligation:
The TRS P consists of the following rules:

   U171^1(tt, M', N) -> U172^1(equal(_>_(N, M'), true), M', N)
   U172^1(tt, M', N) -> QUOT(d(N, M'), M')
   QUOT(N, M') -> U171^1(and(isNzNat(M'), isNat(N)), M', N)

The TRS R consists of the following rules:

   isNzNat(6) -> tt
   isNzNat(3) -> tt
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   and(tt, X) -> X
   isNat(0) -> tt
   equal(X, X) -> tt
   U61(tt) -> false
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   U91(tt, N) -> N
   isNat(V) -> isNzNat(V)
   isNzNat(s_(V1)) -> isNat(V1)
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(0, M) -> U61(isNat(M))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   U81(tt, M, N) -> _>_(N, M)
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   U101(tt, M, N) -> d(N, M)
   d(0, N) -> U91(isNat(N), N)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(7) -> tt
   isNzNat(1) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   U71(tt) -> true
   isNzNat(2) -> tt
   c(x, y) -> x
   c(x, y) -> y

The set E consists of the following equations:

   d(x, y) == d(y, x)

E# is empty.
We have to consider all (P,E#,R,E)-chains
----------------------------------------

(45)
Obligation:
The TRS P consists of the following rules:

   GCD(N', M') -> U121^1(and(isNzNat(M'), isNzNat(N')), M', N')
   U122^1(tt, M', N') -> GCD(d(N', M'), M')
   U121^1(tt, M', N') -> U122^1(equal(_>_(N', M'), true), M', N')

The TRS R consists of the following rules:

   1 -> s_(0)
   2 -> s_(s_(0))
   3 -> s_(s_(s_(0)))
   4 -> s_(s_(s_(s_(0))))
   5 -> s_(s_(s_(s_(s_(0)))))
   6 -> s_(s_(s_(s_(s_(s_(0))))))
   7 -> s_(s_(s_(s_(s_(s_(s_(0)))))))
   U101(tt, M, N) -> d(N, M)
   U11(tt) -> 0
   U111(tt) -> 0
   U121(tt, M', N') -> U122(equal(_>_(N', M'), true), M', N')
   U122(tt, M', N') -> gcd(d(N', M'), M')
   U131(tt, N') -> N'
   U141(tt, N) -> N
   U151(tt) -> s_(0)
   U161(tt, M', N) -> U162(equal(_>_(M', N), true))
   U162(tt) -> 0
   U171(tt, M', N) -> U172(equal(_>_(N, M'), true), M', N)
   U172(tt, M', N) -> s_(quot(d(N, M'), M'))
   U21(tt, M, N) -> s_(_+_(N, _+_(M, _*_(N, M))))
   U31(tt, N) -> N
   U41(tt, M, N) -> s_(s_(_+_(N, M)))
   U51(tt, M, N) -> _>_(M, N)
   U61(tt) -> false
   U71(tt) -> true
   U81(tt, M, N) -> _>_(N, M)
   U91(tt, N) -> N
   _*_(N, 0) -> U11(isNat(N))
   _*_(s_(N), s_(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   _+_(N, 0) -> U31(isNat(N), N)
   _+_(s_(N), s_(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   _<_(N, M) -> U51(and(isNat(M), isNat(N)), M, N)
   _>_(0, M) -> U61(isNat(M))
   _>_(N', 0) -> U71(isNzNat(N'))
   _>_(s_(N), s_(M)) -> U81(and(isNat(M), isNat(N)), M, N)
   and(tt, X) -> X
   d(0, N) -> U91(isNat(N), N)
   d(s_(N), s_(M)) -> U101(and(isNat(M), isNat(N)), M, N)
   equal(X, X) -> tt
   gcd(0, N) -> U111(isNat(N))
   gcd(N', M') -> U121(and(isNzNat(M'), isNzNat(N')), M', N')
   gcd(N', N') -> U131(isNzNat(N'), N')
   isBoolean(false) -> tt
   isBoolean(true) -> tt
   isBoolean(_<_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isBoolean(_>_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(0) -> tt
   isNat(V) -> isNzNat(V)
   isNat(_*_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(_+_(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(d(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(gcd(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(p_(V1)) -> isNzNat(V1)
   isNat(quot(V1, V2)) -> and(isNat(V1), isNzNat(V2))
   isNzNat(1) -> tt
   isNzNat(2) -> tt
   isNzNat(3) -> tt
   isNzNat(4) -> tt
   isNzNat(5) -> tt
   isNzNat(6) -> tt
   isNzNat(7) -> tt
   isNzNat(_*_(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(gcd(V1, V2)) -> and(isNzNat(V1), isNzNat(V2))
   isNzNat(s_(V1)) -> isNat(V1)
   p_(s_(N)) -> U141(isNat(N), N)
   quot(M', M') -> U151(isNzNat(M'))
   quot(N, M') -> U161(and(isNzNat(M'), isNat(N)), M', N)
   quot(N, M') -> U171(and(isNzNat(M'), isNat(N)), M', N)

The set E consists of the following equations:

   _*_(x, y) == _*_(y, x)
   _+_(x, y) == _+_(y, x)
   d(x, y) == d(y, x)
   gcd(x, y) == gcd(y, x)

The set E# consists of the following equations:

   _*_^1(x, y) == _*_^1(y, x)
   _+_^1(x, y) == _+_^1(y, x)
   D(x, y) == D(y, x)
   GCD(x, y) == GCD(y, x)

We have to consider all minimal (P,E#,R,E)-chains