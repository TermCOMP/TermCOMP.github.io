YES
We consider the system 1AQ4V.

  Alphabet:

    cons : [c * b] --> b 
    map : [c -> c * b] --> b 
    nil : [] --> b 
    node : [a * b] --> c 
    treemap : [a -> a] --> c -> c 

  Rules:

    map(F, nil) => nil 
    map(F, cons(X, Y)) => cons(F X, map(F, Y)) 
    treemap(F) node(X, Y) => node(F X, map(treemap(F), Y)) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  map(F, nil) >? nil 
  map(F, cons(X, Y)) >? cons(F X, map(F, Y)) 
  treemap(F) node(X, Y) >? node(F X, map(treemap(F), Y)) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

Argument functions:

  [[nil]] = _|_ 

We choose Lex = {} and Mul = {@_{o -> o}, cons, map, node, treemap}, and the following precedence: treemap > @_{o -> o} = map > cons > node

Taking the argument function into account, and fixing the greater / greater equal choices, the constraints can be denoted as follows:

  map(F, _|_) > _|_ 
  map(F, cons(X, Y)) >= cons(@_{o -> o}(F, X), map(F, Y)) 
  @_{o -> o}(treemap(F), node(X, Y)) >= node(@_{o -> o}(F, X), map(treemap(F), Y)) 

With these choices, we have:

  1] map(F, _|_) > _|_  because [2], by definition 
  2] map*(F, _|_) >= _|_  by (Bot) 

  3] map(F, cons(X, Y)) >= cons(@_{o -> o}(F, X), map(F, Y))  because [4], by (Star) 
  4] map*(F, cons(X, Y)) >= cons(@_{o -> o}(F, X), map(F, Y))  because map > cons, [5] and [10], by (Copy) 
  5] map*(F, cons(X, Y)) >= @_{o -> o}(F, X)  because map = @_{o -> o}, map in Mul, [6] and [7], by (Stat) 
  6] F >= F  by (Meta) 
  7] cons(X, Y) > X  because [8], by definition 
  8] cons*(X, Y) >= X  because [9], by (Select) 
  9] X >= X  by (Meta) 
  10] map*(F, cons(X, Y)) >= map(F, Y)  because map in Mul, [6] and [11], by (Stat) 
  11] cons(X, Y) > Y  because [12], by definition 
  12] cons*(X, Y) >= Y  because [13], by (Select) 
  13] Y >= Y  by (Meta) 

  14] @_{o -> o}(treemap(F), node(X, Y)) >= node(@_{o -> o}(F, X), map(treemap(F), Y))  because [15], by (Star) 
  15] @_{o -> o}*(treemap(F), node(X, Y)) >= node(@_{o -> o}(F, X), map(treemap(F), Y))  because [16], by (Select) 
  16] treemap(F) @_{o -> o}*(treemap(F), node(X, Y)) >= node(@_{o -> o}(F, X), map(treemap(F), Y))  because [17] 
  17] treemap*(F, @_{o -> o}*(treemap(F), node(X, Y))) >= node(@_{o -> o}(F, X), map(treemap(F), Y))  because treemap > node, [18] and [29], by (Copy) 
  18] treemap*(F, @_{o -> o}*(treemap(F), node(X, Y))) >= @_{o -> o}(F, X)  because treemap > @_{o -> o}, [19] and [21], by (Copy) 
  19] treemap*(F, @_{o -> o}*(treemap(F), node(X, Y))) >= F  because [20], by (Select) 
  20] F >= F  by (Meta) 
  21] treemap*(F, @_{o -> o}*(treemap(F), node(X, Y))) >= X  because [22], by (Select) 
  22] @_{o -> o}*(treemap(F), node(X, Y)) >= X  because [23], by (Select) 
  23] treemap(F) @_{o -> o}*(treemap(F), node(X, Y)) >= X  because [24] 
  24] treemap*(F, @_{o -> o}*(treemap(F), node(X, Y))) >= X  because [25], by (Select) 
  25] @_{o -> o}*(treemap(F), node(X, Y)) >= X  because [26], by (Select) 
  26] node(X, Y) >= X  because [27], by (Star) 
  27] node*(X, Y) >= X  because [28], by (Select) 
  28] X >= X  by (Meta) 
  29] treemap*(F, @_{o -> o}*(treemap(F), node(X, Y))) >= map(treemap(F), Y)  because [30], by (Select) 
  30] @_{o -> o}*(treemap(F), node(X, Y)) >= map(treemap(F), Y)  because @_{o -> o} = map, @_{o -> o} in Mul, [31] and [33], by (Stat) 
  31] treemap(F) >= treemap(F)  because treemap in Mul and [32], by (Fun) 
  32] F >= F  by (Meta) 
  33] node(X, Y) > Y  because [34], by definition 
  34] node*(X, Y) >= Y  because [35], by (Select) 
  35] Y >= Y  by (Meta) 

We can thus remove the following rules:

  map(F, nil) => nil 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  map(F, cons(X, Y)) >? cons(F X, map(F, Y)) 
  treemap(F) node(X, Y) >? node(F X, map(treemap(F), Y)) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

We choose Lex = {} and Mul = {@_{o -> o}, cons, map, node, treemap}, and the following precedence: @_{o -> o} = map > cons > node > treemap

With these choices, we have:

  1] map(F, cons(X, Y)) > cons(@_{o -> o}(F, X), map(F, Y))  because [2], by definition 
  2] map*(F, cons(X, Y)) >= cons(@_{o -> o}(F, X), map(F, Y))  because map > cons, [3] and [8], by (Copy) 
  3] map*(F, cons(X, Y)) >= @_{o -> o}(F, X)  because map = @_{o -> o}, map in Mul, [4] and [5], by (Stat) 
  4] F >= F  by (Meta) 
  5] cons(X, Y) > X  because [6], by definition 
  6] cons*(X, Y) >= X  because [7], by (Select) 
  7] X >= X  by (Meta) 
  8] map*(F, cons(X, Y)) >= map(F, Y)  because map in Mul, [4] and [9], by (Stat) 
  9] cons(X, Y) > Y  because [10], by definition 
  10] cons*(X, Y) >= Y  because [11], by (Select) 
  11] Y >= Y  by (Meta) 

  12] @_{o -> o}(treemap(F), node(X, Y)) >= node(@_{o -> o}(F, X), map(treemap(F), Y))  because [13], by (Star) 
  13] @_{o -> o}*(treemap(F), node(X, Y)) >= node(@_{o -> o}(F, X), map(treemap(F), Y))  because @_{o -> o} > node, [14] and [21], by (Copy) 
  14] @_{o -> o}*(treemap(F), node(X, Y)) >= @_{o -> o}(F, X)  because @_{o -> o} in Mul, [15] and [18], by (Stat) 
  15] treemap(F) >= F  because [16], by (Star) 
  16] treemap*(F) >= F  because [17], by (Select) 
  17] F >= F  by (Meta) 
  18] node(X, Y) > X  because [19], by definition 
  19] node*(X, Y) >= X  because [20], by (Select) 
  20] X >= X  by (Meta) 
  21] @_{o -> o}*(treemap(F), node(X, Y)) >= map(treemap(F), Y)  because @_{o -> o} = map, @_{o -> o} in Mul, [22] and [24], by (Stat) 
  22] treemap(F) >= treemap(F)  because treemap in Mul and [23], by (Fun) 
  23] F >= F  by (Meta) 
  24] node(X, Y) > Y  because [25], by definition 
  25] node*(X, Y) >= Y  because [26], by (Select) 
  26] Y >= Y  by (Meta) 

We can thus remove the following rules:

  map(F, cons(X, Y)) => cons(F X, map(F, Y)) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  treemap(F) node(X, Y) >? node(F X, map(treemap(F), Y)) 

We orient these requirements with a polynomial interpretation in the natural numbers.

The following interpretation satisfies the requirements:

  map = Lam[G0;y1].y1 + G0(y1) 
  node = Lam[y0;y1].3 + y0 + 2*y1 
  treemap = Lam[G0;y1].3*y1 + G0(0) + 2*y1*G0(y1) 

Using this interpretation, the requirements translate to:

  [[treemap(_F0) node(_x1, _x2)]] = 12 + 4*x1 + 8*x2 + F0(0) + 2*x1*F0(3 + x1 + 2*x2) + 4*x2*F0(3 + x1 + 2*x2) + 6*F0(3 + x1 + 2*x2) > 3 + x1 + 8*x2 + F0(x1) + 2*F0(0) + 4*x2*F0(x2) = [[node(_F0 _x1, map(treemap(_F0), _x2))]] 

We can thus remove the following rules:

  treemap(F) node(X, Y) => node(F X, map(treemap(F), Y)) 

All rules were succesfully removed.  Thus, termination of the original system has been reduced to termination of the beta-rule, which is well-known to hold.


+++ Citations +++

[Kop12]  C. Kop.  Higher Order Termination.  PhD Thesis, 2012.
