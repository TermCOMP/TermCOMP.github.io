NO
We consider the system Mb4i2.

  Alphabet:

    activate : [A] --> A 
    app : [A -> A * A] --> A 
    cons : [A * A] --> A 
    cons1 : [A * A] --> A 
    fcons : [A * A] --> A 
    first : [A * A] --> A 
    first1 : [A * A] --> A 
    from : [A] --> A 
    map : [A -> A * A] --> A 
    n0 : [] --> A 
    n01 : [] --> A 
    nil : [] --> A 
    nil1 : [] --> A 
    nxx0 : [] --> A 
    nxxcons : [A * A] --> A 
    nxxfirst : [A * A] --> A 
    nxxfrom : [A] --> A 
    nxxnil : [] --> A 
    nxxs : [A] --> A 
    nxxsel : [A * A] --> A 
    quote : [A] --> A 
    quote1 : [A] --> A 
    s : [A] --> A 
    s1 : [A] --> A 
    sel : [A * A] --> A 
    sel1 : [A * A] --> A 
    unquote : [A] --> A 
    unquote1 : [A] --> A 

  Rules:

    sel(s(X), cons(Y, Z)) => sel(X, activate(Z)) 
    sel(n0, cons(X, Y)) => X 
    first(n0, X) => nil 
    first(s(X), cons(Y, Z)) => cons(Y, nxxfirst(X, activate(Z))) 
    from(X) => cons(X, nxxfrom(nxxs(X))) 
    sel1(s(X), cons(Y, Z)) => sel1(X, activate(Z)) 
    sel1(n0, cons(X, Y)) => quote(X) 
    first1(n0, X) => nil1 
    first1(s(X), cons(Y, Z)) => cons1(quote(Y), first1(X, activate(Z))) 
    quote(nxx0) => n01 
    quote1(nxxcons(X, Y)) => cons1(quote(activate(X)), quote1(activate(Y))) 
    quote1(nxxnil) => nil1 
    quote(nxxs(X)) => s1(quote(activate(X))) 
    quote(nxxsel(X, Y)) => sel1(activate(X), activate(Y)) 
    quote1(nxxfirst(X, Y)) => first1(activate(X), activate(Y)) 
    unquote(n01) => n0 
    unquote(s1(X)) => s(unquote(X)) 
    unquote1(nil1) => nil 
    unquote1(cons1(X, Y)) => fcons(unquote(X), unquote1(Y)) 
    fcons(X, Y) => cons(X, Y) 
    first(X, Y) => nxxfirst(X, Y) 
    from(X) => nxxfrom(X) 
    s(X) => nxxs(X) 
    n0 => nxx0 
    cons(X, Y) => nxxcons(X, Y) 
    nil => nxxnil 
    sel(X, Y) => nxxsel(X, Y) 
    activate(nxxfirst(X, Y)) => first(activate(X), activate(Y)) 
    activate(nxxfrom(X)) => from(activate(X)) 
    activate(nxxs(X)) => s(activate(X)) 
    activate(nxx0) => n0 
    activate(nxxcons(X, Y)) => cons(activate(X), Y) 
    activate(nxxnil) => nil 
    activate(nxxsel(X, Y)) => sel(activate(X), activate(Y)) 
    activate(X) => X 
    map(F, nil) => nil 
    app(F, X) => F X 

Symbol app is an encoding for application that is only used in innocuous ways.  We can simplify the program (without losing non-termination) by removing it.  This gives:

  Alphabet:

    activate : [A] --> A 
    cons : [A * A] --> A 
    cons1 : [A * A] --> A 
    fcons : [A * A] --> A 
    first : [A * A] --> A 
    first1 : [A * A] --> A 
    from : [A] --> A 
    map : [A -> A * A] --> A 
    n0 : [] --> A 
    n01 : [] --> A 
    nil : [] --> A 
    nil1 : [] --> A 
    nxx0 : [] --> A 
    nxxcons : [A * A] --> A 
    nxxfirst : [A * A] --> A 
    nxxfrom : [A] --> A 
    nxxnil : [] --> A 
    nxxs : [A] --> A 
    nxxsel : [A * A] --> A 
    quote : [A] --> A 
    quote1 : [A] --> A 
    s : [A] --> A 
    s1 : [A] --> A 
    sel : [A * A] --> A 
    sel1 : [A * A] --> A 
    unquote : [A] --> A 
    unquote1 : [A] --> A 

  Rules:

    sel(s(X), cons(Y, Z)) => sel(X, activate(Z)) 
    sel(n0, cons(X, Y)) => X 
    first(n0, X) => nil 
    first(s(X), cons(Y, Z)) => cons(Y, nxxfirst(X, activate(Z))) 
    from(X) => cons(X, nxxfrom(nxxs(X))) 
    sel1(s(X), cons(Y, Z)) => sel1(X, activate(Z)) 
    sel1(n0, cons(X, Y)) => quote(X) 
    first1(n0, X) => nil1 
    first1(s(X), cons(Y, Z)) => cons1(quote(Y), first1(X, activate(Z))) 
    quote(nxx0) => n01 
    quote1(nxxcons(X, Y)) => cons1(quote(activate(X)), quote1(activate(Y))) 
    quote1(nxxnil) => nil1 
    quote(nxxs(X)) => s1(quote(activate(X))) 
    quote(nxxsel(X, Y)) => sel1(activate(X), activate(Y)) 
    quote1(nxxfirst(X, Y)) => first1(activate(X), activate(Y)) 
    unquote(n01) => n0 
    unquote(s1(X)) => s(unquote(X)) 
    unquote1(nil1) => nil 
    unquote1(cons1(X, Y)) => fcons(unquote(X), unquote1(Y)) 
    fcons(X, Y) => cons(X, Y) 
    first(X, Y) => nxxfirst(X, Y) 
    from(X) => nxxfrom(X) 
    s(X) => nxxs(X) 
    n0 => nxx0 
    cons(X, Y) => nxxcons(X, Y) 
    nil => nxxnil 
    sel(X, Y) => nxxsel(X, Y) 
    activate(nxxfirst(X, Y)) => first(activate(X), activate(Y)) 
    activate(nxxfrom(X)) => from(activate(X)) 
    activate(nxxs(X)) => s(activate(X)) 
    activate(nxx0) => n0 
    activate(nxxcons(X, Y)) => cons(activate(X), Y) 
    activate(nxxnil) => nil 
    activate(nxxsel(X, Y)) => sel(activate(X), activate(Y)) 
    activate(X) => X 
    map(F, nil) => nil 

This system is non-terminating, as demonstrated by our external first-order non-termination checker:

 || quote1(activate(nxxfrom(%X')))
 || proof of system.trs
 || # AProVE Commit ID: 500ec9b2e2a919720cb177ef26031cb0220e008e fuhs 20130603
 || 
 || 
 || Termination w.r.t. Q of the given QTRS could be disproven:
 || 
 || (0) QTRS
 || (1) NonTerminationProof [EQUIVALENT, 797 ms]
 || (2) NO
 || 
 || 
 || ----------------------------------------
 || 
 || (0)
 || Obligation:
 || Q restricted rewrite system:
 || The TRS R consists of the following rules:
 || 
 ||    sel(s(%X), cons(%Y, %Z)) -> sel(%X, activate(%Z))
 ||    sel(n0, cons(%X, %Y)) -> %X
 ||    first(n0, %X) -> nil
 ||    first(s(%X), cons(%Y, %Z)) -> cons(%Y, nxxfirst(%X, activate(%Z)))
 ||    from(%X) -> cons(%X, nxxfrom(nxxs(%X)))
 ||    sel1(s(%X), cons(%Y, %Z)) -> sel1(%X, activate(%Z))
 ||    sel1(n0, cons(%X, %Y)) -> quote(%X)
 ||    first1(n0, %X) -> nil1
 ||    first1(s(%X), cons(%Y, %Z)) -> cons1(quote(%Y), first1(%X, activate(%Z)))
 ||    quote(nxx0) -> n01
 ||    quote1(nxxcons(%X, %Y)) -> cons1(quote(activate(%X)), quote1(activate(%Y)))
 ||    quote1(nxxnil) -> nil1
 ||    quote(nxxs(%X)) -> s1(quote(activate(%X)))
 ||    quote(nxxsel(%X, %Y)) -> sel1(activate(%X), activate(%Y))
 ||    quote1(nxxfirst(%X, %Y)) -> first1(activate(%X), activate(%Y))
 ||    unquote(n01) -> n0
 ||    unquote(s1(%X)) -> s(unquote(%X))
 ||    unquote1(nil1) -> nil
 ||    unquote1(cons1(%X, %Y)) -> fcons(unquote(%X), unquote1(%Y))
 ||    fcons(%X, %Y) -> cons(%X, %Y)
 ||    first(%X, %Y) -> nxxfirst(%X, %Y)
 ||    from(%X) -> nxxfrom(%X)
 ||    s(%X) -> nxxs(%X)
 ||    n0 -> nxx0
 ||    cons(%X, %Y) -> nxxcons(%X, %Y)
 ||    nil -> nxxnil
 ||    sel(%X, %Y) -> nxxsel(%X, %Y)
 ||    activate(nxxfirst(%X, %Y)) -> first(activate(%X), activate(%Y))
 ||    activate(nxxfrom(%X)) -> from(activate(%X))
 ||    activate(nxxs(%X)) -> s(activate(%X))
 ||    activate(nxx0) -> n0
 ||    activate(nxxcons(%X, %Y)) -> cons(activate(%X), %Y)
 ||    activate(nxxnil) -> nil
 ||    activate(nxxsel(%X, %Y)) -> sel(activate(%X), activate(%Y))
 ||    activate(%X) -> %X
 || 
 || Q is empty.
 || 
 || ----------------------------------------
 || 
 || (1) NonTerminationProof (EQUIVALENT)
 || The following loops were found:
 || 
 || ---------- Loop: ----------
 || 
 || quote1(activate(nxxfrom(%X'))) -> quote1(from(activate(%X'))) with rule activate(nxxfrom(%X'')) -> from(activate(%X'')) at position [0] and matcher [%X'' / %X']
 || 
 || quote1(from(activate(%X'))) -> quote1(cons(activate(%X'), nxxfrom(nxxs(activate(%X'))))) with rule from(%X) -> cons(%X, nxxfrom(nxxs(%X))) at position [0] and matcher [%X / activate(%X')]
 || 
 || quote1(cons(activate(%X'), nxxfrom(nxxs(activate(%X'))))) -> quote1(nxxcons(activate(%X'), nxxfrom(nxxs(activate(%X'))))) with rule cons(%X'', %Y') -> nxxcons(%X'', %Y') at position [0] and matcher [%X'' / activate(%X'), %Y' / nxxfrom(nxxs(activate(%X')))]
 || 
 || quote1(nxxcons(activate(%X'), nxxfrom(nxxs(activate(%X'))))) -> cons1(quote(activate(activate(%X'))), quote1(activate(nxxfrom(nxxs(activate(%X')))))) with rule quote1(nxxcons(%X, %Y)) -> cons1(quote(activate(%X)), quote1(activate(%Y))) at position [] and matcher [%X / activate(%X'), %Y / nxxfrom(nxxs(activate(%X')))]
 || 
 || Now an instance of the first term with Matcher [%X' / nxxs(activate(%X'))] occurs in the last term at position [1].
 || 
 || Context: cons1(quote(activate(activate(%X'))), [])
 || 
 || 
 || ----------------------------------------
 || 
 || (2)
 || NO
 || 
