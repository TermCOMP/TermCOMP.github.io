YES
We consider the system Wi3L6.

  Alphabet:

    O : [] --> a 
    add : [a * a] --> a 
    fact : [] --> a -> a 
    mult : [] --> a -> a -> a 
    rec : [a -> a -> a * a] --> a -> a 
    s : [a] --> a 

  Rules:

    add(O, X) => X 
    add(s(X), Y) => s(add(X, Y)) 
    mult O X => O 
    mult s(X) Y => add(mult X Y, Y) 
    rec(F, X) O => X 
    rec(F, X) s(Y) => F s(Y) (rec(F, X) Y) 
    fact => rec(mult, s(O)) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  add(O, X) >? X 
  add(s(X), Y) >? s(add(X, Y)) 
  mult O X >? O 
  mult s(X) Y >? add(mult X Y, Y) 
  rec(F, X) O >? X 
  rec(F, X) s(Y) >? F s(Y) (rec(F, X) Y) 
  fact >? rec(mult, s(O)) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

Argument functions:

  [[O]] = _|_ 

We choose Lex = {} and Mul = {@_{o -> o -> o}, @_{o -> o}, add, fact, mult, rec, s}, and the following precedence: fact > mult > rec > @_{o -> o -> o} > @_{o -> o} > add > s

Taking the argument function into account, and fixing the greater / greater equal choices, the constraints can be denoted as follows:

  add(_|_, X) > X 
  add(s(X), Y) > s(add(X, Y)) 
  @_{o -> o}(@_{o -> o -> o}(mult, _|_), X) >= _|_ 
  @_{o -> o}(@_{o -> o -> o}(mult, s(X)), Y) >= add(@_{o -> o}(@_{o -> o -> o}(mult, X), Y), Y) 
  @_{o -> o}(rec(F, X), _|_) >= X 
  @_{o -> o}(rec(F, X), s(Y)) > @_{o -> o}(@_{o -> o -> o}(F, s(Y)), @_{o -> o}(rec(F, X), Y)) 
  fact >= rec(mult, s(_|_)) 

With these choices, we have:

  1] add(_|_, X) > X  because [2], by definition 
  2] add*(_|_, X) >= X  because [3], by (Select) 
  3] X >= X  by (Meta) 

  4] add(s(X), Y) > s(add(X, Y))  because [5], by definition 
  5] add*(s(X), Y) >= s(add(X, Y))  because add > s and [6], by (Copy) 
  6] add*(s(X), Y) >= add(X, Y)  because add in Mul, [7] and [10], by (Stat) 
  7] s(X) > X  because [8], by definition 
  8] s*(X) >= X  because [9], by (Select) 
  9] X >= X  by (Meta) 
  10] Y >= Y  by (Meta) 

  11] @_{o -> o}(@_{o -> o -> o}(mult, _|_), X) >= _|_  by (Bot) 

  12] @_{o -> o}(@_{o -> o -> o}(mult, s(X)), Y) >= add(@_{o -> o}(@_{o -> o -> o}(mult, X), Y), Y)  because [13], by (Star) 
  13] @_{o -> o}*(@_{o -> o -> o}(mult, s(X)), Y) >= add(@_{o -> o}(@_{o -> o -> o}(mult, X), Y), Y)  because @_{o -> o} > add, [14] and [22], by (Copy) 
  14] @_{o -> o}*(@_{o -> o -> o}(mult, s(X)), Y) >= @_{o -> o}(@_{o -> o -> o}(mult, X), Y)  because @_{o -> o} in Mul, [15] and [21], by (Stat) 
  15] @_{o -> o -> o}(mult, s(X)) > @_{o -> o -> o}(mult, X)  because [16], by definition 
  16] @_{o -> o -> o}*(mult, s(X)) >= @_{o -> o -> o}(mult, X)  because @_{o -> o -> o} in Mul, [17] and [18], by (Stat) 
  17] mult >= mult  by (Fun) 
  18] s(X) > X  because [19], by definition 
  19] s*(X) >= X  because [20], by (Select) 
  20] X >= X  by (Meta) 
  21] Y >= Y  by (Meta) 
  22] @_{o -> o}*(@_{o -> o -> o}(mult, s(X)), Y) >= Y  because [21], by (Select) 

  23] @_{o -> o}(rec(F, X), _|_) >= X  because [24], by (Star) 
  24] @_{o -> o}*(rec(F, X), _|_) >= X  because [25], by (Select) 
  25] rec(F, X) @_{o -> o}*(rec(F, X), _|_) >= X  because [26] 
  26] rec*(F, X, @_{o -> o}*(rec(F, X), _|_)) >= X  because [27], by (Select) 
  27] X >= X  by (Meta) 

  28] @_{o -> o}(rec(F, X), s(Y)) > @_{o -> o}(@_{o -> o -> o}(F, s(Y)), @_{o -> o}(rec(F, X), Y))  because [29], by definition 
  29] @_{o -> o}*(rec(F, X), s(Y)) >= @_{o -> o}(@_{o -> o -> o}(F, s(Y)), @_{o -> o}(rec(F, X), Y))  because [30], by (Select) 
  30] rec(F, X) @_{o -> o}*(rec(F, X), s(Y)) >= @_{o -> o}(@_{o -> o -> o}(F, s(Y)), @_{o -> o}(rec(F, X), Y))  because [31] 
  31] rec*(F, X, @_{o -> o}*(rec(F, X), s(Y))) >= @_{o -> o}(@_{o -> o -> o}(F, s(Y)), @_{o -> o}(rec(F, X), Y))  because rec > @_{o -> o}, [32] and [41], by (Copy) 
  32] rec*(F, X, @_{o -> o}*(rec(F, X), s(Y))) >= @_{o -> o -> o}(F, s(Y))  because rec > @_{o -> o -> o}, [33] and [35], by (Copy) 
  33] rec*(F, X, @_{o -> o}*(rec(F, X), s(Y))) >= F  because [34], by (Select) 
  34] F >= F  by (Meta) 
  35] rec*(F, X, @_{o -> o}*(rec(F, X), s(Y))) >= s(Y)  because [36], by (Select) 
  36] @_{o -> o}*(rec(F, X), s(Y)) >= s(Y)  because @_{o -> o} > s and [37], by (Copy) 
  37] @_{o -> o}*(rec(F, X), s(Y)) >= Y  because [38], by (Select) 
  38] s(Y) >= Y  because [39], by (Star) 
  39] s*(Y) >= Y  because [40], by (Select) 
  40] Y >= Y  by (Meta) 
  41] rec*(F, X, @_{o -> o}*(rec(F, X), s(Y))) >= @_{o -> o}(rec(F, X), Y)  because [42], by (Select) 
  42] @_{o -> o}*(rec(F, X), s(Y)) >= @_{o -> o}(rec(F, X), Y)  because @_{o -> o} in Mul, [43] and [46], by (Stat) 
  43] rec(F, X) >= rec(F, X)  because rec in Mul, [44] and [45], by (Fun) 
  44] F >= F  by (Meta) 
  45] X >= X  by (Meta) 
  46] s(Y) > Y  because [47], by definition 
  47] s*(Y) >= Y  because [40], by (Select) 

  48] fact >= rec(mult, s(_|_))  because [49], by (Star) 
  49] fact* >= rec(mult, s(_|_))  because fact > rec, [50] and [51], by (Copy) 
  50] fact* >= mult  because fact > mult, by (Copy) 
  51] fact* >= s(_|_)  because fact > s and [52], by (Copy) 
  52] fact* >= _|_  by (Bot) 

We can thus remove the following rules:

  add(O, X) => X 
  add(s(X), Y) => s(add(X, Y)) 
  rec(F, X) s(Y) => F s(Y) (rec(F, X) Y) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  mult O X >? O 
  mult s(X) Y >? add(mult X Y, Y) 
  rec(F, X) O >? X 
  fact >? rec(mult, s(O)) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

Argument functions:

  [[O]] = _|_ 

We choose Lex = {} and Mul = {@_{o -> o -> o}, @_{o -> o}, add, fact, mult, rec, s}, and the following precedence: @_{o -> o -> o} > add > fact > rec > mult > @_{o -> o} > s

Taking the argument function into account, and fixing the greater / greater equal choices, the constraints can be denoted as follows:

  @_{o -> o}(@_{o -> o -> o}(mult, _|_), X) >= _|_ 
  @_{o -> o}(@_{o -> o -> o}(mult, s(X)), Y) >= add(@_{o -> o}(@_{o -> o -> o}(mult, X), Y), Y) 
  @_{o -> o}(rec(F, X), _|_) > X 
  fact > rec(mult, s(_|_)) 

With these choices, we have:

  1] @_{o -> o}(@_{o -> o -> o}(mult, _|_), X) >= _|_  by (Bot) 

  2] @_{o -> o}(@_{o -> o -> o}(mult, s(X)), Y) >= add(@_{o -> o}(@_{o -> o -> o}(mult, X), Y), Y)  because [3], by (Star) 
  3] @_{o -> o}*(@_{o -> o -> o}(mult, s(X)), Y) >= add(@_{o -> o}(@_{o -> o -> o}(mult, X), Y), Y)  because [4], by (Select) 
  4] @_{o -> o -> o}(mult, s(X)) @_{o -> o}*(@_{o -> o -> o}(mult, s(X)), Y) >= add(@_{o -> o}(@_{o -> o -> o}(mult, X), Y), Y)  because [5] 
  5] @_{o -> o -> o}*(mult, s(X), @_{o -> o}*(@_{o -> o -> o}(mult, s(X)), Y)) >= add(@_{o -> o}(@_{o -> o -> o}(mult, X), Y), Y)  because @_{o -> o -> o} > add, [6] and [12], by (Copy) 
  6] @_{o -> o -> o}*(mult, s(X), @_{o -> o}*(@_{o -> o -> o}(mult, s(X)), Y)) >= @_{o -> o}(@_{o -> o -> o}(mult, X), Y)  because @_{o -> o -> o} > @_{o -> o}, [7] and [12], by (Copy) 
  7] @_{o -> o -> o}*(mult, s(X), @_{o -> o}*(@_{o -> o -> o}(mult, s(X)), Y)) >= @_{o -> o -> o}(mult, X)  because @_{o -> o -> o} in Mul, [8] and [9], by (Stat) 
  8] mult >= mult  by (Fun) 
  9] s(X) > X  because [10], by definition 
  10] s*(X) >= X  because [11], by (Select) 
  11] X >= X  by (Meta) 
  12] @_{o -> o -> o}*(mult, s(X), @_{o -> o}*(@_{o -> o -> o}(mult, s(X)), Y)) >= Y  because [13], by (Select) 
  13] @_{o -> o}*(@_{o -> o -> o}(mult, s(X)), Y) >= Y  because [14], by (Select) 
  14] Y >= Y  by (Meta) 

  15] @_{o -> o}(rec(F, X), _|_) > X  because [16], by definition 
  16] @_{o -> o}*(rec(F, X), _|_) >= X  because [17], by (Select) 
  17] rec(F, X) @_{o -> o}*(rec(F, X), _|_) >= X  because [18] 
  18] rec*(F, X, @_{o -> o}*(rec(F, X), _|_)) >= X  because [19], by (Select) 
  19] X >= X  by (Meta) 

  20] fact > rec(mult, s(_|_))  because [21], by definition 
  21] fact* >= rec(mult, s(_|_))  because fact > rec, [22] and [23], by (Copy) 
  22] fact* >= mult  because fact > mult, by (Copy) 
  23] fact* >= s(_|_)  because fact > s and [24], by (Copy) 
  24] fact* >= _|_  by (Bot) 

We can thus remove the following rules:

  rec(F, X) O => X 
  fact => rec(mult, s(O)) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  mult(O, X) >? O 
  mult(s(X), Y) >? add(mult(X, Y), Y) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

We choose Lex = {} and Mul = {O, add, mult, s}, and the following precedence: mult > O > add > s

With these choices, we have:

  1] mult(O, X) >= O  because [2], by (Star) 
  2] mult*(O, X) >= O  because mult > O, by (Copy) 

  3] mult(s(X), Y) > add(mult(X, Y), Y)  because [4], by definition 
  4] mult*(s(X), Y) >= add(mult(X, Y), Y)  because mult > add, [5] and [10], by (Copy) 
  5] mult*(s(X), Y) >= mult(X, Y)  because mult in Mul, [6] and [9], by (Stat) 
  6] s(X) > X  because [7], by definition 
  7] s*(X) >= X  because [8], by (Select) 
  8] X >= X  by (Meta) 
  9] Y >= Y  by (Meta) 
  10] mult*(s(X), Y) >= Y  because [9], by (Select) 

We can thus remove the following rules:

  mult(s(X), Y) => add(mult(X, Y), Y) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  mult(O, X) >? O 

We orient these requirements with a polynomial interpretation in the natural numbers.

The following interpretation satisfies the requirements:

  O = 0 
  mult = Lam[y0;y1].3 + y1 + 3*y0 

Using this interpretation, the requirements translate to:

  [[mult(O, _x0)]] = 3 + x0 > 0 = [[O]] 

We can thus remove the following rules:

  mult(O, X) => O 

All rules were succesfully removed.  Thus, termination of the original system has been reduced to termination of the beta-rule, which is well-known to hold.


+++ Citations +++

[Kop12]  C. Kop.  Higher Order Termination.  PhD Thesis, 2012.
