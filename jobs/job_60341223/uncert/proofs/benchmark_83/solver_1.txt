YES
We consider the system hg8zY.

  Alphabet:

    O : [] --> nat 
    apply : [nat * nat] --> nat 
    avg : [nat * nat] --> nat 
    check : [nat] --> nat 
    func : [nat -> nat] --> nat 
    s : [nat] --> nat 

  Rules:

    avg(s(X), Y) => avg(X, s(Y)) 
    avg(X, s(s(s(Y)))) => s(avg(s(X), Y)) 
    avg(O, O) => O 
    avg(O, s(O)) => O 
    avg(O, s(s(O))) => s(O) 
    apply(func(F), X) => F check(X) 
    check(s(X)) => s(check(X)) 
    check(O) => O 

We observe that the rules contain a first-order subset:

  avg(s(X), Y) => avg(X, s(Y)) 
  avg(X, s(s(s(Y)))) => s(avg(s(X), Y)) 
  avg(O, O) => O 
  avg(O, s(O)) => O 
  avg(O, s(s(O))) => s(O) 
  check(s(X)) => s(check(X)) 
  check(O) => O 

Moreover, the system is finitely branching.  Thus, by [Kop12, Thm. 7.55], we may omit all first-order dependency pairs from the dependency pair problem (DP(R), R) if this first-order part is Ce-terminating when seen as a many-sorted first-order TRS.

According to the external first-order termination prover, this system is indeed Ce-terminating:

 || Input TRS:
 ||     1: avg(s(PeRCenTX),PeRCenTY) -> avg(PeRCenTX,s(PeRCenTY))
 ||     2: avg(PeRCenTX,s(s(s(PeRCenTY)))) -> s(avg(s(PeRCenTX),PeRCenTY))
 ||     3: avg(O(),O()) -> O()
 ||     4: avg(O(),s(O())) -> O()
 ||     5: avg(O(),s(s(O()))) -> s(O())
 ||     6: check(s(PeRCenTX)) -> s(check(PeRCenTX))
 ||     7: check(O()) -> O()
 ||     8: TIlDePAIR(PeRCenTX,PeRCenTY) -> PeRCenTX
 ||     9: TIlDePAIR(PeRCenTX,PeRCenTY) -> PeRCenTY
 || Number of strict rules: 9
 || Direct POLO(bPol) ... removes: 4 8 1 3 5 7 9 6
 ||       TIlDePAIR	w: 2 * x1 + 2 * x2 + 1
 ||       s 	w: x1 + 1
 ||       O 	w: 1
 ||       check	w: 2 * x1 + 1
 ||       avg	w: 2 * x1 + x2
 || Number of strict rules: 1
 || Direct POLO(bPol) ... removes: 2
 ||       TIlDePAIR	w: 2 * x1 + 2 * x2 + 1
 ||       s 	w: x1 + 1
 ||       O 	w: 1
 ||       check	w: 2 * x1 + 1
 ||       avg	w: 2 * x1 + 2 * x2
 || Number of strict rules: 0
 || 
We use the dependency pair framework as described in [Kop12, Ch. 6/7], with dynamic dependency pairs.

After applying [Kop12, Thm. 7.22] to denote collapsing dependency pairs in an extended form, we thus obtain the following dependency pair problem (P_0, R_0, minimal, formative):

  Dependency Pairs P_0:

    0] apply#(func(F), X) =#> F[check(X)]   
    1] apply#(func(F), X) =#> check#(X)   

  Rules R_0:

    avg(s(X), Y) => avg(X, s(Y)) 
    avg(X, s(s(s(Y)))) => s(avg(s(X), Y)) 
    avg(O, O) => O 
    avg(O, s(O)) => O 
    avg(O, s(s(O))) => s(O) 
    apply(func(F), X) => F check(X) 
    check(s(X)) => s(check(X)) 
    check(O) => O 

Thus, the original system is terminating if (P_0, R_0, minimal, formative) is finite.

We consider the dependency pair problem (P_0, R_0, minimal, formative).

We place the elements of P in a dependency graph approximation G (see e.g. [Kop12, Thm. 7.27, 7.29], as follows:

    * 0 : 0, 1 
    * 1 :  

This graph has the following strongly connected components:

  P_1:

    apply#(func(F), X) =#> F[check(X)]   

By [Kop12, Thm. 7.31], we may replace any dependency pair problem (P_0, R_0, m, f) by (P_1, R_0, m, f).

Thus, the original system is terminating if (P_1, R_0, minimal, formative) is finite.

We consider the dependency pair problem (P_1, R_0, minimal, formative).

The formative rules of (P_1, R_0) are R_1 ::=

  apply(func(F), X) => F check(X) 

By [Kop12, Thm. 7.17], we may replace the dependency pair problem (P_1, R_0, minimal, formative) by (P_1, R_1, minimal, formative).

Thus, the original system is terminating if (P_1, R_1, minimal, formative) is finite.

We consider the dependency pair problem (P_1, R_1, minimal, formative).

We will use the reduction pair processor [Kop12, Thm. 7.16].  As the system is abstraction-simple and the formative flag is set, it suffices to find a tagged reduction pair [Kop12, Def. 6.70].  Thus, we must orient:

  apply#(func(F), X) >? F[check(X)] 
  apply(func(F), X) >= F check(X) 

We orient these requirements with a polynomial interpretation in the natural numbers.

The following interpretation satisfies the requirements:

  apply = Lam[y0;y1].3 + 3*y0 
  apply# = Lam[y0;y1].3 + y0 
  check = Lam[y0].0 
  func = Lam[G0].3 + G0(0) 

Using this interpretation, the requirements translate to:

  [[apply#(func(_F0), _x1)]] = 6 + F0(0) > F0(0) = [[_F0[check(_x1)]]] 
  [[apply(func(_F0), _x1)]] = 12 + 3*F0(0) >= F0(0) = [[_F0 check(_x1)]] 

By the observations in [Kop12, Sec. 6.6], this reduction pair suffices; we may thus replace a dependency pair problem (P_1, R_1) by ({}, R_1).  By the empty set processor [Kop12, Thm. 7.15] this problem may be immediately removed.

As all dependency pair problems were succesfully simplified with sound (and complete) processors until nothing remained, we conclude termination.


+++ Citations +++

[Kop12]  C. Kop.  Higher Order Termination.  PhD Thesis, 2012.
