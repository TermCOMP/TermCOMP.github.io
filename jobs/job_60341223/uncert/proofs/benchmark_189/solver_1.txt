YES
We consider the system 6IDML.

  Alphabet:

    O : [] --> a 
    asort : [b] --> b 
    cons : [a * b] --> b 
    dsort : [b] --> b 
    insert : [a -> a -> a * a -> a -> a * b * a] --> b 
    isort : [a -> a -> a * a -> a -> a * b] --> b 
    max : [] --> a -> a -> a 
    min : [] --> a -> a -> a 
    nil : [] --> b 
    s : [a] --> a 

  Rules:

    isort(F, G, nil) => nil 
    isort(F, G, cons(X, Y)) => insert(F, G, isort(F, G, Y), X) 
    insert(F, G, nil, X) => cons(X, nil) 
    insert(F, G, cons(X, Y), Z) => cons(F X Z, insert(F, G, Y, G X Z)) 
    max O X => X 
    max X O => X 
    max s(X) s(Y) => max X Y 
    min O X => O 
    min X O => O 
    min s(X) s(Y) => min X Y 
    asort(X) => isort(min, max, X) 
    dsort(X) => isort(max, min, X) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  isort(F, G, nil) >? nil 
  isort(F, G, cons(X, Y)) >? insert(F, G, isort(F, G, Y), X) 
  insert(F, G, nil, X) >? cons(X, nil) 
  insert(F, G, cons(X, Y), Z) >? cons(F X Z, insert(F, G, Y, G X Z)) 
  max O X >? X 
  max X O >? X 
  max s(X) s(Y) >? max X Y 
  min O X >? O 
  min X O >? O 
  min s(X) s(Y) >? min X Y 
  asort(X) >? isort(min, max, X) 
  dsort(X) >? isort(max, min, X) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

Argument functions:

  [[O]] = _|_ 
  [[insert(x_1, x_2, x_3, x_4)]] = insert(x_1, x_3, x_4, x_2) 
  [[nil]] = _|_ 

We choose Lex = {insert} and Mul = {@_{o -> o -> o}, @_{o -> o}, asort, cons, dsort, isort, max, min, s}, and the following precedence: asort > dsort > isort > insert > @_{o -> o -> o} > cons > max > min > @_{o -> o} > s

Taking the argument function into account, and fixing the greater / greater equal choices, the constraints can be denoted as follows:

  isort(F, G, _|_) >= _|_ 
  isort(F, G, cons(X, Y)) > insert(F, G, isort(F, G, Y), X) 
  insert(F, G, _|_, X) > cons(X, _|_) 
  insert(F, G, cons(X, Y), Z) >= cons(@_{o -> o}(@_{o -> o -> o}(F, X), Z), insert(F, G, Y, @_{o -> o}(@_{o -> o -> o}(G, X), Z))) 
  @_{o -> o}(@_{o -> o -> o}(max, _|_), X) > X 
  @_{o -> o}(@_{o -> o -> o}(max, X), _|_) >= X 
  @_{o -> o}(@_{o -> o -> o}(max, s(X)), s(Y)) >= @_{o -> o}(@_{o -> o -> o}(max, X), Y) 
  @_{o -> o}(@_{o -> o -> o}(min, _|_), X) >= _|_ 
  @_{o -> o}(@_{o -> o -> o}(min, X), _|_) >= _|_ 
  @_{o -> o}(@_{o -> o -> o}(min, s(X)), s(Y)) >= @_{o -> o}(@_{o -> o -> o}(min, X), Y) 
  asort(X) >= isort(min, max, X) 
  dsort(X) >= isort(max, min, X) 

With these choices, we have:

  1] isort(F, G, _|_) >= _|_  by (Bot) 

  2] isort(F, G, cons(X, Y)) > insert(F, G, isort(F, G, Y), X)  because [3], by definition 
  3] isort*(F, G, cons(X, Y)) >= insert(F, G, isort(F, G, Y), X)  because isort > insert, [4], [6], [8] and [14], by (Copy) 
  4] isort*(F, G, cons(X, Y)) >= F  because [5], by (Select) 
  5] F >= F  by (Meta) 
  6] isort*(F, G, cons(X, Y)) >= G  because [7], by (Select) 
  7] G >= G  by (Meta) 
  8] isort*(F, G, cons(X, Y)) >= isort(F, G, Y)  because isort in Mul, [9], [10] and [11], by (Stat) 
  9] F >= F  by (Meta) 
  10] G >= G  by (Meta) 
  11] cons(X, Y) > Y  because [12], by definition 
  12] cons*(X, Y) >= Y  because [13], by (Select) 
  13] Y >= Y  by (Meta) 
  14] isort*(F, G, cons(X, Y)) >= X  because [15], by (Select) 
  15] cons(X, Y) >= X  because [16], by (Star) 
  16] cons*(X, Y) >= X  because [17], by (Select) 
  17] X >= X  by (Meta) 

  18] insert(F, G, _|_, X) > cons(X, _|_)  because [19], by definition 
  19] insert*(F, G, _|_, X) >= cons(X, _|_)  because insert > cons, [20] and [22], by (Copy) 
  20] insert*(F, G, _|_, X) >= X  because [21], by (Select) 
  21] X >= X  by (Meta) 
  22] insert*(F, G, _|_, X) >= _|_  by (Bot) 

  23] insert(F, G, cons(X, Y), Z) >= cons(@_{o -> o}(@_{o -> o -> o}(F, X), Z), insert(F, G, Y, @_{o -> o}(@_{o -> o -> o}(G, X), Z)))  because [24], by (Star) 
  24] insert*(F, G, cons(X, Y), Z) >= cons(@_{o -> o}(@_{o -> o -> o}(F, X), Z), insert(F, G, Y, @_{o -> o}(@_{o -> o -> o}(G, X), Z)))  because insert > cons, [25] and [35], by (Copy) 
  25] insert*(F, G, cons(X, Y), Z) >= @_{o -> o}(@_{o -> o -> o}(F, X), Z)  because insert > @_{o -> o}, [26] and [33], by (Copy) 
  26] insert*(F, G, cons(X, Y), Z) >= @_{o -> o -> o}(F, X)  because insert > @_{o -> o -> o}, [27] and [29], by (Copy) 
  27] insert*(F, G, cons(X, Y), Z) >= F  because [28], by (Select) 
  28] F >= F  by (Meta) 
  29] insert*(F, G, cons(X, Y), Z) >= X  because [30], by (Select) 
  30] cons(X, Y) >= X  because [31], by (Star) 
  31] cons*(X, Y) >= X  because [32], by (Select) 
  32] X >= X  by (Meta) 
  33] insert*(F, G, cons(X, Y), Z) >= Z  because [34], by (Select) 
  34] Z >= Z  by (Meta) 
  35] insert*(F, G, cons(X, Y), Z) >= insert(F, G, Y, @_{o -> o}(@_{o -> o -> o}(G, X), Z))  because insert in Lex, [36], [37], [27], [40], [42] and [44], by (Stat) 
  36] F >= F  by (Meta) 
  37] cons(X, Y) > Y  because [38], by definition 
  38] cons*(X, Y) >= Y  because [39], by (Select) 
  39] Y >= Y  by (Meta) 
  40] insert*(F, G, cons(X, Y), Z) >= G  because [41], by (Select) 
  41] G >= G  by (Meta) 
  42] insert*(F, G, cons(X, Y), Z) >= Y  because [43], by (Select) 
  43] cons(X, Y) >= Y  because [38], by (Star) 
  44] insert*(F, G, cons(X, Y), Z) >= @_{o -> o}(@_{o -> o -> o}(G, X), Z)  because insert > @_{o -> o}, [45] and [33], by (Copy) 
  45] insert*(F, G, cons(X, Y), Z) >= @_{o -> o -> o}(G, X)  because insert > @_{o -> o -> o}, [40] and [29], by (Copy) 

  46] @_{o -> o}(@_{o -> o -> o}(max, _|_), X) > X  because [47], by definition 
  47] @_{o -> o}*(@_{o -> o -> o}(max, _|_), X) >= X  because [48], by (Select) 
  48] X >= X  by (Meta) 

  49] @_{o -> o}(@_{o -> o -> o}(max, X), _|_) >= X  because [50], by (Star) 
  50] @_{o -> o}*(@_{o -> o -> o}(max, X), _|_) >= X  because [51], by (Select) 
  51] @_{o -> o -> o}(max, X) @_{o -> o}*(@_{o -> o -> o}(max, X), _|_) >= X  because [52] 
  52] @_{o -> o -> o}*(max, X, @_{o -> o}*(@_{o -> o -> o}(max, X), _|_)) >= X  because [53], by (Select) 
  53] X >= X  by (Meta) 

  54] @_{o -> o}(@_{o -> o -> o}(max, s(X)), s(Y)) >= @_{o -> o}(@_{o -> o -> o}(max, X), Y)  because @_{o -> o} in Mul, [55] and [60], by (Fun) 
  55] @_{o -> o -> o}(max, s(X)) >= @_{o -> o -> o}(max, X)  because @_{o -> o -> o} in Mul, [56] and [57], by (Fun) 
  56] max >= max  by (Fun) 
  57] s(X) >= X  because [58], by (Star) 
  58] s*(X) >= X  because [59], by (Select) 
  59] X >= X  by (Meta) 
  60] s(Y) >= Y  because [61], by (Star) 
  61] s*(Y) >= Y  because [62], by (Select) 
  62] Y >= Y  by (Meta) 

  63] @_{o -> o}(@_{o -> o -> o}(min, _|_), X) >= _|_  by (Bot) 

  64] @_{o -> o}(@_{o -> o -> o}(min, X), _|_) >= _|_  by (Bot) 

  65] @_{o -> o}(@_{o -> o -> o}(min, s(X)), s(Y)) >= @_{o -> o}(@_{o -> o -> o}(min, X), Y)  because @_{o -> o} in Mul, [66] and [71], by (Fun) 
  66] @_{o -> o -> o}(min, s(X)) >= @_{o -> o -> o}(min, X)  because @_{o -> o -> o} in Mul, [67] and [68], by (Fun) 
  67] min >= min  by (Fun) 
  68] s(X) >= X  because [69], by (Star) 
  69] s*(X) >= X  because [70], by (Select) 
  70] X >= X  by (Meta) 
  71] s(Y) >= Y  because [72], by (Star) 
  72] s*(Y) >= Y  because [73], by (Select) 
  73] Y >= Y  by (Meta) 

  74] asort(X) >= isort(min, max, X)  because [75], by (Star) 
  75] asort*(X) >= isort(min, max, X)  because asort > isort, [76], [77] and [78], by (Copy) 
  76] asort*(X) >= min  because asort > min, by (Copy) 
  77] asort*(X) >= max  because asort > max, by (Copy) 
  78] asort*(X) >= X  because [79], by (Select) 
  79] X >= X  by (Meta) 

  80] dsort(X) >= isort(max, min, X)  because [81], by (Star) 
  81] dsort*(X) >= isort(max, min, X)  because dsort > isort, [82], [83] and [84], by (Copy) 
  82] dsort*(X) >= max  because dsort > max, by (Copy) 
  83] dsort*(X) >= min  because dsort > min, by (Copy) 
  84] dsort*(X) >= X  because [85], by (Select) 
  85] X >= X  by (Meta) 

We can thus remove the following rules:

  isort(F, G, cons(X, Y)) => insert(F, G, isort(F, G, Y), X) 
  insert(F, G, nil, X) => cons(X, nil) 
  max O X => X 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  isort(F, G, nil) >? nil 
  insert(F, G, cons(X, Y), Z) >? cons(F X Z, insert(F, G, Y, G X Z)) 
  max X O >? X 
  max s(X) s(Y) >? max X Y 
  min O X >? O 
  min X O >? O 
  min s(X) s(Y) >? min X Y 
  asort(X) >? isort(min, max, X) 
  dsort(X) >? isort(max, min, X) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

Argument functions:

  [[O]] = _|_ 
  [[nil]] = _|_ 

We choose Lex = {insert} and Mul = {@_{o -> o -> o}, @_{o -> o}, asort, cons, dsort, isort, max, min, s}, and the following precedence: asort > dsort > insert > @_{o -> o -> o} > @_{o -> o} > cons > isort > max > min > s

Taking the argument function into account, and fixing the greater / greater equal choices, the constraints can be denoted as follows:

  isort(F, G, _|_) >= _|_ 
  insert(F, G, cons(X, Y), Z) > cons(@_{o -> o}(@_{o -> o -> o}(F, X), Z), insert(F, G, Y, @_{o -> o}(@_{o -> o -> o}(G, X), Z))) 
  @_{o -> o}(@_{o -> o -> o}(max, X), _|_) > X 
  @_{o -> o}(@_{o -> o -> o}(max, s(X)), s(Y)) >= @_{o -> o}(@_{o -> o -> o}(max, X), Y) 
  @_{o -> o}(@_{o -> o -> o}(min, _|_), X) >= _|_ 
  @_{o -> o}(@_{o -> o -> o}(min, X), _|_) >= _|_ 
  @_{o -> o}(@_{o -> o -> o}(min, s(X)), s(Y)) >= @_{o -> o}(@_{o -> o -> o}(min, X), Y) 
  asort(X) > isort(min, max, X) 
  dsort(X) >= isort(max, min, X) 

With these choices, we have:

  1] isort(F, G, _|_) >= _|_  by (Bot) 

  2] insert(F, G, cons(X, Y), Z) > cons(@_{o -> o}(@_{o -> o -> o}(F, X), Z), insert(F, G, Y, @_{o -> o}(@_{o -> o -> o}(G, X), Z)))  because [3], by definition 
  3] insert*(F, G, cons(X, Y), Z) >= cons(@_{o -> o}(@_{o -> o -> o}(F, X), Z), insert(F, G, Y, @_{o -> o}(@_{o -> o -> o}(G, X), Z)))  because insert > cons, [4] and [14], by (Copy) 
  4] insert*(F, G, cons(X, Y), Z) >= @_{o -> o}(@_{o -> o -> o}(F, X), Z)  because insert > @_{o -> o}, [5] and [12], by (Copy) 
  5] insert*(F, G, cons(X, Y), Z) >= @_{o -> o -> o}(F, X)  because insert > @_{o -> o -> o}, [6] and [8], by (Copy) 
  6] insert*(F, G, cons(X, Y), Z) >= F  because [7], by (Select) 
  7] F >= F  by (Meta) 
  8] insert*(F, G, cons(X, Y), Z) >= X  because [9], by (Select) 
  9] cons(X, Y) >= X  because [10], by (Star) 
  10] cons*(X, Y) >= X  because [11], by (Select) 
  11] X >= X  by (Meta) 
  12] insert*(F, G, cons(X, Y), Z) >= Z  because [13], by (Select) 
  13] Z >= Z  by (Meta) 
  14] insert*(F, G, cons(X, Y), Z) >= insert(F, G, Y, @_{o -> o}(@_{o -> o -> o}(G, X), Z))  because insert in Lex, [15], [16], [17], [6], [20], [21] and [23], by (Stat) 
  15] F >= F  by (Meta) 
  16] G >= G  by (Meta) 
  17] cons(X, Y) > Y  because [18], by definition 
  18] cons*(X, Y) >= Y  because [19], by (Select) 
  19] Y >= Y  by (Meta) 
  20] insert*(F, G, cons(X, Y), Z) >= G  because [16], by (Select) 
  21] insert*(F, G, cons(X, Y), Z) >= Y  because [22], by (Select) 
  22] cons(X, Y) >= Y  because [18], by (Star) 
  23] insert*(F, G, cons(X, Y), Z) >= @_{o -> o}(@_{o -> o -> o}(G, X), Z)  because insert > @_{o -> o}, [24] and [12], by (Copy) 
  24] insert*(F, G, cons(X, Y), Z) >= @_{o -> o -> o}(G, X)  because insert > @_{o -> o -> o}, [20] and [8], by (Copy) 

  25] @_{o -> o}(@_{o -> o -> o}(max, X), _|_) > X  because [26], by definition 
  26] @_{o -> o}*(@_{o -> o -> o}(max, X), _|_) >= X  because [27], by (Select) 
  27] @_{o -> o -> o}(max, X) @_{o -> o}*(@_{o -> o -> o}(max, X), _|_) >= X  because [28] 
  28] @_{o -> o -> o}*(max, X, @_{o -> o}*(@_{o -> o -> o}(max, X), _|_)) >= X  because [29], by (Select) 
  29] X >= X  by (Meta) 

  30] @_{o -> o}(@_{o -> o -> o}(max, s(X)), s(Y)) >= @_{o -> o}(@_{o -> o -> o}(max, X), Y)  because @_{o -> o} in Mul, [31] and [36], by (Fun) 
  31] @_{o -> o -> o}(max, s(X)) >= @_{o -> o -> o}(max, X)  because @_{o -> o -> o} in Mul, [32] and [33], by (Fun) 
  32] max >= max  by (Fun) 
  33] s(X) >= X  because [34], by (Star) 
  34] s*(X) >= X  because [35], by (Select) 
  35] X >= X  by (Meta) 
  36] s(Y) >= Y  because [37], by (Star) 
  37] s*(Y) >= Y  because [38], by (Select) 
  38] Y >= Y  by (Meta) 

  39] @_{o -> o}(@_{o -> o -> o}(min, _|_), X) >= _|_  by (Bot) 

  40] @_{o -> o}(@_{o -> o -> o}(min, X), _|_) >= _|_  by (Bot) 

  41] @_{o -> o}(@_{o -> o -> o}(min, s(X)), s(Y)) >= @_{o -> o}(@_{o -> o -> o}(min, X), Y)  because @_{o -> o} in Mul, [42] and [47], by (Fun) 
  42] @_{o -> o -> o}(min, s(X)) >= @_{o -> o -> o}(min, X)  because @_{o -> o -> o} in Mul, [43] and [44], by (Fun) 
  43] min >= min  by (Fun) 
  44] s(X) >= X  because [45], by (Star) 
  45] s*(X) >= X  because [46], by (Select) 
  46] X >= X  by (Meta) 
  47] s(Y) >= Y  because [48], by (Star) 
  48] s*(Y) >= Y  because [49], by (Select) 
  49] Y >= Y  by (Meta) 

  50] asort(X) > isort(min, max, X)  because [51], by definition 
  51] asort*(X) >= isort(min, max, X)  because asort > isort, [52], [53] and [54], by (Copy) 
  52] asort*(X) >= min  because asort > min, by (Copy) 
  53] asort*(X) >= max  because asort > max, by (Copy) 
  54] asort*(X) >= X  because [55], by (Select) 
  55] X >= X  by (Meta) 

  56] dsort(X) >= isort(max, min, X)  because [57], by (Star) 
  57] dsort*(X) >= isort(max, min, X)  because dsort > isort, [58], [59] and [60], by (Copy) 
  58] dsort*(X) >= max  because dsort > max, by (Copy) 
  59] dsort*(X) >= min  because dsort > min, by (Copy) 
  60] dsort*(X) >= X  because [61], by (Select) 
  61] X >= X  by (Meta) 

We can thus remove the following rules:

  insert(F, G, cons(X, Y), Z) => cons(F X Z, insert(F, G, Y, G X Z)) 
  max X O => X 
  asort(X) => isort(min, max, X) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  isort(F, G, nil) >? nil 
  max s(X) s(Y) >? max X Y 
  min O X >? O 
  min X O >? O 
  min s(X) s(Y) >? min X Y 
  dsort(X) >? isort(max, min, X) 

We orient these requirements with a polynomial interpretation in the natural numbers.

The following interpretation satisfies the requirements:

  O = 3 
  dsort = Lam[y0].3 + 3*y0 
  isort = Lam[G0;G1;y2].y2 + G0(0,0) + G1(0,0) 
  max = Lam[y0;y1].0 
  min = Lam[y0;y1].0 
  nil = 0 
  s = Lam[y0].3 + 3*y0 

Using this interpretation, the requirements translate to:

  [[isort(_F0, _F1, nil)]] = F0(0,0) + F1(0,0) >= 0 = [[nil]] 
  [[max s(_x0) s(_x1)]] = 6 + 3*x0 + 3*x1 > x0 + x1 = [[max _x0 _x1]] 
  [[min O _x0]] = 3 + x0 >= 3 = [[O]] 
  [[min _x0 O]] = 3 + x0 >= 3 = [[O]] 
  [[min s(_x0) s(_x1)]] = 6 + 3*x0 + 3*x1 > x0 + x1 = [[min _x0 _x1]] 
  [[dsort(_x0)]] = 3 + 3*x0 > x0 = [[isort(max, min, _x0)]] 

We can thus remove the following rules:

  max s(X) s(Y) => max X Y 
  min s(X) s(Y) => min X Y 
  dsort(X) => isort(max, min, X) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  isort(F, G, nil) >? nil 
  min(O, X) >? O 
  min(X, O) >? O 

We orient these requirements with a polynomial interpretation in the natural numbers.

The following interpretation satisfies the requirements:

  O = 0 
  isort = Lam[G0;G1;y2].3 + 3*y2 + G0(0,0) + G1(0,0) 
  min = Lam[y0;y1].3 + 3*y0 + 3*y1 
  nil = 0 

Using this interpretation, the requirements translate to:

  [[isort(_F0, _F1, nil)]] = 3 + F0(0,0) + F1(0,0) > 0 = [[nil]] 
  [[min(O, _x0)]] = 3 + 3*x0 > 0 = [[O]] 
  [[min(_x0, O)]] = 3 + 3*x0 > 0 = [[O]] 

We can thus remove the following rules:

  isort(F, G, nil) => nil 
  min(O, X) => O 
  min(X, O) => O 

All rules were succesfully removed.  Thus, termination of the original system has been reduced to termination of the beta-rule, which is well-known to hold.


+++ Citations +++

[Kop12]  C. Kop.  Higher Order Termination.  PhD Thesis, 2012.
