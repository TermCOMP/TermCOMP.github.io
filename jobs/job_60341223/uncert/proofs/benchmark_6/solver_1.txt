YES
We consider the system KLIYY.

  Alphabet:

    mult : [N * N] --> N 
    plus : [N * N] --> N 
    s : [N] --> N 
    z : [] --> N 

  Rules:

    plus(z, X) => X 
    plus(s(X), Y) => plus(X, s(Y)) 
    plus(plus(X, Y), Z) => plus(X, plus(Y, Z)) 
    mult(z, X) => z 
    mult(s(X), Y) => plus(mult(X, Y), Y) 
    mult(plus(X, Y), Z) => plus(mult(X, Z), mult(Y, Z)) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  plus(z, X) >? X 
  plus(s(X), Y) >? plus(X, s(Y)) 
  plus(plus(X, Y), Z) >? plus(X, plus(Y, Z)) 
  mult(z, X) >? z 
  mult(s(X), Y) >? plus(mult(X, Y), Y) 
  mult(plus(X, Y), Z) >? plus(mult(X, Z), mult(Y, Z)) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

Argument functions:

  [[z]] = _|_ 

We choose Lex = {plus} and Mul = {mult, s}, and the following precedence: mult > plus > s

Taking the argument function into account, and fixing the greater / greater equal choices, the constraints can be denoted as follows:

  plus(_|_, X) >= X 
  plus(s(X), Y) >= plus(X, s(Y)) 
  plus(plus(X, Y), Z) > plus(X, plus(Y, Z)) 
  mult(_|_, X) >= _|_ 
  mult(s(X), Y) >= plus(mult(X, Y), Y) 
  mult(plus(X, Y), Z) > plus(mult(X, Z), mult(Y, Z)) 

With these choices, we have:

  1] plus(_|_, X) >= X  because [2], by (Star) 
  2] plus*(_|_, X) >= X  because [3], by (Select) 
  3] X >= X  by (Meta) 

  4] plus(s(X), Y) >= plus(X, s(Y))  because [5], by (Star) 
  5] plus*(s(X), Y) >= plus(X, s(Y))  because plus in Lex, [6], [9] and [11], by (Stat) 
  6] s(X) > X  because [7], by definition 
  7] s*(X) >= X  because [8], by (Select) 
  8] X >= X  by (Meta) 
  9] plus*(s(X), Y) >= X  because [10], by (Select) 
  10] s(X) >= X  because [7], by (Star) 
  11] plus*(s(X), Y) >= s(Y)  because plus > s and [12], by (Copy) 
  12] plus*(s(X), Y) >= Y  because [13], by (Select) 
  13] Y >= Y  by (Meta) 

  14] plus(plus(X, Y), Z) > plus(X, plus(Y, Z))  because [15], by definition 
  15] plus*(plus(X, Y), Z) >= plus(X, plus(Y, Z))  because plus in Lex, [16], [19] and [21], by (Stat) 
  16] plus(X, Y) > X  because [17], by definition 
  17] plus*(X, Y) >= X  because [18], by (Select) 
  18] X >= X  by (Meta) 
  19] plus*(plus(X, Y), Z) >= X  because [20], by (Select) 
  20] plus(X, Y) >= X  because [17], by (Star) 
  21] plus*(plus(X, Y), Z) >= plus(Y, Z)  because plus in Lex, [22], [25] and [27], by (Stat) 
  22] plus(X, Y) > Y  because [23], by definition 
  23] plus*(X, Y) >= Y  because [24], by (Select) 
  24] Y >= Y  by (Meta) 
  25] plus*(plus(X, Y), Z) >= Y  because [26], by (Select) 
  26] plus(X, Y) >= Y  because [23], by (Star) 
  27] plus*(plus(X, Y), Z) >= Z  because [28], by (Select) 
  28] Z >= Z  by (Meta) 

  29] mult(_|_, X) >= _|_  by (Bot) 

  30] mult(s(X), Y) >= plus(mult(X, Y), Y)  because [31], by (Star) 
  31] mult*(s(X), Y) >= plus(mult(X, Y), Y)  because mult > plus, [32] and [37], by (Copy) 
  32] mult*(s(X), Y) >= mult(X, Y)  because mult in Mul, [33] and [36], by (Stat) 
  33] s(X) > X  because [34], by definition 
  34] s*(X) >= X  because [35], by (Select) 
  35] X >= X  by (Meta) 
  36] Y >= Y  by (Meta) 
  37] mult*(s(X), Y) >= Y  because [36], by (Select) 

  38] mult(plus(X, Y), Z) > plus(mult(X, Z), mult(Y, Z))  because [39], by definition 
  39] mult*(plus(X, Y), Z) >= plus(mult(X, Z), mult(Y, Z))  because mult > plus, [40] and [45], by (Copy) 
  40] mult*(plus(X, Y), Z) >= mult(X, Z)  because mult in Mul, [41] and [44], by (Stat) 
  41] plus(X, Y) > X  because [42], by definition 
  42] plus*(X, Y) >= X  because [43], by (Select) 
  43] X >= X  by (Meta) 
  44] Z >= Z  by (Meta) 
  45] mult*(plus(X, Y), Z) >= mult(Y, Z)  because mult in Mul, [46] and [44], by (Stat) 
  46] plus(X, Y) > Y  because [47], by definition 
  47] plus*(X, Y) >= Y  because [48], by (Select) 
  48] Y >= Y  by (Meta) 

We can thus remove the following rules:

  plus(plus(X, Y), Z) => plus(X, plus(Y, Z)) 
  mult(plus(X, Y), Z) => plus(mult(X, Z), mult(Y, Z)) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  plus(z, X) >? X 
  plus(s(X), Y) >? plus(X, s(Y)) 
  mult(z, X) >? z 
  mult(s(X), Y) >? plus(mult(X, Y), Y) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

Argument functions:

  [[z]] = _|_ 

We choose Lex = {mult, plus} and Mul = {s}, and the following precedence: mult > plus > s

Taking the argument function into account, and fixing the greater / greater equal choices, the constraints can be denoted as follows:

  plus(_|_, X) > X 
  plus(s(X), Y) >= plus(X, s(Y)) 
  mult(_|_, X) >= _|_ 
  mult(s(X), Y) >= plus(mult(X, Y), Y) 

With these choices, we have:

  1] plus(_|_, X) > X  because [2], by definition 
  2] plus*(_|_, X) >= X  because [3], by (Select) 
  3] X >= X  by (Meta) 

  4] plus(s(X), Y) >= plus(X, s(Y))  because [5], by (Star) 
  5] plus*(s(X), Y) >= plus(X, s(Y))  because plus in Lex, [6], [9] and [11], by (Stat) 
  6] s(X) > X  because [7], by definition 
  7] s*(X) >= X  because [8], by (Select) 
  8] X >= X  by (Meta) 
  9] plus*(s(X), Y) >= X  because [10], by (Select) 
  10] s(X) >= X  because [7], by (Star) 
  11] plus*(s(X), Y) >= s(Y)  because plus > s and [12], by (Copy) 
  12] plus*(s(X), Y) >= Y  because [13], by (Select) 
  13] Y >= Y  by (Meta) 

  14] mult(_|_, X) >= _|_  by (Bot) 

  15] mult(s(X), Y) >= plus(mult(X, Y), Y)  because [16], by (Star) 
  16] mult*(s(X), Y) >= plus(mult(X, Y), Y)  because mult > plus, [17] and [23], by (Copy) 
  17] mult*(s(X), Y) >= mult(X, Y)  because mult in Lex, [18], [21] and [23], by (Stat) 
  18] s(X) > X  because [19], by definition 
  19] s*(X) >= X  because [20], by (Select) 
  20] X >= X  by (Meta) 
  21] mult*(s(X), Y) >= X  because [22], by (Select) 
  22] s(X) >= X  because [19], by (Star) 
  23] mult*(s(X), Y) >= Y  because [24], by (Select) 
  24] Y >= Y  by (Meta) 

We can thus remove the following rules:

  plus(z, X) => X 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  plus(s(X), Y) >? plus(X, s(Y)) 
  mult(z, X) >? z 
  mult(s(X), Y) >? plus(mult(X, Y), Y) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

Argument functions:

  [[z]] = _|_ 

We choose Lex = {plus} and Mul = {mult, s}, and the following precedence: mult > plus > s

Taking the argument function into account, and fixing the greater / greater equal choices, the constraints can be denoted as follows:

  plus(s(X), Y) >= plus(X, s(Y)) 
  mult(_|_, X) > _|_ 
  mult(s(X), Y) >= plus(mult(X, Y), Y) 

With these choices, we have:

  1] plus(s(X), Y) >= plus(X, s(Y))  because [2], by (Star) 
  2] plus*(s(X), Y) >= plus(X, s(Y))  because plus in Lex, [3], [6] and [8], by (Stat) 
  3] s(X) > X  because [4], by definition 
  4] s*(X) >= X  because [5], by (Select) 
  5] X >= X  by (Meta) 
  6] plus*(s(X), Y) >= X  because [7], by (Select) 
  7] s(X) >= X  because [4], by (Star) 
  8] plus*(s(X), Y) >= s(Y)  because plus > s and [9], by (Copy) 
  9] plus*(s(X), Y) >= Y  because [10], by (Select) 
  10] Y >= Y  by (Meta) 

  11] mult(_|_, X) > _|_  because [12], by definition 
  12] mult*(_|_, X) >= _|_  by (Bot) 

  13] mult(s(X), Y) >= plus(mult(X, Y), Y)  because [14], by (Star) 
  14] mult*(s(X), Y) >= plus(mult(X, Y), Y)  because mult > plus, [15] and [20], by (Copy) 
  15] mult*(s(X), Y) >= mult(X, Y)  because mult in Mul, [16] and [19], by (Stat) 
  16] s(X) > X  because [17], by definition 
  17] s*(X) >= X  because [18], by (Select) 
  18] X >= X  by (Meta) 
  19] Y >= Y  by (Meta) 
  20] mult*(s(X), Y) >= Y  because [19], by (Select) 

We can thus remove the following rules:

  mult(z, X) => z 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  plus(s(X), Y) >? plus(X, s(Y)) 
  mult(s(X), Y) >? plus(mult(X, Y), Y) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

We choose Lex = {plus} and Mul = {mult, s}, and the following precedence: mult > plus > s

With these choices, we have:

  1] plus(s(X), Y) >= plus(X, s(Y))  because [2], by (Star) 
  2] plus*(s(X), Y) >= plus(X, s(Y))  because plus in Lex, [3], [6] and [8], by (Stat) 
  3] s(X) > X  because [4], by definition 
  4] s*(X) >= X  because [5], by (Select) 
  5] X >= X  by (Meta) 
  6] plus*(s(X), Y) >= X  because [7], by (Select) 
  7] s(X) >= X  because [4], by (Star) 
  8] plus*(s(X), Y) >= s(Y)  because plus > s and [9], by (Copy) 
  9] plus*(s(X), Y) >= Y  because [10], by (Select) 
  10] Y >= Y  by (Meta) 

  11] mult(s(X), Y) > plus(mult(X, Y), Y)  because [12], by definition 
  12] mult*(s(X), Y) >= plus(mult(X, Y), Y)  because mult > plus, [13] and [18], by (Copy) 
  13] mult*(s(X), Y) >= mult(X, Y)  because mult in Mul, [14] and [17], by (Stat) 
  14] s(X) > X  because [15], by definition 
  15] s*(X) >= X  because [16], by (Select) 
  16] X >= X  by (Meta) 
  17] Y >= Y  by (Meta) 
  18] mult*(s(X), Y) >= Y  because [17], by (Select) 

We can thus remove the following rules:

  mult(s(X), Y) => plus(mult(X, Y), Y) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  plus(s(X), Y) >? plus(X, s(Y)) 

We orient these requirements with a polynomial interpretation in the natural numbers.

The following interpretation satisfies the requirements:

  plus = Lam[y0;y1].y1 + 2*y0 
  s = Lam[y0].2 + y0 

Using this interpretation, the requirements translate to:

  [[plus(s(_x0), _x1)]] = 4 + x1 + 2*x0 > 2 + x1 + 2*x0 = [[plus(_x0, s(_x1))]] 

We can thus remove the following rules:

  plus(s(X), Y) => plus(X, s(Y)) 

All rules were succesfully removed.  Thus, termination of the original system has been reduced to termination of the beta-rule, which is well-known to hold.


+++ Citations +++

[Kop12]  C. Kop.  Higher Order Termination.  PhD Thesis, 2012.
