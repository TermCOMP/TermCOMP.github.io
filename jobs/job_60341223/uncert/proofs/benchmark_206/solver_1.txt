NO
We consider the system wLECm.

  Alphabet:

    cons : [e * f] --> f 
    f : [b * b * b * c] --> a 
    false : [] --> d 
    filter : [e -> d * f] --> f 
    filter2 : [d * e -> d * e * f] --> f 
    g : [b * b] --> b 
    h : [b] --> c 
    map : [e -> e * f] --> f 
    nil : [] --> f 
    one : [] --> b 
    true : [] --> d 
    zero : [] --> b 

  Rules:

    f(zero, one, g(X, Y), Z) => f(g(X, Y), g(X, Y), g(X, Y), h(X)) 
    g(zero, one) => zero 
    g(zero, one) => one 
    h(g(X, Y)) => h(X) 
    map(F, nil) => nil 
    map(F, cons(X, Y)) => cons(F X, map(F, Y)) 
    filter(F, nil) => nil 
    filter(F, cons(X, Y)) => filter2(F X, F, X, Y) 
    filter2(true, F, X, Y) => cons(X, filter(F, Y)) 
    filter2(false, F, X, Y) => filter(F, Y) 

This system is non-terminating, as demonstrated by our external first-order non-termination checker:

 || The following well-typed term is terminating: f(g(zero, one), g(zero, one), g(zero, one), h(zero))
 || 
 || proof of system.trs
 || # AProVE Commit ID: 500ec9b2e2a919720cb177ef26031cb0220e008e fuhs 20130603
 || 
 || 
 || Termination w.r.t. Q of the given QTRS could be disproven:
 || 
 || (0) QTRS
 || (1) NonTerminationProof [EQUIVALENT, 0 ms]
 || (2) NO
 || 
 || 
 || ----------------------------------------
 || 
 || (0)
 || Obligation:
 || Q restricted rewrite system:
 || The TRS R consists of the following rules:
 || 
 ||    f(zero, one, g(%X, %Y), %Z) -> f(g(%X, %Y), g(%X, %Y), g(%X, %Y), h(%X))
 ||    g(zero, one) -> zero
 ||    g(zero, one) -> one
 ||    h(g(%X, %Y)) -> h(%X)
 || 
 || Q is empty.
 || 
 || ----------------------------------------
 || 
 || (1) NonTerminationProof (EQUIVALENT)
 || The following loops were found:
 || 
 || ---------- Loop: ----------
 || 
 || f(g(zero, one), g(zero, one), g(zero, one), h(zero)) -> f(g(zero, one), one, g(zero, one), h(zero)) with rule g(zero, one) -> one at position [1] and matcher [ ]
 || 
 || f(g(zero, one), one, g(zero, one), h(zero)) -> f(zero, one, g(zero, one), h(zero)) with rule g(zero, one) -> zero at position [0] and matcher [ ]
 || 
 || f(zero, one, g(zero, one), h(zero)) -> f(g(zero, one), g(zero, one), g(zero, one), h(zero)) with rule f(zero, one, g(%X, %Y), %Z) -> f(g(%X, %Y), g(%X, %Y), g(%X, %Y), h(%X)) at position [] and matcher [%X / zero, %Y / one, %Z / h(zero)]
 || 
 || Now an instance of the first term with Matcher [ ] occurs in the last term at position [].
 || 
 || Context: []
 || 
 || 
 || ----------------------------------------
 || 
 || (2)
 || NO
 || 
