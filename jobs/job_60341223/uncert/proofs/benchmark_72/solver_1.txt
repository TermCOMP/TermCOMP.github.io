YES
We consider the system uKcuz.

  Alphabet:

    O : [] --> nat 
    cons : [nat * list] --> list 
    foldl : [nat -> nat -> nat * nat * list] --> nat 
    nil : [] --> list 
    plusc : [nat * nat] --> nat 
    s : [nat] --> nat 
    sum : [list] --> nat 

  Rules:

    foldl(F, X, nil) => X 
    foldl(F, X, cons(Y, Z)) => foldl(F, F X Y, Z) 
    plusc(X, O) => X 
    plusc(X, s(Y)) => s(plusc(X, Y)) 
    sum(X) => foldl(/\x./\y.plusc(x, y), O, X) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  foldl(F, X, nil) >? X 
  foldl(F, X, cons(Y, Z)) >? foldl(F, F X Y, Z) 
  plusc(X, O) >? X 
  plusc(X, s(Y)) >? s(plusc(X, Y)) 
  sum(X) >? foldl(/\x./\y.plusc(x, y), O, X) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

Argument functions:

  [[@_{o -> o}(x_1, x_2)]] = @_{o -> o}(x_2, x_1) 
  [[O]] = _|_ 
  [[foldl(x_1, x_2, x_3)]] = foldl(x_3, x_2, x_1) 

We choose Lex = {@_{o -> o}, foldl} and Mul = {@_{o -> o -> o}, cons, nil, plusc, s, sum}, and the following precedence: cons > nil > sum > @_{o -> o} = foldl > @_{o -> o -> o} > plusc > s

Taking the argument function into account, and fixing the greater / greater equal choices, the constraints can be denoted as follows:

  foldl(F, X, nil) >= X 
  foldl(F, X, cons(Y, Z)) >= foldl(F, @_{o -> o}(@_{o -> o -> o}(F, X), Y), Z) 
  plusc(X, _|_) > X 
  plusc(X, s(Y)) >= s(plusc(X, Y)) 
  sum(X) >= foldl(/\x./\y.plusc(x, y), _|_, X) 

With these choices, we have:

  1] foldl(F, X, nil) >= X  because [2], by (Star) 
  2] foldl*(F, X, nil) >= X  because [3], by (Select) 
  3] X >= X  by (Meta) 

  4] foldl(F, X, cons(Y, Z)) >= foldl(F, @_{o -> o}(@_{o -> o -> o}(F, X), Y), Z)  because [5], by (Star) 
  5] foldl*(F, X, cons(Y, Z)) >= foldl(F, @_{o -> o}(@_{o -> o -> o}(F, X), Y), Z)  because foldl in Lex, [6], [9], [11] and [20], by (Stat) 
  6] cons(Y, Z) > Z  because [7], by definition 
  7] cons*(Y, Z) >= Z  because [8], by (Select) 
  8] Z >= Z  by (Meta) 
  9] foldl*(F, X, cons(Y, Z)) >= F  because [10], by (Select) 
  10] F >= F  by (Meta) 
  11] foldl*(F, X, cons(Y, Z)) >= @_{o -> o}(@_{o -> o -> o}(F, X), Y)  because foldl = @_{o -> o}, foldl in Lex, [12], [15] and [18], by (Stat) 
  12] cons(Y, Z) > Y  because [13], by definition 
  13] cons*(Y, Z) >= Y  because [14], by (Select) 
  14] Y >= Y  by (Meta) 
  15] foldl*(F, X, cons(Y, Z)) >= @_{o -> o -> o}(F, X)  because foldl > @_{o -> o -> o}, [9] and [16], by (Copy) 
  16] foldl*(F, X, cons(Y, Z)) >= X  because [17], by (Select) 
  17] X >= X  by (Meta) 
  18] foldl*(F, X, cons(Y, Z)) >= Y  because [19], by (Select) 
  19] cons(Y, Z) >= Y  because [13], by (Star) 
  20] foldl*(F, X, cons(Y, Z)) >= Z  because [21], by (Select) 
  21] cons(Y, Z) >= Z  because [7], by (Star) 

  22] plusc(X, _|_) > X  because [23], by definition 
  23] plusc*(X, _|_) >= X  because [24], by (Select) 
  24] X >= X  by (Meta) 

  25] plusc(X, s(Y)) >= s(plusc(X, Y))  because [26], by (Star) 
  26] plusc*(X, s(Y)) >= s(plusc(X, Y))  because plusc > s and [27], by (Copy) 
  27] plusc*(X, s(Y)) >= plusc(X, Y)  because plusc in Mul, [28] and [29], by (Stat) 
  28] X >= X  by (Meta) 
  29] s(Y) > Y  because [30], by definition 
  30] s*(Y) >= Y  because [31], by (Select) 
  31] Y >= Y  by (Meta) 

  32] sum(X) >= foldl(/\x./\y.plusc(x, y), _|_, X)  because [33], by (Star) 
  33] sum*(X) >= foldl(/\x./\y.plusc(x, y), _|_, X)  because sum > foldl, [34], [41] and [42], by (Copy) 
  34] sum*(X) >= /\y./\z.plusc(y, z)  because [35], by (F-Abs) 
  35] sum*(X, x) >= /\z.plusc(x, z)  because [36], by (F-Abs) 
  36] sum*(X, x, y) >= plusc(x, y)  because sum > plusc, [37] and [39], by (Copy) 
  37] sum*(X, x, y) >= x  because [38], by (Select) 
  38] x >= x  by (Var) 
  39] sum*(X, x, y) >= y  because [40], by (Select) 
  40] y >= y  by (Var) 
  41] sum*(X) >= _|_  by (Bot) 
  42] sum*(X) >= X  because [43], by (Select) 
  43] X >= X  by (Meta) 

We can thus remove the following rules:

  plusc(X, O) => X 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  foldl(F, X, nil) >? X 
  foldl(F, X, cons(Y, Z)) >? foldl(F, F X Y, Z) 
  plusc(X, s(Y)) >? s(plusc(X, Y)) 
  sum(X) >? foldl(/\x./\y.plusc(x, y), O, X) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

Argument functions:

  [[O]] = _|_ 
  [[foldl(x_1, x_2, x_3)]] = foldl(x_3, x_1, x_2) 

We choose Lex = {foldl} and Mul = {@_{o -> o -> o}, @_{o -> o}, cons, nil, plusc, s, sum}, and the following precedence: cons > nil > sum > foldl > plusc > @_{o -> o -> o} > @_{o -> o} > s

Taking the argument function into account, and fixing the greater / greater equal choices, the constraints can be denoted as follows:

  foldl(F, X, nil) > X 
  foldl(F, X, cons(Y, Z)) >= foldl(F, @_{o -> o}(@_{o -> o -> o}(F, X), Y), Z) 
  plusc(X, s(Y)) >= s(plusc(X, Y)) 
  sum(X) >= foldl(/\x./\y.plusc(x, y), _|_, X) 

With these choices, we have:

  1] foldl(F, X, nil) > X  because [2], by definition 
  2] foldl*(F, X, nil) >= X  because [3], by (Select) 
  3] X >= X  by (Meta) 

  4] foldl(F, X, cons(Y, Z)) >= foldl(F, @_{o -> o}(@_{o -> o -> o}(F, X), Y), Z)  because [5], by (Star) 
  5] foldl*(F, X, cons(Y, Z)) >= foldl(F, @_{o -> o}(@_{o -> o -> o}(F, X), Y), Z)  because foldl in Lex, [6], [9], [11] and [19], by (Stat) 
  6] cons(Y, Z) > Z  because [7], by definition 
  7] cons*(Y, Z) >= Z  because [8], by (Select) 
  8] Z >= Z  by (Meta) 
  9] foldl*(F, X, cons(Y, Z)) >= F  because [10], by (Select) 
  10] F >= F  by (Meta) 
  11] foldl*(F, X, cons(Y, Z)) >= @_{o -> o}(@_{o -> o -> o}(F, X), Y)  because foldl > @_{o -> o}, [12] and [15], by (Copy) 
  12] foldl*(F, X, cons(Y, Z)) >= @_{o -> o -> o}(F, X)  because foldl > @_{o -> o -> o}, [9] and [13], by (Copy) 
  13] foldl*(F, X, cons(Y, Z)) >= X  because [14], by (Select) 
  14] X >= X  by (Meta) 
  15] foldl*(F, X, cons(Y, Z)) >= Y  because [16], by (Select) 
  16] cons(Y, Z) >= Y  because [17], by (Star) 
  17] cons*(Y, Z) >= Y  because [18], by (Select) 
  18] Y >= Y  by (Meta) 
  19] foldl*(F, X, cons(Y, Z)) >= Z  because [20], by (Select) 
  20] cons(Y, Z) >= Z  because [7], by (Star) 

  21] plusc(X, s(Y)) >= s(plusc(X, Y))  because [22], by (Star) 
  22] plusc*(X, s(Y)) >= s(plusc(X, Y))  because plusc > s and [23], by (Copy) 
  23] plusc*(X, s(Y)) >= plusc(X, Y)  because plusc in Mul, [24] and [25], by (Stat) 
  24] X >= X  by (Meta) 
  25] s(Y) > Y  because [26], by definition 
  26] s*(Y) >= Y  because [27], by (Select) 
  27] Y >= Y  by (Meta) 

  28] sum(X) >= foldl(/\x./\y.plusc(x, y), _|_, X)  because [29], by (Star) 
  29] sum*(X) >= foldl(/\x./\y.plusc(x, y), _|_, X)  because sum > foldl, [30], [37] and [38], by (Copy) 
  30] sum*(X) >= /\y./\z.plusc(y, z)  because [31], by (F-Abs) 
  31] sum*(X, x) >= /\z.plusc(x, z)  because [32], by (F-Abs) 
  32] sum*(X, x, y) >= plusc(x, y)  because sum > plusc, [33] and [35], by (Copy) 
  33] sum*(X, x, y) >= x  because [34], by (Select) 
  34] x >= x  by (Var) 
  35] sum*(X, x, y) >= y  because [36], by (Select) 
  36] y >= y  by (Var) 
  37] sum*(X) >= _|_  by (Bot) 
  38] sum*(X) >= X  because [39], by (Select) 
  39] X >= X  by (Meta) 

We can thus remove the following rules:

  foldl(F, X, nil) => X 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  foldl(F, X, cons(Y, Z)) >? foldl(F, F X Y, Z) 
  plusc(X, s(Y)) >? s(plusc(X, Y)) 
  sum(X) >? foldl(/\x./\y.plusc(x, y), O, X) 

We use a recursive path ordering as defined in [Kop12, Chapter 5].

Argument functions:

  [[O]] = _|_ 
  [[foldl(x_1, x_2, x_3)]] = foldl(x_3, x_1, x_2) 

We choose Lex = {foldl} and Mul = {@_{o -> o -> o}, @_{o -> o}, cons, plusc, s, sum}, and the following precedence: cons > sum > foldl > @_{o -> o -> o} > @_{o -> o} > plusc > s

Taking the argument function into account, and fixing the greater / greater equal choices, the constraints can be denoted as follows:

  foldl(F, X, cons(Y, Z)) > foldl(F, @_{o -> o}(@_{o -> o -> o}(F, X), Y), Z) 
  plusc(X, s(Y)) >= s(plusc(X, Y)) 
  sum(X) >= foldl(/\x./\y.plusc(x, y), _|_, X) 

With these choices, we have:

  1] foldl(F, X, cons(Y, Z)) > foldl(F, @_{o -> o}(@_{o -> o -> o}(F, X), Y), Z)  because [2], by definition 
  2] foldl*(F, X, cons(Y, Z)) >= foldl(F, @_{o -> o}(@_{o -> o -> o}(F, X), Y), Z)  because foldl in Lex, [3], [6], [8] and [16], by (Stat) 
  3] cons(Y, Z) > Z  because [4], by definition 
  4] cons*(Y, Z) >= Z  because [5], by (Select) 
  5] Z >= Z  by (Meta) 
  6] foldl*(F, X, cons(Y, Z)) >= F  because [7], by (Select) 
  7] F >= F  by (Meta) 
  8] foldl*(F, X, cons(Y, Z)) >= @_{o -> o}(@_{o -> o -> o}(F, X), Y)  because foldl > @_{o -> o}, [9] and [12], by (Copy) 
  9] foldl*(F, X, cons(Y, Z)) >= @_{o -> o -> o}(F, X)  because foldl > @_{o -> o -> o}, [6] and [10], by (Copy) 
  10] foldl*(F, X, cons(Y, Z)) >= X  because [11], by (Select) 
  11] X >= X  by (Meta) 
  12] foldl*(F, X, cons(Y, Z)) >= Y  because [13], by (Select) 
  13] cons(Y, Z) >= Y  because [14], by (Star) 
  14] cons*(Y, Z) >= Y  because [15], by (Select) 
  15] Y >= Y  by (Meta) 
  16] foldl*(F, X, cons(Y, Z)) >= Z  because [17], by (Select) 
  17] cons(Y, Z) >= Z  because [4], by (Star) 

  18] plusc(X, s(Y)) >= s(plusc(X, Y))  because [19], by (Star) 
  19] plusc*(X, s(Y)) >= s(plusc(X, Y))  because plusc > s and [20], by (Copy) 
  20] plusc*(X, s(Y)) >= plusc(X, Y)  because plusc in Mul, [21] and [22], by (Stat) 
  21] X >= X  by (Meta) 
  22] s(Y) > Y  because [23], by definition 
  23] s*(Y) >= Y  because [24], by (Select) 
  24] Y >= Y  by (Meta) 

  25] sum(X) >= foldl(/\x./\y.plusc(x, y), _|_, X)  because [26], by (Star) 
  26] sum*(X) >= foldl(/\x./\y.plusc(x, y), _|_, X)  because sum > foldl, [27], [34] and [35], by (Copy) 
  27] sum*(X) >= /\y./\z.plusc(y, z)  because [28], by (F-Abs) 
  28] sum*(X, x) >= /\z.plusc(x, z)  because [29], by (F-Abs) 
  29] sum*(X, x, y) >= plusc(x, y)  because sum > plusc, [30] and [32], by (Copy) 
  30] sum*(X, x, y) >= x  because [31], by (Select) 
  31] x >= x  by (Var) 
  32] sum*(X, x, y) >= y  because [33], by (Select) 
  33] y >= y  by (Var) 
  34] sum*(X) >= _|_  by (Bot) 
  35] sum*(X) >= X  because [36], by (Select) 
  36] X >= X  by (Meta) 

We can thus remove the following rules:

  foldl(F, X, cons(Y, Z)) => foldl(F, F X Y, Z) 

We use rule removal, following [Kop12, Theorem 2.23].

This gives the following requirements (possibly using Theorems 2.25 and 2.26 in [Kop12]):

  plusc(X, s(Y)) >? s(plusc(X, Y)) 
  sum(X) >? foldl(/\x./\y.plusc(x, y), O, X) 

We orient these requirements with a polynomial interpretation in the natural numbers.

The following interpretation satisfies the requirements:

  O = 0 
  foldl = Lam[G0;y1;y2].y1 + y2 + G0(0,0) 
  plusc = Lam[y0;y1].y0 + 2*y1 
  s = Lam[y0].1 + y0 
  sum = Lam[y0].3 + 3*y0 

Using this interpretation, the requirements translate to:

  [[plusc(_x0, s(_x1))]] = 2 + x0 + 2*x1 > 1 + x0 + 2*x1 = [[s(plusc(_x0, _x1))]] 
  [[sum(_x0)]] = 3 + 3*x0 > x0 = [[foldl(/\x./\y.plusc(x, y), O, _x0)]] 

We can thus remove the following rules:

  plusc(X, s(Y)) => s(plusc(X, Y)) 
  sum(X) => foldl(/\x./\y.plusc(x, y), O, X) 

All rules were succesfully removed.  Thus, termination of the original system has been reduced to termination of the beta-rule, which is well-known to hold.


+++ Citations +++

[Kop12]  C. Kop.  Higher Order Termination.  PhD Thesis, 2012.
