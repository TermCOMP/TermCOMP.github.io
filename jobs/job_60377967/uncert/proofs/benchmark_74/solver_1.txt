YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/yF10m.itrs
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given ITRS could be proven:

(0) ITRS
(1) ITRStoIDPProof [EQUIVALENT, 0 ms]
(2) IDP
(3) UsableRulesProof [EQUIVALENT, 0 ms]
(4) IDP
(5) ItpfGraphProof [EQUIVALENT, 4 ms]
(6) IDP
(7) IDependencyGraphProof [EQUIVALENT, 0 ms]
(8) AND
    (9) IDP
        (10) UsableRulesProof [EQUIVALENT, 0 ms]
        (11) IDP
        (12) IDPNonInfProof [SOUND, 109 ms]
        (13) IDP
        (14) IDependencyGraphProof [EQUIVALENT, 0 ms]
        (15) TRUE
    (16) IDP
        (17) UsableRulesProof [EQUIVALENT, 0 ms]
        (18) IDP
        (19) IDPNonInfProof [SOUND, 68 ms]
        (20) IDP
        (21) IDependencyGraphProof [EQUIVALENT, 0 ms]
        (22) IDP
        (23) IDPNonInfProof [SOUND, 34 ms]
        (24) IDP
        (25) IDependencyGraphProof [EQUIVALENT, 0 ms]
        (26) IDP
        (27) IDPNonInfProof [SOUND, 2 ms]
        (28) IDP
        (29) IDependencyGraphProof [EQUIVALENT, 0 ms]
        (30) TRUE
    (31) IDP
        (32) UsableRulesProof [EQUIVALENT, 0 ms]
        (33) IDP
        (34) IDPNonInfProof [SOUND, 91 ms]
        (35) IDP
        (36) IDependencyGraphProof [EQUIVALENT, 0 ms]
        (37) TRUE
    (38) IDP
        (39) UsableRulesProof [EQUIVALENT, 0 ms]
        (40) IDP
        (41) IDPtoQDPProof [SOUND, 2 ms]
        (42) QDP
        (43) QReductionProof [EQUIVALENT, 0 ms]
        (44) QDP
        (45) QDPQMonotonicMRRProof [EQUIVALENT, 61 ms]
        (46) QDP
        (47) PisEmptyProof [EQUIVALENT, 0 ms]
        (48) YES
    (49) IDP
        (50) UsableRulesProof [EQUIVALENT, 0 ms]
        (51) IDP
        (52) IDPNonInfProof [SOUND, 18 ms]
        (53) IDP
        (54) IDependencyGraphProof [EQUIVALENT, 0 ms]
        (55) TRUE


----------------------------------------

(0)
Obligation:
ITRS problem:

The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>

The TRS R consists of the following rules:
isprime(x) -> mem(x, primes(x))
mem(x, nil) -> FALSE
mem(x, cons(y, zs)) -> Cond_mem(x = y, x, cons(y, zs))
Cond_mem(TRUE, x, cons(y, zs)) -> TRUE
mem(x, cons(y, zs)) -> Cond_mem1(y > x, x, cons(y, zs))
Cond_mem1(TRUE, x, cons(y, zs)) -> mem(x, zs)
mem(x, cons(y, zs)) -> Cond_mem2(x > y, x, cons(y, zs))
Cond_mem2(TRUE, x, cons(y, zs)) -> mem(x, zs)
primes(x) -> sieve(nats(2, x))
nats(x, y) -> Cond_nats(x > y, x, y)
Cond_nats(TRUE, x, y) -> nil
nats(x, y) -> Cond_nats1(x = y, x, y)
Cond_nats1(TRUE, x, y) -> cons(x, nil)
nats(x, y) -> Cond_nats2(y > x, x, y)
Cond_nats2(TRUE, x, y) -> cons(x, nats(x + 1, y))
sieve(nil) -> nil
sieve(cons(x, ys)) -> cons(x, sieve(filter(x, ys)))
filter(x, nil) -> nil
filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)
if_1(TRUE, x, y, zs) -> filter(x, zs)
filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
if_2(FALSE, x, y, zs) -> cons(x, filter(x, zs))
isdiv(x, 0) -> Cond_isdiv(x > 0, x, 0)
Cond_isdiv(TRUE, x, 0) -> TRUE
isdiv(x, y) -> Cond_isdiv1(x > y && y > 0, x, y)
Cond_isdiv1(TRUE, x, y) -> FALSE
isdiv(x, y) -> Cond_isdiv2(y >= x && x > 0, x, y)
Cond_isdiv2(TRUE, x, y) -> isdiv(x, -(x) + y)
isdiv(x, y) -> Cond_isdiv3(0 > y, x, y)
Cond_isdiv3(TRUE, x, y) -> isdiv(x, -(y))
isdiv(x, y) -> Cond_isdiv4(0 > x, x, y)
Cond_isdiv4(TRUE, x, y) -> isdiv(-(x), y)
The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(1) ITRStoIDPProof (EQUIVALENT)
Added dependency pairs
----------------------------------------

(2)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

The ITRS R consists of the following rules:
isprime(x) -> mem(x, primes(x))
mem(x, nil) -> FALSE
mem(x, cons(y, zs)) -> Cond_mem(x = y, x, cons(y, zs))
Cond_mem(TRUE, x, cons(y, zs)) -> TRUE
mem(x, cons(y, zs)) -> Cond_mem1(y > x, x, cons(y, zs))
Cond_mem1(TRUE, x, cons(y, zs)) -> mem(x, zs)
mem(x, cons(y, zs)) -> Cond_mem2(x > y, x, cons(y, zs))
Cond_mem2(TRUE, x, cons(y, zs)) -> mem(x, zs)
primes(x) -> sieve(nats(2, x))
nats(x, y) -> Cond_nats(x > y, x, y)
Cond_nats(TRUE, x, y) -> nil
nats(x, y) -> Cond_nats1(x = y, x, y)
Cond_nats1(TRUE, x, y) -> cons(x, nil)
nats(x, y) -> Cond_nats2(y > x, x, y)
Cond_nats2(TRUE, x, y) -> cons(x, nats(x + 1, y))
sieve(nil) -> nil
sieve(cons(x, ys)) -> cons(x, sieve(filter(x, ys)))
filter(x, nil) -> nil
filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)
if_1(TRUE, x, y, zs) -> filter(x, zs)
filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
if_2(FALSE, x, y, zs) -> cons(x, filter(x, zs))
isdiv(x, 0) -> Cond_isdiv(x > 0, x, 0)
Cond_isdiv(TRUE, x, 0) -> TRUE
isdiv(x, y) -> Cond_isdiv1(x > y && y > 0, x, y)
Cond_isdiv1(TRUE, x, y) -> FALSE
isdiv(x, y) -> Cond_isdiv2(y >= x && x > 0, x, y)
Cond_isdiv2(TRUE, x, y) -> isdiv(x, -(x) + y)
isdiv(x, y) -> Cond_isdiv3(0 > y, x, y)
Cond_isdiv3(TRUE, x, y) -> isdiv(x, -(y))
isdiv(x, y) -> Cond_isdiv4(0 > x, x, y)
Cond_isdiv4(TRUE, x, y) -> isdiv(-(x), y)

The integer pair graph contains the following rules and edges:
(0): ISPRIME(x[0]) -> MEM(x[0], primes(x[0]))
(1): ISPRIME(x[1]) -> PRIMES(x[1])
(2): MEM(x[2], cons(y[2], zs[2])) -> COND_MEM(x[2] = y[2], x[2], cons(y[2], zs[2]))
(3): MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(y[3] > x[3], x[3], cons(y[3], zs[3]))
(4): COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4])
(5): MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(x[5] > y[5], x[5], cons(y[5], zs[5]))
(6): COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6])
(7): PRIMES(x[7]) -> SIEVE(nats(2, x[7]))
(8): PRIMES(x[8]) -> NATS(2, x[8])
(9): NATS(x[9], y[9]) -> COND_NATS(x[9] > y[9], x[9], y[9])
(10): NATS(x[10], y[10]) -> COND_NATS1(x[10] = y[10], x[10], y[10])
(11): NATS(x[11], y[11]) -> COND_NATS2(y[11] > x[11], x[11], y[11])
(12): COND_NATS2(TRUE, x[12], y[12]) -> NATS(x[12] + 1, y[12])
(13): SIEVE(cons(x[13], ys[13])) -> SIEVE(filter(x[13], ys[13]))
(14): SIEVE(cons(x[14], ys[14])) -> FILTER(x[14], ys[14])
(15): FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])
(16): FILTER(x[16], cons(y[16], zs[16])) -> ISDIV(x[16], y[16])
(17): IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17])
(18): FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])
(19): IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19])
(20): ISDIV(x[20], 0) -> COND_ISDIV(x[20] > 0, x[20], 0)
(21): ISDIV(x[21], y[21]) -> COND_ISDIV1(x[21] > y[21] && y[21] > 0, x[21], y[21])
(22): ISDIV(x[22], y[22]) -> COND_ISDIV2(y[22] >= x[22] && x[22] > 0, x[22], y[22])
(23): COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], -(x[23]) + y[23])
(24): ISDIV(x[24], y[24]) -> COND_ISDIV3(0 > y[24], x[24], y[24])
(25): COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25]))
(26): ISDIV(x[26], y[26]) -> COND_ISDIV4(0 > x[26], x[26], y[26])
(27): COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27])

   (0) -> (2), if (x[0] ->^* x[2] & primes(x[0]) ->^* cons(y[2], zs[2]))
   (0) -> (3), if (x[0] ->^* x[3] & primes(x[0]) ->^* cons(y[3], zs[3]))
   (0) -> (5), if (x[0] ->^* x[5] & primes(x[0]) ->^* cons(y[5], zs[5]))
   (1) -> (7), if (x[1] ->^* x[7])
   (1) -> (8), if (x[1] ->^* x[8])
   (3) -> (4), if (y[3] > x[3]  & x[3] ->^* x[4] & cons(y[3], zs[3]) ->^* cons(y[4], zs[4]))
   (4) -> (2), if (x[4] ->^* x[2] & zs[4] ->^* cons(y[2], zs[2]))
   (4) -> (3), if (x[4] ->^* x[3] & zs[4] ->^* cons(y[3], zs[3]))
   (4) -> (5), if (x[4] ->^* x[5] & zs[4] ->^* cons(y[5], zs[5]))
   (5) -> (6), if (x[5] > y[5]  & x[5] ->^* x[6] & cons(y[5], zs[5]) ->^* cons(y[6], zs[6]))
   (6) -> (2), if (x[6] ->^* x[2] & zs[6] ->^* cons(y[2], zs[2]))
   (6) -> (3), if (x[6] ->^* x[3] & zs[6] ->^* cons(y[3], zs[3]))
   (6) -> (5), if (x[6] ->^* x[5] & zs[6] ->^* cons(y[5], zs[5]))
   (7) -> (13), if (nats(2, x[7]) ->^* cons(x[13], ys[13]))
   (7) -> (14), if (nats(2, x[7]) ->^* cons(x[14], ys[14]))
   (8) -> (9), if (2 ->^* x[9] & x[8] ->^* y[9])
   (8) -> (10), if (2 ->^* x[10] & x[8] ->^* y[10])
   (8) -> (11), if (2 ->^* x[11] & x[8] ->^* y[11])
   (11) -> (12), if (y[11] > x[11]  & x[11] ->^* x[12] & y[11] ->^* y[12])
   (12) -> (9), if (x[12] + 1 ->^* x[9] & y[12] ->^* y[9])
   (12) -> (10), if (x[12] + 1 ->^* x[10] & y[12] ->^* y[10])
   (12) -> (11), if (x[12] + 1 ->^* x[11] & y[12] ->^* y[11])
   (13) -> (13), if (filter(x[13], ys[13]) ->^* cons(x[13]', ys[13]'))
   (13) -> (14), if (filter(x[13], ys[13]) ->^* cons(x[14], ys[14]))
   (14) -> (15), if (x[14] ->^* x[15] & ys[14] ->^* cons(y[15], zs[15]))
   (14) -> (16), if (x[14] ->^* x[16] & ys[14] ->^* cons(y[16], zs[16]))
   (14) -> (18), if (x[14] ->^* x[18] & ys[14] ->^* cons(y[18], zs[18]))
   (15) -> (17), if (isdiv(x[15], y[15])  & x[15] ->^* x[17] & y[15] ->^* y[17] & zs[15] ->^* zs[17])
   (16) -> (20), if (x[16] ->^* x[20] & y[16] ->^* 0)
   (16) -> (21), if (x[16] ->^* x[21] & y[16] ->^* y[21])
   (16) -> (22), if (x[16] ->^* x[22] & y[16] ->^* y[22])
   (16) -> (24), if (x[16] ->^* x[24] & y[16] ->^* y[24])
   (16) -> (26), if (x[16] ->^* x[26] & y[16] ->^* y[26])
   (17) -> (15), if (x[17] ->^* x[15] & zs[17] ->^* cons(y[15], zs[15]))
   (17) -> (16), if (x[17] ->^* x[16] & zs[17] ->^* cons(y[16], zs[16]))
   (17) -> (18), if (x[17] ->^* x[18] & zs[17] ->^* cons(y[18], zs[18]))
   (18) -> (19), if (isdiv(x[18], y[18]) ->^* FALSE & x[18] ->^* x[19] & y[18] ->^* y[19] & zs[18] ->^* zs[19])
   (19) -> (15), if (x[19] ->^* x[15] & zs[19] ->^* cons(y[15], zs[15]))
   (19) -> (16), if (x[19] ->^* x[16] & zs[19] ->^* cons(y[16], zs[16]))
   (19) -> (18), if (x[19] ->^* x[18] & zs[19] ->^* cons(y[18], zs[18]))
   (22) -> (23), if (y[22] >= x[22] && x[22] > 0  & x[22] ->^* x[23] & y[22] ->^* y[23])
   (23) -> (20), if (x[23] ->^* x[20] & -(x[23]) + y[23] ->^* 0)
   (23) -> (21), if (x[23] ->^* x[21] & -(x[23]) + y[23] ->^* y[21])
   (23) -> (22), if (x[23] ->^* x[22] & -(x[23]) + y[23] ->^* y[22])
   (23) -> (24), if (x[23] ->^* x[24] & -(x[23]) + y[23] ->^* y[24])
   (23) -> (26), if (x[23] ->^* x[26] & -(x[23]) + y[23] ->^* y[26])
   (24) -> (25), if (0 > y[24]  & x[24] ->^* x[25] & y[24] ->^* y[25])
   (25) -> (20), if (x[25] ->^* x[20] & -(y[25]) ->^* 0)
   (25) -> (21), if (x[25] ->^* x[21] & -(y[25]) ->^* y[21])
   (25) -> (22), if (x[25] ->^* x[22] & -(y[25]) ->^* y[22])
   (25) -> (24), if (x[25] ->^* x[24] & -(y[25]) ->^* y[24])
   (25) -> (26), if (x[25] ->^* x[26] & -(y[25]) ->^* y[26])
   (26) -> (27), if (0 > x[26]  & x[26] ->^* x[27] & y[26] ->^* y[27])
   (27) -> (20), if (-(x[27]) ->^* x[20] & y[27] ->^* 0)
   (27) -> (21), if (-(x[27]) ->^* x[21] & y[27] ->^* y[21])
   (27) -> (22), if (-(x[27]) ->^* x[22] & y[27] ->^* y[22])
   (27) -> (24), if (-(x[27]) ->^* x[24] & y[27] ->^* y[24])
   (27) -> (26), if (-(x[27]) ->^* x[26] & y[27] ->^* y[26])

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(3) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(4)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

The ITRS R consists of the following rules:
primes(x) -> sieve(nats(2, x))
nats(x, y) -> Cond_nats(x > y, x, y)
nats(x, y) -> Cond_nats1(x = y, x, y)
nats(x, y) -> Cond_nats2(y > x, x, y)
filter(x, nil) -> nil
filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)
if_1(TRUE, x, y, zs) -> filter(x, zs)
filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
isdiv(x, 0) -> Cond_isdiv(x > 0, x, 0)
isdiv(x, y) -> Cond_isdiv1(x > y && y > 0, x, y)
isdiv(x, y) -> Cond_isdiv2(y >= x && x > 0, x, y)
Cond_isdiv2(TRUE, x, y) -> isdiv(x, -(x) + y)
isdiv(x, y) -> Cond_isdiv3(0 > y, x, y)
Cond_isdiv3(TRUE, x, y) -> isdiv(x, -(y))
isdiv(x, y) -> Cond_isdiv4(0 > x, x, y)
Cond_isdiv4(TRUE, x, y) -> isdiv(-(x), y)
sieve(nil) -> nil
sieve(cons(x, ys)) -> cons(x, sieve(filter(x, ys)))
Cond_nats2(TRUE, x, y) -> cons(x, nats(x + 1, y))
Cond_nats(TRUE, x, y) -> nil
Cond_nats1(TRUE, x, y) -> cons(x, nil)
if_2(FALSE, x, y, zs) -> cons(x, filter(x, zs))
Cond_isdiv(TRUE, x, 0) -> TRUE
Cond_isdiv1(TRUE, x, y) -> FALSE

The integer pair graph contains the following rules and edges:
(0): ISPRIME(x[0]) -> MEM(x[0], primes(x[0]))
(1): ISPRIME(x[1]) -> PRIMES(x[1])
(2): MEM(x[2], cons(y[2], zs[2])) -> COND_MEM(x[2] = y[2], x[2], cons(y[2], zs[2]))
(3): MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(y[3] > x[3], x[3], cons(y[3], zs[3]))
(4): COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4])
(5): MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(x[5] > y[5], x[5], cons(y[5], zs[5]))
(6): COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6])
(7): PRIMES(x[7]) -> SIEVE(nats(2, x[7]))
(8): PRIMES(x[8]) -> NATS(2, x[8])
(9): NATS(x[9], y[9]) -> COND_NATS(x[9] > y[9], x[9], y[9])
(10): NATS(x[10], y[10]) -> COND_NATS1(x[10] = y[10], x[10], y[10])
(11): NATS(x[11], y[11]) -> COND_NATS2(y[11] > x[11], x[11], y[11])
(12): COND_NATS2(TRUE, x[12], y[12]) -> NATS(x[12] + 1, y[12])
(13): SIEVE(cons(x[13], ys[13])) -> SIEVE(filter(x[13], ys[13]))
(14): SIEVE(cons(x[14], ys[14])) -> FILTER(x[14], ys[14])
(15): FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])
(16): FILTER(x[16], cons(y[16], zs[16])) -> ISDIV(x[16], y[16])
(17): IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17])
(18): FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])
(19): IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19])
(20): ISDIV(x[20], 0) -> COND_ISDIV(x[20] > 0, x[20], 0)
(21): ISDIV(x[21], y[21]) -> COND_ISDIV1(x[21] > y[21] && y[21] > 0, x[21], y[21])
(22): ISDIV(x[22], y[22]) -> COND_ISDIV2(y[22] >= x[22] && x[22] > 0, x[22], y[22])
(23): COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], -(x[23]) + y[23])
(24): ISDIV(x[24], y[24]) -> COND_ISDIV3(0 > y[24], x[24], y[24])
(25): COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25]))
(26): ISDIV(x[26], y[26]) -> COND_ISDIV4(0 > x[26], x[26], y[26])
(27): COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27])

   (0) -> (2), if (x[0] ->^* x[2] & primes(x[0]) ->^* cons(y[2], zs[2]))
   (0) -> (3), if (x[0] ->^* x[3] & primes(x[0]) ->^* cons(y[3], zs[3]))
   (0) -> (5), if (x[0] ->^* x[5] & primes(x[0]) ->^* cons(y[5], zs[5]))
   (1) -> (7), if (x[1] ->^* x[7])
   (1) -> (8), if (x[1] ->^* x[8])
   (3) -> (4), if (y[3] > x[3]  & x[3] ->^* x[4] & cons(y[3], zs[3]) ->^* cons(y[4], zs[4]))
   (4) -> (2), if (x[4] ->^* x[2] & zs[4] ->^* cons(y[2], zs[2]))
   (4) -> (3), if (x[4] ->^* x[3] & zs[4] ->^* cons(y[3], zs[3]))
   (4) -> (5), if (x[4] ->^* x[5] & zs[4] ->^* cons(y[5], zs[5]))
   (5) -> (6), if (x[5] > y[5]  & x[5] ->^* x[6] & cons(y[5], zs[5]) ->^* cons(y[6], zs[6]))
   (6) -> (2), if (x[6] ->^* x[2] & zs[6] ->^* cons(y[2], zs[2]))
   (6) -> (3), if (x[6] ->^* x[3] & zs[6] ->^* cons(y[3], zs[3]))
   (6) -> (5), if (x[6] ->^* x[5] & zs[6] ->^* cons(y[5], zs[5]))
   (7) -> (13), if (nats(2, x[7]) ->^* cons(x[13], ys[13]))
   (7) -> (14), if (nats(2, x[7]) ->^* cons(x[14], ys[14]))
   (8) -> (9), if (2 ->^* x[9] & x[8] ->^* y[9])
   (8) -> (10), if (2 ->^* x[10] & x[8] ->^* y[10])
   (8) -> (11), if (2 ->^* x[11] & x[8] ->^* y[11])
   (11) -> (12), if (y[11] > x[11]  & x[11] ->^* x[12] & y[11] ->^* y[12])
   (12) -> (9), if (x[12] + 1 ->^* x[9] & y[12] ->^* y[9])
   (12) -> (10), if (x[12] + 1 ->^* x[10] & y[12] ->^* y[10])
   (12) -> (11), if (x[12] + 1 ->^* x[11] & y[12] ->^* y[11])
   (13) -> (13), if (filter(x[13], ys[13]) ->^* cons(x[13]', ys[13]'))
   (13) -> (14), if (filter(x[13], ys[13]) ->^* cons(x[14], ys[14]))
   (14) -> (15), if (x[14] ->^* x[15] & ys[14] ->^* cons(y[15], zs[15]))
   (14) -> (16), if (x[14] ->^* x[16] & ys[14] ->^* cons(y[16], zs[16]))
   (14) -> (18), if (x[14] ->^* x[18] & ys[14] ->^* cons(y[18], zs[18]))
   (15) -> (17), if (isdiv(x[15], y[15])  & x[15] ->^* x[17] & y[15] ->^* y[17] & zs[15] ->^* zs[17])
   (16) -> (20), if (x[16] ->^* x[20] & y[16] ->^* 0)
   (16) -> (21), if (x[16] ->^* x[21] & y[16] ->^* y[21])
   (16) -> (22), if (x[16] ->^* x[22] & y[16] ->^* y[22])
   (16) -> (24), if (x[16] ->^* x[24] & y[16] ->^* y[24])
   (16) -> (26), if (x[16] ->^* x[26] & y[16] ->^* y[26])
   (17) -> (15), if (x[17] ->^* x[15] & zs[17] ->^* cons(y[15], zs[15]))
   (17) -> (16), if (x[17] ->^* x[16] & zs[17] ->^* cons(y[16], zs[16]))
   (17) -> (18), if (x[17] ->^* x[18] & zs[17] ->^* cons(y[18], zs[18]))
   (18) -> (19), if (isdiv(x[18], y[18]) ->^* FALSE & x[18] ->^* x[19] & y[18] ->^* y[19] & zs[18] ->^* zs[19])
   (19) -> (15), if (x[19] ->^* x[15] & zs[19] ->^* cons(y[15], zs[15]))
   (19) -> (16), if (x[19] ->^* x[16] & zs[19] ->^* cons(y[16], zs[16]))
   (19) -> (18), if (x[19] ->^* x[18] & zs[19] ->^* cons(y[18], zs[18]))
   (22) -> (23), if (y[22] >= x[22] && x[22] > 0  & x[22] ->^* x[23] & y[22] ->^* y[23])
   (23) -> (20), if (x[23] ->^* x[20] & -(x[23]) + y[23] ->^* 0)
   (23) -> (21), if (x[23] ->^* x[21] & -(x[23]) + y[23] ->^* y[21])
   (23) -> (22), if (x[23] ->^* x[22] & -(x[23]) + y[23] ->^* y[22])
   (23) -> (24), if (x[23] ->^* x[24] & -(x[23]) + y[23] ->^* y[24])
   (23) -> (26), if (x[23] ->^* x[26] & -(x[23]) + y[23] ->^* y[26])
   (24) -> (25), if (0 > y[24]  & x[24] ->^* x[25] & y[24] ->^* y[25])
   (25) -> (20), if (x[25] ->^* x[20] & -(y[25]) ->^* 0)
   (25) -> (21), if (x[25] ->^* x[21] & -(y[25]) ->^* y[21])
   (25) -> (22), if (x[25] ->^* x[22] & -(y[25]) ->^* y[22])
   (25) -> (24), if (x[25] ->^* x[24] & -(y[25]) ->^* y[24])
   (25) -> (26), if (x[25] ->^* x[26] & -(y[25]) ->^* y[26])
   (26) -> (27), if (0 > x[26]  & x[26] ->^* x[27] & y[26] ->^* y[27])
   (27) -> (20), if (-(x[27]) ->^* x[20] & y[27] ->^* 0)
   (27) -> (21), if (-(x[27]) ->^* x[21] & y[27] ->^* y[21])
   (27) -> (22), if (-(x[27]) ->^* x[22] & y[27] ->^* y[22])
   (27) -> (24), if (-(x[27]) ->^* x[24] & y[27] ->^* y[24])
   (27) -> (26), if (-(x[27]) ->^* x[26] & y[27] ->^* y[26])

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(5) ItpfGraphProof (EQUIVALENT)
Applied rule ItpfICap [ICap]
----------------------------------------

(6)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

The ITRS R consists of the following rules:
primes(x) -> sieve(nats(2, x))
nats(x, y) -> Cond_nats(x > y, x, y)
nats(x, y) -> Cond_nats1(x = y, x, y)
nats(x, y) -> Cond_nats2(y > x, x, y)
filter(x, nil) -> nil
filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)
if_1(TRUE, x, y, zs) -> filter(x, zs)
filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
isdiv(x, 0) -> Cond_isdiv(x > 0, x, 0)
isdiv(x, y) -> Cond_isdiv1(x > y && y > 0, x, y)
isdiv(x, y) -> Cond_isdiv2(y >= x && x > 0, x, y)
Cond_isdiv2(TRUE, x, y) -> isdiv(x, -(x) + y)
isdiv(x, y) -> Cond_isdiv3(0 > y, x, y)
Cond_isdiv3(TRUE, x, y) -> isdiv(x, -(y))
isdiv(x, y) -> Cond_isdiv4(0 > x, x, y)
Cond_isdiv4(TRUE, x, y) -> isdiv(-(x), y)
sieve(nil) -> nil
sieve(cons(x, ys)) -> cons(x, sieve(filter(x, ys)))
Cond_nats2(TRUE, x, y) -> cons(x, nats(x + 1, y))
Cond_nats(TRUE, x, y) -> nil
Cond_nats1(TRUE, x, y) -> cons(x, nil)
if_2(FALSE, x, y, zs) -> cons(x, filter(x, zs))
Cond_isdiv(TRUE, x, 0) -> TRUE
Cond_isdiv1(TRUE, x, y) -> FALSE

The integer pair graph contains the following rules and edges:
(0): ISPRIME(x[0]) -> MEM(x[0], primes(x[0]))
(1): ISPRIME(x[1]) -> PRIMES(x[1])
(2): MEM(x[2], cons(y[2], zs[2])) -> COND_MEM(x[2] = y[2], x[2], cons(y[2], zs[2]))
(3): MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(y[3] > x[3], x[3], cons(y[3], zs[3]))
(4): COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4])
(5): MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(x[5] > y[5], x[5], cons(y[5], zs[5]))
(6): COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6])
(7): PRIMES(x[7]) -> SIEVE(nats(2, x[7]))
(8): PRIMES(x[8]) -> NATS(2, x[8])
(9): NATS(x[9], y[9]) -> COND_NATS(x[9] > y[9], x[9], y[9])
(10): NATS(x[10], y[10]) -> COND_NATS1(x[10] = y[10], x[10], y[10])
(11): NATS(x[11], y[11]) -> COND_NATS2(y[11] > x[11], x[11], y[11])
(12): COND_NATS2(TRUE, x[12], y[12]) -> NATS(x[12] + 1, y[12])
(13): SIEVE(cons(x[13], ys[13])) -> SIEVE(filter(x[13], ys[13]))
(14): SIEVE(cons(x[14], ys[14])) -> FILTER(x[14], ys[14])
(15): FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])
(16): FILTER(x[16], cons(y[16], zs[16])) -> ISDIV(x[16], y[16])
(17): IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17])
(18): FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])
(19): IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19])
(20): ISDIV(x[20], 0) -> COND_ISDIV(x[20] > 0, x[20], 0)
(21): ISDIV(x[21], y[21]) -> COND_ISDIV1(x[21] > y[21] && y[21] > 0, x[21], y[21])
(22): ISDIV(x[22], y[22]) -> COND_ISDIV2(y[22] >= x[22] && x[22] > 0, x[22], y[22])
(23): COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], -(x[23]) + y[23])
(24): ISDIV(x[24], y[24]) -> COND_ISDIV3(0 > y[24], x[24], y[24])
(25): COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25]))
(26): ISDIV(x[26], y[26]) -> COND_ISDIV4(0 > x[26], x[26], y[26])
(27): COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27])

   (0) -> (2), if (x[0] ->^* x[2] & primes(x[0]) ->^* cons(y[2], zs[2]))
   (0) -> (3), if (x[0] ->^* x[3] & primes(x[0]) ->^* cons(y[3], zs[3]))
   (0) -> (5), if (x[0] ->^* x[5] & primes(x[0]) ->^* cons(y[5], zs[5]))
   (1) -> (7), if (x[1] ->^* x[7])
   (1) -> (8), if (x[1] ->^* x[8])
   (4) -> (2), if (x[4] ->^* x[2] & zs[4] ->^* cons(y[2], zs[2]))
   (4) -> (3), if (x[4] ->^* x[3] & zs[4] ->^* cons(y[3], zs[3]))
   (4) -> (5), if (x[4] ->^* x[5] & zs[4] ->^* cons(y[5], zs[5]))
   (6) -> (2), if (x[6] ->^* x[2] & zs[6] ->^* cons(y[2], zs[2]))
   (6) -> (3), if (x[6] ->^* x[3] & zs[6] ->^* cons(y[3], zs[3]))
   (6) -> (5), if (x[6] ->^* x[5] & zs[6] ->^* cons(y[5], zs[5]))
   (7) -> (13), if (nats(2, x[7]) ->^* cons(x[13], ys[13]))
   (7) -> (14), if (nats(2, x[7]) ->^* cons(x[14], ys[14]))
   (8) -> (9), if (2 ->^* x[9] & x[8] ->^* y[9])
   (8) -> (10), if (2 ->^* x[10] & x[8] ->^* y[10])
   (8) -> (11), if (2 ->^* x[11] & x[8] ->^* y[11])
   (11) -> (12), if (y[11] > x[11]  & x[11] ->^* x[12] & y[11] ->^* y[12])
   (12) -> (9), if (x[12] + 1 ->^* x[9] & y[12] ->^* y[9])
   (12) -> (10), if (x[12] + 1 ->^* x[10] & y[12] ->^* y[10])
   (12) -> (11), if (x[12] + 1 ->^* x[11] & y[12] ->^* y[11])
   (13) -> (13), if (filter(x[13], ys[13]) ->^* cons(x[13]', ys[13]'))
   (13) -> (14), if (filter(x[13], ys[13]) ->^* cons(x[14], ys[14]))
   (14) -> (15), if (x[14] ->^* x[15] & ys[14] ->^* cons(y[15], zs[15]))
   (14) -> (16), if (x[14] ->^* x[16] & ys[14] ->^* cons(y[16], zs[16]))
   (14) -> (18), if (x[14] ->^* x[18] & ys[14] ->^* cons(y[18], zs[18]))
   (15) -> (17), if (isdiv(x[15], y[15])  & x[15] ->^* x[17] & y[15] ->^* y[17] & zs[15] ->^* zs[17])
   (16) -> (20), if (x[16] ->^* x[20] & y[16] ->^* 0)
   (16) -> (21), if (x[16] ->^* x[21] & y[16] ->^* y[21])
   (16) -> (22), if (x[16] ->^* x[22] & y[16] ->^* y[22])
   (16) -> (24), if (x[16] ->^* x[24] & y[16] ->^* y[24])
   (16) -> (26), if (x[16] ->^* x[26] & y[16] ->^* y[26])
   (17) -> (15), if (x[17] ->^* x[15] & zs[17] ->^* cons(y[15], zs[15]))
   (17) -> (16), if (x[17] ->^* x[16] & zs[17] ->^* cons(y[16], zs[16]))
   (17) -> (18), if (x[17] ->^* x[18] & zs[17] ->^* cons(y[18], zs[18]))
   (18) -> (19), if (isdiv(x[18], y[18]) ->^* FALSE & x[18] ->^* x[19] & y[18] ->^* y[19] & zs[18] ->^* zs[19])
   (19) -> (15), if (x[19] ->^* x[15] & zs[19] ->^* cons(y[15], zs[15]))
   (19) -> (16), if (x[19] ->^* x[16] & zs[19] ->^* cons(y[16], zs[16]))
   (19) -> (18), if (x[19] ->^* x[18] & zs[19] ->^* cons(y[18], zs[18]))
   (22) -> (23), if (y[22] >= x[22] && x[22] > 0  & x[22] ->^* x[23] & y[22] ->^* y[23])
   (23) -> (20), if (x[23] ->^* x[20] & -(x[23]) + y[23] ->^* 0)
   (23) -> (21), if (x[23] ->^* x[21] & -(x[23]) + y[23] ->^* y[21])
   (23) -> (22), if (x[23] ->^* x[22] & -(x[23]) + y[23] ->^* y[22])
   (23) -> (24), if (x[23] ->^* x[24] & -(x[23]) + y[23] ->^* y[24])
   (23) -> (26), if (x[23] ->^* x[26] & -(x[23]) + y[23] ->^* y[26])
   (24) -> (25), if (0 > y[24]  & x[24] ->^* x[25] & y[24] ->^* y[25])
   (25) -> (20), if (x[25] ->^* x[20] & -(y[25]) ->^* 0)
   (25) -> (21), if (x[25] ->^* x[21] & -(y[25]) ->^* y[21])
   (25) -> (22), if (x[25] ->^* x[22] & -(y[25]) ->^* y[22])
   (25) -> (24), if (x[25] ->^* x[24] & -(y[25]) ->^* y[24])
   (25) -> (26), if (x[25] ->^* x[26] & -(y[25]) ->^* y[26])
   (26) -> (27), if (0 > x[26]  & x[26] ->^* x[27] & y[26] ->^* y[27])
   (27) -> (20), if (-(x[27]) ->^* x[20] & y[27] ->^* 0)
   (27) -> (21), if (-(x[27]) ->^* x[21] & y[27] ->^* y[21])
   (27) -> (22), if (-(x[27]) ->^* x[22] & y[27] ->^* y[22])
   (27) -> (24), if (-(x[27]) ->^* x[24] & y[27] ->^* y[24])
   (27) -> (26), if (-(x[27]) ->^* x[26] & y[27] ->^* y[26])
   (3) -> (4), if (y[3] > x[3]  & x[3] ->^* x[4] & (y[3] ->^* y[4] & zs[3] ->^* zs[4]))
   (5) -> (6), if (x[5] > y[5]  & x[5] ->^* x[6] & (y[5] ->^* y[6] & zs[5] ->^* zs[6]))

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(7) IDependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 5 SCCs with 11 less nodes.
----------------------------------------

(8)
Complex Obligation (AND)

----------------------------------------

(9)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

The ITRS R consists of the following rules:
primes(x) -> sieve(nats(2, x))
nats(x, y) -> Cond_nats(x > y, x, y)
nats(x, y) -> Cond_nats1(x = y, x, y)
nats(x, y) -> Cond_nats2(y > x, x, y)
filter(x, nil) -> nil
filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)
if_1(TRUE, x, y, zs) -> filter(x, zs)
filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
isdiv(x, 0) -> Cond_isdiv(x > 0, x, 0)
isdiv(x, y) -> Cond_isdiv1(x > y && y > 0, x, y)
isdiv(x, y) -> Cond_isdiv2(y >= x && x > 0, x, y)
Cond_isdiv2(TRUE, x, y) -> isdiv(x, -(x) + y)
isdiv(x, y) -> Cond_isdiv3(0 > y, x, y)
Cond_isdiv3(TRUE, x, y) -> isdiv(x, -(y))
isdiv(x, y) -> Cond_isdiv4(0 > x, x, y)
Cond_isdiv4(TRUE, x, y) -> isdiv(-(x), y)
sieve(nil) -> nil
sieve(cons(x, ys)) -> cons(x, sieve(filter(x, ys)))
Cond_nats2(TRUE, x, y) -> cons(x, nats(x + 1, y))
Cond_nats(TRUE, x, y) -> nil
Cond_nats1(TRUE, x, y) -> cons(x, nil)
if_2(FALSE, x, y, zs) -> cons(x, filter(x, zs))
Cond_isdiv(TRUE, x, 0) -> TRUE
Cond_isdiv1(TRUE, x, y) -> FALSE

The integer pair graph contains the following rules and edges:
(6): COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6])
(5): MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(x[5] > y[5], x[5], cons(y[5], zs[5]))
(4): COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4])
(3): MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(y[3] > x[3], x[3], cons(y[3], zs[3]))

   (4) -> (3), if (x[4] ->^* x[3] & zs[4] ->^* cons(y[3], zs[3]))
   (6) -> (3), if (x[6] ->^* x[3] & zs[6] ->^* cons(y[3], zs[3]))
   (3) -> (4), if (y[3] > x[3]  & x[3] ->^* x[4] & (y[3] ->^* y[4] & zs[3] ->^* zs[4]))
   (4) -> (5), if (x[4] ->^* x[5] & zs[4] ->^* cons(y[5], zs[5]))
   (6) -> (5), if (x[6] ->^* x[5] & zs[6] ->^* cons(y[5], zs[5]))
   (5) -> (6), if (x[5] > y[5]  & x[5] ->^* x[6] & (y[5] ->^* y[6] & zs[5] ->^* zs[6]))

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(10) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(11)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer

R is empty.

The integer pair graph contains the following rules and edges:
(6): COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6])
(5): MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(x[5] > y[5], x[5], cons(y[5], zs[5]))
(4): COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4])
(3): MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(y[3] > x[3], x[3], cons(y[3], zs[3]))

   (4) -> (3), if (x[4] ->^* x[3] & zs[4] ->^* cons(y[3], zs[3]))
   (6) -> (3), if (x[6] ->^* x[3] & zs[6] ->^* cons(y[3], zs[3]))
   (3) -> (4), if (y[3] > x[3]  & x[3] ->^* x[4] & (y[3] ->^* y[4] & zs[3] ->^* zs[4]))
   (4) -> (5), if (x[4] ->^* x[5] & zs[4] ->^* cons(y[5], zs[5]))
   (6) -> (5), if (x[6] ->^* x[5] & zs[6] ->^* cons(y[5], zs[5]))
   (5) -> (6), if (x[5] > y[5]  & x[5] ->^* x[6] & (y[5] ->^* y[6] & zs[5] ->^* zs[6]))

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(12) IDPNonInfProof (SOUND)
Used the following options for this NonInfProof:

IDPGPoloSolver:
Range: [(-1,2)]
IsNat: true
Interpretation Shape Heuristic: aprove.DPFramework.IDPProblem.Processors.nonInf.poly.IdpDefaultShapeHeuristic@393b4c3e
Constraint Generator: NonInfConstraintGenerator:
PathGenerator: MetricPathGenerator:
Max Left Steps: 1
Max Right Steps: 1



The constraints were generated the following way:

The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6]) the following chains were created:
*We consider the chain MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5])), COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6]), MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3])) which results in the following constraint:

(1)    (>(x[5], y[5])=TRUE & x[5]=x[6] & y[5]=y[6] & zs[5]=zs[6] & x[6]=x[3] & zs[6]=cons(y[3], zs[3])  ==>  COND_MEM2(TRUE, x[6], cons(y[6], zs[6]))_>=_NonInfC & COND_MEM2(TRUE, x[6], cons(y[6], zs[6]))_>=_MEM(x[6], zs[6]) & (U^Increasing(MEM(x[6], zs[6])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (>(x[5], y[5])=TRUE  ==>  COND_MEM2(TRUE, x[5], cons(y[5], cons(y[3], zs[3])))_>=_NonInfC & COND_MEM2(TRUE, x[5], cons(y[5], cons(y[3], zs[3])))_>=_MEM(x[5], cons(y[3], zs[3])) & (U^Increasing(MEM(x[6], zs[6])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (0 >= 0  ==>  (U^Increasing(MEM(x[6], zs[6])), >=) & [(4)bni_15 + (-1)Bound*bni_15] + [(9)bni_15]zs[3] + [(2)bni_15]x[5] >= 0 & [(-1)bso_16] + [3]zs[3] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (0 >= 0  ==>  (U^Increasing(MEM(x[6], zs[6])), >=) & [(4)bni_15 + (-1)Bound*bni_15] + [(9)bni_15]zs[3] + [(2)bni_15]x[5] >= 0 & [(-1)bso_16] + [3]zs[3] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (0 >= 0  ==>  (U^Increasing(MEM(x[6], zs[6])), >=) & [(4)bni_15 + (-1)Bound*bni_15] + [(9)bni_15]zs[3] + [(2)bni_15]x[5] >= 0 & [(-1)bso_16] + [3]zs[3] >= 0)



We simplified constraint (5) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(6)    (0 >= 0  ==>  (U^Increasing(MEM(x[6], zs[6])), >=) & [(9)bni_15] >= 0 & 0 >= 0 & 0 >= 0 & [(2)bni_15] >= 0 & [(4)bni_15 + (-1)Bound*bni_15] >= 0 & 0 >= 0 & [(-1)bso_16] >= 0 & [1] >= 0)




*We consider the chain MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5])), COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6]), MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5])) which results in the following constraint:

(1)    (>(x[5], y[5])=TRUE & x[5]=x[6] & y[5]=y[6] & zs[5]=zs[6] & x[6]=x[5]1 & zs[6]=cons(y[5]1, zs[5]1)  ==>  COND_MEM2(TRUE, x[6], cons(y[6], zs[6]))_>=_NonInfC & COND_MEM2(TRUE, x[6], cons(y[6], zs[6]))_>=_MEM(x[6], zs[6]) & (U^Increasing(MEM(x[6], zs[6])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (>(x[5], y[5])=TRUE  ==>  COND_MEM2(TRUE, x[5], cons(y[5], cons(y[5]1, zs[5]1)))_>=_NonInfC & COND_MEM2(TRUE, x[5], cons(y[5], cons(y[5]1, zs[5]1)))_>=_MEM(x[5], cons(y[5]1, zs[5]1)) & (U^Increasing(MEM(x[6], zs[6])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (0 >= 0  ==>  (U^Increasing(MEM(x[6], zs[6])), >=) & [(4)bni_15 + (-1)Bound*bni_15] + [(9)bni_15]zs[5]1 + [(2)bni_15]x[5] >= 0 & [(-1)bso_16] + [3]zs[5]1 >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (0 >= 0  ==>  (U^Increasing(MEM(x[6], zs[6])), >=) & [(4)bni_15 + (-1)Bound*bni_15] + [(9)bni_15]zs[5]1 + [(2)bni_15]x[5] >= 0 & [(-1)bso_16] + [3]zs[5]1 >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (0 >= 0  ==>  (U^Increasing(MEM(x[6], zs[6])), >=) & [(4)bni_15 + (-1)Bound*bni_15] + [(9)bni_15]zs[5]1 + [(2)bni_15]x[5] >= 0 & [(-1)bso_16] + [3]zs[5]1 >= 0)



We simplified constraint (5) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(6)    (0 >= 0  ==>  (U^Increasing(MEM(x[6], zs[6])), >=) & [(9)bni_15] >= 0 & 0 >= 0 & 0 >= 0 & [(2)bni_15] >= 0 & [(4)bni_15 + (-1)Bound*bni_15] >= 0 & 0 >= 0 & [(-1)bso_16] >= 0 & [1] >= 0)








For Pair MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5])) the following chains were created:
*We consider the chain MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5])), COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6]) which results in the following constraint:

(1)    (>(x[5], y[5])=TRUE & x[5]=x[6] & y[5]=y[6] & zs[5]=zs[6]  ==>  MEM(x[5], cons(y[5], zs[5]))_>=_NonInfC & MEM(x[5], cons(y[5], zs[5]))_>=_COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5])) & (U^Increasing(COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5]))), >=))



We simplified constraint (1) using rule (IV) which results in the following new constraint:

(2)    (>(x[5], y[5])=TRUE  ==>  MEM(x[5], cons(y[5], zs[5]))_>=_NonInfC & MEM(x[5], cons(y[5], zs[5]))_>=_COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5])) & (U^Increasing(COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (0 >= 0  ==>  (U^Increasing(COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5]))), >=) & [(4)bni_17 + (-1)Bound*bni_17] + [(6)bni_17]zs[5] + [(2)bni_17]x[5] >= 0 & [3 + (-1)bso_18] + [3]zs[5] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (0 >= 0  ==>  (U^Increasing(COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5]))), >=) & [(4)bni_17 + (-1)Bound*bni_17] + [(6)bni_17]zs[5] + [(2)bni_17]x[5] >= 0 & [3 + (-1)bso_18] + [3]zs[5] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (0 >= 0  ==>  (U^Increasing(COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5]))), >=) & [(4)bni_17 + (-1)Bound*bni_17] + [(6)bni_17]zs[5] + [(2)bni_17]x[5] >= 0 & [3 + (-1)bso_18] + [3]zs[5] >= 0)



We simplified constraint (5) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(6)    (0 >= 0  ==>  (U^Increasing(COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5]))), >=) & [(6)bni_17] >= 0 & 0 >= 0 & [(2)bni_17] >= 0 & [(4)bni_17 + (-1)Bound*bni_17] >= 0 & [3 + (-1)bso_18] >= 0 & [1] >= 0)








For Pair COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4]) the following chains were created:
*We consider the chain MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3])), COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4]), MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3])) which results in the following constraint:

(1)    (>(y[3], x[3])=TRUE & x[3]=x[4] & y[3]=y[4] & zs[3]=zs[4] & x[4]=x[3]1 & zs[4]=cons(y[3]1, zs[3]1)  ==>  COND_MEM1(TRUE, x[4], cons(y[4], zs[4]))_>=_NonInfC & COND_MEM1(TRUE, x[4], cons(y[4], zs[4]))_>=_MEM(x[4], zs[4]) & (U^Increasing(MEM(x[4], zs[4])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (>(y[3], x[3])=TRUE  ==>  COND_MEM1(TRUE, x[3], cons(y[3], cons(y[3]1, zs[3]1)))_>=_NonInfC & COND_MEM1(TRUE, x[3], cons(y[3], cons(y[3]1, zs[3]1)))_>=_MEM(x[3], cons(y[3]1, zs[3]1)) & (U^Increasing(MEM(x[4], zs[4])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (0 >= 0  ==>  (U^Increasing(MEM(x[4], zs[4])), >=) & [(4)bni_19 + (-1)Bound*bni_19] + [(9)bni_19]zs[3]1 + [(2)bni_19]x[3] >= 0 & [(-1)bso_20] + [3]zs[3]1 >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (0 >= 0  ==>  (U^Increasing(MEM(x[4], zs[4])), >=) & [(4)bni_19 + (-1)Bound*bni_19] + [(9)bni_19]zs[3]1 + [(2)bni_19]x[3] >= 0 & [(-1)bso_20] + [3]zs[3]1 >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (0 >= 0  ==>  (U^Increasing(MEM(x[4], zs[4])), >=) & [(4)bni_19 + (-1)Bound*bni_19] + [(9)bni_19]zs[3]1 + [(2)bni_19]x[3] >= 0 & [(-1)bso_20] + [3]zs[3]1 >= 0)



We simplified constraint (5) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(6)    (0 >= 0  ==>  (U^Increasing(MEM(x[4], zs[4])), >=) & [(9)bni_19] >= 0 & 0 >= 0 & 0 >= 0 & [(2)bni_19] >= 0 & [(4)bni_19 + (-1)Bound*bni_19] >= 0 & 0 >= 0 & [(-1)bso_20] >= 0 & [1] >= 0)




*We consider the chain MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3])), COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4]), MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5])) which results in the following constraint:

(1)    (>(y[3], x[3])=TRUE & x[3]=x[4] & y[3]=y[4] & zs[3]=zs[4] & x[4]=x[5] & zs[4]=cons(y[5], zs[5])  ==>  COND_MEM1(TRUE, x[4], cons(y[4], zs[4]))_>=_NonInfC & COND_MEM1(TRUE, x[4], cons(y[4], zs[4]))_>=_MEM(x[4], zs[4]) & (U^Increasing(MEM(x[4], zs[4])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (>(y[3], x[3])=TRUE  ==>  COND_MEM1(TRUE, x[3], cons(y[3], cons(y[5], zs[5])))_>=_NonInfC & COND_MEM1(TRUE, x[3], cons(y[3], cons(y[5], zs[5])))_>=_MEM(x[3], cons(y[5], zs[5])) & (U^Increasing(MEM(x[4], zs[4])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (0 >= 0  ==>  (U^Increasing(MEM(x[4], zs[4])), >=) & [(4)bni_19 + (-1)Bound*bni_19] + [(9)bni_19]zs[5] + [(2)bni_19]x[3] >= 0 & [(-1)bso_20] + [3]zs[5] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (0 >= 0  ==>  (U^Increasing(MEM(x[4], zs[4])), >=) & [(4)bni_19 + (-1)Bound*bni_19] + [(9)bni_19]zs[5] + [(2)bni_19]x[3] >= 0 & [(-1)bso_20] + [3]zs[5] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (0 >= 0  ==>  (U^Increasing(MEM(x[4], zs[4])), >=) & [(4)bni_19 + (-1)Bound*bni_19] + [(9)bni_19]zs[5] + [(2)bni_19]x[3] >= 0 & [(-1)bso_20] + [3]zs[5] >= 0)



We simplified constraint (5) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(6)    (0 >= 0  ==>  (U^Increasing(MEM(x[4], zs[4])), >=) & [(9)bni_19] >= 0 & 0 >= 0 & 0 >= 0 & [(2)bni_19] >= 0 & [(4)bni_19 + (-1)Bound*bni_19] >= 0 & 0 >= 0 & [(-1)bso_20] >= 0 & [1] >= 0)








For Pair MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3])) the following chains were created:
*We consider the chain MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3])), COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4]) which results in the following constraint:

(1)    (>(y[3], x[3])=TRUE & x[3]=x[4] & y[3]=y[4] & zs[3]=zs[4]  ==>  MEM(x[3], cons(y[3], zs[3]))_>=_NonInfC & MEM(x[3], cons(y[3], zs[3]))_>=_COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3])) & (U^Increasing(COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3]))), >=))



We simplified constraint (1) using rule (IV) which results in the following new constraint:

(2)    (>(y[3], x[3])=TRUE  ==>  MEM(x[3], cons(y[3], zs[3]))_>=_NonInfC & MEM(x[3], cons(y[3], zs[3]))_>=_COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3])) & (U^Increasing(COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (0 >= 0  ==>  (U^Increasing(COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3]))), >=) & [(4)bni_21 + (-1)Bound*bni_21] + [(6)bni_21]zs[3] + [(2)bni_21]x[3] >= 0 & [3 + (-1)bso_22] + [3]zs[3] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (0 >= 0  ==>  (U^Increasing(COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3]))), >=) & [(4)bni_21 + (-1)Bound*bni_21] + [(6)bni_21]zs[3] + [(2)bni_21]x[3] >= 0 & [3 + (-1)bso_22] + [3]zs[3] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (0 >= 0  ==>  (U^Increasing(COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3]))), >=) & [(4)bni_21 + (-1)Bound*bni_21] + [(6)bni_21]zs[3] + [(2)bni_21]x[3] >= 0 & [3 + (-1)bso_22] + [3]zs[3] >= 0)



We simplified constraint (5) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(6)    (0 >= 0  ==>  (U^Increasing(COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3]))), >=) & [(6)bni_21] >= 0 & 0 >= 0 & [(2)bni_21] >= 0 & [(4)bni_21 + (-1)Bound*bni_21] >= 0 & [3 + (-1)bso_22] >= 0 & [1] >= 0)








To summarize, we get the following constraints P__>=_ for the following pairs.

*COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6])

*(0 >= 0  ==>  (U^Increasing(MEM(x[6], zs[6])), >=) & [(9)bni_15] >= 0 & 0 >= 0 & 0 >= 0 & [(2)bni_15] >= 0 & [(4)bni_15 + (-1)Bound*bni_15] >= 0 & 0 >= 0 & [(-1)bso_16] >= 0 & [1] >= 0)


*(0 >= 0  ==>  (U^Increasing(MEM(x[6], zs[6])), >=) & [(9)bni_15] >= 0 & 0 >= 0 & 0 >= 0 & [(2)bni_15] >= 0 & [(4)bni_15 + (-1)Bound*bni_15] >= 0 & 0 >= 0 & [(-1)bso_16] >= 0 & [1] >= 0)




*MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5]))

*(0 >= 0  ==>  (U^Increasing(COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5]))), >=) & [(6)bni_17] >= 0 & 0 >= 0 & [(2)bni_17] >= 0 & [(4)bni_17 + (-1)Bound*bni_17] >= 0 & [3 + (-1)bso_18] >= 0 & [1] >= 0)




*COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4])

*(0 >= 0  ==>  (U^Increasing(MEM(x[4], zs[4])), >=) & [(9)bni_19] >= 0 & 0 >= 0 & 0 >= 0 & [(2)bni_19] >= 0 & [(4)bni_19 + (-1)Bound*bni_19] >= 0 & 0 >= 0 & [(-1)bso_20] >= 0 & [1] >= 0)


*(0 >= 0  ==>  (U^Increasing(MEM(x[4], zs[4])), >=) & [(9)bni_19] >= 0 & 0 >= 0 & 0 >= 0 & [(2)bni_19] >= 0 & [(4)bni_19 + (-1)Bound*bni_19] >= 0 & 0 >= 0 & [(-1)bso_20] >= 0 & [1] >= 0)




*MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3]))

*(0 >= 0  ==>  (U^Increasing(COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3]))), >=) & [(6)bni_21] >= 0 & 0 >= 0 & [(2)bni_21] >= 0 & [(4)bni_21 + (-1)Bound*bni_21] >= 0 & [3 + (-1)bso_22] >= 0 & [1] >= 0)








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation over integers with natural coefficients for non-tuple symbols [NONINF][POLO]:

   POL(TRUE) = 0
   POL(FALSE) = 0
   POL(COND_MEM2(x_1, x_2, x_3)) = x_3 + [2]x_2
   POL(cons(x_1, x_2)) = [1] + [3]x_2
   POL(MEM(x_1, x_2)) = [2] + [2]x_2 + [2]x_1
   POL(>(x_1, x_2)) = 0
   POL(COND_MEM1(x_1, x_2, x_3)) = x_3 + [2]x_2


The following pairs are in P_>:


   MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5]))
   MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3]))


The following pairs are in P_bound:


   COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6])
   MEM(x[5], cons(y[5], zs[5])) -> COND_MEM2(>(x[5], y[5]), x[5], cons(y[5], zs[5]))
   COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4])
   MEM(x[3], cons(y[3], zs[3])) -> COND_MEM1(>(y[3], x[3]), x[3], cons(y[3], zs[3]))


The following pairs are in P_>=:


   COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6])
   COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4])


There are no usable rules.
----------------------------------------

(13)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
none

R is empty.

The integer pair graph contains the following rules and edges:
(6): COND_MEM2(TRUE, x[6], cons(y[6], zs[6])) -> MEM(x[6], zs[6])
(4): COND_MEM1(TRUE, x[4], cons(y[4], zs[4])) -> MEM(x[4], zs[4])


The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(14) IDependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 2 less nodes.
----------------------------------------

(15)
TRUE

----------------------------------------

(16)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

The ITRS R consists of the following rules:
primes(x) -> sieve(nats(2, x))
nats(x, y) -> Cond_nats(x > y, x, y)
nats(x, y) -> Cond_nats1(x = y, x, y)
nats(x, y) -> Cond_nats2(y > x, x, y)
filter(x, nil) -> nil
filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)
if_1(TRUE, x, y, zs) -> filter(x, zs)
filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
isdiv(x, 0) -> Cond_isdiv(x > 0, x, 0)
isdiv(x, y) -> Cond_isdiv1(x > y && y > 0, x, y)
isdiv(x, y) -> Cond_isdiv2(y >= x && x > 0, x, y)
Cond_isdiv2(TRUE, x, y) -> isdiv(x, -(x) + y)
isdiv(x, y) -> Cond_isdiv3(0 > y, x, y)
Cond_isdiv3(TRUE, x, y) -> isdiv(x, -(y))
isdiv(x, y) -> Cond_isdiv4(0 > x, x, y)
Cond_isdiv4(TRUE, x, y) -> isdiv(-(x), y)
sieve(nil) -> nil
sieve(cons(x, ys)) -> cons(x, sieve(filter(x, ys)))
Cond_nats2(TRUE, x, y) -> cons(x, nats(x + 1, y))
Cond_nats(TRUE, x, y) -> nil
Cond_nats1(TRUE, x, y) -> cons(x, nil)
if_2(FALSE, x, y, zs) -> cons(x, filter(x, zs))
Cond_isdiv(TRUE, x, 0) -> TRUE
Cond_isdiv1(TRUE, x, y) -> FALSE

The integer pair graph contains the following rules and edges:
(27): COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27])
(26): ISDIV(x[26], y[26]) -> COND_ISDIV4(0 > x[26], x[26], y[26])
(25): COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25]))
(24): ISDIV(x[24], y[24]) -> COND_ISDIV3(0 > y[24], x[24], y[24])
(23): COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], -(x[23]) + y[23])
(22): ISDIV(x[22], y[22]) -> COND_ISDIV2(y[22] >= x[22] && x[22] > 0, x[22], y[22])

   (23) -> (22), if (x[23] ->^* x[22] & -(x[23]) + y[23] ->^* y[22])
   (25) -> (22), if (x[25] ->^* x[22] & -(y[25]) ->^* y[22])
   (27) -> (22), if (-(x[27]) ->^* x[22] & y[27] ->^* y[22])
   (22) -> (23), if (y[22] >= x[22] && x[22] > 0  & x[22] ->^* x[23] & y[22] ->^* y[23])
   (23) -> (24), if (x[23] ->^* x[24] & -(x[23]) + y[23] ->^* y[24])
   (25) -> (24), if (x[25] ->^* x[24] & -(y[25]) ->^* y[24])
   (27) -> (24), if (-(x[27]) ->^* x[24] & y[27] ->^* y[24])
   (24) -> (25), if (0 > y[24]  & x[24] ->^* x[25] & y[24] ->^* y[25])
   (23) -> (26), if (x[23] ->^* x[26] & -(x[23]) + y[23] ->^* y[26])
   (25) -> (26), if (x[25] ->^* x[26] & -(y[25]) ->^* y[26])
   (27) -> (26), if (-(x[27]) ->^* x[26] & y[27] ->^* y[26])
   (26) -> (27), if (0 > x[26]  & x[26] ->^* x[27] & y[26] ->^* y[27])

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(17) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(18)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

R is empty.

The integer pair graph contains the following rules and edges:
(27): COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27])
(26): ISDIV(x[26], y[26]) -> COND_ISDIV4(0 > x[26], x[26], y[26])
(25): COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25]))
(24): ISDIV(x[24], y[24]) -> COND_ISDIV3(0 > y[24], x[24], y[24])
(23): COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], -(x[23]) + y[23])
(22): ISDIV(x[22], y[22]) -> COND_ISDIV2(y[22] >= x[22] && x[22] > 0, x[22], y[22])

   (23) -> (22), if (x[23] ->^* x[22] & -(x[23]) + y[23] ->^* y[22])
   (25) -> (22), if (x[25] ->^* x[22] & -(y[25]) ->^* y[22])
   (27) -> (22), if (-(x[27]) ->^* x[22] & y[27] ->^* y[22])
   (22) -> (23), if (y[22] >= x[22] && x[22] > 0  & x[22] ->^* x[23] & y[22] ->^* y[23])
   (23) -> (24), if (x[23] ->^* x[24] & -(x[23]) + y[23] ->^* y[24])
   (25) -> (24), if (x[25] ->^* x[24] & -(y[25]) ->^* y[24])
   (27) -> (24), if (-(x[27]) ->^* x[24] & y[27] ->^* y[24])
   (24) -> (25), if (0 > y[24]  & x[24] ->^* x[25] & y[24] ->^* y[25])
   (23) -> (26), if (x[23] ->^* x[26] & -(x[23]) + y[23] ->^* y[26])
   (25) -> (26), if (x[25] ->^* x[26] & -(y[25]) ->^* y[26])
   (27) -> (26), if (-(x[27]) ->^* x[26] & y[27] ->^* y[26])
   (26) -> (27), if (0 > x[26]  & x[26] ->^* x[27] & y[26] ->^* y[27])

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(19) IDPNonInfProof (SOUND)
Used the following options for this NonInfProof:

IDPGPoloSolver:
Range: [(-1,2)]
IsNat: false
Interpretation Shape Heuristic: aprove.DPFramework.IDPProblem.Processors.nonInf.poly.IdpDefaultShapeHeuristic@7e5f8ace
Constraint Generator: NonInfConstraintGenerator:
PathGenerator: MetricPathGenerator:
Max Left Steps: 1
Max Right Steps: 1



The constraints were generated the following way:

The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27]) the following chains were created:
*We consider the chain ISDIV(x[26], y[26]) -> COND_ISDIV4(>(0, x[26]), x[26], y[26]), COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27]), ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) which results in the following constraint:

(1)    (>(0, x[26])=TRUE & x[26]=x[27] & y[26]=y[27] & -(x[27])=x[22] & y[27]=y[22]  ==>  COND_ISDIV4(TRUE, x[27], y[27])_>=_NonInfC & COND_ISDIV4(TRUE, x[27], y[27])_>=_ISDIV(-(x[27]), y[27]) & (U^Increasing(ISDIV(-(x[27]), y[27])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (>(0, x[26])=TRUE  ==>  COND_ISDIV4(TRUE, x[26], y[26])_>=_NonInfC & COND_ISDIV4(TRUE, x[26], y[26])_>=_ISDIV(-(x[26]), y[26]) & (U^Increasing(ISDIV(-(x[27]), y[27])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[26] >= 0 & [(-1)bso_22] + [-2]x[26] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[26] >= 0 & [(-1)bso_22] + [-2]x[26] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[26] >= 0 & [(-1)bso_22] + [-2]x[26] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & 0 = 0 & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[26] >= 0 & [(-1)bso_22] + [-2]x[26] >= 0)



We simplified constraint (6) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(7)    ([-1] + x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & 0 = 0 & [(-1)bni_21 + (-1)Bound*bni_21] + [bni_21]x[26] >= 0 & [(-1)bso_22] + [2]x[26] >= 0)




*We consider the chain ISDIV(x[26], y[26]) -> COND_ISDIV4(>(0, x[26]), x[26], y[26]), COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27]), ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]) which results in the following constraint:

(1)    (>(0, x[26])=TRUE & x[26]=x[27] & y[26]=y[27] & -(x[27])=x[24] & y[27]=y[24]  ==>  COND_ISDIV4(TRUE, x[27], y[27])_>=_NonInfC & COND_ISDIV4(TRUE, x[27], y[27])_>=_ISDIV(-(x[27]), y[27]) & (U^Increasing(ISDIV(-(x[27]), y[27])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (>(0, x[26])=TRUE  ==>  COND_ISDIV4(TRUE, x[26], y[26])_>=_NonInfC & COND_ISDIV4(TRUE, x[26], y[26])_>=_ISDIV(-(x[26]), y[26]) & (U^Increasing(ISDIV(-(x[27]), y[27])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[26] >= 0 & [(-1)bso_22] + [-2]x[26] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[26] >= 0 & [(-1)bso_22] + [-2]x[26] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[26] >= 0 & [(-1)bso_22] + [-2]x[26] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & 0 = 0 & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[26] >= 0 & [(-1)bso_22] + [-2]x[26] >= 0)



We simplified constraint (6) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(7)    ([-1] + x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & 0 = 0 & [(-1)bni_21 + (-1)Bound*bni_21] + [bni_21]x[26] >= 0 & [(-1)bso_22] + [2]x[26] >= 0)




*We consider the chain ISDIV(x[26], y[26]) -> COND_ISDIV4(>(0, x[26]), x[26], y[26]), COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27]), ISDIV(x[26], y[26]) -> COND_ISDIV4(>(0, x[26]), x[26], y[26]) which results in the following constraint:

(1)    (>(0, x[26])=TRUE & x[26]=x[27] & y[26]=y[27] & -(x[27])=x[26]1 & y[27]=y[26]1  ==>  COND_ISDIV4(TRUE, x[27], y[27])_>=_NonInfC & COND_ISDIV4(TRUE, x[27], y[27])_>=_ISDIV(-(x[27]), y[27]) & (U^Increasing(ISDIV(-(x[27]), y[27])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (>(0, x[26])=TRUE  ==>  COND_ISDIV4(TRUE, x[26], y[26])_>=_NonInfC & COND_ISDIV4(TRUE, x[26], y[26])_>=_ISDIV(-(x[26]), y[26]) & (U^Increasing(ISDIV(-(x[27]), y[27])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[26] >= 0 & [(-1)bso_22] + [-2]x[26] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[26] >= 0 & [(-1)bso_22] + [-2]x[26] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[26] >= 0 & [(-1)bso_22] + [-2]x[26] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & 0 = 0 & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[26] >= 0 & [(-1)bso_22] + [-2]x[26] >= 0)



We simplified constraint (6) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(7)    ([-1] + x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & 0 = 0 & [(-1)bni_21 + (-1)Bound*bni_21] + [bni_21]x[26] >= 0 & [(-1)bso_22] + [2]x[26] >= 0)








For Pair ISDIV(x[26], y[26]) -> COND_ISDIV4(>(0, x[26]), x[26], y[26]) the following chains were created:
*We consider the chain ISDIV(x[26], y[26]) -> COND_ISDIV4(>(0, x[26]), x[26], y[26]), COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27]) which results in the following constraint:

(1)    (>(0, x[26])=TRUE & x[26]=x[27] & y[26]=y[27]  ==>  ISDIV(x[26], y[26])_>=_NonInfC & ISDIV(x[26], y[26])_>=_COND_ISDIV4(>(0, x[26]), x[26], y[26]) & (U^Increasing(COND_ISDIV4(>(0, x[26]), x[26], y[26])), >=))



We simplified constraint (1) using rule (IV) which results in the following new constraint:

(2)    (>(0, x[26])=TRUE  ==>  ISDIV(x[26], y[26])_>=_NonInfC & ISDIV(x[26], y[26])_>=_COND_ISDIV4(>(0, x[26]), x[26], y[26]) & (U^Increasing(COND_ISDIV4(>(0, x[26]), x[26], y[26])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(COND_ISDIV4(>(0, x[26]), x[26], y[26])), >=) & [(-1)bni_23 + (-1)Bound*bni_23] + [(-1)bni_23]x[26] >= 0 & [(-1)bso_24] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(COND_ISDIV4(>(0, x[26]), x[26], y[26])), >=) & [(-1)bni_23 + (-1)Bound*bni_23] + [(-1)bni_23]x[26] >= 0 & [(-1)bso_24] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(COND_ISDIV4(>(0, x[26]), x[26], y[26])), >=) & [(-1)bni_23 + (-1)Bound*bni_23] + [(-1)bni_23]x[26] >= 0 & [(-1)bso_24] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ([-1] + [-1]x[26] >= 0  ==>  (U^Increasing(COND_ISDIV4(>(0, x[26]), x[26], y[26])), >=) & 0 = 0 & [(-1)bni_23 + (-1)Bound*bni_23] + [(-1)bni_23]x[26] >= 0 & [(-1)bso_24] >= 0)



We simplified constraint (6) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(7)    ([-1] + x[26] >= 0  ==>  (U^Increasing(COND_ISDIV4(>(0, x[26]), x[26], y[26])), >=) & 0 = 0 & [(-1)bni_23 + (-1)Bound*bni_23] + [bni_23]x[26] >= 0 & [(-1)bso_24] >= 0)








For Pair COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])) the following chains were created:
*We consider the chain ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])), ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) which results in the following constraint:

(1)    (>(0, y[24])=TRUE & x[24]=x[25] & y[24]=y[25] & x[25]=x[22] & -(y[25])=y[22]  ==>  COND_ISDIV3(TRUE, x[25], y[25])_>=_NonInfC & COND_ISDIV3(TRUE, x[25], y[25])_>=_ISDIV(x[25], -(y[25])) & (U^Increasing(ISDIV(x[25], -(y[25]))), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (>(0, y[24])=TRUE  ==>  COND_ISDIV3(TRUE, x[24], y[24])_>=_NonInfC & COND_ISDIV3(TRUE, x[24], y[24])_>=_ISDIV(x[24], -(y[24])) & (U^Increasing(ISDIV(x[25], -(y[25]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25 + (-1)Bound*bni_25] + [(-1)bni_25]x[24] >= 0 & [(-1)bso_26] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25 + (-1)Bound*bni_25] + [(-1)bni_25]x[24] >= 0 & [(-1)bso_26] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25 + (-1)Bound*bni_25] + [(-1)bni_25]x[24] >= 0 & [(-1)bso_26] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25] = 0 & [(-1)bni_25 + (-1)Bound*bni_25] >= 0 & [(-1)bso_26] >= 0)



We simplified constraint (6) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(7)    ([-1] + y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25] = 0 & [(-1)bni_25 + (-1)Bound*bni_25] >= 0 & [(-1)bso_26] >= 0)




*We consider the chain ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])), ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]) which results in the following constraint:

(1)    (>(0, y[24])=TRUE & x[24]=x[25] & y[24]=y[25] & x[25]=x[24]1 & -(y[25])=y[24]1  ==>  COND_ISDIV3(TRUE, x[25], y[25])_>=_NonInfC & COND_ISDIV3(TRUE, x[25], y[25])_>=_ISDIV(x[25], -(y[25])) & (U^Increasing(ISDIV(x[25], -(y[25]))), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (>(0, y[24])=TRUE  ==>  COND_ISDIV3(TRUE, x[24], y[24])_>=_NonInfC & COND_ISDIV3(TRUE, x[24], y[24])_>=_ISDIV(x[24], -(y[24])) & (U^Increasing(ISDIV(x[25], -(y[25]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25 + (-1)Bound*bni_25] + [(-1)bni_25]x[24] >= 0 & [(-1)bso_26] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25 + (-1)Bound*bni_25] + [(-1)bni_25]x[24] >= 0 & [(-1)bso_26] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25 + (-1)Bound*bni_25] + [(-1)bni_25]x[24] >= 0 & [(-1)bso_26] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25] = 0 & [(-1)bni_25 + (-1)Bound*bni_25] >= 0 & [(-1)bso_26] >= 0)



We simplified constraint (6) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(7)    ([-1] + y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25] = 0 & [(-1)bni_25 + (-1)Bound*bni_25] >= 0 & [(-1)bso_26] >= 0)




*We consider the chain ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])), ISDIV(x[26], y[26]) -> COND_ISDIV4(>(0, x[26]), x[26], y[26]) which results in the following constraint:

(1)    (>(0, y[24])=TRUE & x[24]=x[25] & y[24]=y[25] & x[25]=x[26] & -(y[25])=y[26]  ==>  COND_ISDIV3(TRUE, x[25], y[25])_>=_NonInfC & COND_ISDIV3(TRUE, x[25], y[25])_>=_ISDIV(x[25], -(y[25])) & (U^Increasing(ISDIV(x[25], -(y[25]))), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (>(0, y[24])=TRUE  ==>  COND_ISDIV3(TRUE, x[24], y[24])_>=_NonInfC & COND_ISDIV3(TRUE, x[24], y[24])_>=_ISDIV(x[24], -(y[24])) & (U^Increasing(ISDIV(x[25], -(y[25]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25 + (-1)Bound*bni_25] + [(-1)bni_25]x[24] >= 0 & [(-1)bso_26] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25 + (-1)Bound*bni_25] + [(-1)bni_25]x[24] >= 0 & [(-1)bso_26] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25 + (-1)Bound*bni_25] + [(-1)bni_25]x[24] >= 0 & [(-1)bso_26] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25] = 0 & [(-1)bni_25 + (-1)Bound*bni_25] >= 0 & [(-1)bso_26] >= 0)



We simplified constraint (6) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(7)    ([-1] + y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25] = 0 & [(-1)bni_25 + (-1)Bound*bni_25] >= 0 & [(-1)bso_26] >= 0)








For Pair ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]) the following chains were created:
*We consider the chain ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])) which results in the following constraint:

(1)    (>(0, y[24])=TRUE & x[24]=x[25] & y[24]=y[25]  ==>  ISDIV(x[24], y[24])_>=_NonInfC & ISDIV(x[24], y[24])_>=_COND_ISDIV3(>(0, y[24]), x[24], y[24]) & (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=))



We simplified constraint (1) using rule (IV) which results in the following new constraint:

(2)    (>(0, y[24])=TRUE  ==>  ISDIV(x[24], y[24])_>=_NonInfC & ISDIV(x[24], y[24])_>=_COND_ISDIV3(>(0, y[24]), x[24], y[24]) & (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=) & [(-1)bni_27 + (-1)Bound*bni_27] + [(-1)bni_27]x[24] >= 0 & [(-1)bso_28] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=) & [(-1)bni_27 + (-1)Bound*bni_27] + [(-1)bni_27]x[24] >= 0 & [(-1)bso_28] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=) & [(-1)bni_27 + (-1)Bound*bni_27] + [(-1)bni_27]x[24] >= 0 & [(-1)bso_28] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=) & [(-1)bni_27] = 0 & [(-1)bni_27 + (-1)Bound*bni_27] >= 0 & [(-1)bso_28] >= 0)



We simplified constraint (6) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(7)    ([-1] + y[24] >= 0  ==>  (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=) & [(-1)bni_27] = 0 & [(-1)bni_27 + (-1)Bound*bni_27] >= 0 & [(-1)bso_28] >= 0)








For Pair COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])) the following chains were created:
*We consider the chain ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])), ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) which results in the following constraint:

(1)    (&&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23] & x[23]=x[22]1 & +(-(x[23]), y[23])=y[22]1  ==>  COND_ISDIV2(TRUE, x[23], y[23])_>=_NonInfC & COND_ISDIV2(TRUE, x[23], y[23])_>=_ISDIV(x[23], +(-(x[23]), y[23])) & (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=))



We simplified constraint (1) using rules (III), (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>=(y[22], x[22])=TRUE & >(x[22], 0)=TRUE  ==>  COND_ISDIV2(TRUE, x[22], y[22])_>=_NonInfC & COND_ISDIV2(TRUE, x[22], y[22])_>=_ISDIV(x[22], +(-(x[22]), y[22])) & (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_29 + (-1)Bound*bni_29] + [(-1)bni_29]x[22] >= 0 & [(-1)bso_30] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_29 + (-1)Bound*bni_29] + [(-1)bni_29]x[22] >= 0 & [(-1)bso_30] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_29 + (-1)Bound*bni_29] + [(-1)bni_29]x[22] >= 0 & [(-1)bso_30] >= 0)




*We consider the chain ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])), ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]) which results in the following constraint:

(1)    (&&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23] & x[23]=x[24] & +(-(x[23]), y[23])=y[24]  ==>  COND_ISDIV2(TRUE, x[23], y[23])_>=_NonInfC & COND_ISDIV2(TRUE, x[23], y[23])_>=_ISDIV(x[23], +(-(x[23]), y[23])) & (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=))



We simplified constraint (1) using rules (III), (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>=(y[22], x[22])=TRUE & >(x[22], 0)=TRUE  ==>  COND_ISDIV2(TRUE, x[22], y[22])_>=_NonInfC & COND_ISDIV2(TRUE, x[22], y[22])_>=_ISDIV(x[22], +(-(x[22]), y[22])) & (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_29 + (-1)Bound*bni_29] + [(-1)bni_29]x[22] >= 0 & [(-1)bso_30] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_29 + (-1)Bound*bni_29] + [(-1)bni_29]x[22] >= 0 & [(-1)bso_30] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_29 + (-1)Bound*bni_29] + [(-1)bni_29]x[22] >= 0 & [(-1)bso_30] >= 0)




*We consider the chain ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])), ISDIV(x[26], y[26]) -> COND_ISDIV4(>(0, x[26]), x[26], y[26]) which results in the following constraint:

(1)    (&&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23] & x[23]=x[26] & +(-(x[23]), y[23])=y[26]  ==>  COND_ISDIV2(TRUE, x[23], y[23])_>=_NonInfC & COND_ISDIV2(TRUE, x[23], y[23])_>=_ISDIV(x[23], +(-(x[23]), y[23])) & (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=))



We simplified constraint (1) using rules (III), (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>=(y[22], x[22])=TRUE & >(x[22], 0)=TRUE  ==>  COND_ISDIV2(TRUE, x[22], y[22])_>=_NonInfC & COND_ISDIV2(TRUE, x[22], y[22])_>=_ISDIV(x[22], +(-(x[22]), y[22])) & (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_29 + (-1)Bound*bni_29] + [(-1)bni_29]x[22] >= 0 & [(-1)bso_30] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_29 + (-1)Bound*bni_29] + [(-1)bni_29]x[22] >= 0 & [(-1)bso_30] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_29 + (-1)Bound*bni_29] + [(-1)bni_29]x[22] >= 0 & [(-1)bso_30] >= 0)








For Pair ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) the following chains were created:
*We consider the chain ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])) which results in the following constraint:

(1)    (&&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23]  ==>  ISDIV(x[22], y[22])_>=_NonInfC & ISDIV(x[22], y[22])_>=_COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) & (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=))



We simplified constraint (1) using rules (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>=(y[22], x[22])=TRUE & >(x[22], 0)=TRUE  ==>  ISDIV(x[22], y[22])_>=_NonInfC & ISDIV(x[22], y[22])_>=_COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) & (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=) & [(-1)bni_31 + (-1)Bound*bni_31] + [(-1)bni_31]x[22] >= 0 & [(-1)bso_32] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=) & [(-1)bni_31 + (-1)Bound*bni_31] + [(-1)bni_31]x[22] >= 0 & [(-1)bso_32] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=) & [(-1)bni_31 + (-1)Bound*bni_31] + [(-1)bni_31]x[22] >= 0 & [(-1)bso_32] >= 0)








To summarize, we get the following constraints P__>=_ for the following pairs.

*COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27])

*([-1] + x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & 0 = 0 & [(-1)bni_21 + (-1)Bound*bni_21] + [bni_21]x[26] >= 0 & [(-1)bso_22] + [2]x[26] >= 0)


*([-1] + x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & 0 = 0 & [(-1)bni_21 + (-1)Bound*bni_21] + [bni_21]x[26] >= 0 & [(-1)bso_22] + [2]x[26] >= 0)


*([-1] + x[26] >= 0  ==>  (U^Increasing(ISDIV(-(x[27]), y[27])), >=) & 0 = 0 & [(-1)bni_21 + (-1)Bound*bni_21] + [bni_21]x[26] >= 0 & [(-1)bso_22] + [2]x[26] >= 0)




*ISDIV(x[26], y[26]) -> COND_ISDIV4(>(0, x[26]), x[26], y[26])

*([-1] + x[26] >= 0  ==>  (U^Increasing(COND_ISDIV4(>(0, x[26]), x[26], y[26])), >=) & 0 = 0 & [(-1)bni_23 + (-1)Bound*bni_23] + [bni_23]x[26] >= 0 & [(-1)bso_24] >= 0)




*COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25]))

*([-1] + y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25] = 0 & [(-1)bni_25 + (-1)Bound*bni_25] >= 0 & [(-1)bso_26] >= 0)


*([-1] + y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25] = 0 & [(-1)bni_25 + (-1)Bound*bni_25] >= 0 & [(-1)bso_26] >= 0)


*([-1] + y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)bni_25] = 0 & [(-1)bni_25 + (-1)Bound*bni_25] >= 0 & [(-1)bso_26] >= 0)




*ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24])

*([-1] + y[24] >= 0  ==>  (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=) & [(-1)bni_27] = 0 & [(-1)bni_27 + (-1)Bound*bni_27] >= 0 & [(-1)bso_28] >= 0)




*COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23]))

*(y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_29 + (-1)Bound*bni_29] + [(-1)bni_29]x[22] >= 0 & [(-1)bso_30] >= 0)


*(y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_29 + (-1)Bound*bni_29] + [(-1)bni_29]x[22] >= 0 & [(-1)bso_30] >= 0)


*(y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_29 + (-1)Bound*bni_29] + [(-1)bni_29]x[22] >= 0 & [(-1)bso_30] >= 0)




*ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])

*(y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=) & [(-1)bni_31 + (-1)Bound*bni_31] + [(-1)bni_31]x[22] >= 0 & [(-1)bso_32] >= 0)








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation over integers[POLO]:

   POL(TRUE) = 0
   POL(FALSE) = [1]
   POL(COND_ISDIV4(x_1, x_2, x_3)) = [-1] + [-1]x_2
   POL(ISDIV(x_1, x_2)) = [-1] + [-1]x_1
   POL(-(x_1)) = [-1]x_1
   POL(>(x_1, x_2)) = [-1]
   POL(0) = 0
   POL(COND_ISDIV3(x_1, x_2, x_3)) = [-1] + [-1]x_2
   POL(COND_ISDIV2(x_1, x_2, x_3)) = [-1] + [-1]x_2
   POL(+(x_1, x_2)) = x_1 + x_2
   POL(&&(x_1, x_2)) = [-1]
   POL(>=(x_1, x_2)) = [-1]


The following pairs are in P_>:


   COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27])


The following pairs are in P_bound:


   COND_ISDIV4(TRUE, x[27], y[27]) -> ISDIV(-(x[27]), y[27])
   ISDIV(x[26], y[26]) -> COND_ISDIV4(>(0, x[26]), x[26], y[26])


The following pairs are in P_>=:


   ISDIV(x[26], y[26]) -> COND_ISDIV4(>(0, x[26]), x[26], y[26])
   COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25]))
   ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24])
   COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23]))
   ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])


At least the following rules have been oriented under context sensitive arithmetic replacement:

   TRUE^1 -> &&(TRUE, TRUE)^1
   FALSE^1 -> &&(TRUE, FALSE)^1

----------------------------------------

(20)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

R is empty.

The integer pair graph contains the following rules and edges:
(26): ISDIV(x[26], y[26]) -> COND_ISDIV4(0 > x[26], x[26], y[26])
(25): COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25]))
(24): ISDIV(x[24], y[24]) -> COND_ISDIV3(0 > y[24], x[24], y[24])
(23): COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], -(x[23]) + y[23])
(22): ISDIV(x[22], y[22]) -> COND_ISDIV2(y[22] >= x[22] && x[22] > 0, x[22], y[22])

   (23) -> (22), if (x[23] ->^* x[22] & -(x[23]) + y[23] ->^* y[22])
   (25) -> (22), if (x[25] ->^* x[22] & -(y[25]) ->^* y[22])
   (22) -> (23), if (y[22] >= x[22] && x[22] > 0  & x[22] ->^* x[23] & y[22] ->^* y[23])
   (23) -> (24), if (x[23] ->^* x[24] & -(x[23]) + y[23] ->^* y[24])
   (25) -> (24), if (x[25] ->^* x[24] & -(y[25]) ->^* y[24])
   (24) -> (25), if (0 > y[24]  & x[24] ->^* x[25] & y[24] ->^* y[25])
   (23) -> (26), if (x[23] ->^* x[26] & -(x[23]) + y[23] ->^* y[26])
   (25) -> (26), if (x[25] ->^* x[26] & -(y[25]) ->^* y[26])

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(21) IDependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(22)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

R is empty.

The integer pair graph contains the following rules and edges:
(24): ISDIV(x[24], y[24]) -> COND_ISDIV3(0 > y[24], x[24], y[24])
(23): COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], -(x[23]) + y[23])
(22): ISDIV(x[22], y[22]) -> COND_ISDIV2(y[22] >= x[22] && x[22] > 0, x[22], y[22])
(25): COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25]))

   (23) -> (22), if (x[23] ->^* x[22] & -(x[23]) + y[23] ->^* y[22])
   (25) -> (22), if (x[25] ->^* x[22] & -(y[25]) ->^* y[22])
   (22) -> (23), if (y[22] >= x[22] && x[22] > 0  & x[22] ->^* x[23] & y[22] ->^* y[23])
   (23) -> (24), if (x[23] ->^* x[24] & -(x[23]) + y[23] ->^* y[24])
   (25) -> (24), if (x[25] ->^* x[24] & -(y[25]) ->^* y[24])
   (24) -> (25), if (0 > y[24]  & x[24] ->^* x[25] & y[24] ->^* y[25])

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(23) IDPNonInfProof (SOUND)
Used the following options for this NonInfProof:

IDPGPoloSolver:
Range: [(-1,2)]
IsNat: false
Interpretation Shape Heuristic: aprove.DPFramework.IDPProblem.Processors.nonInf.poly.IdpDefaultShapeHeuristic@76ec7b99
Constraint Generator: NonInfConstraintGenerator:
PathGenerator: MetricPathGenerator:
Max Left Steps: 3
Max Right Steps: 2



The constraints were generated the following way:

The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]) the following chains were created:
*We consider the chain ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])) which results in the following constraint:

(1)    (>(0, y[24])=TRUE & x[24]=x[25] & y[24]=y[25]  ==>  ISDIV(x[24], y[24])_>=_NonInfC & ISDIV(x[24], y[24])_>=_COND_ISDIV3(>(0, y[24]), x[24], y[24]) & (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=))



We simplified constraint (1) using rule (IV) which results in the following new constraint:

(2)    (>(0, y[24])=TRUE  ==>  ISDIV(x[24], y[24])_>=_NonInfC & ISDIV(x[24], y[24])_>=_COND_ISDIV3(>(0, y[24]), x[24], y[24]) & (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=) & [(-1)bni_17 + (-1)Bound*bni_17] + [(-1)bni_17]x[24] >= 0 & [-1 + (-1)bso_18] + [-2]y[24] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=) & [(-1)bni_17 + (-1)Bound*bni_17] + [(-1)bni_17]x[24] >= 0 & [-1 + (-1)bso_18] + [-2]y[24] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=) & [(-1)bni_17 + (-1)Bound*bni_17] + [(-1)bni_17]x[24] >= 0 & [-1 + (-1)bso_18] + [-2]y[24] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ([-1] + [-1]y[24] >= 0  ==>  (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=) & [(-1)bni_17] = 0 & [(-1)bni_17 + (-1)Bound*bni_17] >= 0 & [-1 + (-1)bso_18] + [-2]y[24] >= 0)



We simplified constraint (6) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(7)    ([-1] + y[24] >= 0  ==>  (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=) & [(-1)bni_17] = 0 & [(-1)bni_17 + (-1)Bound*bni_17] >= 0 & [-1 + (-1)bso_18] + [2]y[24] >= 0)








For Pair COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])) the following chains were created:
*We consider the chain ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])), ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])), ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])) which results in the following constraint:

(1)    (&&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23] & x[23]=x[22]1 & +(-(x[23]), y[23])=y[22]1 & &&(>=(y[22]1, x[22]1), >(x[22]1, 0))=TRUE & x[22]1=x[23]1 & y[22]1=y[23]1 & x[23]1=x[22]2 & +(-(x[23]1), y[23]1)=y[22]2 & &&(>=(y[22]2, x[22]2), >(x[22]2, 0))=TRUE & x[22]2=x[23]2 & y[22]2=y[23]2  ==>  COND_ISDIV2(TRUE, x[23]1, y[23]1)_>=_NonInfC & COND_ISDIV2(TRUE, x[23]1, y[23]1)_>=_ISDIV(x[23]1, +(-(x[23]1), y[23]1)) & (U^Increasing(ISDIV(x[23]1, +(-(x[23]1), y[23]1))), >=))



We simplified constraint (1) using rules (III), (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>=(y[22], x[22])=TRUE & >(x[22], 0)=TRUE & >=(+(-(x[22]), y[22]), x[22])=TRUE & >=(+(-(x[22]), +(-(x[22]), y[22])), x[22])=TRUE  ==>  COND_ISDIV2(TRUE, x[22], +(-(x[22]), y[22]))_>=_NonInfC & COND_ISDIV2(TRUE, x[22], +(-(x[22]), y[22]))_>=_ISDIV(x[22], +(-(x[22]), +(-(x[22]), y[22]))) & (U^Increasing(ISDIV(x[23]1, +(-(x[23]1), y[23]1))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-2]x[22] + y[22] >= 0 & [-3]x[22] + y[22] >= 0  ==>  (U^Increasing(ISDIV(x[23]1, +(-(x[23]1), y[23]1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-2]x[22] + y[22] >= 0 & [-3]x[22] + y[22] >= 0  ==>  (U^Increasing(ISDIV(x[23]1, +(-(x[23]1), y[23]1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-2]x[22] + y[22] >= 0 & [-3]x[22] + y[22] >= 0  ==>  (U^Increasing(ISDIV(x[23]1, +(-(x[23]1), y[23]1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)




*We consider the chain ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])), ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])), ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])) which results in the following constraint:

(1)    (&&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23] & x[23]=x[22]1 & +(-(x[23]), y[23])=y[22]1 & &&(>=(y[22]1, x[22]1), >(x[22]1, 0))=TRUE & x[22]1=x[23]1 & y[22]1=y[23]1 & x[23]1=x[24] & +(-(x[23]1), y[23]1)=y[24] & >(0, y[24])=TRUE & x[24]=x[25] & y[24]=y[25]  ==>  COND_ISDIV2(TRUE, x[23]1, y[23]1)_>=_NonInfC & COND_ISDIV2(TRUE, x[23]1, y[23]1)_>=_ISDIV(x[23]1, +(-(x[23]1), y[23]1)) & (U^Increasing(ISDIV(x[23]1, +(-(x[23]1), y[23]1))), >=))



We simplified constraint (1) using rules (III), (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>(0, +(-(x[22]), +(-(x[22]), y[22])))=TRUE & >=(y[22], x[22])=TRUE & >(x[22], 0)=TRUE & >=(+(-(x[22]), y[22]), x[22])=TRUE  ==>  COND_ISDIV2(TRUE, x[22], +(-(x[22]), y[22]))_>=_NonInfC & COND_ISDIV2(TRUE, x[22], +(-(x[22]), y[22]))_>=_ISDIV(x[22], +(-(x[22]), +(-(x[22]), y[22]))) & (U^Increasing(ISDIV(x[23]1, +(-(x[23]1), y[23]1))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [2]x[22] + [-1]y[22] >= 0 & y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-2]x[22] + y[22] >= 0  ==>  (U^Increasing(ISDIV(x[23]1, +(-(x[23]1), y[23]1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [2]x[22] + [-1]y[22] >= 0 & y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-2]x[22] + y[22] >= 0  ==>  (U^Increasing(ISDIV(x[23]1, +(-(x[23]1), y[23]1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [2]x[22] + [-1]y[22] >= 0 & y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-2]x[22] + y[22] >= 0  ==>  (U^Increasing(ISDIV(x[23]1, +(-(x[23]1), y[23]1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)



We solved constraint (5) using rule (IDP_SMT_SPLIT).
*We consider the chain ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])), ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])), ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])) which results in the following constraint:

(1)    (>(0, y[24])=TRUE & x[24]=x[25] & y[24]=y[25] & x[25]=x[22] & -(y[25])=y[22] & &&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23] & x[23]=x[22]1 & +(-(x[23]), y[23])=y[22]1 & &&(>=(y[22]1, x[22]1), >(x[22]1, 0))=TRUE & x[22]1=x[23]1 & y[22]1=y[23]1  ==>  COND_ISDIV2(TRUE, x[23], y[23])_>=_NonInfC & COND_ISDIV2(TRUE, x[23], y[23])_>=_ISDIV(x[23], +(-(x[23]), y[23])) & (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=))



We simplified constraint (1) using rules (III), (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>(0, y[24])=TRUE & >=(-(y[24]), x[22])=TRUE & >(x[22], 0)=TRUE & >=(+(-(x[22]), -(y[24])), x[22])=TRUE  ==>  COND_ISDIV2(TRUE, x[22], -(y[24]))_>=_NonInfC & COND_ISDIV2(TRUE, x[22], -(y[24]))_>=_ISDIV(x[22], +(-(x[22]), -(y[24]))) & (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]y[24] >= 0 & [-1]y[24] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-2]x[22] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]y[24] >= 0 & [-1]y[24] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-2]x[22] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]y[24] >= 0 & [-1]y[24] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-2]x[22] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (5) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(6)    ([-1] + y[24] >= 0 & y[24] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-2]x[22] + y[24] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)




*We consider the chain ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])), ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])), ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])) which results in the following constraint:

(1)    (>(0, y[24])=TRUE & x[24]=x[25] & y[24]=y[25] & x[25]=x[22] & -(y[25])=y[22] & &&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23] & x[23]=x[24]1 & +(-(x[23]), y[23])=y[24]1 & >(0, y[24]1)=TRUE & x[24]1=x[25]1 & y[24]1=y[25]1  ==>  COND_ISDIV2(TRUE, x[23], y[23])_>=_NonInfC & COND_ISDIV2(TRUE, x[23], y[23])_>=_ISDIV(x[23], +(-(x[23]), y[23])) & (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=))



We simplified constraint (1) using rules (III), (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>(0, y[24])=TRUE & >(0, +(-(x[22]), -(y[24])))=TRUE & >=(-(y[24]), x[22])=TRUE & >(x[22], 0)=TRUE  ==>  COND_ISDIV2(TRUE, x[22], -(y[24]))_>=_NonInfC & COND_ISDIV2(TRUE, x[22], -(y[24]))_>=_ISDIV(x[22], +(-(x[22]), -(y[24]))) & (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]y[24] >= 0 & [-1] + x[22] + y[24] >= 0 & [-1]y[24] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]y[24] >= 0 & [-1] + x[22] + y[24] >= 0 & [-1]y[24] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]y[24] >= 0 & [-1] + x[22] + y[24] >= 0 & [-1]y[24] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)



We solved constraint (5) using rule (IDP_SMT_SPLIT).




For Pair ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) the following chains were created:
*We consider the chain ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])) which results in the following constraint:

(1)    (&&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23]  ==>  ISDIV(x[22], y[22])_>=_NonInfC & ISDIV(x[22], y[22])_>=_COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) & (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=))



We simplified constraint (1) using rules (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>=(y[22], x[22])=TRUE & >(x[22], 0)=TRUE  ==>  ISDIV(x[22], y[22])_>=_NonInfC & ISDIV(x[22], y[22])_>=_COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) & (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[22] >= 0 & [(-1)bso_22] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[22] >= 0 & [(-1)bso_22] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[22] >= 0 & [(-1)bso_22] >= 0)








For Pair COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])) the following chains were created:
*We consider the chain ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])), ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])), ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])) which results in the following constraint:

(1)    (&&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23] & x[23]=x[24] & +(-(x[23]), y[23])=y[24] & >(0, y[24])=TRUE & x[24]=x[25] & y[24]=y[25] & x[25]=x[22]1 & -(y[25])=y[22]1 & &&(>=(y[22]1, x[22]1), >(x[22]1, 0))=TRUE & x[22]1=x[23]1 & y[22]1=y[23]1  ==>  COND_ISDIV3(TRUE, x[25], y[25])_>=_NonInfC & COND_ISDIV3(TRUE, x[25], y[25])_>=_ISDIV(x[25], -(y[25])) & (U^Increasing(ISDIV(x[25], -(y[25]))), >=))



We simplified constraint (1) using rules (III), (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>(0, +(-(x[22]), y[22]))=TRUE & >=(y[22], x[22])=TRUE & >(x[22], 0)=TRUE & >=(-(+(-(x[22]), y[22])), x[22])=TRUE  ==>  COND_ISDIV3(TRUE, x[22], +(-(x[22]), y[22]))_>=_NonInfC & COND_ISDIV3(TRUE, x[22], +(-(x[22]), y[22]))_>=_ISDIV(x[22], -(+(-(x[22]), y[22]))) & (U^Increasing(ISDIV(x[25], -(y[25]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + x[22] + [-1]y[22] >= 0 & y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-1]y[22] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)Bound*bni_23] + [(-3)bni_23]x[22] + [(2)bni_23]y[22] >= 0 & [1 + (-1)bso_24] + [-2]x[22] + [2]y[22] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + x[22] + [-1]y[22] >= 0 & y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-1]y[22] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)Bound*bni_23] + [(-3)bni_23]x[22] + [(2)bni_23]y[22] >= 0 & [1 + (-1)bso_24] + [-2]x[22] + [2]y[22] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + x[22] + [-1]y[22] >= 0 & y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-1]y[22] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)Bound*bni_23] + [(-3)bni_23]x[22] + [(2)bni_23]y[22] >= 0 & [1 + (-1)bso_24] + [-2]x[22] + [2]y[22] >= 0)



We solved constraint (5) using rule (IDP_SMT_SPLIT).
*We consider the chain ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])), ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])), ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])) which results in the following constraint:

(1)    (&&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23] & x[23]=x[24] & +(-(x[23]), y[23])=y[24] & >(0, y[24])=TRUE & x[24]=x[25] & y[24]=y[25] & x[25]=x[24]1 & -(y[25])=y[24]1 & >(0, y[24]1)=TRUE & x[24]1=x[25]1 & y[24]1=y[25]1  ==>  COND_ISDIV3(TRUE, x[25], y[25])_>=_NonInfC & COND_ISDIV3(TRUE, x[25], y[25])_>=_ISDIV(x[25], -(y[25])) & (U^Increasing(ISDIV(x[25], -(y[25]))), >=))



We simplified constraint (1) using rules (III), (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>(0, +(-(x[22]), y[22]))=TRUE & >(0, -(+(-(x[22]), y[22])))=TRUE & >=(y[22], x[22])=TRUE & >(x[22], 0)=TRUE  ==>  COND_ISDIV3(TRUE, x[22], +(-(x[22]), y[22]))_>=_NonInfC & COND_ISDIV3(TRUE, x[22], +(-(x[22]), y[22]))_>=_ISDIV(x[22], -(+(-(x[22]), y[22]))) & (U^Increasing(ISDIV(x[25], -(y[25]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + x[22] + [-1]y[22] >= 0 & [-1] + [-1]x[22] + y[22] >= 0 & y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)Bound*bni_23] + [(-3)bni_23]x[22] + [(2)bni_23]y[22] >= 0 & [1 + (-1)bso_24] + [-2]x[22] + [2]y[22] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + x[22] + [-1]y[22] >= 0 & [-1] + [-1]x[22] + y[22] >= 0 & y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)Bound*bni_23] + [(-3)bni_23]x[22] + [(2)bni_23]y[22] >= 0 & [1 + (-1)bso_24] + [-2]x[22] + [2]y[22] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + x[22] + [-1]y[22] >= 0 & [-1] + [-1]x[22] + y[22] >= 0 & y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[25], -(y[25]))), >=) & [(-1)Bound*bni_23] + [(-3)bni_23]x[22] + [(2)bni_23]y[22] >= 0 & [1 + (-1)bso_24] + [-2]x[22] + [2]y[22] >= 0)



We solved constraint (5) using rule (IDP_SMT_SPLIT).
*We consider the chain ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])), ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])), ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])) which results in the following constraint:

(1)    (>(0, y[24])=TRUE & x[24]=x[25] & y[24]=y[25] & x[25]=x[24]1 & -(y[25])=y[24]1 & >(0, y[24]1)=TRUE & x[24]1=x[25]1 & y[24]1=y[25]1 & x[25]1=x[22] & -(y[25]1)=y[22] & &&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23]  ==>  COND_ISDIV3(TRUE, x[25]1, y[25]1)_>=_NonInfC & COND_ISDIV3(TRUE, x[25]1, y[25]1)_>=_ISDIV(x[25]1, -(y[25]1)) & (U^Increasing(ISDIV(x[25]1, -(y[25]1))), >=))



We simplified constraint (1) using rules (III), (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>(0, y[24])=TRUE & >(0, -(y[24]))=TRUE & >=(-(-(y[24])), x[22])=TRUE & >(x[22], 0)=TRUE  ==>  COND_ISDIV3(TRUE, x[22], -(y[24]))_>=_NonInfC & COND_ISDIV3(TRUE, x[22], -(y[24]))_>=_ISDIV(x[22], -(-(y[24]))) & (U^Increasing(ISDIV(x[25]1, -(y[25]1))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]y[24] >= 0 & [-1] + y[24] >= 0 & y[24] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[25]1, -(y[25]1))), >=) & [(-1)Bound*bni_23] + [(-2)bni_23]y[24] + [(-1)bni_23]x[22] >= 0 & [1 + (-1)bso_24] + [-2]y[24] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]y[24] >= 0 & [-1] + y[24] >= 0 & y[24] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[25]1, -(y[25]1))), >=) & [(-1)Bound*bni_23] + [(-2)bni_23]y[24] + [(-1)bni_23]x[22] >= 0 & [1 + (-1)bso_24] + [-2]y[24] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]y[24] >= 0 & [-1] + y[24] >= 0 & y[24] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[25]1, -(y[25]1))), >=) & [(-1)Bound*bni_23] + [(-2)bni_23]y[24] + [(-1)bni_23]x[22] >= 0 & [1 + (-1)bso_24] + [-2]y[24] >= 0)



We solved constraint (5) using rule (IDP_SMT_SPLIT).
*We consider the chain ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])), ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])), ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24]), COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25])) which results in the following constraint:

(1)    (>(0, y[24])=TRUE & x[24]=x[25] & y[24]=y[25] & x[25]=x[24]1 & -(y[25])=y[24]1 & >(0, y[24]1)=TRUE & x[24]1=x[25]1 & y[24]1=y[25]1 & x[25]1=x[24]2 & -(y[25]1)=y[24]2 & >(0, y[24]2)=TRUE & x[24]2=x[25]2 & y[24]2=y[25]2  ==>  COND_ISDIV3(TRUE, x[25]1, y[25]1)_>=_NonInfC & COND_ISDIV3(TRUE, x[25]1, y[25]1)_>=_ISDIV(x[25]1, -(y[25]1)) & (U^Increasing(ISDIV(x[25]1, -(y[25]1))), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (>(0, y[24])=TRUE & >(0, -(y[24]))=TRUE & >(0, -(-(y[24])))=TRUE  ==>  COND_ISDIV3(TRUE, x[24], -(y[24]))_>=_NonInfC & COND_ISDIV3(TRUE, x[24], -(y[24]))_>=_ISDIV(x[24], -(-(y[24]))) & (U^Increasing(ISDIV(x[25]1, -(y[25]1))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ([-1] + [-1]y[24] >= 0 & [-1] + y[24] >= 0 & [-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25]1, -(y[25]1))), >=) & [(-1)Bound*bni_23] + [(-2)bni_23]y[24] + [(-1)bni_23]x[24] >= 0 & [1 + (-1)bso_24] + [-2]y[24] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ([-1] + [-1]y[24] >= 0 & [-1] + y[24] >= 0 & [-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25]1, -(y[25]1))), >=) & [(-1)Bound*bni_23] + [(-2)bni_23]y[24] + [(-1)bni_23]x[24] >= 0 & [1 + (-1)bso_24] + [-2]y[24] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ([-1] + [-1]y[24] >= 0 & [-1] + y[24] >= 0 & [-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25]1, -(y[25]1))), >=) & [(-1)Bound*bni_23] + [(-2)bni_23]y[24] + [(-1)bni_23]x[24] >= 0 & [1 + (-1)bso_24] + [-2]y[24] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ([-1] + [-1]y[24] >= 0 & [-1] + y[24] >= 0 & [-1] + [-1]y[24] >= 0  ==>  (U^Increasing(ISDIV(x[25]1, -(y[25]1))), >=) & [(-1)bni_23] = 0 & [(-1)Bound*bni_23] + [(-2)bni_23]y[24] >= 0 & [1 + (-1)bso_24] + [-2]y[24] >= 0)



We solved constraint (6) using rule (IDP_SMT_SPLIT).




To summarize, we get the following constraints P__>=_ for the following pairs.

*ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24])

*([-1] + y[24] >= 0  ==>  (U^Increasing(COND_ISDIV3(>(0, y[24]), x[24], y[24])), >=) & [(-1)bni_17] = 0 & [(-1)bni_17 + (-1)Bound*bni_17] >= 0 & [-1 + (-1)bso_18] + [2]y[24] >= 0)




*COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23]))

*(y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-2]x[22] + y[22] >= 0 & [-3]x[22] + y[22] >= 0  ==>  (U^Increasing(ISDIV(x[23]1, +(-(x[23]1), y[23]1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)


*([-1] + y[24] >= 0 & y[24] + [-1]x[22] >= 0 & x[22] + [-1] >= 0 & [-2]x[22] + y[24] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x[22] >= 0 & [(-1)bso_20] >= 0)




*ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])

*(y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=) & [(-1)bni_21 + (-1)Bound*bni_21] + [(-1)bni_21]x[22] >= 0 & [(-1)bso_22] >= 0)




*COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25]))








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation over integers[POLO]:

   POL(TRUE) = 0
   POL(FALSE) = [1]
   POL(ISDIV(x_1, x_2)) = [-1] + [-1]x_1
   POL(COND_ISDIV3(x_1, x_2, x_3)) = [2]x_3 + [-1]x_2
   POL(>(x_1, x_2)) = [-1]
   POL(0) = 0
   POL(COND_ISDIV2(x_1, x_2, x_3)) = [-1] + [-1]x_2
   POL(+(x_1, x_2)) = x_1 + x_2
   POL(-(x_1)) = [-1]x_1
   POL(&&(x_1, x_2)) = [-1]
   POL(>=(x_1, x_2)) = [-1]


The following pairs are in P_>:


   COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25]))


The following pairs are in P_bound:


   COND_ISDIV3(TRUE, x[25], y[25]) -> ISDIV(x[25], -(y[25]))


The following pairs are in P_>=:


   ISDIV(x[24], y[24]) -> COND_ISDIV3(>(0, y[24]), x[24], y[24])
   COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23]))
   ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])


At least the following rules have been oriented under context sensitive arithmetic replacement:

   TRUE^1 -> &&(TRUE, TRUE)^1
   FALSE^1 -> &&(TRUE, FALSE)^1
   FALSE^1 -> &&(FALSE, FALSE)^1

----------------------------------------

(24)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

R is empty.

The integer pair graph contains the following rules and edges:
(24): ISDIV(x[24], y[24]) -> COND_ISDIV3(0 > y[24], x[24], y[24])
(23): COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], -(x[23]) + y[23])
(22): ISDIV(x[22], y[22]) -> COND_ISDIV2(y[22] >= x[22] && x[22] > 0, x[22], y[22])

   (23) -> (22), if (x[23] ->^* x[22] & -(x[23]) + y[23] ->^* y[22])
   (22) -> (23), if (y[22] >= x[22] && x[22] > 0  & x[22] ->^* x[23] & y[22] ->^* y[23])
   (23) -> (24), if (x[23] ->^* x[24] & -(x[23]) + y[23] ->^* y[24])

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(25) IDependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(26)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Boolean, Integer

R is empty.

The integer pair graph contains the following rules and edges:
(22): ISDIV(x[22], y[22]) -> COND_ISDIV2(y[22] >= x[22] && x[22] > 0, x[22], y[22])
(23): COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], -(x[23]) + y[23])

   (23) -> (22), if (x[23] ->^* x[22] & -(x[23]) + y[23] ->^* y[22])
   (22) -> (23), if (y[22] >= x[22] && x[22] > 0  & x[22] ->^* x[23] & y[22] ->^* y[23])

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(27) IDPNonInfProof (SOUND)
Used the following options for this NonInfProof:

IDPGPoloSolver:
Range: [(-1,2)]
IsNat: false
Interpretation Shape Heuristic: aprove.DPFramework.IDPProblem.Processors.nonInf.poly.IdpDefaultShapeHeuristic@7e5f8ace
Constraint Generator: NonInfConstraintGenerator:
PathGenerator: MetricPathGenerator:
Max Left Steps: 1
Max Right Steps: 1



The constraints were generated the following way:

The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) the following chains were created:
*We consider the chain ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])) which results in the following constraint:

(1)    (&&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23]  ==>  ISDIV(x[22], y[22])_>=_NonInfC & ISDIV(x[22], y[22])_>=_COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) & (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=))



We simplified constraint (1) using rules (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>=(y[22], x[22])=TRUE & >(x[22], 0)=TRUE  ==>  ISDIV(x[22], y[22])_>=_NonInfC & ISDIV(x[22], y[22])_>=_COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) & (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=) & [(-1)bni_13 + (-1)Bound*bni_13] + [(2)bni_13]y[22] + [(-1)bni_13]x[22] >= 0 & [(-1)bso_14] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=) & [(-1)bni_13 + (-1)Bound*bni_13] + [(2)bni_13]y[22] + [(-1)bni_13]x[22] >= 0 & [(-1)bso_14] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=) & [(-1)bni_13 + (-1)Bound*bni_13] + [(2)bni_13]y[22] + [(-1)bni_13]x[22] >= 0 & [(-1)bso_14] >= 0)








For Pair COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])) the following chains were created:
*We consider the chain ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]), COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23])), ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22]) which results in the following constraint:

(1)    (&&(>=(y[22], x[22]), >(x[22], 0))=TRUE & x[22]=x[23] & y[22]=y[23] & x[23]=x[22]1 & +(-(x[23]), y[23])=y[22]1  ==>  COND_ISDIV2(TRUE, x[23], y[23])_>=_NonInfC & COND_ISDIV2(TRUE, x[23], y[23])_>=_ISDIV(x[23], +(-(x[23]), y[23])) & (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=))



We simplified constraint (1) using rules (III), (IV), (IDP_BOOLEAN) which results in the following new constraint:

(2)    (>=(y[22], x[22])=TRUE & >(x[22], 0)=TRUE  ==>  COND_ISDIV2(TRUE, x[22], y[22])_>=_NonInfC & COND_ISDIV2(TRUE, x[22], y[22])_>=_ISDIV(x[22], +(-(x[22]), y[22])) & (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_15 + (-1)Bound*bni_15] + [(2)bni_15]y[22] + [(-1)bni_15]x[22] >= 0 & [(-1)bso_16] + [2]x[22] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_15 + (-1)Bound*bni_15] + [(2)bni_15]y[22] + [(-1)bni_15]x[22] >= 0 & [(-1)bso_16] + [2]x[22] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_15 + (-1)Bound*bni_15] + [(2)bni_15]y[22] + [(-1)bni_15]x[22] >= 0 & [(-1)bso_16] + [2]x[22] >= 0)








To summarize, we get the following constraints P__>=_ for the following pairs.

*ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])

*(y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])), >=) & [(-1)bni_13 + (-1)Bound*bni_13] + [(2)bni_13]y[22] + [(-1)bni_13]x[22] >= 0 & [(-1)bso_14] >= 0)




*COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23]))

*(y[22] + [-1]x[22] >= 0 & x[22] + [-1] >= 0  ==>  (U^Increasing(ISDIV(x[23], +(-(x[23]), y[23]))), >=) & [(-1)bni_15 + (-1)Bound*bni_15] + [(2)bni_15]y[22] + [(-1)bni_15]x[22] >= 0 & [(-1)bso_16] + [2]x[22] >= 0)








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation over integers[POLO]:

   POL(TRUE) = 0
   POL(FALSE) = [1]
   POL(ISDIV(x_1, x_2)) = [-1] + [2]x_2 + [-1]x_1
   POL(COND_ISDIV2(x_1, x_2, x_3)) = [-1] + [2]x_3 + [-1]x_2
   POL(&&(x_1, x_2)) = [-1]
   POL(>=(x_1, x_2)) = [-1]
   POL(>(x_1, x_2)) = [-1]
   POL(0) = 0
   POL(+(x_1, x_2)) = x_1 + x_2
   POL(-(x_1)) = [-1]x_1


The following pairs are in P_>:


   COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23]))


The following pairs are in P_bound:


   ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])
   COND_ISDIV2(TRUE, x[23], y[23]) -> ISDIV(x[23], +(-(x[23]), y[23]))


The following pairs are in P_>=:


   ISDIV(x[22], y[22]) -> COND_ISDIV2(&&(>=(y[22], x[22]), >(x[22], 0)), x[22], y[22])


At least the following rules have been oriented under context sensitive arithmetic replacement:

   TRUE^1 -> &&(TRUE, TRUE)^1
   FALSE^1 -> &&(TRUE, FALSE)^1
   FALSE^1 -> &&(FALSE, TRUE)^1

----------------------------------------

(28)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Boolean, Integer

R is empty.

The integer pair graph contains the following rules and edges:
(22): ISDIV(x[22], y[22]) -> COND_ISDIV2(y[22] >= x[22] && x[22] > 0, x[22], y[22])


The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(29) IDependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(30)
TRUE

----------------------------------------

(31)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

The ITRS R consists of the following rules:
primes(x) -> sieve(nats(2, x))
nats(x, y) -> Cond_nats(x > y, x, y)
nats(x, y) -> Cond_nats1(x = y, x, y)
nats(x, y) -> Cond_nats2(y > x, x, y)
filter(x, nil) -> nil
filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)
if_1(TRUE, x, y, zs) -> filter(x, zs)
filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
isdiv(x, 0) -> Cond_isdiv(x > 0, x, 0)
isdiv(x, y) -> Cond_isdiv1(x > y && y > 0, x, y)
isdiv(x, y) -> Cond_isdiv2(y >= x && x > 0, x, y)
Cond_isdiv2(TRUE, x, y) -> isdiv(x, -(x) + y)
isdiv(x, y) -> Cond_isdiv3(0 > y, x, y)
Cond_isdiv3(TRUE, x, y) -> isdiv(x, -(y))
isdiv(x, y) -> Cond_isdiv4(0 > x, x, y)
Cond_isdiv4(TRUE, x, y) -> isdiv(-(x), y)
sieve(nil) -> nil
sieve(cons(x, ys)) -> cons(x, sieve(filter(x, ys)))
Cond_nats2(TRUE, x, y) -> cons(x, nats(x + 1, y))
Cond_nats(TRUE, x, y) -> nil
Cond_nats1(TRUE, x, y) -> cons(x, nil)
if_2(FALSE, x, y, zs) -> cons(x, filter(x, zs))
Cond_isdiv(TRUE, x, 0) -> TRUE
Cond_isdiv1(TRUE, x, y) -> FALSE

The integer pair graph contains the following rules and edges:
(19): IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19])
(18): FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])
(17): IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17])
(15): FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])

   (17) -> (15), if (x[17] ->^* x[15] & zs[17] ->^* cons(y[15], zs[15]))
   (19) -> (15), if (x[19] ->^* x[15] & zs[19] ->^* cons(y[15], zs[15]))
   (15) -> (17), if (isdiv(x[15], y[15])  & x[15] ->^* x[17] & y[15] ->^* y[17] & zs[15] ->^* zs[17])
   (17) -> (18), if (x[17] ->^* x[18] & zs[17] ->^* cons(y[18], zs[18]))
   (19) -> (18), if (x[19] ->^* x[18] & zs[19] ->^* cons(y[18], zs[18]))
   (18) -> (19), if (isdiv(x[18], y[18]) ->^* FALSE & x[18] ->^* x[19] & y[18] ->^* y[19] & zs[18] ->^* zs[19])

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(32) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(33)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

The ITRS R consists of the following rules:
isdiv(x, 0) -> Cond_isdiv(x > 0, x, 0)
isdiv(x, y) -> Cond_isdiv1(x > y && y > 0, x, y)
isdiv(x, y) -> Cond_isdiv2(y >= x && x > 0, x, y)
Cond_isdiv2(TRUE, x, y) -> isdiv(x, -(x) + y)
isdiv(x, y) -> Cond_isdiv3(0 > y, x, y)
Cond_isdiv3(TRUE, x, y) -> isdiv(x, -(y))
isdiv(x, y) -> Cond_isdiv4(0 > x, x, y)
Cond_isdiv4(TRUE, x, y) -> isdiv(-(x), y)
Cond_isdiv(TRUE, x, 0) -> TRUE
Cond_isdiv1(TRUE, x, y) -> FALSE

The integer pair graph contains the following rules and edges:
(19): IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19])
(18): FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])
(17): IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17])
(15): FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])

   (17) -> (15), if (x[17] ->^* x[15] & zs[17] ->^* cons(y[15], zs[15]))
   (19) -> (15), if (x[19] ->^* x[15] & zs[19] ->^* cons(y[15], zs[15]))
   (15) -> (17), if (isdiv(x[15], y[15])  & x[15] ->^* x[17] & y[15] ->^* y[17] & zs[15] ->^* zs[17])
   (17) -> (18), if (x[17] ->^* x[18] & zs[17] ->^* cons(y[18], zs[18]))
   (19) -> (18), if (x[19] ->^* x[18] & zs[19] ->^* cons(y[18], zs[18]))
   (18) -> (19), if (isdiv(x[18], y[18]) ->^* FALSE & x[18] ->^* x[19] & y[18] ->^* y[19] & zs[18] ->^* zs[19])

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(34) IDPNonInfProof (SOUND)
Used the following options for this NonInfProof:

IDPGPoloSolver:
Range: [(-1,2)]
IsNat: true
Interpretation Shape Heuristic: aprove.DPFramework.IDPProblem.Processors.nonInf.poly.IdpDefaultShapeHeuristic@393b4c3e
Constraint Generator: NonInfConstraintGenerator:
PathGenerator: MetricPathGenerator:
Max Left Steps: 1
Max Right Steps: 1



The constraints were generated the following way:

The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19]) the following chains were created:
*We consider the chain IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19]), FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15]) which results in the following constraint:

(1)    (x[19]=x[15] & zs[19]=cons(y[15], zs[15])  ==>  IF_2(FALSE, x[19], y[19], zs[19])_>=_NonInfC & IF_2(FALSE, x[19], y[19], zs[19])_>=_FILTER(x[19], zs[19]) & (U^Increasing(FILTER(x[19], zs[19])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (IF_2(FALSE, x[19], y[19], cons(y[15], zs[15]))_>=_NonInfC & IF_2(FALSE, x[19], y[19], cons(y[15], zs[15]))_>=_FILTER(x[19], cons(y[15], zs[15])) & (U^Increasing(FILTER(x[19], zs[19])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ((U^Increasing(FILTER(x[19], zs[19])), >=) & [bni_40] = 0 & [1 + (-1)bso_41] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ((U^Increasing(FILTER(x[19], zs[19])), >=) & [bni_40] = 0 & [1 + (-1)bso_41] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ((U^Increasing(FILTER(x[19], zs[19])), >=) & [bni_40] = 0 & [1 + (-1)bso_41] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ((U^Increasing(FILTER(x[19], zs[19])), >=) & [bni_40] = 0 & 0 >= 0 & [1 + (-1)bso_41] >= 0)




*We consider the chain IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19]), FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18]) which results in the following constraint:

(1)    (x[19]=x[18] & zs[19]=cons(y[18], zs[18])  ==>  IF_2(FALSE, x[19], y[19], zs[19])_>=_NonInfC & IF_2(FALSE, x[19], y[19], zs[19])_>=_FILTER(x[19], zs[19]) & (U^Increasing(FILTER(x[19], zs[19])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (IF_2(FALSE, x[19], y[19], cons(y[18], zs[18]))_>=_NonInfC & IF_2(FALSE, x[19], y[19], cons(y[18], zs[18]))_>=_FILTER(x[19], cons(y[18], zs[18])) & (U^Increasing(FILTER(x[19], zs[19])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ((U^Increasing(FILTER(x[19], zs[19])), >=) & [bni_40] = 0 & [1 + (-1)bso_41] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ((U^Increasing(FILTER(x[19], zs[19])), >=) & [bni_40] = 0 & [1 + (-1)bso_41] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ((U^Increasing(FILTER(x[19], zs[19])), >=) & [bni_40] = 0 & [1 + (-1)bso_41] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ((U^Increasing(FILTER(x[19], zs[19])), >=) & [bni_40] = 0 & 0 >= 0 & [1 + (-1)bso_41] >= 0)








For Pair FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18]) the following chains were created:
*We consider the chain IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17]), FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18]), IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19]) which results in the following constraint:

(1)    (x[17]=x[18] & zs[17]=cons(y[18], zs[18]) & isdiv(x[18], y[18])=FALSE & x[18]=x[19] & y[18]=y[19] & zs[18]=zs[19]  ==>  FILTER(x[18], cons(y[18], zs[18]))_>=_NonInfC & FILTER(x[18], cons(y[18], zs[18]))_>=_IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (isdiv(x[18], y[18])=FALSE  ==>  FILTER(x[18], cons(y[18], zs[18]))_>=_NonInfC & FILTER(x[18], cons(y[18], zs[18]))_>=_IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on isdiv(x[18], y[18])=FALSE which results in the following new constraints:

(3)    (Cond_isdiv(>(x0, 0), x0, 0)=FALSE  ==>  FILTER(x0, cons(0, zs[18]))_>=_NonInfC & FILTER(x0, cons(0, zs[18]))_>=_IF_2(isdiv(x0, 0), x0, 0, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))

(4)    (Cond_isdiv1(&&(>(x2, x1), >(x1, 0)), x2, x1)=FALSE  ==>  FILTER(x2, cons(x1, zs[18]))_>=_NonInfC & FILTER(x2, cons(x1, zs[18]))_>=_IF_2(isdiv(x2, x1), x2, x1, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))

(5)    (Cond_isdiv2(&&(>=(x3, x4), >(x4, 0)), x4, x3)=FALSE  ==>  FILTER(x4, cons(x3, zs[18]))_>=_NonInfC & FILTER(x4, cons(x3, zs[18]))_>=_IF_2(isdiv(x4, x3), x4, x3, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))

(6)    (Cond_isdiv3(>(0, x5), x6, x5)=FALSE  ==>  FILTER(x6, cons(x5, zs[18]))_>=_NonInfC & FILTER(x6, cons(x5, zs[18]))_>=_IF_2(isdiv(x6, x5), x6, x5, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))

(7)    (Cond_isdiv4(>(0, x8), x8, x7)=FALSE  ==>  FILTER(x8, cons(x7, zs[18]))_>=_NonInfC & FILTER(x8, cons(x7, zs[18]))_>=_IF_2(isdiv(x8, x7), x8, x7, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (3) using rules (III), (VII) which results in the following new constraint:

(8)    (Cond_isdiv(>(x0, 0), x0, 0)=FALSE  ==>  FILTER(x0, cons(0, zs[18]))_>=_NonInfC & FILTER(x0, cons(0, zs[18]))_>=_IF_2(isdiv(x0, 0), x0, 0, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (4) using rules (III), (VII) which results in the following new constraint:

(9)    (Cond_isdiv1(&&(>(x2, x1), >(x1, 0)), x2, x1)=FALSE  ==>  FILTER(x2, cons(x1, zs[18]))_>=_NonInfC & FILTER(x2, cons(x1, zs[18]))_>=_IF_2(isdiv(x2, x1), x2, x1, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (5) using rules (III), (VII) which results in the following new constraint:

(10)    (Cond_isdiv2(&&(>=(x3, x4), >(x4, 0)), x4, x3)=FALSE  ==>  FILTER(x4, cons(x3, zs[18]))_>=_NonInfC & FILTER(x4, cons(x3, zs[18]))_>=_IF_2(isdiv(x4, x3), x4, x3, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (6) using rules (III), (VII) which results in the following new constraint:

(11)    (Cond_isdiv3(>(0, x5), x6, x5)=FALSE  ==>  FILTER(x6, cons(x5, zs[18]))_>=_NonInfC & FILTER(x6, cons(x5, zs[18]))_>=_IF_2(isdiv(x6, x5), x6, x5, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (7) using rules (III), (VII) which results in the following new constraint:

(12)    (Cond_isdiv4(>(0, x8), x8, x7)=FALSE  ==>  FILTER(x8, cons(x7, zs[18]))_>=_NonInfC & FILTER(x8, cons(x7, zs[18]))_>=_IF_2(isdiv(x8, x7), x8, x7, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (8) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(13)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [bni_42]x0 >= 0 & [5 + (-1)bso_43] + [4]zs[18] >= 0)



We simplified constraint (9) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(14)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x1 + [bni_42]x2 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x1 >= 0)



We simplified constraint (10) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(15)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x3 + [bni_42]x4 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x3 >= 0)



We simplified constraint (11) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(16)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x5 + [bni_42]x6 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x5 >= 0)



We simplified constraint (12) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(17)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x7 + [bni_42]x8 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x7 >= 0)



We simplified constraint (14) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(18)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x1 + [bni_42]x2 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x1 >= 0)



We simplified constraint (15) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(19)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x3 + [bni_42]x4 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x3 >= 0)



We simplified constraint (16) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(20)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x5 + [bni_42]x6 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x5 >= 0)



We simplified constraint (17) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(21)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x7 + [bni_42]x8 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x7 >= 0)



We simplified constraint (13) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(22)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [bni_42]x0 >= 0 & [5 + (-1)bso_43] + [4]zs[18] >= 0)



We simplified constraint (18) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(23)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x1 + [bni_42]x2 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x1 >= 0)



We simplified constraint (19) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(24)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x3 + [bni_42]x4 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x3 >= 0)



We simplified constraint (20) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(25)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x5 + [bni_42]x6 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x5 >= 0)



We simplified constraint (21) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(26)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x7 + [bni_42]x8 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x7 >= 0)



We simplified constraint (22) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(27)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [bni_42]x0 >= 0 & [5 + (-1)bso_43] + [4]zs[18] >= 0)



We simplified constraint (23) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(28)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (24) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(29)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (25) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(30)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (26) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(31)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (27) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(32)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0)




*We consider the chain IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19]), FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18]), IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19]) which results in the following constraint:

(1)    (x[19]=x[18] & zs[19]=cons(y[18], zs[18]) & isdiv(x[18], y[18])=FALSE & x[18]=x[19]1 & y[18]=y[19]1 & zs[18]=zs[19]1  ==>  FILTER(x[18], cons(y[18], zs[18]))_>=_NonInfC & FILTER(x[18], cons(y[18], zs[18]))_>=_IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (isdiv(x[18], y[18])=FALSE  ==>  FILTER(x[18], cons(y[18], zs[18]))_>=_NonInfC & FILTER(x[18], cons(y[18], zs[18]))_>=_IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on isdiv(x[18], y[18])=FALSE which results in the following new constraints:

(3)    (Cond_isdiv(>(x15, 0), x15, 0)=FALSE  ==>  FILTER(x15, cons(0, zs[18]))_>=_NonInfC & FILTER(x15, cons(0, zs[18]))_>=_IF_2(isdiv(x15, 0), x15, 0, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))

(4)    (Cond_isdiv1(&&(>(x17, x16), >(x16, 0)), x17, x16)=FALSE  ==>  FILTER(x17, cons(x16, zs[18]))_>=_NonInfC & FILTER(x17, cons(x16, zs[18]))_>=_IF_2(isdiv(x17, x16), x17, x16, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))

(5)    (Cond_isdiv2(&&(>=(x18, x19), >(x19, 0)), x19, x18)=FALSE  ==>  FILTER(x19, cons(x18, zs[18]))_>=_NonInfC & FILTER(x19, cons(x18, zs[18]))_>=_IF_2(isdiv(x19, x18), x19, x18, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))

(6)    (Cond_isdiv3(>(0, x20), x21, x20)=FALSE  ==>  FILTER(x21, cons(x20, zs[18]))_>=_NonInfC & FILTER(x21, cons(x20, zs[18]))_>=_IF_2(isdiv(x21, x20), x21, x20, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))

(7)    (Cond_isdiv4(>(0, x23), x23, x22)=FALSE  ==>  FILTER(x23, cons(x22, zs[18]))_>=_NonInfC & FILTER(x23, cons(x22, zs[18]))_>=_IF_2(isdiv(x23, x22), x23, x22, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (3) using rules (III), (VII) which results in the following new constraint:

(8)    (Cond_isdiv(>(x15, 0), x15, 0)=FALSE  ==>  FILTER(x15, cons(0, zs[18]))_>=_NonInfC & FILTER(x15, cons(0, zs[18]))_>=_IF_2(isdiv(x15, 0), x15, 0, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (4) using rules (III), (VII) which results in the following new constraint:

(9)    (Cond_isdiv1(&&(>(x17, x16), >(x16, 0)), x17, x16)=FALSE  ==>  FILTER(x17, cons(x16, zs[18]))_>=_NonInfC & FILTER(x17, cons(x16, zs[18]))_>=_IF_2(isdiv(x17, x16), x17, x16, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (5) using rules (III), (VII) which results in the following new constraint:

(10)    (Cond_isdiv2(&&(>=(x18, x19), >(x19, 0)), x19, x18)=FALSE  ==>  FILTER(x19, cons(x18, zs[18]))_>=_NonInfC & FILTER(x19, cons(x18, zs[18]))_>=_IF_2(isdiv(x19, x18), x19, x18, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (6) using rules (III), (VII) which results in the following new constraint:

(11)    (Cond_isdiv3(>(0, x20), x21, x20)=FALSE  ==>  FILTER(x21, cons(x20, zs[18]))_>=_NonInfC & FILTER(x21, cons(x20, zs[18]))_>=_IF_2(isdiv(x21, x20), x21, x20, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (7) using rules (III), (VII) which results in the following new constraint:

(12)    (Cond_isdiv4(>(0, x23), x23, x22)=FALSE  ==>  FILTER(x23, cons(x22, zs[18]))_>=_NonInfC & FILTER(x23, cons(x22, zs[18]))_>=_IF_2(isdiv(x23, x22), x23, x22, zs[18]) & (U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=))



We simplified constraint (8) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(13)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [bni_42]x15 >= 0 & [5 + (-1)bso_43] + [4]zs[18] >= 0)



We simplified constraint (9) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(14)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x16 + [bni_42]x17 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x16 >= 0)



We simplified constraint (10) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(15)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x18 + [bni_42]x19 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x18 >= 0)



We simplified constraint (11) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(16)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x20 + [bni_42]x21 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x20 >= 0)



We simplified constraint (12) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(17)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x22 + [bni_42]x23 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x22 >= 0)



We simplified constraint (14) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(18)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x16 + [bni_42]x17 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x16 >= 0)



We simplified constraint (15) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(19)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x18 + [bni_42]x19 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x18 >= 0)



We simplified constraint (16) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(20)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x20 + [bni_42]x21 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x20 >= 0)



We simplified constraint (17) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(21)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x22 + [bni_42]x23 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x22 >= 0)



We simplified constraint (13) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(22)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [bni_42]x15 >= 0 & [5 + (-1)bso_43] + [4]zs[18] >= 0)



We simplified constraint (18) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(23)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x16 + [bni_42]x17 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x16 >= 0)



We simplified constraint (19) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(24)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x18 + [bni_42]x19 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x18 >= 0)



We simplified constraint (20) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(25)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x20 + [bni_42]x21 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x20 >= 0)



We simplified constraint (21) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(26)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [(6)bni_42]x22 + [bni_42]x23 >= 0 & [5 + (-1)bso_43] + [4]zs[18] + [6]x22 >= 0)



We simplified constraint (22) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(27)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(5)bni_42 + (-1)Bound*bni_42] + [(6)bni_42]zs[18] + [bni_42]x15 >= 0 & [5 + (-1)bso_43] + [4]zs[18] >= 0)



We simplified constraint (23) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(28)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (24) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(29)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (25) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(30)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (26) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(31)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (27) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(32)    ((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0)








For Pair IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17]) the following chains were created:
*We consider the chain IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17]), FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15]) which results in the following constraint:

(1)    (x[17]=x[15] & zs[17]=cons(y[15], zs[15])  ==>  IF_1(TRUE, x[17], y[17], zs[17])_>=_NonInfC & IF_1(TRUE, x[17], y[17], zs[17])_>=_FILTER(x[17], zs[17]) & (U^Increasing(FILTER(x[17], zs[17])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (IF_1(TRUE, x[17], y[17], cons(y[15], zs[15]))_>=_NonInfC & IF_1(TRUE, x[17], y[17], cons(y[15], zs[15]))_>=_FILTER(x[17], cons(y[15], zs[15])) & (U^Increasing(FILTER(x[17], zs[17])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ((U^Increasing(FILTER(x[17], zs[17])), >=) & [bni_44] = 0 & [1 + (-1)bso_45] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ((U^Increasing(FILTER(x[17], zs[17])), >=) & [bni_44] = 0 & [1 + (-1)bso_45] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ((U^Increasing(FILTER(x[17], zs[17])), >=) & [bni_44] = 0 & [1 + (-1)bso_45] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ((U^Increasing(FILTER(x[17], zs[17])), >=) & [bni_44] = 0 & 0 >= 0 & [1 + (-1)bso_45] >= 0)




*We consider the chain IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17]), FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18]) which results in the following constraint:

(1)    (x[17]=x[18] & zs[17]=cons(y[18], zs[18])  ==>  IF_1(TRUE, x[17], y[17], zs[17])_>=_NonInfC & IF_1(TRUE, x[17], y[17], zs[17])_>=_FILTER(x[17], zs[17]) & (U^Increasing(FILTER(x[17], zs[17])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (IF_1(TRUE, x[17], y[17], cons(y[18], zs[18]))_>=_NonInfC & IF_1(TRUE, x[17], y[17], cons(y[18], zs[18]))_>=_FILTER(x[17], cons(y[18], zs[18])) & (U^Increasing(FILTER(x[17], zs[17])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    ((U^Increasing(FILTER(x[17], zs[17])), >=) & [bni_44] = 0 & [1 + (-1)bso_45] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    ((U^Increasing(FILTER(x[17], zs[17])), >=) & [bni_44] = 0 & [1 + (-1)bso_45] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    ((U^Increasing(FILTER(x[17], zs[17])), >=) & [bni_44] = 0 & [1 + (-1)bso_45] >= 0)



We simplified constraint (5) using rule (IDP_UNRESTRICTED_VARS) which results in the following new constraint:

(6)    ((U^Increasing(FILTER(x[17], zs[17])), >=) & [bni_44] = 0 & 0 >= 0 & [1 + (-1)bso_45] >= 0)








For Pair FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15]) the following chains were created:
*We consider the chain IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17]), FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15]), IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17]) which results in the following constraint:

(1)    (x[17]=x[15] & zs[17]=cons(y[15], zs[15]) & isdiv(x[15], y[15])=TRUE & x[15]=x[17]1 & y[15]=y[17]1 & zs[15]=zs[17]1  ==>  FILTER(x[15], cons(y[15], zs[15]))_>=_NonInfC & FILTER(x[15], cons(y[15], zs[15]))_>=_IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (isdiv(x[15], y[15])=TRUE  ==>  FILTER(x[15], cons(y[15], zs[15]))_>=_NonInfC & FILTER(x[15], cons(y[15], zs[15]))_>=_IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on isdiv(x[15], y[15])=TRUE which results in the following new constraints:

(3)    (Cond_isdiv(>(x30, 0), x30, 0)=TRUE  ==>  FILTER(x30, cons(0, zs[15]))_>=_NonInfC & FILTER(x30, cons(0, zs[15]))_>=_IF_1(isdiv(x30, 0), x30, 0, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))

(4)    (Cond_isdiv1(&&(>(x32, x31), >(x31, 0)), x32, x31)=TRUE  ==>  FILTER(x32, cons(x31, zs[15]))_>=_NonInfC & FILTER(x32, cons(x31, zs[15]))_>=_IF_1(isdiv(x32, x31), x32, x31, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))

(5)    (Cond_isdiv2(&&(>=(x33, x34), >(x34, 0)), x34, x33)=TRUE  ==>  FILTER(x34, cons(x33, zs[15]))_>=_NonInfC & FILTER(x34, cons(x33, zs[15]))_>=_IF_1(isdiv(x34, x33), x34, x33, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))

(6)    (Cond_isdiv3(>(0, x35), x36, x35)=TRUE  ==>  FILTER(x36, cons(x35, zs[15]))_>=_NonInfC & FILTER(x36, cons(x35, zs[15]))_>=_IF_1(isdiv(x36, x35), x36, x35, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))

(7)    (Cond_isdiv4(>(0, x38), x38, x37)=TRUE  ==>  FILTER(x38, cons(x37, zs[15]))_>=_NonInfC & FILTER(x38, cons(x37, zs[15]))_>=_IF_1(isdiv(x38, x37), x38, x37, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (3) using rules (III), (VII) which results in the following new constraint:

(8)    (Cond_isdiv(>(x30, 0), x30, 0)=TRUE  ==>  FILTER(x30, cons(0, zs[15]))_>=_NonInfC & FILTER(x30, cons(0, zs[15]))_>=_IF_1(isdiv(x30, 0), x30, 0, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (4) using rules (III), (VII) which results in the following new constraint:

(9)    (Cond_isdiv1(&&(>(x32, x31), >(x31, 0)), x32, x31)=TRUE  ==>  FILTER(x32, cons(x31, zs[15]))_>=_NonInfC & FILTER(x32, cons(x31, zs[15]))_>=_IF_1(isdiv(x32, x31), x32, x31, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (5) using rules (III), (VII) which results in the following new constraint:

(10)    (Cond_isdiv2(&&(>=(x33, x34), >(x34, 0)), x34, x33)=TRUE  ==>  FILTER(x34, cons(x33, zs[15]))_>=_NonInfC & FILTER(x34, cons(x33, zs[15]))_>=_IF_1(isdiv(x34, x33), x34, x33, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (6) using rules (III), (VII) which results in the following new constraint:

(11)    (Cond_isdiv3(>(0, x35), x36, x35)=TRUE  ==>  FILTER(x36, cons(x35, zs[15]))_>=_NonInfC & FILTER(x36, cons(x35, zs[15]))_>=_IF_1(isdiv(x36, x35), x36, x35, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (7) using rules (III), (VII) which results in the following new constraint:

(12)    (Cond_isdiv4(>(0, x38), x38, x37)=TRUE  ==>  FILTER(x38, cons(x37, zs[15]))_>=_NonInfC & FILTER(x38, cons(x37, zs[15]))_>=_IF_1(isdiv(x38, x37), x38, x37, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (8) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(13)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [bni_46]x30 >= 0 & [5 + (-1)bso_47] + [4]zs[15] >= 0)



We simplified constraint (9) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(14)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x31 + [bni_46]x32 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x31 >= 0)



We simplified constraint (10) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(15)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x33 + [bni_46]x34 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x33 >= 0)



We simplified constraint (11) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(16)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x35 + [bni_46]x36 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x35 >= 0)



We simplified constraint (12) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(17)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x37 + [bni_46]x38 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x37 >= 0)



We simplified constraint (14) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(18)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x31 + [bni_46]x32 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x31 >= 0)



We simplified constraint (15) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(19)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x33 + [bni_46]x34 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x33 >= 0)



We simplified constraint (16) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(20)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x35 + [bni_46]x36 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x35 >= 0)



We simplified constraint (17) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(21)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x37 + [bni_46]x38 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x37 >= 0)



We simplified constraint (13) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(22)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [bni_46]x30 >= 0 & [5 + (-1)bso_47] + [4]zs[15] >= 0)



We simplified constraint (18) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(23)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x31 + [bni_46]x32 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x31 >= 0)



We simplified constraint (19) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(24)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x33 + [bni_46]x34 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x33 >= 0)



We simplified constraint (20) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(25)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x35 + [bni_46]x36 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x35 >= 0)



We simplified constraint (21) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(26)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x37 + [bni_46]x38 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x37 >= 0)



We simplified constraint (22) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(27)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [bni_46]x30 >= 0 & [5 + (-1)bso_47] + [4]zs[15] >= 0)



We simplified constraint (23) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(28)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (24) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(29)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (25) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(30)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (26) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(31)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (27) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(32)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0)




*We consider the chain IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19]), FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15]), IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17]) which results in the following constraint:

(1)    (x[19]=x[15] & zs[19]=cons(y[15], zs[15]) & isdiv(x[15], y[15])=TRUE & x[15]=x[17] & y[15]=y[17] & zs[15]=zs[17]  ==>  FILTER(x[15], cons(y[15], zs[15]))_>=_NonInfC & FILTER(x[15], cons(y[15], zs[15]))_>=_IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (isdiv(x[15], y[15])=TRUE  ==>  FILTER(x[15], cons(y[15], zs[15]))_>=_NonInfC & FILTER(x[15], cons(y[15], zs[15]))_>=_IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on isdiv(x[15], y[15])=TRUE which results in the following new constraints:

(3)    (Cond_isdiv(>(x45, 0), x45, 0)=TRUE  ==>  FILTER(x45, cons(0, zs[15]))_>=_NonInfC & FILTER(x45, cons(0, zs[15]))_>=_IF_1(isdiv(x45, 0), x45, 0, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))

(4)    (Cond_isdiv1(&&(>(x47, x46), >(x46, 0)), x47, x46)=TRUE  ==>  FILTER(x47, cons(x46, zs[15]))_>=_NonInfC & FILTER(x47, cons(x46, zs[15]))_>=_IF_1(isdiv(x47, x46), x47, x46, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))

(5)    (Cond_isdiv2(&&(>=(x48, x49), >(x49, 0)), x49, x48)=TRUE  ==>  FILTER(x49, cons(x48, zs[15]))_>=_NonInfC & FILTER(x49, cons(x48, zs[15]))_>=_IF_1(isdiv(x49, x48), x49, x48, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))

(6)    (Cond_isdiv3(>(0, x50), x51, x50)=TRUE  ==>  FILTER(x51, cons(x50, zs[15]))_>=_NonInfC & FILTER(x51, cons(x50, zs[15]))_>=_IF_1(isdiv(x51, x50), x51, x50, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))

(7)    (Cond_isdiv4(>(0, x53), x53, x52)=TRUE  ==>  FILTER(x53, cons(x52, zs[15]))_>=_NonInfC & FILTER(x53, cons(x52, zs[15]))_>=_IF_1(isdiv(x53, x52), x53, x52, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (3) using rules (III), (VII) which results in the following new constraint:

(8)    (Cond_isdiv(>(x45, 0), x45, 0)=TRUE  ==>  FILTER(x45, cons(0, zs[15]))_>=_NonInfC & FILTER(x45, cons(0, zs[15]))_>=_IF_1(isdiv(x45, 0), x45, 0, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (4) using rules (III), (VII) which results in the following new constraint:

(9)    (Cond_isdiv1(&&(>(x47, x46), >(x46, 0)), x47, x46)=TRUE  ==>  FILTER(x47, cons(x46, zs[15]))_>=_NonInfC & FILTER(x47, cons(x46, zs[15]))_>=_IF_1(isdiv(x47, x46), x47, x46, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (5) using rules (III), (VII) which results in the following new constraint:

(10)    (Cond_isdiv2(&&(>=(x48, x49), >(x49, 0)), x49, x48)=TRUE  ==>  FILTER(x49, cons(x48, zs[15]))_>=_NonInfC & FILTER(x49, cons(x48, zs[15]))_>=_IF_1(isdiv(x49, x48), x49, x48, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (6) using rules (III), (VII) which results in the following new constraint:

(11)    (Cond_isdiv3(>(0, x50), x51, x50)=TRUE  ==>  FILTER(x51, cons(x50, zs[15]))_>=_NonInfC & FILTER(x51, cons(x50, zs[15]))_>=_IF_1(isdiv(x51, x50), x51, x50, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (7) using rules (III), (VII) which results in the following new constraint:

(12)    (Cond_isdiv4(>(0, x53), x53, x52)=TRUE  ==>  FILTER(x53, cons(x52, zs[15]))_>=_NonInfC & FILTER(x53, cons(x52, zs[15]))_>=_IF_1(isdiv(x53, x52), x53, x52, zs[15]) & (U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=))



We simplified constraint (8) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(13)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [bni_46]x45 >= 0 & [5 + (-1)bso_47] + [4]zs[15] >= 0)



We simplified constraint (9) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(14)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x46 + [bni_46]x47 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x46 >= 0)



We simplified constraint (10) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(15)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x48 + [bni_46]x49 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x48 >= 0)



We simplified constraint (11) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(16)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x50 + [bni_46]x51 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x50 >= 0)



We simplified constraint (12) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(17)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x52 + [bni_46]x53 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x52 >= 0)



We simplified constraint (14) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(18)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x46 + [bni_46]x47 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x46 >= 0)



We simplified constraint (15) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(19)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x48 + [bni_46]x49 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x48 >= 0)



We simplified constraint (16) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(20)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x50 + [bni_46]x51 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x50 >= 0)



We simplified constraint (17) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(21)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x52 + [bni_46]x53 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x52 >= 0)



We simplified constraint (13) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(22)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [bni_46]x45 >= 0 & [5 + (-1)bso_47] + [4]zs[15] >= 0)



We simplified constraint (18) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(23)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x46 + [bni_46]x47 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x46 >= 0)



We simplified constraint (19) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(24)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x48 + [bni_46]x49 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x48 >= 0)



We simplified constraint (20) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(25)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x50 + [bni_46]x51 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x50 >= 0)



We simplified constraint (21) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(26)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [(6)bni_46]x52 + [bni_46]x53 >= 0 & [5 + (-1)bso_47] + [4]zs[15] + [6]x52 >= 0)



We simplified constraint (22) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(27)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(5)bni_46 + (-1)Bound*bni_46] + [(6)bni_46]zs[15] + [bni_46]x45 >= 0 & [5 + (-1)bso_47] + [4]zs[15] >= 0)



We simplified constraint (23) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(28)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (24) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(29)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (25) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(30)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (26) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(31)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)



We simplified constraint (27) using rules (IDP_UNRESTRICTED_VARS), (IDP_POLY_GCD) which results in the following new constraint:

(32)    ((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0)








To summarize, we get the following constraints P__>=_ for the following pairs.

*IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19])

*((U^Increasing(FILTER(x[19], zs[19])), >=) & [bni_40] = 0 & 0 >= 0 & [1 + (-1)bso_41] >= 0)


*((U^Increasing(FILTER(x[19], zs[19])), >=) & [bni_40] = 0 & 0 >= 0 & [1 + (-1)bso_41] >= 0)




*FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])

*((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0)


*((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])), >=) & [(6)bni_42] >= 0 & [bni_42] >= 0 & [(5)bni_42 + (-1)Bound*bni_42] >= 0 & [5 + (-1)bso_43] >= 0 & [1] >= 0)




*IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17])

*((U^Increasing(FILTER(x[17], zs[17])), >=) & [bni_44] = 0 & 0 >= 0 & [1 + (-1)bso_45] >= 0)


*((U^Increasing(FILTER(x[17], zs[17])), >=) & [bni_44] = 0 & 0 >= 0 & [1 + (-1)bso_45] >= 0)




*FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])

*((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0)


*((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0 & [1] >= 0)


*((U^Increasing(IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])), >=) & [(6)bni_46] >= 0 & [bni_46] >= 0 & [(5)bni_46 + (-1)Bound*bni_46] >= 0 & [5 + (-1)bso_47] >= 0 & [1] >= 0)








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation over integers with natural coefficients for non-tuple symbols [NONINF][POLO]:

   POL(TRUE) = 0
   POL(FALSE) = 0
   POL(isdiv(x_1, x_2)) = 0
   POL(0) = 0
   POL(Cond_isdiv(x_1, x_2, x_3)) = 0
   POL(>(x_1, x_2)) = 0
   POL(Cond_isdiv1(x_1, x_2, x_3)) = 0
   POL(&&(x_1, x_2)) = 0
   POL(Cond_isdiv2(x_1, x_2, x_3)) = [3]x_1
   POL(>=(x_1, x_2)) = 0
   POL(+(x_1, x_2)) = 0
   POL(-(x_1)) = 0
   POL(Cond_isdiv3(x_1, x_2, x_3)) = 0
   POL(Cond_isdiv4(x_1, x_2, x_3)) = 0
   POL(IF_2(x_1, x_2, x_3, x_4)) = [2]x_4 + x_2 + [-1]x_1
   POL(FILTER(x_1, x_2)) = [-1] + [2]x_2 + x_1
   POL(cons(x_1, x_2)) = [3] + [3]x_2 + [3]x_1
   POL(IF_1(x_1, x_2, x_3, x_4)) = [2]x_4 + x_2 + [-1]x_1


The following pairs are in P_>:


   IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19])
   FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])
   IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17])
   FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])


The following pairs are in P_bound:


   FILTER(x[18], cons(y[18], zs[18])) -> IF_2(isdiv(x[18], y[18]), x[18], y[18], zs[18])
   FILTER(x[15], cons(y[15], zs[15])) -> IF_1(isdiv(x[15], y[15]), x[15], y[15], zs[15])


The following pairs are in P_>=:

none


At least the following rules have been oriented under context sensitive arithmetic replacement:

   isdiv(x, 0)^1 <-> Cond_isdiv(>(x, 0), x, 0)^1
   isdiv(x, y)^1 <-> Cond_isdiv1(&&(>(x, y), >(y, 0)), x, y)^1
   isdiv(x, y)^1 <-> Cond_isdiv2(&&(>=(y, x), >(x, 0)), x, y)^1
   Cond_isdiv2(TRUE, x, y)^1 <-> isdiv(x, +(-(x), y))^1
   isdiv(x, y)^1 <-> Cond_isdiv3(>(0, y), x, y)^1
   Cond_isdiv3(TRUE, x, y)^1 <-> isdiv(x, -(y))^1
   isdiv(x, y)^1 <-> Cond_isdiv4(>(0, x), x, y)^1
   Cond_isdiv4(TRUE, x, y)^1 <-> isdiv(-(x), y)^1
   &&(TRUE, TRUE)^1 <-> TRUE^1
   &&(TRUE, FALSE)^1 <-> FALSE^1
   &&(FALSE, TRUE)^1 <-> FALSE^1
   &&(FALSE, FALSE)^1 <-> FALSE^1
   Cond_isdiv(TRUE, x, 0)^1 <-> TRUE^1
   Cond_isdiv1(TRUE, x, y)^1 <-> FALSE^1

----------------------------------------

(35)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

The ITRS R consists of the following rules:
isdiv(x, 0) -> Cond_isdiv(x > 0, x, 0)
isdiv(x, y) -> Cond_isdiv1(x > y && y > 0, x, y)
isdiv(x, y) -> Cond_isdiv2(y >= x && x > 0, x, y)
Cond_isdiv2(TRUE, x, y) -> isdiv(x, -(x) + y)
isdiv(x, y) -> Cond_isdiv3(0 > y, x, y)
Cond_isdiv3(TRUE, x, y) -> isdiv(x, -(y))
isdiv(x, y) -> Cond_isdiv4(0 > x, x, y)
Cond_isdiv4(TRUE, x, y) -> isdiv(-(x), y)
Cond_isdiv(TRUE, x, 0) -> TRUE
Cond_isdiv1(TRUE, x, y) -> FALSE

The integer pair graph contains the following rules and edges:
(19): IF_2(FALSE, x[19], y[19], zs[19]) -> FILTER(x[19], zs[19])
(17): IF_1(TRUE, x[17], y[17], zs[17]) -> FILTER(x[17], zs[17])


The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(36) IDependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 2 less nodes.
----------------------------------------

(37)
TRUE

----------------------------------------

(38)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

The ITRS R consists of the following rules:
primes(x) -> sieve(nats(2, x))
nats(x, y) -> Cond_nats(x > y, x, y)
nats(x, y) -> Cond_nats1(x = y, x, y)
nats(x, y) -> Cond_nats2(y > x, x, y)
filter(x, nil) -> nil
filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)
if_1(TRUE, x, y, zs) -> filter(x, zs)
filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
isdiv(x, 0) -> Cond_isdiv(x > 0, x, 0)
isdiv(x, y) -> Cond_isdiv1(x > y && y > 0, x, y)
isdiv(x, y) -> Cond_isdiv2(y >= x && x > 0, x, y)
Cond_isdiv2(TRUE, x, y) -> isdiv(x, -(x) + y)
isdiv(x, y) -> Cond_isdiv3(0 > y, x, y)
Cond_isdiv3(TRUE, x, y) -> isdiv(x, -(y))
isdiv(x, y) -> Cond_isdiv4(0 > x, x, y)
Cond_isdiv4(TRUE, x, y) -> isdiv(-(x), y)
sieve(nil) -> nil
sieve(cons(x, ys)) -> cons(x, sieve(filter(x, ys)))
Cond_nats2(TRUE, x, y) -> cons(x, nats(x + 1, y))
Cond_nats(TRUE, x, y) -> nil
Cond_nats1(TRUE, x, y) -> cons(x, nil)
if_2(FALSE, x, y, zs) -> cons(x, filter(x, zs))
Cond_isdiv(TRUE, x, 0) -> TRUE
Cond_isdiv1(TRUE, x, y) -> FALSE

The integer pair graph contains the following rules and edges:
(13): SIEVE(cons(x[13], ys[13])) -> SIEVE(filter(x[13], ys[13]))

   (13) -> (13), if (filter(x[13], ys[13]) ->^* cons(x[13]', ys[13]'))

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(39) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(40)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

The ITRS R consists of the following rules:
filter(x, nil) -> nil
filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)
if_1(TRUE, x, y, zs) -> filter(x, zs)
filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
if_2(FALSE, x, y, zs) -> cons(x, filter(x, zs))
isdiv(x, 0) -> Cond_isdiv(x > 0, x, 0)
isdiv(x, y) -> Cond_isdiv1(x > y && y > 0, x, y)
isdiv(x, y) -> Cond_isdiv2(y >= x && x > 0, x, y)
Cond_isdiv2(TRUE, x, y) -> isdiv(x, -(x) + y)
isdiv(x, y) -> Cond_isdiv3(0 > y, x, y)
Cond_isdiv3(TRUE, x, y) -> isdiv(x, -(y))
isdiv(x, y) -> Cond_isdiv4(0 > x, x, y)
Cond_isdiv4(TRUE, x, y) -> isdiv(-(x), y)
Cond_isdiv(TRUE, x, 0) -> TRUE
Cond_isdiv1(TRUE, x, y) -> FALSE

The integer pair graph contains the following rules and edges:
(13): SIEVE(cons(x[13], ys[13])) -> SIEVE(filter(x[13], ys[13]))

   (13) -> (13), if (filter(x[13], ys[13]) ->^* cons(x[13]', ys[13]'))

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(41) IDPtoQDPProof (SOUND)
Represented integers and predefined function symbols by Terms
----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SIEVE(cons(x[13], ys[13])) -> SIEVE(filter(x[13], ys[13]))

The TRS R consists of the following rules:

   filter(x, nil) -> nil
   filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)
   if_1(true, x, y, zs) -> filter(x, zs)
   filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
   if_2(false, x, y, zs) -> cons(x, filter(x, zs))
   isdiv(x, pos(01)) -> Cond_isdiv(greater_int(x, pos(01)), x, pos(01))
   isdiv(x, y) -> Cond_isdiv1(and(greater_int(x, y), greater_int(y, pos(01))), x, y)
   isdiv(x, y) -> Cond_isdiv2(and(greatereq_int(y, x), greater_int(x, pos(01))), x, y)
   Cond_isdiv2(true, x, y) -> isdiv(x, plus_int(neg_int(x), y))
   isdiv(x, y) -> Cond_isdiv3(greater_int(pos(01), y), x, y)
   Cond_isdiv3(true, x, y) -> isdiv(x, neg_int(y))
   isdiv(x, y) -> Cond_isdiv4(greater_int(pos(01), x), x, y)
   Cond_isdiv4(true, x, y) -> isdiv(neg_int(x), y)
   Cond_isdiv(true, x, pos(01)) -> true
   Cond_isdiv1(true, x, y) -> false
   greater_int(pos(01), pos(01)) -> false
   greater_int(pos(01), neg(01)) -> false
   greater_int(neg(01), pos(01)) -> false
   greater_int(neg(01), neg(01)) -> false
   greater_int(pos(01), pos(s(y))) -> false
   greater_int(neg(01), pos(s(y))) -> false
   greater_int(pos(01), neg(s(y))) -> true
   greater_int(neg(01), neg(s(y))) -> true
   greater_int(pos(s(x)), pos(01)) -> true
   greater_int(neg(s(x)), pos(01)) -> false
   greater_int(pos(s(x)), neg(01)) -> true
   greater_int(neg(s(x)), neg(01)) -> false
   greater_int(pos(s(x)), neg(s(y))) -> true
   greater_int(neg(s(x)), pos(s(y))) -> false
   greater_int(pos(s(x)), pos(s(y))) -> greater_int(pos(x), pos(y))
   greater_int(neg(s(x)), neg(s(y))) -> greater_int(neg(x), neg(y))
   and(false, false) -> false
   and(false, true) -> false
   and(true, false) -> false
   and(true, true) -> true
   greatereq_int(pos(x), pos(01)) -> true
   greatereq_int(neg(01), pos(01)) -> true
   greatereq_int(neg(01), neg(y)) -> true
   greatereq_int(pos(x), neg(y)) -> true
   greatereq_int(pos(01), pos(s(y))) -> false
   greatereq_int(neg(x), pos(s(y))) -> false
   greatereq_int(neg(s(x)), pos(01)) -> false
   greatereq_int(neg(s(x)), neg(01)) -> false
   greatereq_int(pos(s(x)), pos(s(y))) -> greatereq_int(pos(x), pos(y))
   greatereq_int(neg(s(x)), neg(s(y))) -> greatereq_int(neg(x), neg(y))
   plus_int(pos(x), neg(y)) -> minus_nat(x, y)
   plus_int(neg(x), pos(y)) -> minus_nat(y, x)
   plus_int(neg(x), neg(y)) -> neg(plus_nat(x, y))
   plus_int(pos(x), pos(y)) -> pos(plus_nat(x, y))
   plus_nat(01, x) -> x
   plus_nat(s(x), y) -> s(plus_nat(x, y))
   minus_nat(01, 01) -> pos(01)
   minus_nat(01, s(y)) -> neg(s(y))
   minus_nat(s(x), 01) -> pos(s(x))
   minus_nat(s(x), s(y)) -> minus_nat(x, y)
   neg_int(pos(x)) -> neg(x)
   neg_int(neg(x)) -> pos(x)

The set Q consists of the following terms:

   isprime(x0)
   mem(x0, nil)
   mem(x0, cons(x1, x2))
   Cond_mem(true, x0, cons(x1, x2))
   Cond_mem1(true, x0, cons(x1, x2))
   Cond_mem2(true, x0, cons(x1, x2))
   primes(x0)
   nats(x0, x1)
   Cond_nats(true, x0, x1)
   Cond_nats1(true, x0, x1)
   Cond_nats2(true, x0, x1)
   sieve(nil)
   sieve(cons(x0, x1))
   filter(x0, nil)
   filter(x0, cons(x1, x2))
   if_1(true, x0, x1, x2)
   if_2(false, x0, x1, x2)
   Cond_isdiv(true, x0, pos(01))
   isdiv(x0, x1)
   Cond_isdiv1(true, x0, x1)
   Cond_isdiv2(true, x0, x1)
   Cond_isdiv3(true, x0, x1)
   Cond_isdiv4(true, x0, x1)
   greater_int(pos(01), pos(01))
   greater_int(pos(01), neg(01))
   greater_int(neg(01), pos(01))
   greater_int(neg(01), neg(01))
   greater_int(pos(01), pos(s(x0)))
   greater_int(neg(01), pos(s(x0)))
   greater_int(pos(01), neg(s(x0)))
   greater_int(neg(01), neg(s(x0)))
   greater_int(pos(s(x0)), pos(01))
   greater_int(neg(s(x0)), pos(01))
   greater_int(pos(s(x0)), neg(01))
   greater_int(neg(s(x0)), neg(01))
   greater_int(pos(s(x0)), neg(s(x1)))
   greater_int(neg(s(x0)), pos(s(x1)))
   greater_int(pos(s(x0)), pos(s(x1)))
   greater_int(neg(s(x0)), neg(s(x1)))
   and(false, false)
   and(false, true)
   and(true, false)
   and(true, true)
   greatereq_int(pos(x0), pos(01))
   greatereq_int(neg(01), pos(01))
   greatereq_int(neg(01), neg(x0))
   greatereq_int(pos(x0), neg(x1))
   greatereq_int(pos(01), pos(s(x0)))
   greatereq_int(neg(x0), pos(s(x1)))
   greatereq_int(neg(s(x0)), pos(01))
   greatereq_int(neg(s(x0)), neg(01))
   greatereq_int(pos(s(x0)), pos(s(x1)))
   greatereq_int(neg(s(x0)), neg(s(x1)))
   plus_int(pos(x0), neg(x1))
   plus_int(neg(x0), pos(x1))
   plus_int(neg(x0), neg(x1))
   plus_int(pos(x0), pos(x1))
   plus_nat(01, x0)
   plus_nat(s(x0), x1)
   minus_nat(01, 01)
   minus_nat(01, s(x0))
   minus_nat(s(x0), 01)
   minus_nat(s(x0), s(x1))
   neg_int(pos(x0))
   neg_int(neg(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(43) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   isprime(x0)
   mem(x0, nil)
   mem(x0, cons(x1, x2))
   Cond_mem(true, x0, cons(x1, x2))
   Cond_mem1(true, x0, cons(x1, x2))
   Cond_mem2(true, x0, cons(x1, x2))
   primes(x0)
   nats(x0, x1)
   Cond_nats(true, x0, x1)
   Cond_nats1(true, x0, x1)
   Cond_nats2(true, x0, x1)
   sieve(nil)
   sieve(cons(x0, x1))


----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SIEVE(cons(x[13], ys[13])) -> SIEVE(filter(x[13], ys[13]))

The TRS R consists of the following rules:

   filter(x, nil) -> nil
   filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)
   if_1(true, x, y, zs) -> filter(x, zs)
   filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
   if_2(false, x, y, zs) -> cons(x, filter(x, zs))
   isdiv(x, pos(01)) -> Cond_isdiv(greater_int(x, pos(01)), x, pos(01))
   isdiv(x, y) -> Cond_isdiv1(and(greater_int(x, y), greater_int(y, pos(01))), x, y)
   isdiv(x, y) -> Cond_isdiv2(and(greatereq_int(y, x), greater_int(x, pos(01))), x, y)
   Cond_isdiv2(true, x, y) -> isdiv(x, plus_int(neg_int(x), y))
   isdiv(x, y) -> Cond_isdiv3(greater_int(pos(01), y), x, y)
   Cond_isdiv3(true, x, y) -> isdiv(x, neg_int(y))
   isdiv(x, y) -> Cond_isdiv4(greater_int(pos(01), x), x, y)
   Cond_isdiv4(true, x, y) -> isdiv(neg_int(x), y)
   Cond_isdiv(true, x, pos(01)) -> true
   Cond_isdiv1(true, x, y) -> false
   greater_int(pos(01), pos(01)) -> false
   greater_int(pos(01), neg(01)) -> false
   greater_int(neg(01), pos(01)) -> false
   greater_int(neg(01), neg(01)) -> false
   greater_int(pos(01), pos(s(y))) -> false
   greater_int(neg(01), pos(s(y))) -> false
   greater_int(pos(01), neg(s(y))) -> true
   greater_int(neg(01), neg(s(y))) -> true
   greater_int(pos(s(x)), pos(01)) -> true
   greater_int(neg(s(x)), pos(01)) -> false
   greater_int(pos(s(x)), neg(01)) -> true
   greater_int(neg(s(x)), neg(01)) -> false
   greater_int(pos(s(x)), neg(s(y))) -> true
   greater_int(neg(s(x)), pos(s(y))) -> false
   greater_int(pos(s(x)), pos(s(y))) -> greater_int(pos(x), pos(y))
   greater_int(neg(s(x)), neg(s(y))) -> greater_int(neg(x), neg(y))
   and(false, false) -> false
   and(false, true) -> false
   and(true, false) -> false
   and(true, true) -> true
   greatereq_int(pos(x), pos(01)) -> true
   greatereq_int(neg(01), pos(01)) -> true
   greatereq_int(neg(01), neg(y)) -> true
   greatereq_int(pos(x), neg(y)) -> true
   greatereq_int(pos(01), pos(s(y))) -> false
   greatereq_int(neg(x), pos(s(y))) -> false
   greatereq_int(neg(s(x)), pos(01)) -> false
   greatereq_int(neg(s(x)), neg(01)) -> false
   greatereq_int(pos(s(x)), pos(s(y))) -> greatereq_int(pos(x), pos(y))
   greatereq_int(neg(s(x)), neg(s(y))) -> greatereq_int(neg(x), neg(y))
   plus_int(pos(x), neg(y)) -> minus_nat(x, y)
   plus_int(neg(x), pos(y)) -> minus_nat(y, x)
   plus_int(neg(x), neg(y)) -> neg(plus_nat(x, y))
   plus_int(pos(x), pos(y)) -> pos(plus_nat(x, y))
   plus_nat(01, x) -> x
   plus_nat(s(x), y) -> s(plus_nat(x, y))
   minus_nat(01, 01) -> pos(01)
   minus_nat(01, s(y)) -> neg(s(y))
   minus_nat(s(x), 01) -> pos(s(x))
   minus_nat(s(x), s(y)) -> minus_nat(x, y)
   neg_int(pos(x)) -> neg(x)
   neg_int(neg(x)) -> pos(x)

The set Q consists of the following terms:

   filter(x0, nil)
   filter(x0, cons(x1, x2))
   if_1(true, x0, x1, x2)
   if_2(false, x0, x1, x2)
   Cond_isdiv(true, x0, pos(01))
   isdiv(x0, x1)
   Cond_isdiv1(true, x0, x1)
   Cond_isdiv2(true, x0, x1)
   Cond_isdiv3(true, x0, x1)
   Cond_isdiv4(true, x0, x1)
   greater_int(pos(01), pos(01))
   greater_int(pos(01), neg(01))
   greater_int(neg(01), pos(01))
   greater_int(neg(01), neg(01))
   greater_int(pos(01), pos(s(x0)))
   greater_int(neg(01), pos(s(x0)))
   greater_int(pos(01), neg(s(x0)))
   greater_int(neg(01), neg(s(x0)))
   greater_int(pos(s(x0)), pos(01))
   greater_int(neg(s(x0)), pos(01))
   greater_int(pos(s(x0)), neg(01))
   greater_int(neg(s(x0)), neg(01))
   greater_int(pos(s(x0)), neg(s(x1)))
   greater_int(neg(s(x0)), pos(s(x1)))
   greater_int(pos(s(x0)), pos(s(x1)))
   greater_int(neg(s(x0)), neg(s(x1)))
   and(false, false)
   and(false, true)
   and(true, false)
   and(true, true)
   greatereq_int(pos(x0), pos(01))
   greatereq_int(neg(01), pos(01))
   greatereq_int(neg(01), neg(x0))
   greatereq_int(pos(x0), neg(x1))
   greatereq_int(pos(01), pos(s(x0)))
   greatereq_int(neg(x0), pos(s(x1)))
   greatereq_int(neg(s(x0)), pos(01))
   greatereq_int(neg(s(x0)), neg(01))
   greatereq_int(pos(s(x0)), pos(s(x1)))
   greatereq_int(neg(s(x0)), neg(s(x1)))
   plus_int(pos(x0), neg(x1))
   plus_int(neg(x0), pos(x1))
   plus_int(neg(x0), neg(x1))
   plus_int(pos(x0), pos(x1))
   plus_nat(01, x0)
   plus_nat(s(x0), x1)
   minus_nat(01, 01)
   minus_nat(01, s(x0))
   minus_nat(s(x0), 01)
   minus_nat(s(x0), s(x1))
   neg_int(pos(x0))
   neg_int(neg(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(45) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   SIEVE(cons(x[13], ys[13])) -> SIEVE(filter(x[13], ys[13]))

Strictly oriented rules of the TRS R:

   filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)

Used ordering: Polynomial interpretation [POLO]:

   POL(01) = 0
   POL(Cond_isdiv(x_1, x_2, x_3)) = 0
   POL(Cond_isdiv1(x_1, x_2, x_3)) = 0
   POL(Cond_isdiv2(x_1, x_2, x_3)) = 0
   POL(Cond_isdiv3(x_1, x_2, x_3)) = 0
   POL(Cond_isdiv4(x_1, x_2, x_3)) = 0
   POL(SIEVE(x_1)) = x_1
   POL(and(x_1, x_2)) = 0
   POL(cons(x_1, x_2)) = 1 + 2*x_2
   POL(false) = 0
   POL(filter(x_1, x_2)) = x_2
   POL(greater_int(x_1, x_2)) = 0
   POL(greatereq_int(x_1, x_2)) = 0
   POL(if_1(x_1, x_2, x_3, x_4)) = x_4
   POL(if_2(x_1, x_2, x_3, x_4)) = 1 + 2*x_4
   POL(isdiv(x_1, x_2)) = 0
   POL(minus_nat(x_1, x_2)) = 0
   POL(neg(x_1)) = 0
   POL(neg_int(x_1)) = 0
   POL(nil) = 0
   POL(plus_int(x_1, x_2)) = 0
   POL(plus_nat(x_1, x_2)) = 2*x_2
   POL(pos(x_1)) = 0
   POL(s(x_1)) = 0
   POL(true) = 0


----------------------------------------

(46)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   filter(x, nil) -> nil
   if_1(true, x, y, zs) -> filter(x, zs)
   filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
   if_2(false, x, y, zs) -> cons(x, filter(x, zs))
   isdiv(x, pos(01)) -> Cond_isdiv(greater_int(x, pos(01)), x, pos(01))
   isdiv(x, y) -> Cond_isdiv1(and(greater_int(x, y), greater_int(y, pos(01))), x, y)
   isdiv(x, y) -> Cond_isdiv2(and(greatereq_int(y, x), greater_int(x, pos(01))), x, y)
   Cond_isdiv2(true, x, y) -> isdiv(x, plus_int(neg_int(x), y))
   isdiv(x, y) -> Cond_isdiv3(greater_int(pos(01), y), x, y)
   Cond_isdiv3(true, x, y) -> isdiv(x, neg_int(y))
   isdiv(x, y) -> Cond_isdiv4(greater_int(pos(01), x), x, y)
   Cond_isdiv4(true, x, y) -> isdiv(neg_int(x), y)
   Cond_isdiv(true, x, pos(01)) -> true
   Cond_isdiv1(true, x, y) -> false
   greater_int(pos(01), pos(01)) -> false
   greater_int(pos(01), neg(01)) -> false
   greater_int(neg(01), pos(01)) -> false
   greater_int(neg(01), neg(01)) -> false
   greater_int(pos(01), pos(s(y))) -> false
   greater_int(neg(01), pos(s(y))) -> false
   greater_int(pos(01), neg(s(y))) -> true
   greater_int(neg(01), neg(s(y))) -> true
   greater_int(pos(s(x)), pos(01)) -> true
   greater_int(neg(s(x)), pos(01)) -> false
   greater_int(pos(s(x)), neg(01)) -> true
   greater_int(neg(s(x)), neg(01)) -> false
   greater_int(pos(s(x)), neg(s(y))) -> true
   greater_int(neg(s(x)), pos(s(y))) -> false
   greater_int(pos(s(x)), pos(s(y))) -> greater_int(pos(x), pos(y))
   greater_int(neg(s(x)), neg(s(y))) -> greater_int(neg(x), neg(y))
   and(false, false) -> false
   and(false, true) -> false
   and(true, false) -> false
   and(true, true) -> true
   greatereq_int(pos(x), pos(01)) -> true
   greatereq_int(neg(01), pos(01)) -> true
   greatereq_int(neg(01), neg(y)) -> true
   greatereq_int(pos(x), neg(y)) -> true
   greatereq_int(pos(01), pos(s(y))) -> false
   greatereq_int(neg(x), pos(s(y))) -> false
   greatereq_int(neg(s(x)), pos(01)) -> false
   greatereq_int(neg(s(x)), neg(01)) -> false
   greatereq_int(pos(s(x)), pos(s(y))) -> greatereq_int(pos(x), pos(y))
   greatereq_int(neg(s(x)), neg(s(y))) -> greatereq_int(neg(x), neg(y))
   plus_int(pos(x), neg(y)) -> minus_nat(x, y)
   plus_int(neg(x), pos(y)) -> minus_nat(y, x)
   plus_int(neg(x), neg(y)) -> neg(plus_nat(x, y))
   plus_int(pos(x), pos(y)) -> pos(plus_nat(x, y))
   plus_nat(01, x) -> x
   plus_nat(s(x), y) -> s(plus_nat(x, y))
   minus_nat(01, 01) -> pos(01)
   minus_nat(01, s(y)) -> neg(s(y))
   minus_nat(s(x), 01) -> pos(s(x))
   minus_nat(s(x), s(y)) -> minus_nat(x, y)
   neg_int(pos(x)) -> neg(x)
   neg_int(neg(x)) -> pos(x)

The set Q consists of the following terms:

   filter(x0, nil)
   filter(x0, cons(x1, x2))
   if_1(true, x0, x1, x2)
   if_2(false, x0, x1, x2)
   Cond_isdiv(true, x0, pos(01))
   isdiv(x0, x1)
   Cond_isdiv1(true, x0, x1)
   Cond_isdiv2(true, x0, x1)
   Cond_isdiv3(true, x0, x1)
   Cond_isdiv4(true, x0, x1)
   greater_int(pos(01), pos(01))
   greater_int(pos(01), neg(01))
   greater_int(neg(01), pos(01))
   greater_int(neg(01), neg(01))
   greater_int(pos(01), pos(s(x0)))
   greater_int(neg(01), pos(s(x0)))
   greater_int(pos(01), neg(s(x0)))
   greater_int(neg(01), neg(s(x0)))
   greater_int(pos(s(x0)), pos(01))
   greater_int(neg(s(x0)), pos(01))
   greater_int(pos(s(x0)), neg(01))
   greater_int(neg(s(x0)), neg(01))
   greater_int(pos(s(x0)), neg(s(x1)))
   greater_int(neg(s(x0)), pos(s(x1)))
   greater_int(pos(s(x0)), pos(s(x1)))
   greater_int(neg(s(x0)), neg(s(x1)))
   and(false, false)
   and(false, true)
   and(true, false)
   and(true, true)
   greatereq_int(pos(x0), pos(01))
   greatereq_int(neg(01), pos(01))
   greatereq_int(neg(01), neg(x0))
   greatereq_int(pos(x0), neg(x1))
   greatereq_int(pos(01), pos(s(x0)))
   greatereq_int(neg(x0), pos(s(x1)))
   greatereq_int(neg(s(x0)), pos(01))
   greatereq_int(neg(s(x0)), neg(01))
   greatereq_int(pos(s(x0)), pos(s(x1)))
   greatereq_int(neg(s(x0)), neg(s(x1)))
   plus_int(pos(x0), neg(x1))
   plus_int(neg(x0), pos(x1))
   plus_int(neg(x0), neg(x1))
   plus_int(pos(x0), pos(x1))
   plus_nat(01, x0)
   plus_nat(s(x0), x1)
   minus_nat(01, 01)
   minus_nat(01, s(x0))
   minus_nat(s(x0), 01)
   minus_nat(s(x0), s(x1))
   neg_int(pos(x0))
   neg_int(neg(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(47) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(48)
YES

----------------------------------------

(49)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer, Boolean

The ITRS R consists of the following rules:
primes(x) -> sieve(nats(2, x))
nats(x, y) -> Cond_nats(x > y, x, y)
nats(x, y) -> Cond_nats1(x = y, x, y)
nats(x, y) -> Cond_nats2(y > x, x, y)
filter(x, nil) -> nil
filter(x, cons(y, zs)) -> if_1(isdiv(x, y), x, y, zs)
if_1(TRUE, x, y, zs) -> filter(x, zs)
filter(x, cons(y, zs)) -> if_2(isdiv(x, y), x, y, zs)
isdiv(x, 0) -> Cond_isdiv(x > 0, x, 0)
isdiv(x, y) -> Cond_isdiv1(x > y && y > 0, x, y)
isdiv(x, y) -> Cond_isdiv2(y >= x && x > 0, x, y)
Cond_isdiv2(TRUE, x, y) -> isdiv(x, -(x) + y)
isdiv(x, y) -> Cond_isdiv3(0 > y, x, y)
Cond_isdiv3(TRUE, x, y) -> isdiv(x, -(y))
isdiv(x, y) -> Cond_isdiv4(0 > x, x, y)
Cond_isdiv4(TRUE, x, y) -> isdiv(-(x), y)
sieve(nil) -> nil
sieve(cons(x, ys)) -> cons(x, sieve(filter(x, ys)))
Cond_nats2(TRUE, x, y) -> cons(x, nats(x + 1, y))
Cond_nats(TRUE, x, y) -> nil
Cond_nats1(TRUE, x, y) -> cons(x, nil)
if_2(FALSE, x, y, zs) -> cons(x, filter(x, zs))
Cond_isdiv(TRUE, x, 0) -> TRUE
Cond_isdiv1(TRUE, x, y) -> FALSE

The integer pair graph contains the following rules and edges:
(12): COND_NATS2(TRUE, x[12], y[12]) -> NATS(x[12] + 1, y[12])
(11): NATS(x[11], y[11]) -> COND_NATS2(y[11] > x[11], x[11], y[11])

   (12) -> (11), if (x[12] + 1 ->^* x[11] & y[12] ->^* y[11])
   (11) -> (12), if (y[11] > x[11]  & x[11] ->^* x[12] & y[11] ->^* y[12])

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(50) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(51)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer

R is empty.

The integer pair graph contains the following rules and edges:
(12): COND_NATS2(TRUE, x[12], y[12]) -> NATS(x[12] + 1, y[12])
(11): NATS(x[11], y[11]) -> COND_NATS2(y[11] > x[11], x[11], y[11])

   (12) -> (11), if (x[12] + 1 ->^* x[11] & y[12] ->^* y[11])
   (11) -> (12), if (y[11] > x[11]  & x[11] ->^* x[12] & y[11] ->^* y[12])

The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(52) IDPNonInfProof (SOUND)
Used the following options for this NonInfProof:

IDPGPoloSolver:
Range: [(-1,2)]
IsNat: false
Interpretation Shape Heuristic: aprove.DPFramework.IDPProblem.Processors.nonInf.poly.IdpDefaultShapeHeuristic@7e5f8ace
Constraint Generator: NonInfConstraintGenerator:
PathGenerator: MetricPathGenerator:
Max Left Steps: 1
Max Right Steps: 1



The constraints were generated the following way:

The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair COND_NATS2(TRUE, x[12], y[12]) -> NATS(+(x[12], 1), y[12]) the following chains were created:
*We consider the chain NATS(x[11], y[11]) -> COND_NATS2(>(y[11], x[11]), x[11], y[11]), COND_NATS2(TRUE, x[12], y[12]) -> NATS(+(x[12], 1), y[12]), NATS(x[11], y[11]) -> COND_NATS2(>(y[11], x[11]), x[11], y[11]) which results in the following constraint:

(1)    (>(y[11], x[11])=TRUE & x[11]=x[12] & y[11]=y[12] & +(x[12], 1)=x[11]1 & y[12]=y[11]1  ==>  COND_NATS2(TRUE, x[12], y[12])_>=_NonInfC & COND_NATS2(TRUE, x[12], y[12])_>=_NATS(+(x[12], 1), y[12]) & (U^Increasing(NATS(+(x[12], 1), y[12])), >=))



We simplified constraint (1) using rules (III), (IV) which results in the following new constraint:

(2)    (>(y[11], x[11])=TRUE  ==>  COND_NATS2(TRUE, x[11], y[11])_>=_NonInfC & COND_NATS2(TRUE, x[11], y[11])_>=_NATS(+(x[11], 1), y[11]) & (U^Increasing(NATS(+(x[12], 1), y[12])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (y[11] + [-1] + [-1]x[11] >= 0  ==>  (U^Increasing(NATS(+(x[12], 1), y[12])), >=) & [(2)bni_11 + (-1)Bound*bni_11] + [bni_11]y[11] + [(-1)bni_11]x[11] >= 0 & [1 + (-1)bso_12] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (y[11] + [-1] + [-1]x[11] >= 0  ==>  (U^Increasing(NATS(+(x[12], 1), y[12])), >=) & [(2)bni_11 + (-1)Bound*bni_11] + [bni_11]y[11] + [(-1)bni_11]x[11] >= 0 & [1 + (-1)bso_12] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (y[11] + [-1] + [-1]x[11] >= 0  ==>  (U^Increasing(NATS(+(x[12], 1), y[12])), >=) & [(2)bni_11 + (-1)Bound*bni_11] + [bni_11]y[11] + [(-1)bni_11]x[11] >= 0 & [1 + (-1)bso_12] >= 0)



We simplified constraint (5) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(6)    (y[11] >= 0  ==>  (U^Increasing(NATS(+(x[12], 1), y[12])), >=) & [(3)bni_11 + (-1)Bound*bni_11] + [bni_11]y[11] >= 0 & [1 + (-1)bso_12] >= 0)



We simplified constraint (6) using rule (IDP_SMT_SPLIT) which results in the following new constraints:

(7)    (y[11] >= 0 & x[11] >= 0  ==>  (U^Increasing(NATS(+(x[12], 1), y[12])), >=) & [(3)bni_11 + (-1)Bound*bni_11] + [bni_11]y[11] >= 0 & [1 + (-1)bso_12] >= 0)

(8)    (y[11] >= 0 & x[11] >= 0  ==>  (U^Increasing(NATS(+(x[12], 1), y[12])), >=) & [(3)bni_11 + (-1)Bound*bni_11] + [bni_11]y[11] >= 0 & [1 + (-1)bso_12] >= 0)








For Pair NATS(x[11], y[11]) -> COND_NATS2(>(y[11], x[11]), x[11], y[11]) the following chains were created:
*We consider the chain NATS(x[11], y[11]) -> COND_NATS2(>(y[11], x[11]), x[11], y[11]), COND_NATS2(TRUE, x[12], y[12]) -> NATS(+(x[12], 1), y[12]) which results in the following constraint:

(1)    (>(y[11], x[11])=TRUE & x[11]=x[12] & y[11]=y[12]  ==>  NATS(x[11], y[11])_>=_NonInfC & NATS(x[11], y[11])_>=_COND_NATS2(>(y[11], x[11]), x[11], y[11]) & (U^Increasing(COND_NATS2(>(y[11], x[11]), x[11], y[11])), >=))



We simplified constraint (1) using rule (IV) which results in the following new constraint:

(2)    (>(y[11], x[11])=TRUE  ==>  NATS(x[11], y[11])_>=_NonInfC & NATS(x[11], y[11])_>=_COND_NATS2(>(y[11], x[11]), x[11], y[11]) & (U^Increasing(COND_NATS2(>(y[11], x[11]), x[11], y[11])), >=))



We simplified constraint (2) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(3)    (y[11] + [-1] + [-1]x[11] >= 0  ==>  (U^Increasing(COND_NATS2(>(y[11], x[11]), x[11], y[11])), >=) & [(2)bni_13 + (-1)Bound*bni_13] + [bni_13]y[11] + [(-1)bni_13]x[11] >= 0 & [(-1)bso_14] >= 0)



We simplified constraint (3) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(4)    (y[11] + [-1] + [-1]x[11] >= 0  ==>  (U^Increasing(COND_NATS2(>(y[11], x[11]), x[11], y[11])), >=) & [(2)bni_13 + (-1)Bound*bni_13] + [bni_13]y[11] + [(-1)bni_13]x[11] >= 0 & [(-1)bso_14] >= 0)



We simplified constraint (4) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(5)    (y[11] + [-1] + [-1]x[11] >= 0  ==>  (U^Increasing(COND_NATS2(>(y[11], x[11]), x[11], y[11])), >=) & [(2)bni_13 + (-1)Bound*bni_13] + [bni_13]y[11] + [(-1)bni_13]x[11] >= 0 & [(-1)bso_14] >= 0)



We simplified constraint (5) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(6)    (y[11] >= 0  ==>  (U^Increasing(COND_NATS2(>(y[11], x[11]), x[11], y[11])), >=) & [(3)bni_13 + (-1)Bound*bni_13] + [bni_13]y[11] >= 0 & [(-1)bso_14] >= 0)



We simplified constraint (6) using rule (IDP_SMT_SPLIT) which results in the following new constraints:

(7)    (y[11] >= 0 & x[11] >= 0  ==>  (U^Increasing(COND_NATS2(>(y[11], x[11]), x[11], y[11])), >=) & [(3)bni_13 + (-1)Bound*bni_13] + [bni_13]y[11] >= 0 & [(-1)bso_14] >= 0)

(8)    (y[11] >= 0 & x[11] >= 0  ==>  (U^Increasing(COND_NATS2(>(y[11], x[11]), x[11], y[11])), >=) & [(3)bni_13 + (-1)Bound*bni_13] + [bni_13]y[11] >= 0 & [(-1)bso_14] >= 0)








To summarize, we get the following constraints P__>=_ for the following pairs.

*COND_NATS2(TRUE, x[12], y[12]) -> NATS(+(x[12], 1), y[12])

*(y[11] >= 0 & x[11] >= 0  ==>  (U^Increasing(NATS(+(x[12], 1), y[12])), >=) & [(3)bni_11 + (-1)Bound*bni_11] + [bni_11]y[11] >= 0 & [1 + (-1)bso_12] >= 0)


*(y[11] >= 0 & x[11] >= 0  ==>  (U^Increasing(NATS(+(x[12], 1), y[12])), >=) & [(3)bni_11 + (-1)Bound*bni_11] + [bni_11]y[11] >= 0 & [1 + (-1)bso_12] >= 0)




*NATS(x[11], y[11]) -> COND_NATS2(>(y[11], x[11]), x[11], y[11])

*(y[11] >= 0 & x[11] >= 0  ==>  (U^Increasing(COND_NATS2(>(y[11], x[11]), x[11], y[11])), >=) & [(3)bni_13 + (-1)Bound*bni_13] + [bni_13]y[11] >= 0 & [(-1)bso_14] >= 0)


*(y[11] >= 0 & x[11] >= 0  ==>  (U^Increasing(COND_NATS2(>(y[11], x[11]), x[11], y[11])), >=) & [(3)bni_13 + (-1)Bound*bni_13] + [bni_13]y[11] >= 0 & [(-1)bso_14] >= 0)








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation over integers[POLO]:

   POL(TRUE) = [1]
   POL(FALSE) = 0
   POL(COND_NATS2(x_1, x_2, x_3)) = [2] + x_3 + [-1]x_2
   POL(NATS(x_1, x_2)) = [2] + x_2 + [-1]x_1
   POL(+(x_1, x_2)) = x_1 + x_2
   POL(1) = [1]
   POL(>(x_1, x_2)) = [1]


The following pairs are in P_>:


   COND_NATS2(TRUE, x[12], y[12]) -> NATS(+(x[12], 1), y[12])


The following pairs are in P_bound:


   COND_NATS2(TRUE, x[12], y[12]) -> NATS(+(x[12], 1), y[12])
   NATS(x[11], y[11]) -> COND_NATS2(>(y[11], x[11]), x[11], y[11])


The following pairs are in P_>=:


   NATS(x[11], y[11]) -> COND_NATS2(>(y[11], x[11]), x[11], y[11])


There are no usable rules.
----------------------------------------

(53)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 + 	~ 	Add: (Integer, Integer) -> Integer
 -1 	~ 	Sub: (Integer, Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	UnaryMinus: (Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer

R is empty.

The integer pair graph contains the following rules and edges:
(11): NATS(x[11], y[11]) -> COND_NATS2(y[11] > x[11], x[11], y[11])


The set Q consists of the following terms:
isprime(x0)
mem(x0, nil)
mem(x0, cons(x1, x2))
Cond_mem(TRUE, x0, cons(x1, x2))
Cond_mem1(TRUE, x0, cons(x1, x2))
Cond_mem2(TRUE, x0, cons(x1, x2))
primes(x0)
nats(x0, x1)
Cond_nats(TRUE, x0, x1)
Cond_nats1(TRUE, x0, x1)
Cond_nats2(TRUE, x0, x1)
sieve(nil)
sieve(cons(x0, x1))
filter(x0, nil)
filter(x0, cons(x1, x2))
if_1(TRUE, x0, x1, x2)
if_2(FALSE, x0, x1, x2)
Cond_isdiv(TRUE, x0, 0)
isdiv(x0, x1)
Cond_isdiv1(TRUE, x0, x1)
Cond_isdiv2(TRUE, x0, x1)
Cond_isdiv3(TRUE, x0, x1)
Cond_isdiv4(TRUE, x0, x1)

----------------------------------------

(54) IDependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(55)
TRUE
