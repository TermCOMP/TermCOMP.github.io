YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/A4bjX.itrs
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given ITRS could be proven:

(0) ITRS
(1) ITRStoIDPProof [EQUIVALENT, 0 ms]
(2) IDP
(3) UsableRulesProof [EQUIVALENT, 0 ms]
(4) IDP
(5) IDependencyGraphProof [EQUIVALENT, 0 ms]
(6) IDP
(7) IDPNonInfProof [SOUND, 111 ms]
(8) IDP
(9) IDependencyGraphProof [EQUIVALENT, 0 ms]
(10) TRUE


----------------------------------------

(0)
Obligation:
ITRS problem:

The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 + 	~ 	Add: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 -1 	~ 	UnaryMinus: (Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	Sub: (Integer, Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>

The TRS R consists of the following rules:
minus(x, x) -> 0
minus(x, y) -> cond(min(x, y) = y, x, y)
cond(TRUE, x, y) -> 1 + minus(x, y + 1)
min(u, v) -> if(u < v, u, v)
if(TRUE, u, v) -> u
if(FALSE, u, v) -> v
The set Q consists of the following terms:
minus(x0, x1)
cond(TRUE, x0, x1)
min(x0, x1)
if(TRUE, x0, x1)
if(FALSE, x0, x1)

----------------------------------------

(1) ITRStoIDPProof (EQUIVALENT)
Added dependency pairs
----------------------------------------

(2)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 + 	~ 	Add: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 -1 	~ 	UnaryMinus: (Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	Sub: (Integer, Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer

The ITRS R consists of the following rules:
minus(x, x) -> 0
minus(x, y) -> cond(min(x, y) = y, x, y)
cond(TRUE, x, y) -> 1 + minus(x, y + 1)
min(u, v) -> if(u < v, u, v)
if(TRUE, u, v) -> u
if(FALSE, u, v) -> v

The integer pair graph contains the following rules and edges:
(0): MINUS(x[0], y[0]) -> COND(min(x[0], y[0]) = y[0], x[0], y[0])
(1): MINUS(x[1], y[1]) -> MIN(x[1], y[1])
(2): COND(TRUE, x[2], y[2]) -> MINUS(x[2], y[2] + 1)
(3): MIN(u[3], v[3]) -> IF(u[3] < v[3], u[3], v[3])

   (0) -> (2), if (min(x[0], y[0]) = y[0]  & x[0] ->^* x[2] & y[0] ->^* y[2])
   (1) -> (3), if (x[1] ->^* u[3] & y[1] ->^* v[3])
   (2) -> (0), if (x[2] ->^* x[0] & y[2] + 1 ->^* y[0])
   (2) -> (1), if (x[2] ->^* x[1] & y[2] + 1 ->^* y[1])

The set Q consists of the following terms:
minus(x0, x1)
cond(TRUE, x0, x1)
min(x0, x1)
if(TRUE, x0, x1)
if(FALSE, x0, x1)

----------------------------------------

(3) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(4)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 + 	~ 	Add: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 -1 	~ 	UnaryMinus: (Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	Sub: (Integer, Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer

The ITRS R consists of the following rules:
min(u, v) -> if(u < v, u, v)
if(TRUE, u, v) -> u
if(FALSE, u, v) -> v

The integer pair graph contains the following rules and edges:
(0): MINUS(x[0], y[0]) -> COND(min(x[0], y[0]) = y[0], x[0], y[0])
(1): MINUS(x[1], y[1]) -> MIN(x[1], y[1])
(2): COND(TRUE, x[2], y[2]) -> MINUS(x[2], y[2] + 1)
(3): MIN(u[3], v[3]) -> IF(u[3] < v[3], u[3], v[3])

   (0) -> (2), if (min(x[0], y[0]) = y[0]  & x[0] ->^* x[2] & y[0] ->^* y[2])
   (1) -> (3), if (x[1] ->^* u[3] & y[1] ->^* v[3])
   (2) -> (0), if (x[2] ->^* x[0] & y[2] + 1 ->^* y[0])
   (2) -> (1), if (x[2] ->^* x[1] & y[2] + 1 ->^* y[1])

The set Q consists of the following terms:
minus(x0, x1)
cond(TRUE, x0, x1)
min(x0, x1)
if(TRUE, x0, x1)
if(FALSE, x0, x1)

----------------------------------------

(5) IDependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(6)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 + 	~ 	Add: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 -1 	~ 	UnaryMinus: (Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	Sub: (Integer, Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer

The ITRS R consists of the following rules:
min(u, v) -> if(u < v, u, v)
if(TRUE, u, v) -> u
if(FALSE, u, v) -> v

The integer pair graph contains the following rules and edges:
(2): COND(TRUE, x[2], y[2]) -> MINUS(x[2], y[2] + 1)
(0): MINUS(x[0], y[0]) -> COND(min(x[0], y[0]) = y[0], x[0], y[0])

   (2) -> (0), if (x[2] ->^* x[0] & y[2] + 1 ->^* y[0])
   (0) -> (2), if (min(x[0], y[0]) = y[0]  & x[0] ->^* x[2] & y[0] ->^* y[2])

The set Q consists of the following terms:
minus(x0, x1)
cond(TRUE, x0, x1)
min(x0, x1)
if(TRUE, x0, x1)
if(FALSE, x0, x1)

----------------------------------------

(7) IDPNonInfProof (SOUND)
Used the following options for this NonInfProof:

IDPGPoloSolver:
Range: [(-1,2)]
IsNat: false
Interpretation Shape Heuristic: aprove.DPFramework.IDPProblem.Processors.nonInf.poly.IdpDefaultShapeHeuristic@47c2f478
Constraint Generator: NonInfConstraintGenerator:
PathGenerator: MetricPathGenerator:
Max Left Steps: 1
Max Right Steps: 1



The constraints were generated the following way:

The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair COND(TRUE, x[2], y[2]) -> MINUS(x[2], +(y[2], 1)) the following chains were created:
*We consider the chain MINUS(x[0], y[0]) -> COND(=(min(x[0], y[0]), y[0]), x[0], y[0]), COND(TRUE, x[2], y[2]) -> MINUS(x[2], +(y[2], 1)), MINUS(x[0], y[0]) -> COND(=(min(x[0], y[0]), y[0]), x[0], y[0]) which results in the following constraint:

(1)    (=(min(x[0], y[0]), y[0])=TRUE & x[0]=x[2] & y[0]=y[2] & x[2]=x[0]1 & +(y[2], 1)=y[0]1  ==>  COND(TRUE, x[2], y[2])_>=_NonInfC & COND(TRUE, x[2], y[2])_>=_MINUS(x[2], +(y[2], 1)) & (U^Increasing(MINUS(x[2], +(y[2], 1))), >=))



We simplified constraint (1) using rules (III), (IV), (VII), (IDP_BOOLEAN), (REWRITING) which results in the following new constraint:

(2)    (<(x[0], y[0])=x1 & if(x1, x[0], y[0])=x0 @ Ge: (Integer, Integer) -> Boolean & >=(x0, y[0])=TRUE & <(x[0], y[0])=x3 & if(x3, x[0], y[0])=x2 @ Le: (Integer, Integer) -> Boolean & <=(x2, y[0])=TRUE  ==>  COND(TRUE, x[0], y[0])_>=_NonInfC & COND(TRUE, x[0], y[0])_>=_MINUS(x[0], +(y[0], 1)) & (U^Increasing(MINUS(x[2], +(y[2], 1))), >=))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on if(x1, x[0], y[0])=x0 @ Ge: (Integer, Integer) -> Boolean which results in the following new constraints:

(3)    (x5=x0 @ Ge: (Integer, Integer) -> Boolean & <(x5, x4)=TRUE & >=(x0, x4)=TRUE & <(x5, x4)=x3 & if(x3, x5, x4)=x2 @ Le: (Integer, Integer) -> Boolean & <=(x2, x4)=TRUE  ==>  COND(TRUE, x5, x4)_>=_NonInfC & COND(TRUE, x5, x4)_>=_MINUS(x5, +(x4, 1)) & (U^Increasing(MINUS(x[2], +(y[2], 1))), >=))

(4)    (x6=x0 @ Ge: (Integer, Integer) -> Boolean & <(x7, x6)=FALSE & >=(x0, x6)=TRUE & <(x7, x6)=x3 & if(x3, x7, x6)=x2 @ Le: (Integer, Integer) -> Boolean & <=(x2, x6)=TRUE  ==>  COND(TRUE, x7, x6)_>=_NonInfC & COND(TRUE, x7, x6)_>=_MINUS(x7, +(x6, 1)) & (U^Increasing(MINUS(x[2], +(y[2], 1))), >=))



We simplified constraint (3) using rule (V) (with possible (I) afterwards) using induction on if(x3, x5, x4)=x2 @ Le: (Integer, Integer) -> Boolean which results in the following new constraints:

(5)    (x9=x2 @ Le: (Integer, Integer) -> Boolean & x9=x0 @ Ge: (Integer, Integer) -> Boolean & <(x9, x8)=TRUE & >=(x0, x8)=TRUE & <=(x2, x8)=TRUE  ==>  COND(TRUE, x9, x8)_>=_NonInfC & COND(TRUE, x9, x8)_>=_MINUS(x9, +(x8, 1)) & (U^Increasing(MINUS(x[2], +(y[2], 1))), >=))

(6)    (x10=x2 @ Le: (Integer, Integer) -> Boolean & x11=x0 @ Ge: (Integer, Integer) -> Boolean & <(x11, x10)=TRUE & >=(x0, x10)=TRUE & <(x11, x10)=FALSE & <=(x2, x10)=TRUE  ==>  COND(TRUE, x11, x10)_>=_NonInfC & COND(TRUE, x11, x10)_>=_MINUS(x11, +(x10, 1)) & (U^Increasing(MINUS(x[2], +(y[2], 1))), >=))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on if(x3, x7, x6)=x2 @ Le: (Integer, Integer) -> Boolean which results in the following new constraints:

(7)    (x13=x2 @ Le: (Integer, Integer) -> Boolean & x12=x0 @ Ge: (Integer, Integer) -> Boolean & <(x13, x12)=FALSE & >=(x0, x12)=TRUE & <(x13, x12)=TRUE & <=(x2, x12)=TRUE  ==>  COND(TRUE, x13, x12)_>=_NonInfC & COND(TRUE, x13, x12)_>=_MINUS(x13, +(x12, 1)) & (U^Increasing(MINUS(x[2], +(y[2], 1))), >=))

(8)    (x14=x2 @ Le: (Integer, Integer) -> Boolean & x14=x0 @ Ge: (Integer, Integer) -> Boolean & <(x15, x14)=FALSE & >=(x0, x14)=TRUE & <=(x2, x14)=TRUE  ==>  COND(TRUE, x15, x14)_>=_NonInfC & COND(TRUE, x15, x14)_>=_MINUS(x15, +(x14, 1)) & (U^Increasing(MINUS(x[2], +(y[2], 1))), >=))



We simplified constraint (5) using rule (III) which results in the following new constraint:

(9)    (<(x0, x8)=TRUE & >=(x0, x8)=TRUE & <=(x0, x8)=TRUE  ==>  COND(TRUE, x0, x8)_>=_NonInfC & COND(TRUE, x0, x8)_>=_MINUS(x0, +(x8, 1)) & (U^Increasing(MINUS(x[2], +(y[2], 1))), >=))



We simplified constraint (6) using rule (III) which results in the following new constraint:

(10)    (<(x0, x2)=TRUE & >=(x0, x2)=TRUE & <(x0, x2)=FALSE & <=(x2, x2)=TRUE  ==>  COND(TRUE, x0, x2)_>=_NonInfC & COND(TRUE, x0, x2)_>=_MINUS(x0, +(x2, 1)) & (U^Increasing(MINUS(x[2], +(y[2], 1))), >=))



We simplified constraint (7) using rule (III) which results in the following new constraint:

(11)    (<(x2, x0)=FALSE & >=(x0, x0)=TRUE & <(x2, x0)=TRUE & <=(x2, x0)=TRUE  ==>  COND(TRUE, x2, x0)_>=_NonInfC & COND(TRUE, x2, x0)_>=_MINUS(x2, +(x0, 1)) & (U^Increasing(MINUS(x[2], +(y[2], 1))), >=))



We simplified constraint (8) using rule (III) which results in the following new constraint:

(12)    (<(x15, x0)=FALSE & >=(x0, x0)=TRUE & <=(x0, x0)=TRUE  ==>  COND(TRUE, x15, x0)_>=_NonInfC & COND(TRUE, x15, x0)_>=_MINUS(x15, +(x0, 1)) & (U^Increasing(MINUS(x[2], +(y[2], 1))), >=))



We simplified constraint (9) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(13)    (x8 + [-1] + [-1]x0 >= 0 & x0 + [-1]x8 >= 0 & x8 + [-1]x0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x8 + [bni_19]x0 >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (10) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(14)    (x2 + [-1] + [-1]x0 >= 0 & x0 + [-1]x2 >= 0 & x0 + [-1]x2 >= 0 & 0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x2 + [bni_19]x0 >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (11) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(15)    (x2 + [-1]x0 >= 0 & 0 >= 0 & x0 + [-1] + [-1]x2 >= 0 & x0 + [-1]x2 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x0 + [bni_19]x2 >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (12) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(16)    (x15 + [-1]x0 >= 0 & 0 >= 0 & 0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x0 + [bni_19]x15 >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (13) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(17)    (x8 + [-1] + [-1]x0 >= 0 & x0 + [-1]x8 >= 0 & x8 + [-1]x0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x8 + [bni_19]x0 >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (16) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(18)    (x15 + [-1]x0 >= 0 & 0 >= 0 & 0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x0 + [bni_19]x15 >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (14) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(19)    (x2 + [-1] + [-1]x0 >= 0 & x0 + [-1]x2 >= 0 & x0 + [-1]x2 >= 0 & 0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x2 + [bni_19]x0 >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (15) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(20)    (x2 + [-1]x0 >= 0 & 0 >= 0 & x0 + [-1] + [-1]x2 >= 0 & x0 + [-1]x2 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x0 + [bni_19]x2 >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (17) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(21)    (x8 + [-1] + [-1]x0 >= 0 & x0 + [-1]x8 >= 0 & x8 + [-1]x0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x8 + [bni_19]x0 >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (18) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(22)    (x15 + [-1]x0 >= 0 & 0 >= 0 & 0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x0 + [bni_19]x15 >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (19) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(23)    (x2 + [-1] + [-1]x0 >= 0 & x0 + [-1]x2 >= 0 & x0 + [-1]x2 >= 0 & 0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x2 + [bni_19]x0 >= 0 & [(-1)bso_20] >= 0)



We simplified constraint (20) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(24)    (x2 + [-1]x0 >= 0 & 0 >= 0 & x0 + [-1] + [-1]x2 >= 0 & x0 + [-1]x2 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [(-1)bni_19]x0 + [bni_19]x2 >= 0 & [(-1)bso_20] >= 0)



We solved constraint (21) using rule (IDP_SMT_SPLIT).We simplified constraint (22) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(25)    (x15 >= 0 & 0 >= 0 & 0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [bni_19]x15 >= 0 & [(-1)bso_20] >= 0)



We solved constraint (23) using rule (IDP_SMT_SPLIT).We solved constraint (24) using rule (IDP_SMT_SPLIT).We simplified constraint (25) using rule (IDP_SMT_SPLIT) which results in the following new constraints:

(26)    (x15 >= 0 & 0 >= 0 & 0 >= 0 & x0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [bni_19]x15 >= 0 & [(-1)bso_20] >= 0)

(27)    (x15 >= 0 & 0 >= 0 & 0 >= 0 & x0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [bni_19]x15 >= 0 & [(-1)bso_20] >= 0)








For Pair MINUS(x[0], y[0]) -> COND(=(min(x[0], y[0]), y[0]), x[0], y[0]) the following chains were created:
*We consider the chain MINUS(x[0], y[0]) -> COND(=(min(x[0], y[0]), y[0]), x[0], y[0]), COND(TRUE, x[2], y[2]) -> MINUS(x[2], +(y[2], 1)) which results in the following constraint:

(1)    (=(min(x[0], y[0]), y[0])=TRUE & x[0]=x[2] & y[0]=y[2]  ==>  MINUS(x[0], y[0])_>=_NonInfC & MINUS(x[0], y[0])_>=_COND(=(min(x[0], y[0]), y[0]), x[0], y[0]) & (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=))



We simplified constraint (1) using rules (IV), (VII), (IDP_BOOLEAN), (REWRITING) which results in the following new constraint:

(2)    (<(x[0], y[0])=x17 & if(x17, x[0], y[0])=x16 @ Ge: (Integer, Integer) -> Boolean & >=(x16, y[0])=TRUE & <(x[0], y[0])=x19 & if(x19, x[0], y[0])=x18 @ Le: (Integer, Integer) -> Boolean & <=(x18, y[0])=TRUE  ==>  MINUS(x[0], y[0])_>=_NonInfC & MINUS(x[0], y[0])_>=_COND(=(min(x[0], y[0]), y[0]), x[0], y[0]) & (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on if(x17, x[0], y[0])=x16 @ Ge: (Integer, Integer) -> Boolean which results in the following new constraints:

(3)    (x21=x16 @ Ge: (Integer, Integer) -> Boolean & <(x21, x20)=TRUE & >=(x16, x20)=TRUE & <(x21, x20)=x19 & if(x19, x21, x20)=x18 @ Le: (Integer, Integer) -> Boolean & <=(x18, x20)=TRUE  ==>  MINUS(x21, x20)_>=_NonInfC & MINUS(x21, x20)_>=_COND(=(min(x21, x20), x20), x21, x20) & (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=))

(4)    (x22=x16 @ Ge: (Integer, Integer) -> Boolean & <(x23, x22)=FALSE & >=(x16, x22)=TRUE & <(x23, x22)=x19 & if(x19, x23, x22)=x18 @ Le: (Integer, Integer) -> Boolean & <=(x18, x22)=TRUE  ==>  MINUS(x23, x22)_>=_NonInfC & MINUS(x23, x22)_>=_COND(=(min(x23, x22), x22), x23, x22) & (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=))



We simplified constraint (3) using rule (V) (with possible (I) afterwards) using induction on if(x19, x21, x20)=x18 @ Le: (Integer, Integer) -> Boolean which results in the following new constraints:

(5)    (x25=x18 @ Le: (Integer, Integer) -> Boolean & x25=x16 @ Ge: (Integer, Integer) -> Boolean & <(x25, x24)=TRUE & >=(x16, x24)=TRUE & <=(x18, x24)=TRUE  ==>  MINUS(x25, x24)_>=_NonInfC & MINUS(x25, x24)_>=_COND(=(min(x25, x24), x24), x25, x24) & (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=))

(6)    (x26=x18 @ Le: (Integer, Integer) -> Boolean & x27=x16 @ Ge: (Integer, Integer) -> Boolean & <(x27, x26)=TRUE & >=(x16, x26)=TRUE & <(x27, x26)=FALSE & <=(x18, x26)=TRUE  ==>  MINUS(x27, x26)_>=_NonInfC & MINUS(x27, x26)_>=_COND(=(min(x27, x26), x26), x27, x26) & (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on if(x19, x23, x22)=x18 @ Le: (Integer, Integer) -> Boolean which results in the following new constraints:

(7)    (x29=x18 @ Le: (Integer, Integer) -> Boolean & x28=x16 @ Ge: (Integer, Integer) -> Boolean & <(x29, x28)=FALSE & >=(x16, x28)=TRUE & <(x29, x28)=TRUE & <=(x18, x28)=TRUE  ==>  MINUS(x29, x28)_>=_NonInfC & MINUS(x29, x28)_>=_COND(=(min(x29, x28), x28), x29, x28) & (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=))

(8)    (x30=x18 @ Le: (Integer, Integer) -> Boolean & x30=x16 @ Ge: (Integer, Integer) -> Boolean & <(x31, x30)=FALSE & >=(x16, x30)=TRUE & <=(x18, x30)=TRUE  ==>  MINUS(x31, x30)_>=_NonInfC & MINUS(x31, x30)_>=_COND(=(min(x31, x30), x30), x31, x30) & (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=))



We simplified constraint (5) using rule (III) which results in the following new constraint:

(9)    (<(x16, x24)=TRUE & >=(x16, x24)=TRUE & <=(x16, x24)=TRUE  ==>  MINUS(x16, x24)_>=_NonInfC & MINUS(x16, x24)_>=_COND(=(min(x16, x24), x24), x16, x24) & (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=))



We simplified constraint (6) using rule (III) which results in the following new constraint:

(10)    (<(x16, x18)=TRUE & >=(x16, x18)=TRUE & <(x16, x18)=FALSE & <=(x18, x18)=TRUE  ==>  MINUS(x16, x18)_>=_NonInfC & MINUS(x16, x18)_>=_COND(=(min(x16, x18), x18), x16, x18) & (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=))



We simplified constraint (7) using rule (III) which results in the following new constraint:

(11)    (<(x18, x16)=FALSE & >=(x16, x16)=TRUE & <(x18, x16)=TRUE & <=(x18, x16)=TRUE  ==>  MINUS(x18, x16)_>=_NonInfC & MINUS(x18, x16)_>=_COND(=(min(x18, x16), x16), x18, x16) & (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=))



We simplified constraint (8) using rule (III) which results in the following new constraint:

(12)    (<(x31, x16)=FALSE & >=(x16, x16)=TRUE & <=(x16, x16)=TRUE  ==>  MINUS(x31, x16)_>=_NonInfC & MINUS(x31, x16)_>=_COND(=(min(x31, x16), x16), x31, x16) & (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=))



We simplified constraint (9) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(13)    (x24 + [-1] + [-1]x16 >= 0 & x16 + [-1]x24 >= 0 & x24 + [-1]x16 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [(-1)bni_21]x24 + [bni_21]x16 >= 0 & [1 + (-1)bso_22] >= 0)



We simplified constraint (10) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(14)    (x18 + [-1] + [-1]x16 >= 0 & x16 + [-1]x18 >= 0 & x16 + [-1]x18 >= 0 & 0 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [(-1)bni_21]x18 + [bni_21]x16 >= 0 & [1 + (-1)bso_22] >= 0)



We simplified constraint (11) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(15)    (x18 + [-1]x16 >= 0 & 0 >= 0 & x16 + [-1] + [-1]x18 >= 0 & x16 + [-1]x18 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [(-1)bni_21]x16 + [bni_21]x18 >= 0 & [1 + (-1)bso_22] >= 0)



We simplified constraint (12) using rule (POLY_CONSTRAINTS) which results in the following new constraint:

(16)    (x31 + [-1]x16 >= 0 & 0 >= 0 & 0 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [(-1)bni_21]x16 + [bni_21]x31 >= 0 & [1 + (-1)bso_22] >= 0)



We simplified constraint (13) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(17)    (x24 + [-1] + [-1]x16 >= 0 & x16 + [-1]x24 >= 0 & x24 + [-1]x16 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [(-1)bni_21]x24 + [bni_21]x16 >= 0 & [1 + (-1)bso_22] >= 0)



We simplified constraint (16) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(18)    (x31 + [-1]x16 >= 0 & 0 >= 0 & 0 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [(-1)bni_21]x16 + [bni_21]x31 >= 0 & [1 + (-1)bso_22] >= 0)



We simplified constraint (14) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(19)    (x18 + [-1] + [-1]x16 >= 0 & x16 + [-1]x18 >= 0 & x16 + [-1]x18 >= 0 & 0 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [(-1)bni_21]x18 + [bni_21]x16 >= 0 & [1 + (-1)bso_22] >= 0)



We simplified constraint (15) using rule (IDP_POLY_SIMPLIFY) which results in the following new constraint:

(20)    (x18 + [-1]x16 >= 0 & 0 >= 0 & x16 + [-1] + [-1]x18 >= 0 & x16 + [-1]x18 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [(-1)bni_21]x16 + [bni_21]x18 >= 0 & [1 + (-1)bso_22] >= 0)



We simplified constraint (17) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(21)    (x24 + [-1] + [-1]x16 >= 0 & x16 + [-1]x24 >= 0 & x24 + [-1]x16 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [(-1)bni_21]x24 + [bni_21]x16 >= 0 & [1 + (-1)bso_22] >= 0)



We simplified constraint (18) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(22)    (x31 + [-1]x16 >= 0 & 0 >= 0 & 0 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [(-1)bni_21]x16 + [bni_21]x31 >= 0 & [1 + (-1)bso_22] >= 0)



We simplified constraint (19) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(23)    (x18 + [-1] + [-1]x16 >= 0 & x16 + [-1]x18 >= 0 & x16 + [-1]x18 >= 0 & 0 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [(-1)bni_21]x18 + [bni_21]x16 >= 0 & [1 + (-1)bso_22] >= 0)



We simplified constraint (20) using rule (POLY_REMOVE_MIN_MAX) which results in the following new constraint:

(24)    (x18 + [-1]x16 >= 0 & 0 >= 0 & x16 + [-1] + [-1]x18 >= 0 & x16 + [-1]x18 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [(-1)bni_21]x16 + [bni_21]x18 >= 0 & [1 + (-1)bso_22] >= 0)



We solved constraint (21) using rule (IDP_SMT_SPLIT).We simplified constraint (22) using rule (IDP_SMT_SPLIT) which results in the following new constraint:

(25)    (x31 >= 0 & 0 >= 0 & 0 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [bni_21]x31 >= 0 & [1 + (-1)bso_22] >= 0)



We solved constraint (23) using rule (IDP_SMT_SPLIT).We solved constraint (24) using rule (IDP_SMT_SPLIT).We simplified constraint (25) using rule (IDP_SMT_SPLIT) which results in the following new constraints:

(26)    (x31 >= 0 & 0 >= 0 & 0 >= 0 & x16 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [bni_21]x31 >= 0 & [1 + (-1)bso_22] >= 0)

(27)    (x31 >= 0 & 0 >= 0 & 0 >= 0 & x16 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [bni_21]x31 >= 0 & [1 + (-1)bso_22] >= 0)








To summarize, we get the following constraints P__>=_ for the following pairs.

*COND(TRUE, x[2], y[2]) -> MINUS(x[2], +(y[2], 1))

*(x15 >= 0 & 0 >= 0 & 0 >= 0 & x0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [bni_19]x15 >= 0 & [(-1)bso_20] >= 0)


*(x15 >= 0 & 0 >= 0 & 0 >= 0 & x0 >= 0  ==>  (U^Increasing(MINUS(x[2], +(y[2], 1))), >=) & [(-1)bni_19 + (-1)Bound*bni_19] + [bni_19]x15 >= 0 & [(-1)bso_20] >= 0)




*MINUS(x[0], y[0]) -> COND(=(min(x[0], y[0]), y[0]), x[0], y[0])

*(x31 >= 0 & 0 >= 0 & 0 >= 0 & x16 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [bni_21]x31 >= 0 & [1 + (-1)bso_22] >= 0)


*(x31 >= 0 & 0 >= 0 & 0 >= 0 & x16 >= 0  ==>  (U^Increasing(COND(=(min(x[0], y[0]), y[0]), x[0], y[0])), >=) & [(-1)Bound*bni_21] + [bni_21]x31 >= 0 & [1 + (-1)bso_22] >= 0)








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation over integers[POLO]:

   POL(TRUE) = 0
   POL(FALSE) = [1]
   POL(min(x_1, x_2)) = [2]x_2 + [2]x_1
   POL(if(x_1, x_2, x_3)) = [2] + [2]x_3 + [2]x_2 + [2]x_1
   POL(<(x_1, x_2)) = [1]
   POL(COND(x_1, x_2, x_3)) = [-1] + [-1]x_3 + x_2
   POL(MINUS(x_1, x_2)) = [-1]x_2 + x_1
   POL(+(x_1, x_2)) = x_1 + x_2
   POL(1) = [1]
   POL(=(x_1, x_2)) = [-1]


The following pairs are in P_>:


   MINUS(x[0], y[0]) -> COND(=(min(x[0], y[0]), y[0]), x[0], y[0])


The following pairs are in P_bound:


   COND(TRUE, x[2], y[2]) -> MINUS(x[2], +(y[2], 1))
   MINUS(x[0], y[0]) -> COND(=(min(x[0], y[0]), y[0]), x[0], y[0])


The following pairs are in P_>=:


   COND(TRUE, x[2], y[2]) -> MINUS(x[2], +(y[2], 1))


At least the following rules have been oriented under context sensitive arithmetic replacement:

   if(<(u, v), u, v)^1 -> min(u, v)^1

----------------------------------------

(8)
Obligation:
IDP problem:
The following function symbols are pre-defined:
<<<
 & 	~ 	Bwand: (Integer, Integer) -> Integer
 >= 	~ 	Ge: (Integer, Integer) -> Boolean
 | 	~ 	Bwor: (Integer, Integer) -> Integer
 / 	~ 	Div: (Integer, Integer) -> Integer
 != 	~ 	Neq: (Integer, Integer) -> Boolean
 && 	~ 	Land: (Boolean, Boolean) -> Boolean
 ! 	~ 	Lnot: (Boolean) -> Boolean
 = 	~ 	Eq: (Integer, Integer) -> Boolean
 <= 	~ 	Le: (Integer, Integer) -> Boolean
 ^ 	~ 	Bwxor: (Integer, Integer) -> Integer
 % 	~ 	Mod: (Integer, Integer) -> Integer
 + 	~ 	Add: (Integer, Integer) -> Integer
 > 	~ 	Gt: (Integer, Integer) -> Boolean
 -1 	~ 	UnaryMinus: (Integer) -> Integer
 < 	~ 	Lt: (Integer, Integer) -> Boolean
 || 	~ 	Lor: (Boolean, Boolean) -> Boolean
 - 	~ 	Sub: (Integer, Integer) -> Integer
 ~ 	~ 	Bwnot: (Integer) -> Integer
 * 	~ 	Mul: (Integer, Integer) -> Integer
>>>


The following domains are used:
   Integer

The ITRS R consists of the following rules:
min(u, v) -> if(u < v, u, v)
if(TRUE, u, v) -> u
if(FALSE, u, v) -> v

The integer pair graph contains the following rules and edges:
(2): COND(TRUE, x[2], y[2]) -> MINUS(x[2], y[2] + 1)


The set Q consists of the following terms:
minus(x0, x1)
cond(TRUE, x0, x1)
min(x0, x1)
if(TRUE, x0, x1)
if(FALSE, x0, x1)

----------------------------------------

(9) IDependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(10)
TRUE
