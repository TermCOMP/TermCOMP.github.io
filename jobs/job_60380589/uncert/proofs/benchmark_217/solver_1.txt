MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/dRT5j.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

my_is(g)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) IntegerArithmeticTransformerProof [SOUND, 0 ms]
(2) Prolog
    (3) UnifyTransformerProof [EQUIVALENT, 0 ms]
    (4) Prolog
    (5) PrologToPiTRSProof [SOUND, 0 ms]
    (6) PiTRS
        (7) DependencyPairsProof [EQUIVALENT, 0 ms]
        (8) PiDP
        (9) DependencyGraphProof [EQUIVALENT, 0 ms]
        (10) PiDP
        (11) UsableRulesProof [EQUIVALENT, 0 ms]
        (12) PiDP
        (13) PiDPToQDPProof [EQUIVALENT, 0 ms]
        (14) QDP
        (15) TransformationProof [SOUND, 0 ms]
        (16) QDP
        (17) UsableRulesProof [EQUIVALENT, 0 ms]
        (18) QDP
        (19) QReductionProof [EQUIVALENT, 0 ms]
        (20) QDP
        (21) TransformationProof [EQUIVALENT, 0 ms]
        (22) QDP
        (23) NonTerminationLoopProof [COMPLETE, 0 ms]
        (24) NO
    (25) PrologToPiTRSProof [SOUND, 0 ms]
    (26) PiTRS
        (27) DependencyPairsProof [EQUIVALENT, 0 ms]
        (28) PiDP
        (29) DependencyGraphProof [EQUIVALENT, 0 ms]
        (30) PiDP
        (31) UsableRulesProof [EQUIVALENT, 0 ms]
        (32) PiDP
        (33) PiDPToQDPProof [SOUND, 0 ms]
        (34) QDP
        (35) TransformationProof [SOUND, 0 ms]
        (36) QDP
        (37) UsableRulesProof [EQUIVALENT, 0 ms]
        (38) QDP
        (39) QReductionProof [EQUIVALENT, 0 ms]
        (40) QDP
        (41) TransformationProof [EQUIVALENT, 0 ms]
        (42) QDP
        (43) NonTerminationLoopProof [COMPLETE, 0 ms]
        (44) NO
(45) UndefinedPredicateHandlerProof [SOUND, 0 ms]
(46) Prolog
    (47) PrologToPiTRSProof [SOUND, 0 ms]
    (48) PiTRS
        (49) DependencyPairsProof [EQUIVALENT, 0 ms]
        (50) PiDP
        (51) DependencyGraphProof [EQUIVALENT, 0 ms]
        (52) PiDP
        (53) UsableRulesProof [EQUIVALENT, 0 ms]
        (54) PiDP
        (55) PiDPToQDPProof [EQUIVALENT, 0 ms]
        (56) QDP
        (57) TransformationProof [EQUIVALENT, 0 ms]
        (58) QDP
        (59) UsableRulesProof [EQUIVALENT, 0 ms]
        (60) QDP
        (61) QReductionProof [EQUIVALENT, 0 ms]
        (62) QDP
        (63) NonTerminationLoopProof [COMPLETE, 0 ms]
        (64) NO
    (65) PrologToPiTRSProof [SOUND, 0 ms]
    (66) PiTRS
        (67) DependencyPairsProof [EQUIVALENT, 0 ms]
        (68) PiDP
        (69) DependencyGraphProof [EQUIVALENT, 0 ms]
        (70) PiDP
        (71) UsableRulesProof [EQUIVALENT, 0 ms]
        (72) PiDP
        (73) PiDPToQDPProof [SOUND, 0 ms]
        (74) QDP
        (75) TransformationProof [EQUIVALENT, 0 ms]
        (76) QDP
        (77) UsableRulesProof [EQUIVALENT, 0 ms]
        (78) QDP
        (79) QReductionProof [EQUIVALENT, 0 ms]
        (80) QDP
        (81) NonTerminationLoopProof [COMPLETE, 0 ms]
        (82) NO
(83) PrologToIRSwTTransformerProof [SOUND, 0 ms]
(84) IRSwT
    (85) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
    (86) IRSwT
    (87) IntTRSCompressionProof [EQUIVALENT, 18 ms]
    (88) IRSwT
    (89) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
    (90) IRSwT
    (91) IRSwTTerminationDigraphProof [EQUIVALENT, 18 ms]
    (92) IRSwT
    (93) IntTRSCompressionProof [EQUIVALENT, 0 ms]
    (94) IRSwT
    (95) IntTRSUnneededArgumentFilterProof [EQUIVALENT, 0 ms]
    (96) IRSwT
    (97) IRSwTToIntTRSProof [SOUND, 0 ms]
    (98) IRSwT
    (99) IntTRSCompressionProof [EQUIVALENT, 0 ms]
    (100) IRSwT
    (101) IntTRSPeriodicNontermProof [COMPLETE, 0 ms]
    (102) NO
(103) PrologToDTProblemTransformerProof [SOUND, 0 ms]
(104) TRIPLES
    (105) TriplesToPiDPProof [SOUND, 0 ms]
    (106) PiDP
    (107) DependencyGraphProof [EQUIVALENT, 0 ms]
    (108) PiDP
    (109) PiDPToQDPProof [SOUND, 0 ms]
    (110) QDP
    (111) NonTerminationLoopProof [COMPLETE, 0 ms]
    (112) NO


----------------------------------------

(0)
Obligation:
Clauses:

my_is(X) :- ','(is(X, 1), my_is(X)).


Query: my_is(g)
----------------------------------------

(1) IntegerArithmeticTransformerProof (SOUND)
Added definitions of predefined predicates [PROLOG].
----------------------------------------

(2)
Obligation:
Clauses:

my_is(X) :- ','(=(X, succ(zero)), my_is(X)).
isPlus(zero, X, X).
isPlus(succ(X), zero, succ(X)).
isPlus(succ(X), succ(Y), succ(succ(Z))) :- isPlus(X, Y, Z).
isPlus(succ(X), pred(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), zero, pred(X)).
isPlus(pred(X), succ(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), pred(Y), pred(pred(Z))) :- isPlus(X, Y, Z).
isMinus(X, zero, X).
isMinus(zero, succ(Y), pred(Z)) :- isMinus(zero, Y, Z).
isMinus(zero, pred(Y), succ(Z)) :- isMinus(zero, Y, Z).
isMinus(succ(X), succ(Y), Z) :- isMinus(X, Y, Z).
isMinus(succ(X), pred(Y), succ(succ(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), succ(Y), pred(pred(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), pred(Y), Z) :- isMinus(X, Y, Z).
isTimes(X, zero, zero).
isTimes(zero, succ(Y), zero).
isTimes(zero, pred(Y), zero).
isTimes(succ(X), succ(Y), Z) :- ','(isTimes(succ(X), Y, A), isPlus(A, succ(X), Z)).
isTimes(succ(X), pred(Y), Z) :- ','(isTimes(succ(X), Y, A), isMinus(A, succ(X), Z)).
isTimes(pred(X), succ(Y), Z) :- ','(isTimes(pred(X), Y, A), isPlus(A, pred(X), Z)).
isTimes(pred(X), pred(Y), Z) :- ','(isTimes(pred(X), Y, A), isMinus(A, pred(X), Z)).
isDiv(zero, succ(Y), zero).
isDiv(zero, pred(Y), zero).
isDiv(succ(X), succ(Y), zero) :- isMinus(succ(X), succ(Y), pred(Z)).
isDiv(succ(X), succ(Y), succ(Z)) :- ','(isMinus(succ(X), succ(Y), A), isDiv(A, succ(Y), Z)).
isDiv(succ(X), pred(Y), Z) :- ','(isMinus(zero, pred(Y), A), ','(isDiv(succ(X), A, B), isMinus(zero, B, Z))).
isDiv(pred(X), pred(Y), zero) :- isMinus(pred(X), pred(Y), succ(Z)).
isDiv(pred(X), pred(Y), succ(Z)) :- ','(isMinus(pred(X), pred(Y), A), isDiv(A, pred(Y), Z)).
isDiv(pred(X), succ(Y), Z) :- ','(isMinus(zero, pred(X), A), ','(isDiv(A, succ(Y), B), isMinus(zero, B, Z))).
isModulo(X, Y, Z) :- ','(isDiv(X, Y, A), ','(isTimes(A, Y, B), isMinus(X, B, Z))).


Query: my_is(g)
----------------------------------------

(3) UnifyTransformerProof (EQUIVALENT)
Added a fact for the built-in = predicate [PROLOG].
----------------------------------------

(4)
Obligation:
Clauses:

my_is(X) :- ','(=(X, succ(zero)), my_is(X)).
isPlus(zero, X, X).
isPlus(succ(X), zero, succ(X)).
isPlus(succ(X), succ(Y), succ(succ(Z))) :- isPlus(X, Y, Z).
isPlus(succ(X), pred(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), zero, pred(X)).
isPlus(pred(X), succ(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), pred(Y), pred(pred(Z))) :- isPlus(X, Y, Z).
isMinus(X, zero, X).
isMinus(zero, succ(Y), pred(Z)) :- isMinus(zero, Y, Z).
isMinus(zero, pred(Y), succ(Z)) :- isMinus(zero, Y, Z).
isMinus(succ(X), succ(Y), Z) :- isMinus(X, Y, Z).
isMinus(succ(X), pred(Y), succ(succ(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), succ(Y), pred(pred(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), pred(Y), Z) :- isMinus(X, Y, Z).
isTimes(X, zero, zero).
isTimes(zero, succ(Y), zero).
isTimes(zero, pred(Y), zero).
isTimes(succ(X), succ(Y), Z) :- ','(isTimes(succ(X), Y, A), isPlus(A, succ(X), Z)).
isTimes(succ(X), pred(Y), Z) :- ','(isTimes(succ(X), Y, A), isMinus(A, succ(X), Z)).
isTimes(pred(X), succ(Y), Z) :- ','(isTimes(pred(X), Y, A), isPlus(A, pred(X), Z)).
isTimes(pred(X), pred(Y), Z) :- ','(isTimes(pred(X), Y, A), isMinus(A, pred(X), Z)).
isDiv(zero, succ(Y), zero).
isDiv(zero, pred(Y), zero).
isDiv(succ(X), succ(Y), zero) :- isMinus(succ(X), succ(Y), pred(Z)).
isDiv(succ(X), succ(Y), succ(Z)) :- ','(isMinus(succ(X), succ(Y), A), isDiv(A, succ(Y), Z)).
isDiv(succ(X), pred(Y), Z) :- ','(isMinus(zero, pred(Y), A), ','(isDiv(succ(X), A, B), isMinus(zero, B, Z))).
isDiv(pred(X), pred(Y), zero) :- isMinus(pred(X), pred(Y), succ(Z)).
isDiv(pred(X), pred(Y), succ(Z)) :- ','(isMinus(pred(X), pred(Y), A), isDiv(A, pred(Y), Z)).
isDiv(pred(X), succ(Y), Z) :- ','(isMinus(zero, pred(X), A), ','(isDiv(A, succ(Y), B), isMinus(zero, B, Z))).
isModulo(X, Y, Z) :- ','(isDiv(X, Y, A), ','(isTimes(A, Y, B), isMinus(X, B, Z))).
=(X, X).


Query: my_is(g)
----------------------------------------

(5) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

my_is_in_1: (b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, =_in_gg(X, succ(zero)))
   =_in_gg(X, X) -> =_out_gg(X, X)
   U1_g(X, =_out_gg(X, succ(zero))) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

Pi is empty.



Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(6)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, =_in_gg(X, succ(zero)))
   =_in_gg(X, X) -> =_out_gg(X, X)
   U1_g(X, =_out_gg(X, succ(zero))) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

Pi is empty.

----------------------------------------

(7) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   MY_IS_IN_G(X) -> U1_G(X, =_in_gg(X, succ(zero)))
   MY_IS_IN_G(X) -> =_IN_GG(X, succ(zero))
   U1_G(X, =_out_gg(X, succ(zero))) -> U2_G(X, my_is_in_g(X))
   U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X)

The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, =_in_gg(X, succ(zero)))
   =_in_gg(X, X) -> =_out_gg(X, X)
   U1_g(X, =_out_gg(X, succ(zero))) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(8)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MY_IS_IN_G(X) -> U1_G(X, =_in_gg(X, succ(zero)))
   MY_IS_IN_G(X) -> =_IN_GG(X, succ(zero))
   U1_G(X, =_out_gg(X, succ(zero))) -> U2_G(X, my_is_in_g(X))
   U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X)

The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, =_in_gg(X, succ(zero)))
   =_in_gg(X, X) -> =_out_gg(X, X)
   U1_g(X, =_out_gg(X, succ(zero))) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(9) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 2 less nodes.
----------------------------------------

(10)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, =_in_gg(X, succ(zero)))

The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, =_in_gg(X, succ(zero)))
   =_in_gg(X, X) -> =_out_gg(X, X)
   U1_g(X, =_out_gg(X, succ(zero))) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(11) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(12)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, =_in_gg(X, succ(zero)))

The TRS R consists of the following rules:

   =_in_gg(X, X) -> =_out_gg(X, X)

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(13) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, =_in_gg(X, succ(zero)))

The TRS R consists of the following rules:

   =_in_gg(X, X) -> =_out_gg(X, X)

The set Q consists of the following terms:

   =_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(15) TransformationProof (SOUND)
By narrowing [LPAR04] the rule MY_IS_IN_G(X) -> U1_G(X, =_in_gg(X, succ(zero))) at position [1] we obtained the following new rules [LPAR04]:

   (MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg(succ(zero), succ(zero))),MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg(succ(zero), succ(zero))))


----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X)
   MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg(succ(zero), succ(zero)))

The TRS R consists of the following rules:

   =_in_gg(X, X) -> =_out_gg(X, X)

The set Q consists of the following terms:

   =_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(17) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X)
   MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg(succ(zero), succ(zero)))

R is empty.
The set Q consists of the following terms:

   =_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   =_in_gg(x0, x1)


----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X)
   MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg(succ(zero), succ(zero)))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(21) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X) we obtained the following new rules [LPAR04]:

   (U1_G(succ(zero), =_out_gg(succ(zero), succ(zero))) -> MY_IS_IN_G(succ(zero)),U1_G(succ(zero), =_out_gg(succ(zero), succ(zero))) -> MY_IS_IN_G(succ(zero)))


----------------------------------------

(22)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg(succ(zero), succ(zero)))
   U1_G(succ(zero), =_out_gg(succ(zero), succ(zero))) -> MY_IS_IN_G(succ(zero))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(23) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = U1_G(succ(zero), =_out_gg(succ(zero), succ(zero))) evaluates to  t =U1_G(succ(zero), =_out_gg(succ(zero), succ(zero)))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

U1_G(succ(zero), =_out_gg(succ(zero), succ(zero))) -> MY_IS_IN_G(succ(zero))
with rule U1_G(succ(zero), =_out_gg(succ(zero), succ(zero))) -> MY_IS_IN_G(succ(zero)) at position [] and matcher [ ]

MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg(succ(zero), succ(zero)))
with rule MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg(succ(zero), succ(zero)))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(24)
NO

----------------------------------------

(25) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

my_is_in_1: (b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, =_in_gg(X, succ(zero)))
   =_in_gg(X, X) -> =_out_gg(X, X)
   U1_g(X, =_out_gg(X, succ(zero))) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

The argument filtering Pi contains the following mapping:
my_is_in_g(x1)  =  my_is_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

=_in_gg(x1, x2)  =  =_in_gg(x1, x2)

=_out_gg(x1, x2)  =  =_out_gg

succ(x1)  =  succ(x1)

zero  =  zero

U2_g(x1, x2)  =  U2_g(x2)

my_is_out_g(x1)  =  my_is_out_g





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(26)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, =_in_gg(X, succ(zero)))
   =_in_gg(X, X) -> =_out_gg(X, X)
   U1_g(X, =_out_gg(X, succ(zero))) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

The argument filtering Pi contains the following mapping:
my_is_in_g(x1)  =  my_is_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

=_in_gg(x1, x2)  =  =_in_gg(x1, x2)

=_out_gg(x1, x2)  =  =_out_gg

succ(x1)  =  succ(x1)

zero  =  zero

U2_g(x1, x2)  =  U2_g(x2)

my_is_out_g(x1)  =  my_is_out_g



----------------------------------------

(27) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   MY_IS_IN_G(X) -> U1_G(X, =_in_gg(X, succ(zero)))
   MY_IS_IN_G(X) -> =_IN_GG(X, succ(zero))
   U1_G(X, =_out_gg(X, succ(zero))) -> U2_G(X, my_is_in_g(X))
   U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X)

The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, =_in_gg(X, succ(zero)))
   =_in_gg(X, X) -> =_out_gg(X, X)
   U1_g(X, =_out_gg(X, succ(zero))) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

The argument filtering Pi contains the following mapping:
my_is_in_g(x1)  =  my_is_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

=_in_gg(x1, x2)  =  =_in_gg(x1, x2)

=_out_gg(x1, x2)  =  =_out_gg

succ(x1)  =  succ(x1)

zero  =  zero

U2_g(x1, x2)  =  U2_g(x2)

my_is_out_g(x1)  =  my_is_out_g

MY_IS_IN_G(x1)  =  MY_IS_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)

=_IN_GG(x1, x2)  =  =_IN_GG(x1, x2)

U2_G(x1, x2)  =  U2_G(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(28)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MY_IS_IN_G(X) -> U1_G(X, =_in_gg(X, succ(zero)))
   MY_IS_IN_G(X) -> =_IN_GG(X, succ(zero))
   U1_G(X, =_out_gg(X, succ(zero))) -> U2_G(X, my_is_in_g(X))
   U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X)

The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, =_in_gg(X, succ(zero)))
   =_in_gg(X, X) -> =_out_gg(X, X)
   U1_g(X, =_out_gg(X, succ(zero))) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

The argument filtering Pi contains the following mapping:
my_is_in_g(x1)  =  my_is_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

=_in_gg(x1, x2)  =  =_in_gg(x1, x2)

=_out_gg(x1, x2)  =  =_out_gg

succ(x1)  =  succ(x1)

zero  =  zero

U2_g(x1, x2)  =  U2_g(x2)

my_is_out_g(x1)  =  my_is_out_g

MY_IS_IN_G(x1)  =  MY_IS_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)

=_IN_GG(x1, x2)  =  =_IN_GG(x1, x2)

U2_G(x1, x2)  =  U2_G(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(29) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 2 less nodes.
----------------------------------------

(30)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, =_in_gg(X, succ(zero)))

The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, =_in_gg(X, succ(zero)))
   =_in_gg(X, X) -> =_out_gg(X, X)
   U1_g(X, =_out_gg(X, succ(zero))) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

The argument filtering Pi contains the following mapping:
my_is_in_g(x1)  =  my_is_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

=_in_gg(x1, x2)  =  =_in_gg(x1, x2)

=_out_gg(x1, x2)  =  =_out_gg

succ(x1)  =  succ(x1)

zero  =  zero

U2_g(x1, x2)  =  U2_g(x2)

my_is_out_g(x1)  =  my_is_out_g

MY_IS_IN_G(x1)  =  MY_IS_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(31) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(32)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, =_out_gg(X, succ(zero))) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, =_in_gg(X, succ(zero)))

The TRS R consists of the following rules:

   =_in_gg(X, X) -> =_out_gg(X, X)

The argument filtering Pi contains the following mapping:
=_in_gg(x1, x2)  =  =_in_gg(x1, x2)

=_out_gg(x1, x2)  =  =_out_gg

succ(x1)  =  succ(x1)

zero  =  zero

MY_IS_IN_G(x1)  =  MY_IS_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(33) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(34)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, =_out_gg) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, =_in_gg(X, succ(zero)))

The TRS R consists of the following rules:

   =_in_gg(X, X) -> =_out_gg

The set Q consists of the following terms:

   =_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(35) TransformationProof (SOUND)
By narrowing [LPAR04] the rule MY_IS_IN_G(X) -> U1_G(X, =_in_gg(X, succ(zero))) at position [1] we obtained the following new rules [LPAR04]:

   (MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg),MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg))


----------------------------------------

(36)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, =_out_gg) -> MY_IS_IN_G(X)
   MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg)

The TRS R consists of the following rules:

   =_in_gg(X, X) -> =_out_gg

The set Q consists of the following terms:

   =_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(37) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(38)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, =_out_gg) -> MY_IS_IN_G(X)
   MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg)

R is empty.
The set Q consists of the following terms:

   =_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(39) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   =_in_gg(x0, x1)


----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, =_out_gg) -> MY_IS_IN_G(X)
   MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(41) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U1_G(X, =_out_gg) -> MY_IS_IN_G(X) we obtained the following new rules [LPAR04]:

   (U1_G(succ(zero), =_out_gg) -> MY_IS_IN_G(succ(zero)),U1_G(succ(zero), =_out_gg) -> MY_IS_IN_G(succ(zero)))


----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg)
   U1_G(succ(zero), =_out_gg) -> MY_IS_IN_G(succ(zero))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(43) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = U1_G(succ(zero), =_out_gg) evaluates to  t =U1_G(succ(zero), =_out_gg)

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

U1_G(succ(zero), =_out_gg) -> MY_IS_IN_G(succ(zero))
with rule U1_G(succ(zero), =_out_gg) -> MY_IS_IN_G(succ(zero)) at position [] and matcher [ ]

MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg)
with rule MY_IS_IN_G(succ(zero)) -> U1_G(succ(zero), =_out_gg)

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(44)
NO

----------------------------------------

(45) UndefinedPredicateHandlerProof (SOUND)
Added facts for all undefined predicates [PROLOG].
----------------------------------------

(46)
Obligation:
Clauses:

my_is(X) :- ','(is(X, 1), my_is(X)).
is(X0, X1).


Query: my_is(g)
----------------------------------------

(47) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

my_is_in_1: (b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, is_in_gg(X, 1))
   is_in_gg(X0, X1) -> is_out_gg(X0, X1)
   U1_g(X, is_out_gg(X, 1)) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

Pi is empty.



Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(48)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, is_in_gg(X, 1))
   is_in_gg(X0, X1) -> is_out_gg(X0, X1)
   U1_g(X, is_out_gg(X, 1)) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

Pi is empty.

----------------------------------------

(49) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   MY_IS_IN_G(X) -> U1_G(X, is_in_gg(X, 1))
   MY_IS_IN_G(X) -> IS_IN_GG(X, 1)
   U1_G(X, is_out_gg(X, 1)) -> U2_G(X, my_is_in_g(X))
   U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)

The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, is_in_gg(X, 1))
   is_in_gg(X0, X1) -> is_out_gg(X0, X1)
   U1_g(X, is_out_gg(X, 1)) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(50)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MY_IS_IN_G(X) -> U1_G(X, is_in_gg(X, 1))
   MY_IS_IN_G(X) -> IS_IN_GG(X, 1)
   U1_G(X, is_out_gg(X, 1)) -> U2_G(X, my_is_in_g(X))
   U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)

The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, is_in_gg(X, 1))
   is_in_gg(X0, X1) -> is_out_gg(X0, X1)
   U1_g(X, is_out_gg(X, 1)) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(51) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 2 less nodes.
----------------------------------------

(52)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, is_in_gg(X, 1))

The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, is_in_gg(X, 1))
   is_in_gg(X0, X1) -> is_out_gg(X0, X1)
   U1_g(X, is_out_gg(X, 1)) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(53) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(54)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, is_in_gg(X, 1))

The TRS R consists of the following rules:

   is_in_gg(X0, X1) -> is_out_gg(X0, X1)

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(55) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, is_in_gg(X, 1))

The TRS R consists of the following rules:

   is_in_gg(X0, X1) -> is_out_gg(X0, X1)

The set Q consists of the following terms:

   is_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(57) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule MY_IS_IN_G(X) -> U1_G(X, is_in_gg(X, 1)) at position [1] we obtained the following new rules [LPAR04]:

   (MY_IS_IN_G(X) -> U1_G(X, is_out_gg(X, 1)),MY_IS_IN_G(X) -> U1_G(X, is_out_gg(X, 1)))


----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, is_out_gg(X, 1))

The TRS R consists of the following rules:

   is_in_gg(X0, X1) -> is_out_gg(X0, X1)

The set Q consists of the following terms:

   is_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(59) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(60)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, is_out_gg(X, 1))

R is empty.
The set Q consists of the following terms:

   is_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(61) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   is_in_gg(x0, x1)


----------------------------------------

(62)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, is_out_gg(X, 1))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(63) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = MY_IS_IN_G(X') evaluates to  t =MY_IS_IN_G(X')

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

MY_IS_IN_G(X') -> U1_G(X', is_out_gg(X', 1))
with rule MY_IS_IN_G(X'') -> U1_G(X'', is_out_gg(X'', 1)) at position [] and matcher [X'' / X']

U1_G(X', is_out_gg(X', 1)) -> MY_IS_IN_G(X')
with rule U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(64)
NO

----------------------------------------

(65) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

my_is_in_1: (b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, is_in_gg(X, 1))
   is_in_gg(X0, X1) -> is_out_gg(X0, X1)
   U1_g(X, is_out_gg(X, 1)) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

The argument filtering Pi contains the following mapping:
my_is_in_g(x1)  =  my_is_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

is_in_gg(x1, x2)  =  is_in_gg(x1, x2)

is_out_gg(x1, x2)  =  is_out_gg

1  =  1

U2_g(x1, x2)  =  U2_g(x2)

my_is_out_g(x1)  =  my_is_out_g





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(66)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, is_in_gg(X, 1))
   is_in_gg(X0, X1) -> is_out_gg(X0, X1)
   U1_g(X, is_out_gg(X, 1)) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

The argument filtering Pi contains the following mapping:
my_is_in_g(x1)  =  my_is_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

is_in_gg(x1, x2)  =  is_in_gg(x1, x2)

is_out_gg(x1, x2)  =  is_out_gg

1  =  1

U2_g(x1, x2)  =  U2_g(x2)

my_is_out_g(x1)  =  my_is_out_g



----------------------------------------

(67) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   MY_IS_IN_G(X) -> U1_G(X, is_in_gg(X, 1))
   MY_IS_IN_G(X) -> IS_IN_GG(X, 1)
   U1_G(X, is_out_gg(X, 1)) -> U2_G(X, my_is_in_g(X))
   U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)

The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, is_in_gg(X, 1))
   is_in_gg(X0, X1) -> is_out_gg(X0, X1)
   U1_g(X, is_out_gg(X, 1)) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

The argument filtering Pi contains the following mapping:
my_is_in_g(x1)  =  my_is_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

is_in_gg(x1, x2)  =  is_in_gg(x1, x2)

is_out_gg(x1, x2)  =  is_out_gg

1  =  1

U2_g(x1, x2)  =  U2_g(x2)

my_is_out_g(x1)  =  my_is_out_g

MY_IS_IN_G(x1)  =  MY_IS_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)

IS_IN_GG(x1, x2)  =  IS_IN_GG(x1, x2)

U2_G(x1, x2)  =  U2_G(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(68)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MY_IS_IN_G(X) -> U1_G(X, is_in_gg(X, 1))
   MY_IS_IN_G(X) -> IS_IN_GG(X, 1)
   U1_G(X, is_out_gg(X, 1)) -> U2_G(X, my_is_in_g(X))
   U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)

The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, is_in_gg(X, 1))
   is_in_gg(X0, X1) -> is_out_gg(X0, X1)
   U1_g(X, is_out_gg(X, 1)) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

The argument filtering Pi contains the following mapping:
my_is_in_g(x1)  =  my_is_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

is_in_gg(x1, x2)  =  is_in_gg(x1, x2)

is_out_gg(x1, x2)  =  is_out_gg

1  =  1

U2_g(x1, x2)  =  U2_g(x2)

my_is_out_g(x1)  =  my_is_out_g

MY_IS_IN_G(x1)  =  MY_IS_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)

IS_IN_GG(x1, x2)  =  IS_IN_GG(x1, x2)

U2_G(x1, x2)  =  U2_G(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(69) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 2 less nodes.
----------------------------------------

(70)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, is_in_gg(X, 1))

The TRS R consists of the following rules:

   my_is_in_g(X) -> U1_g(X, is_in_gg(X, 1))
   is_in_gg(X0, X1) -> is_out_gg(X0, X1)
   U1_g(X, is_out_gg(X, 1)) -> U2_g(X, my_is_in_g(X))
   U2_g(X, my_is_out_g(X)) -> my_is_out_g(X)

The argument filtering Pi contains the following mapping:
my_is_in_g(x1)  =  my_is_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

is_in_gg(x1, x2)  =  is_in_gg(x1, x2)

is_out_gg(x1, x2)  =  is_out_gg

1  =  1

U2_g(x1, x2)  =  U2_g(x2)

my_is_out_g(x1)  =  my_is_out_g

MY_IS_IN_G(x1)  =  MY_IS_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(71) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(72)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, is_out_gg(X, 1)) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, is_in_gg(X, 1))

The TRS R consists of the following rules:

   is_in_gg(X0, X1) -> is_out_gg(X0, X1)

The argument filtering Pi contains the following mapping:
is_in_gg(x1, x2)  =  is_in_gg(x1, x2)

is_out_gg(x1, x2)  =  is_out_gg

1  =  1

MY_IS_IN_G(x1)  =  MY_IS_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(73) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(74)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, is_out_gg) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, is_in_gg(X, 1))

The TRS R consists of the following rules:

   is_in_gg(X0, X1) -> is_out_gg

The set Q consists of the following terms:

   is_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(75) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule MY_IS_IN_G(X) -> U1_G(X, is_in_gg(X, 1)) at position [1] we obtained the following new rules [LPAR04]:

   (MY_IS_IN_G(X) -> U1_G(X, is_out_gg),MY_IS_IN_G(X) -> U1_G(X, is_out_gg))


----------------------------------------

(76)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, is_out_gg) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, is_out_gg)

The TRS R consists of the following rules:

   is_in_gg(X0, X1) -> is_out_gg

The set Q consists of the following terms:

   is_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(77) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(78)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, is_out_gg) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, is_out_gg)

R is empty.
The set Q consists of the following terms:

   is_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(79) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   is_in_gg(x0, x1)


----------------------------------------

(80)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, is_out_gg) -> MY_IS_IN_G(X)
   MY_IS_IN_G(X) -> U1_G(X, is_out_gg)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(81) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = MY_IS_IN_G(X') evaluates to  t =MY_IS_IN_G(X')

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

MY_IS_IN_G(X') -> U1_G(X', is_out_gg)
with rule MY_IS_IN_G(X'') -> U1_G(X'', is_out_gg) at position [] and matcher [X'' / X']

U1_G(X', is_out_gg) -> MY_IS_IN_G(X')
with rule U1_G(X, is_out_gg) -> MY_IS_IN_G(X)

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(82)
NO

----------------------------------------

(83) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 2,
    "program": {
        "directives": [],
        "clauses": [[
            "(my_is X)",
            "(',' (is X (1)) (my_is X))"
        ]]
    },
    "graph": {
        "nodes": {
            "2": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(my_is T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "167": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(my_is T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "1017": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "1016": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(my_is T5)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": [{
                            "lhs": {
                                "name": "T5",
                                "type": "PlainIntegerVariable"
                            },
                            "type": "PlainIntegerRelation",
                            "rhs": {
                                "type": "PlainIntegerConstant",
                                "value": "1"
                            },
                            "operation": "="
                        }]
                    },
                    "ground": [
                        "T4",
                        "T5"
                    ],
                    "free": [],
                    "exprvars": ["T5"]
                }
            },
            "825": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (is T4 (1)) (my_is T4))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes"
        },
        "edges": [
            {
                "from": 2,
                "to": 167,
                "label": "CASE"
            },
            {
                "from": 167,
                "to": 825,
                "label": "ONLY EVAL with clause\nmy_is(X3) :- ','(is(X3, 1), my_is(X3)).\nand substitutionT1 -> T4,\nX3 -> T4"
            },
            {
                "from": 825,
                "to": 1016,
                "label": "\nT4 -> T5"
            },
            {
                "from": 825,
                "to": 1017,
                "label": "IS FAIL"
            },
            {
                "from": 1016,
                "to": 2,
                "label": "INSTANCE with matching:\nT1 -> T5"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(84)
Obligation:
Rules:
f167_out(T1) -> f2_out(T1) :|: TRUE
f2_in(x) -> f167_in(x) :|: TRUE
f825_out(T4) -> f167_out(T4) :|: TRUE
f167_in(x1) -> f825_in(x1) :|: TRUE
f1016_in(x2, x3) -> f2_in(x2) :|: TRUE
f2_out(x4) -> f1016_out(x4, x5) :|: TRUE
f1017_out(x6) -> f825_out(x6) :|: TRUE
f825_in(x7) -> f1016_in(x7, x8) :|: x7 = 1
f825_in(x9) -> f1017_in(x9) :|: !(x9 = 1)
f1016_out(x10, x11) -> f825_out(x10) :|: TRUE
Start term: f2_in(T1)

----------------------------------------

(85) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f2_in(x) -> f167_in(x) :|: TRUE
f167_in(x1) -> f825_in(x1) :|: TRUE
f1016_in(x2, x3) -> f2_in(x2) :|: TRUE
f825_in(x7) -> f1016_in(x7, x8) :|: x7 = 1


----------------------------------------

(86)
Obligation:
Rules:
f2_in(x) -> f167_in(x) :|: TRUE
f167_in(x1) -> f825_in(x1) :|: TRUE
f1016_in(x2, x3) -> f2_in(x2) :|: TRUE
f825_in(x7) -> f1016_in(x7, x8) :|: x7 = 1

----------------------------------------

(87) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(88)
Obligation:
Rules:
f1016_in(cons_1, x3:0) -> f1016_in(1, x8:0) :|: TRUE && cons_1 = 1

----------------------------------------

(89) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(90)
Obligation:
Rules:
f1016_in(cons_1, x3:0) -> f1016_in(1, x8:0) :|: TRUE && cons_1 = 1

----------------------------------------

(91) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f1016_in(cons_1, x3:0) -> f1016_in(1, x8:0) :|: TRUE && cons_1 = 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(92)
Obligation:

Termination digraph:
Nodes:
(1) f1016_in(cons_1, x3:0) -> f1016_in(1, x8:0) :|: TRUE && cons_1 = 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(93) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(94)
Obligation:
Rules:
f1016_in(cons_1, x3:0:0) -> f1016_in(1, x8:0:0) :|: TRUE && cons_1 = 1

----------------------------------------

(95) IntTRSUnneededArgumentFilterProof (EQUIVALENT)
Some arguments are removed because they cannot influence termination. We removed arguments according to the following replacements:

   f1016_in(x1, x2) -> f1016_in(x1)

----------------------------------------

(96)
Obligation:
Rules:
f1016_in(cons_1) -> f1016_in(1) :|: TRUE && cons_1 = 1

----------------------------------------

(97) IRSwTToIntTRSProof (SOUND)
Applied path-length measure to transform intTRS with terms to intTRS.
----------------------------------------

(98)
Obligation:
Rules:
f1016_in(cons_1) -> f1016_in(1) :|: TRUE && cons_1 = 1

----------------------------------------

(99) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(100)
Obligation:
Rules:
f1016_in(cons_1) -> f1016_in(1) :|: TRUE && cons_1 = 1

----------------------------------------

(101) IntTRSPeriodicNontermProof (COMPLETE)
Normalized system to the following form:
f(pc, cons_1) -> f(1, 1) :|: pc = 1 && (TRUE && cons_1 = 1)
Witness term starting non-terminating reduction: f(1, 1)
----------------------------------------

(102)
NO

----------------------------------------

(103) PrologToDTProblemTransformerProof (SOUND)
Built DT problem from termination graph DT10.

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [[
            "(my_is X)",
            "(',' (is X (1)) (my_is X))"
        ]]
    },
    "graph": {
        "nodes": {
            "1019": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(my_is T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "1018": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(my_is T4)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": [{
                            "lhs": {
                                "name": "T4",
                                "type": "PlainIntegerVariable"
                            },
                            "type": "PlainIntegerRelation",
                            "rhs": {
                                "type": "PlainIntegerConstant",
                                "value": "1"
                            },
                            "operation": "="
                        }]
                    },
                    "ground": [
                        "T4",
                        "T3"
                    ],
                    "free": [],
                    "exprvars": ["T4"]
                }
            },
            "1029": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": [
                            {
                                "lhs": {
                                    "name": "T4",
                                    "type": "PlainIntegerVariable"
                                },
                                "type": "PlainIntegerRelation",
                                "rhs": {
                                    "type": "PlainIntegerConstant",
                                    "value": "1"
                                },
                                "operation": "="
                            },
                            {
                                "lhs": {
                                    "type": "PlainIntegerConstant",
                                    "value": "1"
                                },
                                "type": "PlainIntegerRelation",
                                "rhs": {
                                    "type": "PlainIntegerConstant",
                                    "value": "1"
                                },
                                "operation": "="
                            }
                        ]
                    },
                    "ground": ["T7"],
                    "free": [],
                    "exprvars": [
                        "T4",
                        "T7"
                    ]
                }
            },
            "1028": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(my_is T8)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": [
                            {
                                "lhs": {
                                    "name": "T4",
                                    "type": "PlainIntegerVariable"
                                },
                                "type": "PlainIntegerRelation",
                                "rhs": {
                                    "type": "PlainIntegerConstant",
                                    "value": "1"
                                },
                                "operation": "="
                            },
                            {
                                "lhs": {
                                    "type": "PlainIntegerConstant",
                                    "value": "1"
                                },
                                "type": "PlainIntegerRelation",
                                "rhs": {
                                    "type": "PlainIntegerConstant",
                                    "value": "1"
                                },
                                "operation": "="
                            },
                            {
                                "lhs": {
                                    "name": "T8",
                                    "type": "PlainIntegerVariable"
                                },
                                "type": "PlainIntegerRelation",
                                "rhs": {
                                    "type": "PlainIntegerConstant",
                                    "value": "1"
                                },
                                "operation": "="
                            }
                        ]
                    },
                    "ground": [
                        "T7",
                        "T8"
                    ],
                    "free": [],
                    "exprvars": [
                        "T4",
                        "T7",
                        "T8"
                    ]
                }
            },
            "1027": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (is T7 (1)) (my_is T7))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": [
                            {
                                "lhs": {
                                    "name": "T4",
                                    "type": "PlainIntegerVariable"
                                },
                                "type": "PlainIntegerRelation",
                                "rhs": {
                                    "type": "PlainIntegerConstant",
                                    "value": "1"
                                },
                                "operation": "="
                            },
                            {
                                "lhs": {
                                    "type": "PlainIntegerConstant",
                                    "value": "1"
                                },
                                "type": "PlainIntegerRelation",
                                "rhs": {
                                    "type": "PlainIntegerConstant",
                                    "value": "1"
                                },
                                "operation": "="
                            }
                        ]
                    },
                    "ground": ["T7"],
                    "free": [],
                    "exprvars": [
                        "T4",
                        "T7"
                    ]
                }
            },
            "774": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(my_is T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "1020": {
                "goal": [{
                    "clause": 0,
                    "scope": 2,
                    "term": "(my_is T4)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": [{
                            "lhs": {
                                "name": "T4",
                                "type": "PlainIntegerVariable"
                            },
                            "type": "PlainIntegerRelation",
                            "rhs": {
                                "type": "PlainIntegerConstant",
                                "value": "1"
                            },
                            "operation": "="
                        }]
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": ["T4"]
                }
            },
            "type": "Nodes",
            "790": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (is T3 (1)) (my_is T3))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 1,
                "to": 774,
                "label": "CASE"
            },
            {
                "from": 774,
                "to": 790,
                "label": "ONLY EVAL with clause\nmy_is(X2) :- ','(is(X2, 1), my_is(X2)).\nand substitutionT1 -> T3,\nX2 -> T3"
            },
            {
                "from": 790,
                "to": 1018,
                "label": "\nT3 -> T4"
            },
            {
                "from": 790,
                "to": 1019,
                "label": "IS FAIL"
            },
            {
                "from": 1018,
                "to": 1020,
                "label": "CASE"
            },
            {
                "from": 1020,
                "to": 1027,
                "label": "ONLY EVAL with clause\nmy_is(X5) :- ','(is(X5, 1), my_is(X5)).\nand substitutionT4 -> T7,\nX5 -> T7"
            },
            {
                "from": 1027,
                "to": 1028,
                "label": "\nT7 -> T8"
            },
            {
                "from": 1027,
                "to": 1029,
                "label": "IS FAIL"
            },
            {
                "from": 1028,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> T8"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(104)
Obligation:
Triples:

my_isA(X1) :- my_isA(X2).

Clauses:

my_iscA(X1) :- my_iscA(X2).

Afs:

my_isA(x1)  =  my_isA(x1)


----------------------------------------

(105) TriplesToPiDPProof (SOUND)
We use the technique of [DT09]. With regard to the inferred argument filtering the predicates were used in the following modes:

my_isA_in_1: (b) (f)

Transforming TRIPLES into the following Term Rewriting System:

Pi DP problem:
The TRS P consists of the following rules:

   MY_ISA_IN_G(X1) -> U1_G(X1, my_isA_in_a(X2))
   MY_ISA_IN_G(X1) -> MY_ISA_IN_A(X2)
   MY_ISA_IN_A(X1) -> U1_A(X1, my_isA_in_a(X2))
   MY_ISA_IN_A(X1) -> MY_ISA_IN_A(X2)

R is empty.
The argument filtering Pi contains the following mapping:
my_isA_in_a(x1)  =  my_isA_in_a

MY_ISA_IN_G(x1)  =  MY_ISA_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)

MY_ISA_IN_A(x1)  =  MY_ISA_IN_A

U1_A(x1, x2)  =  U1_A(x2)


We have to consider all (P,R,Pi)-chains


Infinitary Constructor Rewriting Termination of PiDP implies Termination of TRIPLES



----------------------------------------

(106)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MY_ISA_IN_G(X1) -> U1_G(X1, my_isA_in_a(X2))
   MY_ISA_IN_G(X1) -> MY_ISA_IN_A(X2)
   MY_ISA_IN_A(X1) -> U1_A(X1, my_isA_in_a(X2))
   MY_ISA_IN_A(X1) -> MY_ISA_IN_A(X2)

R is empty.
The argument filtering Pi contains the following mapping:
my_isA_in_a(x1)  =  my_isA_in_a

MY_ISA_IN_G(x1)  =  MY_ISA_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)

MY_ISA_IN_A(x1)  =  MY_ISA_IN_A

U1_A(x1, x2)  =  U1_A(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(107) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 3 less nodes.
----------------------------------------

(108)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MY_ISA_IN_A(X1) -> MY_ISA_IN_A(X2)

R is empty.
The argument filtering Pi contains the following mapping:
MY_ISA_IN_A(x1)  =  MY_ISA_IN_A


We have to consider all (P,R,Pi)-chains
----------------------------------------

(109) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(110)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MY_ISA_IN_A -> MY_ISA_IN_A

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(111) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = MY_ISA_IN_A evaluates to  t =MY_ISA_IN_A

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from MY_ISA_IN_A to MY_ISA_IN_A.




----------------------------------------

(112)
NO
