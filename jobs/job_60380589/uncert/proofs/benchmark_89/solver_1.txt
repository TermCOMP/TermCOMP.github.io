YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/6Sbtb.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

area(g,a)

w.r.t. the given Prolog program could successfully be proven:

(0) Prolog
(1) IntegerArithmeticTransformerProof [SOUND, 0 ms]
(2) Prolog
(3) UndefinedPredicateHandlerProof [SOUND, 0 ms]
(4) Prolog
(5) PrologToPiTRSProof [SOUND, 0 ms]
(6) PiTRS
(7) DependencyPairsProof [EQUIVALENT, 0 ms]
(8) PiDP
(9) DependencyGraphProof [EQUIVALENT, 0 ms]
(10) PiDP
(11) UsableRulesProof [EQUIVALENT, 0 ms]
(12) PiDP
(13) PiDPToQDPProof [SOUND, 0 ms]
(14) QDP
(15) MRRProof [EQUIVALENT, 11 ms]
(16) QDP
(17) PisEmptyProof [EQUIVALENT, 0 ms]
(18) YES


----------------------------------------

(0)
Obligation:
Clauses:

area(Ps, Area) :- area(Ps, 0, Area).
area(.(Pair, []), Area, Area).
area(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) :- ','(is(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), 2))), area(.(p(X2, Y2), XYs), Temp1, Area)).


Query: area(g,a)
----------------------------------------

(1) IntegerArithmeticTransformerProof (SOUND)
Added definitions of predefined predicates [PROLOG].
----------------------------------------

(2)
Obligation:
Clauses:

area(Ps, Area) :- area(Ps, zero, Area).
area(.(Pair, []), Area, Area).
area(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) :- ','(is(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))), area(.(p(X2, Y2), XYs), Temp1, Area)).
isPlus(zero, X, X).
isPlus(succ(X), zero, succ(X)).
isPlus(succ(X), succ(Y), succ(succ(Z))) :- isPlus(X, Y, Z).
isPlus(succ(X), pred(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), zero, pred(X)).
isPlus(pred(X), succ(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), pred(Y), pred(pred(Z))) :- isPlus(X, Y, Z).
isMinus(X, zero, X).
isMinus(zero, succ(Y), pred(Z)) :- isMinus(zero, Y, Z).
isMinus(zero, pred(Y), succ(Z)) :- isMinus(zero, Y, Z).
isMinus(succ(X), succ(Y), Z) :- isMinus(X, Y, Z).
isMinus(succ(X), pred(Y), succ(succ(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), succ(Y), pred(pred(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), pred(Y), Z) :- isMinus(X, Y, Z).
isTimes(X, zero, zero).
isTimes(zero, succ(Y), zero).
isTimes(zero, pred(Y), zero).
isTimes(succ(X), succ(Y), Z) :- ','(isTimes(succ(X), Y, A), isPlus(A, succ(X), Z)).
isTimes(succ(X), pred(Y), Z) :- ','(isTimes(succ(X), Y, A), isMinus(A, succ(X), Z)).
isTimes(pred(X), succ(Y), Z) :- ','(isTimes(pred(X), Y, A), isPlus(A, pred(X), Z)).
isTimes(pred(X), pred(Y), Z) :- ','(isTimes(pred(X), Y, A), isMinus(A, pred(X), Z)).
isDiv(zero, succ(Y), zero).
isDiv(zero, pred(Y), zero).
isDiv(succ(X), succ(Y), zero) :- isMinus(succ(X), succ(Y), pred(Z)).
isDiv(succ(X), succ(Y), succ(Z)) :- ','(isMinus(succ(X), succ(Y), A), isDiv(A, succ(Y), Z)).
isDiv(succ(X), pred(Y), Z) :- ','(isMinus(zero, pred(Y), A), ','(isDiv(succ(X), A, B), isMinus(zero, B, Z))).
isDiv(pred(X), pred(Y), zero) :- isMinus(pred(X), pred(Y), succ(Z)).
isDiv(pred(X), pred(Y), succ(Z)) :- ','(isMinus(pred(X), pred(Y), A), isDiv(A, pred(Y), Z)).
isDiv(pred(X), succ(Y), Z) :- ','(isMinus(zero, pred(X), A), ','(isDiv(A, succ(Y), B), isMinus(zero, B, Z))).
isModulo(X, Y, Z) :- ','(isDiv(X, Y, A), ','(isTimes(A, Y, B), isMinus(X, B, Z))).


Query: area(g,a)
----------------------------------------

(3) UndefinedPredicateHandlerProof (SOUND)
Added facts for all undefined predicates [PROLOG].
----------------------------------------

(4)
Obligation:
Clauses:

area(Ps, Area) :- area(Ps, zero, Area).
area(.(Pair, []), Area, Area).
area(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) :- ','(is(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))), area(.(p(X2, Y2), XYs), Temp1, Area)).
isPlus(zero, X, X).
isPlus(succ(X), zero, succ(X)).
isPlus(succ(X), succ(Y), succ(succ(Z))) :- isPlus(X, Y, Z).
isPlus(succ(X), pred(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), zero, pred(X)).
isPlus(pred(X), succ(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), pred(Y), pred(pred(Z))) :- isPlus(X, Y, Z).
isMinus(X, zero, X).
isMinus(zero, succ(Y), pred(Z)) :- isMinus(zero, Y, Z).
isMinus(zero, pred(Y), succ(Z)) :- isMinus(zero, Y, Z).
isMinus(succ(X), succ(Y), Z) :- isMinus(X, Y, Z).
isMinus(succ(X), pred(Y), succ(succ(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), succ(Y), pred(pred(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), pred(Y), Z) :- isMinus(X, Y, Z).
isTimes(X, zero, zero).
isTimes(zero, succ(Y), zero).
isTimes(zero, pred(Y), zero).
isTimes(succ(X), succ(Y), Z) :- ','(isTimes(succ(X), Y, A), isPlus(A, succ(X), Z)).
isTimes(succ(X), pred(Y), Z) :- ','(isTimes(succ(X), Y, A), isMinus(A, succ(X), Z)).
isTimes(pred(X), succ(Y), Z) :- ','(isTimes(pred(X), Y, A), isPlus(A, pred(X), Z)).
isTimes(pred(X), pred(Y), Z) :- ','(isTimes(pred(X), Y, A), isMinus(A, pred(X), Z)).
isDiv(zero, succ(Y), zero).
isDiv(zero, pred(Y), zero).
isDiv(succ(X), succ(Y), zero) :- isMinus(succ(X), succ(Y), pred(Z)).
isDiv(succ(X), succ(Y), succ(Z)) :- ','(isMinus(succ(X), succ(Y), A), isDiv(A, succ(Y), Z)).
isDiv(succ(X), pred(Y), Z) :- ','(isMinus(zero, pred(Y), A), ','(isDiv(succ(X), A, B), isMinus(zero, B, Z))).
isDiv(pred(X), pred(Y), zero) :- isMinus(pred(X), pred(Y), succ(Z)).
isDiv(pred(X), pred(Y), succ(Z)) :- ','(isMinus(pred(X), pred(Y), A), isDiv(A, pred(Y), Z)).
isDiv(pred(X), succ(Y), Z) :- ','(isMinus(zero, pred(X), A), ','(isDiv(A, succ(Y), B), isMinus(zero, B, Z))).
isModulo(X, Y, Z) :- ','(isDiv(X, Y, A), ','(isTimes(A, Y, B), isMinus(X, B, Z))).
is(X0, X1).


Query: area(g,a)
----------------------------------------

(5) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

area_in_2: (b,f)

area_in_3: (b,b,f) (b,f,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   area_in_ga(Ps, Area) -> U1_ga(Ps, Area, area_in_gga(Ps, zero, Area))
   area_in_gga(.(Pair, []), Area, Area) -> area_out_gga(.(Pair, []), Area, Area)
   area_in_gga(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_gga(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   is_in_ag(X0, X1) -> is_out_ag(X0, X1)
   U2_gga(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_gga(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   area_in_gaa(.(Pair, []), Area, Area) -> area_out_gaa(.(Pair, []), Area, Area)
   area_in_gaa(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   is_in_aa(X0, X1) -> is_out_aa(X0, X1)
   U2_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   U3_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, area_out_gaa(.(p(X2, Y2), XYs), Temp1, Area)) -> area_out_gaa(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area)
   U3_gga(X1, Y1, X2, Y2, XYs, Temp, Area, area_out_gaa(.(p(X2, Y2), XYs), Temp1, Area)) -> area_out_gga(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area)
   U1_ga(Ps, Area, area_out_gga(Ps, zero, Area)) -> area_out_ga(Ps, Area)

The argument filtering Pi contains the following mapping:
area_in_ga(x1, x2)  =  area_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

area_in_gga(x1, x2, x3)  =  area_in_gga(x1, x2)

.(x1, x2)  =  .(x1, x2)

[]  =  []

area_out_gga(x1, x2, x3)  =  area_out_gga

p(x1, x2)  =  p(x1, x2)

U2_gga(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gga(x3, x4, x5, x8)

is_in_ag(x1, x2)  =  is_in_ag(x2)

is_out_ag(x1, x2)  =  is_out_ag

+(x1, x2)  =  +(x1, x2)

/(x1, x2)  =  /(x1, x2)

-(x1, x2)  =  -(x1, x2)

*(x1, x2)  =  *(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U3_gga(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gga(x8)

area_in_gaa(x1, x2, x3)  =  area_in_gaa(x1)

area_out_gaa(x1, x2, x3)  =  area_out_gaa

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x3, x4, x5, x8)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x8)

area_out_ga(x1, x2)  =  area_out_ga





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(6)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   area_in_ga(Ps, Area) -> U1_ga(Ps, Area, area_in_gga(Ps, zero, Area))
   area_in_gga(.(Pair, []), Area, Area) -> area_out_gga(.(Pair, []), Area, Area)
   area_in_gga(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_gga(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   is_in_ag(X0, X1) -> is_out_ag(X0, X1)
   U2_gga(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_gga(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   area_in_gaa(.(Pair, []), Area, Area) -> area_out_gaa(.(Pair, []), Area, Area)
   area_in_gaa(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   is_in_aa(X0, X1) -> is_out_aa(X0, X1)
   U2_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   U3_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, area_out_gaa(.(p(X2, Y2), XYs), Temp1, Area)) -> area_out_gaa(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area)
   U3_gga(X1, Y1, X2, Y2, XYs, Temp, Area, area_out_gaa(.(p(X2, Y2), XYs), Temp1, Area)) -> area_out_gga(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area)
   U1_ga(Ps, Area, area_out_gga(Ps, zero, Area)) -> area_out_ga(Ps, Area)

The argument filtering Pi contains the following mapping:
area_in_ga(x1, x2)  =  area_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

area_in_gga(x1, x2, x3)  =  area_in_gga(x1, x2)

.(x1, x2)  =  .(x1, x2)

[]  =  []

area_out_gga(x1, x2, x3)  =  area_out_gga

p(x1, x2)  =  p(x1, x2)

U2_gga(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gga(x3, x4, x5, x8)

is_in_ag(x1, x2)  =  is_in_ag(x2)

is_out_ag(x1, x2)  =  is_out_ag

+(x1, x2)  =  +(x1, x2)

/(x1, x2)  =  /(x1, x2)

-(x1, x2)  =  -(x1, x2)

*(x1, x2)  =  *(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U3_gga(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gga(x8)

area_in_gaa(x1, x2, x3)  =  area_in_gaa(x1)

area_out_gaa(x1, x2, x3)  =  area_out_gaa

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x3, x4, x5, x8)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x8)

area_out_ga(x1, x2)  =  area_out_ga



----------------------------------------

(7) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   AREA_IN_GA(Ps, Area) -> U1_GA(Ps, Area, area_in_gga(Ps, zero, Area))
   AREA_IN_GA(Ps, Area) -> AREA_IN_GGA(Ps, zero, Area)
   AREA_IN_GGA(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_GGA(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   AREA_IN_GGA(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> IS_IN_AG(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))
   U2_GGA(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_GGA(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   U2_GGA(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> AREA_IN_GAA(.(p(X2, Y2), XYs), Temp1, Area)
   AREA_IN_GAA(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_GAA(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   AREA_IN_GAA(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> IS_IN_AA(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))
   U2_GAA(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_GAA(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   U2_GAA(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> AREA_IN_GAA(.(p(X2, Y2), XYs), Temp1, Area)

The TRS R consists of the following rules:

   area_in_ga(Ps, Area) -> U1_ga(Ps, Area, area_in_gga(Ps, zero, Area))
   area_in_gga(.(Pair, []), Area, Area) -> area_out_gga(.(Pair, []), Area, Area)
   area_in_gga(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_gga(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   is_in_ag(X0, X1) -> is_out_ag(X0, X1)
   U2_gga(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_gga(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   area_in_gaa(.(Pair, []), Area, Area) -> area_out_gaa(.(Pair, []), Area, Area)
   area_in_gaa(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   is_in_aa(X0, X1) -> is_out_aa(X0, X1)
   U2_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   U3_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, area_out_gaa(.(p(X2, Y2), XYs), Temp1, Area)) -> area_out_gaa(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area)
   U3_gga(X1, Y1, X2, Y2, XYs, Temp, Area, area_out_gaa(.(p(X2, Y2), XYs), Temp1, Area)) -> area_out_gga(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area)
   U1_ga(Ps, Area, area_out_gga(Ps, zero, Area)) -> area_out_ga(Ps, Area)

The argument filtering Pi contains the following mapping:
area_in_ga(x1, x2)  =  area_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

area_in_gga(x1, x2, x3)  =  area_in_gga(x1, x2)

.(x1, x2)  =  .(x1, x2)

[]  =  []

area_out_gga(x1, x2, x3)  =  area_out_gga

p(x1, x2)  =  p(x1, x2)

U2_gga(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gga(x3, x4, x5, x8)

is_in_ag(x1, x2)  =  is_in_ag(x2)

is_out_ag(x1, x2)  =  is_out_ag

+(x1, x2)  =  +(x1, x2)

/(x1, x2)  =  /(x1, x2)

-(x1, x2)  =  -(x1, x2)

*(x1, x2)  =  *(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U3_gga(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gga(x8)

area_in_gaa(x1, x2, x3)  =  area_in_gaa(x1)

area_out_gaa(x1, x2, x3)  =  area_out_gaa

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x3, x4, x5, x8)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x8)

area_out_ga(x1, x2)  =  area_out_ga

AREA_IN_GA(x1, x2)  =  AREA_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x3)

AREA_IN_GGA(x1, x2, x3)  =  AREA_IN_GGA(x1, x2)

U2_GGA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_GGA(x3, x4, x5, x8)

IS_IN_AG(x1, x2)  =  IS_IN_AG(x2)

U3_GGA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_GGA(x8)

AREA_IN_GAA(x1, x2, x3)  =  AREA_IN_GAA(x1)

U2_GAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_GAA(x3, x4, x5, x8)

IS_IN_AA(x1, x2)  =  IS_IN_AA

U3_GAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_GAA(x8)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(8)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   AREA_IN_GA(Ps, Area) -> U1_GA(Ps, Area, area_in_gga(Ps, zero, Area))
   AREA_IN_GA(Ps, Area) -> AREA_IN_GGA(Ps, zero, Area)
   AREA_IN_GGA(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_GGA(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   AREA_IN_GGA(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> IS_IN_AG(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))
   U2_GGA(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_GGA(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   U2_GGA(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> AREA_IN_GAA(.(p(X2, Y2), XYs), Temp1, Area)
   AREA_IN_GAA(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_GAA(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   AREA_IN_GAA(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> IS_IN_AA(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))
   U2_GAA(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_GAA(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   U2_GAA(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> AREA_IN_GAA(.(p(X2, Y2), XYs), Temp1, Area)

The TRS R consists of the following rules:

   area_in_ga(Ps, Area) -> U1_ga(Ps, Area, area_in_gga(Ps, zero, Area))
   area_in_gga(.(Pair, []), Area, Area) -> area_out_gga(.(Pair, []), Area, Area)
   area_in_gga(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_gga(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   is_in_ag(X0, X1) -> is_out_ag(X0, X1)
   U2_gga(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_gga(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   area_in_gaa(.(Pair, []), Area, Area) -> area_out_gaa(.(Pair, []), Area, Area)
   area_in_gaa(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   is_in_aa(X0, X1) -> is_out_aa(X0, X1)
   U2_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   U3_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, area_out_gaa(.(p(X2, Y2), XYs), Temp1, Area)) -> area_out_gaa(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area)
   U3_gga(X1, Y1, X2, Y2, XYs, Temp, Area, area_out_gaa(.(p(X2, Y2), XYs), Temp1, Area)) -> area_out_gga(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area)
   U1_ga(Ps, Area, area_out_gga(Ps, zero, Area)) -> area_out_ga(Ps, Area)

The argument filtering Pi contains the following mapping:
area_in_ga(x1, x2)  =  area_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

area_in_gga(x1, x2, x3)  =  area_in_gga(x1, x2)

.(x1, x2)  =  .(x1, x2)

[]  =  []

area_out_gga(x1, x2, x3)  =  area_out_gga

p(x1, x2)  =  p(x1, x2)

U2_gga(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gga(x3, x4, x5, x8)

is_in_ag(x1, x2)  =  is_in_ag(x2)

is_out_ag(x1, x2)  =  is_out_ag

+(x1, x2)  =  +(x1, x2)

/(x1, x2)  =  /(x1, x2)

-(x1, x2)  =  -(x1, x2)

*(x1, x2)  =  *(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U3_gga(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gga(x8)

area_in_gaa(x1, x2, x3)  =  area_in_gaa(x1)

area_out_gaa(x1, x2, x3)  =  area_out_gaa

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x3, x4, x5, x8)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x8)

area_out_ga(x1, x2)  =  area_out_ga

AREA_IN_GA(x1, x2)  =  AREA_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x3)

AREA_IN_GGA(x1, x2, x3)  =  AREA_IN_GGA(x1, x2)

U2_GGA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_GGA(x3, x4, x5, x8)

IS_IN_AG(x1, x2)  =  IS_IN_AG(x2)

U3_GGA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_GGA(x8)

AREA_IN_GAA(x1, x2, x3)  =  AREA_IN_GAA(x1)

U2_GAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_GAA(x3, x4, x5, x8)

IS_IN_AA(x1, x2)  =  IS_IN_AA

U3_GAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_GAA(x8)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(9) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 8 less nodes.
----------------------------------------

(10)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U2_GAA(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> AREA_IN_GAA(.(p(X2, Y2), XYs), Temp1, Area)
   AREA_IN_GAA(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_GAA(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))

The TRS R consists of the following rules:

   area_in_ga(Ps, Area) -> U1_ga(Ps, Area, area_in_gga(Ps, zero, Area))
   area_in_gga(.(Pair, []), Area, Area) -> area_out_gga(.(Pair, []), Area, Area)
   area_in_gga(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_gga(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   is_in_ag(X0, X1) -> is_out_ag(X0, X1)
   U2_gga(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_ag(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_gga(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   area_in_gaa(.(Pair, []), Area, Area) -> area_out_gaa(.(Pair, []), Area, Area)
   area_in_gaa(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))
   is_in_aa(X0, X1) -> is_out_aa(X0, X1)
   U2_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> U3_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, area_in_gaa(.(p(X2, Y2), XYs), Temp1, Area))
   U3_gaa(X1, Y1, X2, Y2, XYs, Temp, Area, area_out_gaa(.(p(X2, Y2), XYs), Temp1, Area)) -> area_out_gaa(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area)
   U3_gga(X1, Y1, X2, Y2, XYs, Temp, Area, area_out_gaa(.(p(X2, Y2), XYs), Temp1, Area)) -> area_out_gga(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area)
   U1_ga(Ps, Area, area_out_gga(Ps, zero, Area)) -> area_out_ga(Ps, Area)

The argument filtering Pi contains the following mapping:
area_in_ga(x1, x2)  =  area_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

area_in_gga(x1, x2, x3)  =  area_in_gga(x1, x2)

.(x1, x2)  =  .(x1, x2)

[]  =  []

area_out_gga(x1, x2, x3)  =  area_out_gga

p(x1, x2)  =  p(x1, x2)

U2_gga(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gga(x3, x4, x5, x8)

is_in_ag(x1, x2)  =  is_in_ag(x2)

is_out_ag(x1, x2)  =  is_out_ag

+(x1, x2)  =  +(x1, x2)

/(x1, x2)  =  /(x1, x2)

-(x1, x2)  =  -(x1, x2)

*(x1, x2)  =  *(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U3_gga(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gga(x8)

area_in_gaa(x1, x2, x3)  =  area_in_gaa(x1)

area_out_gaa(x1, x2, x3)  =  area_out_gaa

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x3, x4, x5, x8)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x8)

area_out_ga(x1, x2)  =  area_out_ga

AREA_IN_GAA(x1, x2, x3)  =  AREA_IN_GAA(x1)

U2_GAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_GAA(x3, x4, x5, x8)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(11) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(12)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U2_GAA(X1, Y1, X2, Y2, XYs, Temp, Area, is_out_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero)))))) -> AREA_IN_GAA(.(p(X2, Y2), XYs), Temp1, Area)
   AREA_IN_GAA(.(p(X1, Y1), .(p(X2, Y2), XYs)), Temp, Area) -> U2_GAA(X1, Y1, X2, Y2, XYs, Temp, Area, is_in_aa(Temp1, +(Temp, /(-(*(X1, Y2), *(Y1, X2)), succ(succ(zero))))))

The TRS R consists of the following rules:

   is_in_aa(X0, X1) -> is_out_aa(X0, X1)

The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

p(x1, x2)  =  p(x1, x2)

+(x1, x2)  =  +(x1, x2)

/(x1, x2)  =  /(x1, x2)

-(x1, x2)  =  -(x1, x2)

*(x1, x2)  =  *(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

AREA_IN_GAA(x1, x2, x3)  =  AREA_IN_GAA(x1)

U2_GAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_GAA(x3, x4, x5, x8)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(13) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_GAA(X2, Y2, XYs, is_out_aa) -> AREA_IN_GAA(.(p(X2, Y2), XYs))
   AREA_IN_GAA(.(p(X1, Y1), .(p(X2, Y2), XYs))) -> U2_GAA(X2, Y2, XYs, is_in_aa)

The TRS R consists of the following rules:

   is_in_aa -> is_out_aa

The set Q consists of the following terms:

   is_in_aa

We have to consider all (P,Q,R)-chains.
----------------------------------------

(15) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   U2_GAA(X2, Y2, XYs, is_out_aa) -> AREA_IN_GAA(.(p(X2, Y2), XYs))
   AREA_IN_GAA(.(p(X1, Y1), .(p(X2, Y2), XYs))) -> U2_GAA(X2, Y2, XYs, is_in_aa)

Strictly oriented rules of the TRS R:

   is_in_aa -> is_out_aa

Used ordering: Knuth-Bendix order [KBO] with precedence:._2 > p_2 > AREA_IN_GAA_1 > is_in_aa > U2_GAA_4 > is_out_aa

and weight map:

   is_in_aa=1
   is_out_aa=1
   AREA_IN_GAA_1=1
   U2_GAA_4=2
   ._2=0
   p_2=0

The variable weight is 1

----------------------------------------

(16)
Obligation:
Q DP problem:
P is empty.
R is empty.
The set Q consists of the following terms:

   is_in_aa

We have to consider all (P,Q,R)-chains.
----------------------------------------

(17) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(18)
YES
