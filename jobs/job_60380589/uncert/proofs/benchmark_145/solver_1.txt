YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/hhViV.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

isPrime(g)

w.r.t. the given Prolog program could successfully be proven:

(0) Prolog
(1) BuiltinConflictTransformerProof [EQUIVALENT, 0 ms]
(2) Prolog
(3) PrologToIRSwTTransformerProof [SOUND, 0 ms]
(4) TRUE


----------------------------------------

(0)
Obligation:
Clauses:

is_prime(2).
is_prime(3).
is_prime(P) :- ','(integer(P), ','(>(P, 3), ','(=\=(mod(P, 2), 0), \+(has_factor(P, 3))))).
integer(X1).
has_factor(N, L) :- =:=(mod(N, L), 0).
has_factor(N, L) :- ','(<(*(L, L), N), ','(is(L2, +(L, 2)), has_factor(N, L2))).


Query: isPrime(g)
----------------------------------------

(1) BuiltinConflictTransformerProof (EQUIVALENT)
Renamed defined predicates conflicting with built-in predicates [PROLOG].
----------------------------------------

(2)
Obligation:
Clauses:

is_prime(2).
is_prime(3).
is_prime(P) :- ','(user_defined_integer(P), ','(>(P, 3), ','(=\=(mod(P, 2), 0), \+(has_factor(P, 3))))).
user_defined_integer(X1).
has_factor(N, L) :- =:=(mod(N, L), 0).
has_factor(N, L) :- ','(<(*(L, L), N), ','(is(L2, +(L, 2)), has_factor(N, L2))).


Query: isPrime(g)
----------------------------------------

(3) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(is_prime (2))",
                null
            ],
            [
                "(is_prime (3))",
                null
            ],
            [
                "(is_prime P)",
                "(',' (user_defined_integer P) (',' (> P (3)) (',' (=\\= (mod P (2)) (0)) (\\+ (has_factor P (3))))))"
            ],
            [
                "(user_defined_integer X1)",
                null
            ],
            [
                "(has_factor N L)",
                "(=:= (mod N L) (0))"
            ],
            [
                "(has_factor N L)",
                "(',' (< (* L L) N) (',' (is L2 (+ L (2))) (has_factor N L2)))"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(isPrime T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "5": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes"
        },
        "edges": [{
            "from": 1,
            "to": 5,
            "label": "UNDEFINED ERROR"
        }],
        "type": "Graph"
    }
}

----------------------------------------

(4)
TRUE
