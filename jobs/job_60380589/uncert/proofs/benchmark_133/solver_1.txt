Graph construction failed
Graph construction failed
Graph construction failed
YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/6Iiis.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

encode_direct(g,a)

w.r.t. the given Prolog program could successfully be proven:

(0) Prolog
(1) UndefinedPredicateHandlerProof [SOUND, 0 ms]
(2) Prolog
(3) PrologToPiTRSProof [SOUND, 0 ms]
(4) PiTRS
(5) DependencyPairsProof [EQUIVALENT, 7 ms]
(6) PiDP
(7) DependencyGraphProof [EQUIVALENT, 0 ms]
(8) AND
    (9) PiDP
        (10) UsableRulesProof [EQUIVALENT, 0 ms]
        (11) PiDP
        (12) PiDPToQDPProof [SOUND, 0 ms]
        (13) QDP
        (14) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (15) YES
    (16) PiDP
        (17) UsableRulesProof [EQUIVALENT, 0 ms]
        (18) PiDP
        (19) PiDPToQDPProof [SOUND, 0 ms]
        (20) QDP
        (21) MRRProof [EQUIVALENT, 79 ms]
        (22) QDP
        (23) PisEmptyProof [EQUIVALENT, 0 ms]
        (24) YES


----------------------------------------

(0)
Obligation:
Clauses:

encode_direct([], []).
encode_direct(.(X, Xs), .(Z, Zs)) :- ','(count(X, Xs, Ys, 1, Z), encode_direct(Ys, Zs)).
count(X, [], [], 1, X).
count(X, [], [], N, .(N, .(X, []))) :- >(N, 1).
count(X, .(Y, Ys), .(Y, Ys), 1, X) :- \=(X, Y).
count(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) :- ','(>(N, 1), \=(X, Y)).
count(X, .(X, Xs), Ys, K, T) :- ','(is(K1, +(K, 1)), count(X, Xs, Ys, K1, T)).


Query: encode_direct(g,a)
----------------------------------------

(1) UndefinedPredicateHandlerProof (SOUND)
Added facts for all undefined predicates [PROLOG].
----------------------------------------

(2)
Obligation:
Clauses:

encode_direct([], []).
encode_direct(.(X, Xs), .(Z, Zs)) :- ','(count(X, Xs, Ys, 1, Z), encode_direct(Ys, Zs)).
count(X, [], [], 1, X).
count(X, [], [], N, .(N, .(X, []))) :- >(N, 1).
count(X, .(Y, Ys), .(Y, Ys), 1, X) :- \=(X, Y).
count(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) :- ','(>(N, 1), \=(X, Y)).
count(X, .(X, Xs), Ys, K, T) :- ','(is(K1, +(K, 1)), count(X, Xs, Ys, K1, T)).
>(X0, X1).
\=(X0, X1).
is(X0, X1).


Query: encode_direct(g,a)
----------------------------------------

(3) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

encode_direct_in_2: (b,f)

count_in_5: (b,b,f,b,f) (b,b,f,f,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   encode_direct_in_ga([], []) -> encode_direct_out_ga([], [])
   encode_direct_in_ga(.(X, Xs), .(Z, Zs)) -> U1_ga(X, Xs, Z, Zs, count_in_ggaga(X, Xs, Ys, 1, Z))
   count_in_ggaga(X, [], [], 1, X) -> count_out_ggaga(X, [], [], 1, X)
   count_in_ggaga(X, [], [], N, .(N, .(X, []))) -> U3_ggaga(X, N, >_in_gg(N, 1))
   >_in_gg(X0, X1) -> >_out_gg(X0, X1)
   U3_ggaga(X, N, >_out_gg(N, 1)) -> count_out_ggaga(X, [], [], N, .(N, .(X, [])))
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaga(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U4_ggaga(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X)
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaga(X, Y, Ys, N, >_in_gg(N, 1))
   U5_ggaga(X, Y, Ys, N, >_out_gg(N, 1)) -> U6_ggaga(X, Y, Ys, N, \=_in_gg(X, Y))
   U6_ggaga(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   count_in_ggaga(X, .(X, Xs), Ys, K, T) -> U7_ggaga(X, Xs, Ys, K, T, is_in_ag(K1, +(K, 1)))
   is_in_ag(X0, X1) -> is_out_ag(X0, X1)
   U7_ggaga(X, Xs, Ys, K, T, is_out_ag(K1, +(K, 1))) -> U8_ggaga(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   count_in_ggaaa(X, [], [], 1, X) -> count_out_ggaaa(X, [], [], 1, X)
   count_in_ggaaa(X, [], [], N, .(N, .(X, []))) -> U3_ggaaa(X, N, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U3_ggaaa(X, N, >_out_ag(N, 1)) -> count_out_ggaaa(X, [], [], N, .(N, .(X, [])))
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaaa(X, Y, Ys, \=_in_gg(X, Y))
   U4_ggaaa(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X)
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaaa(X, Y, Ys, N, >_in_ag(N, 1))
   U5_ggaaa(X, Y, Ys, N, >_out_ag(N, 1)) -> U6_ggaaa(X, Y, Ys, N, \=_in_gg(X, Y))
   U6_ggaaa(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   count_in_ggaaa(X, .(X, Xs), Ys, K, T) -> U7_ggaaa(X, Xs, Ys, K, T, is_in_aa(K1, +(K, 1)))
   is_in_aa(X0, X1) -> is_out_aa(X0, X1)
   U7_ggaaa(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> U8_ggaaa(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   U8_ggaaa(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaaa(X, .(X, Xs), Ys, K, T)
   U8_ggaga(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaga(X, .(X, Xs), Ys, K, T)
   U1_ga(X, Xs, Z, Zs, count_out_ggaga(X, Xs, Ys, 1, Z)) -> U2_ga(X, Xs, Z, Zs, encode_direct_in_ga(Ys, Zs))
   U2_ga(X, Xs, Z, Zs, encode_direct_out_ga(Ys, Zs)) -> encode_direct_out_ga(.(X, Xs), .(Z, Zs))

The argument filtering Pi contains the following mapping:
encode_direct_in_ga(x1, x2)  =  encode_direct_in_ga(x1)

[]  =  []

encode_direct_out_ga(x1, x2)  =  encode_direct_out_ga

.(x1, x2)  =  .(x1, x2)

U1_ga(x1, x2, x3, x4, x5)  =  U1_ga(x5)

count_in_ggaga(x1, x2, x3, x4, x5)  =  count_in_ggaga(x1, x2, x4)

1  =  1

count_out_ggaga(x1, x2, x3, x4, x5)  =  count_out_ggaga(x3)

U3_ggaga(x1, x2, x3)  =  U3_ggaga(x3)

>_in_gg(x1, x2)  =  >_in_gg(x1, x2)

>_out_gg(x1, x2)  =  >_out_gg

U4_ggaga(x1, x2, x3, x4)  =  U4_ggaga(x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U5_ggaga(x1, x2, x3, x4, x5)  =  U5_ggaga(x1, x2, x3, x5)

U6_ggaga(x1, x2, x3, x4, x5)  =  U6_ggaga(x2, x3, x5)

U7_ggaga(x1, x2, x3, x4, x5, x6)  =  U7_ggaga(x1, x2, x6)

is_in_ag(x1, x2)  =  is_in_ag(x2)

is_out_ag(x1, x2)  =  is_out_ag

+(x1, x2)  =  +(x1, x2)

U8_ggaga(x1, x2, x3, x4, x5, x6)  =  U8_ggaga(x6)

count_in_ggaaa(x1, x2, x3, x4, x5)  =  count_in_ggaaa(x1, x2)

count_out_ggaaa(x1, x2, x3, x4, x5)  =  count_out_ggaaa(x3)

U3_ggaaa(x1, x2, x3)  =  U3_ggaaa(x3)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

U4_ggaaa(x1, x2, x3, x4)  =  U4_ggaaa(x2, x3, x4)

U5_ggaaa(x1, x2, x3, x4, x5)  =  U5_ggaaa(x1, x2, x3, x5)

U6_ggaaa(x1, x2, x3, x4, x5)  =  U6_ggaaa(x2, x3, x5)

U7_ggaaa(x1, x2, x3, x4, x5, x6)  =  U7_ggaaa(x1, x2, x6)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

U8_ggaaa(x1, x2, x3, x4, x5, x6)  =  U8_ggaaa(x6)

U2_ga(x1, x2, x3, x4, x5)  =  U2_ga(x5)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(4)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   encode_direct_in_ga([], []) -> encode_direct_out_ga([], [])
   encode_direct_in_ga(.(X, Xs), .(Z, Zs)) -> U1_ga(X, Xs, Z, Zs, count_in_ggaga(X, Xs, Ys, 1, Z))
   count_in_ggaga(X, [], [], 1, X) -> count_out_ggaga(X, [], [], 1, X)
   count_in_ggaga(X, [], [], N, .(N, .(X, []))) -> U3_ggaga(X, N, >_in_gg(N, 1))
   >_in_gg(X0, X1) -> >_out_gg(X0, X1)
   U3_ggaga(X, N, >_out_gg(N, 1)) -> count_out_ggaga(X, [], [], N, .(N, .(X, [])))
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaga(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U4_ggaga(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X)
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaga(X, Y, Ys, N, >_in_gg(N, 1))
   U5_ggaga(X, Y, Ys, N, >_out_gg(N, 1)) -> U6_ggaga(X, Y, Ys, N, \=_in_gg(X, Y))
   U6_ggaga(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   count_in_ggaga(X, .(X, Xs), Ys, K, T) -> U7_ggaga(X, Xs, Ys, K, T, is_in_ag(K1, +(K, 1)))
   is_in_ag(X0, X1) -> is_out_ag(X0, X1)
   U7_ggaga(X, Xs, Ys, K, T, is_out_ag(K1, +(K, 1))) -> U8_ggaga(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   count_in_ggaaa(X, [], [], 1, X) -> count_out_ggaaa(X, [], [], 1, X)
   count_in_ggaaa(X, [], [], N, .(N, .(X, []))) -> U3_ggaaa(X, N, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U3_ggaaa(X, N, >_out_ag(N, 1)) -> count_out_ggaaa(X, [], [], N, .(N, .(X, [])))
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaaa(X, Y, Ys, \=_in_gg(X, Y))
   U4_ggaaa(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X)
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaaa(X, Y, Ys, N, >_in_ag(N, 1))
   U5_ggaaa(X, Y, Ys, N, >_out_ag(N, 1)) -> U6_ggaaa(X, Y, Ys, N, \=_in_gg(X, Y))
   U6_ggaaa(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   count_in_ggaaa(X, .(X, Xs), Ys, K, T) -> U7_ggaaa(X, Xs, Ys, K, T, is_in_aa(K1, +(K, 1)))
   is_in_aa(X0, X1) -> is_out_aa(X0, X1)
   U7_ggaaa(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> U8_ggaaa(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   U8_ggaaa(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaaa(X, .(X, Xs), Ys, K, T)
   U8_ggaga(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaga(X, .(X, Xs), Ys, K, T)
   U1_ga(X, Xs, Z, Zs, count_out_ggaga(X, Xs, Ys, 1, Z)) -> U2_ga(X, Xs, Z, Zs, encode_direct_in_ga(Ys, Zs))
   U2_ga(X, Xs, Z, Zs, encode_direct_out_ga(Ys, Zs)) -> encode_direct_out_ga(.(X, Xs), .(Z, Zs))

The argument filtering Pi contains the following mapping:
encode_direct_in_ga(x1, x2)  =  encode_direct_in_ga(x1)

[]  =  []

encode_direct_out_ga(x1, x2)  =  encode_direct_out_ga

.(x1, x2)  =  .(x1, x2)

U1_ga(x1, x2, x3, x4, x5)  =  U1_ga(x5)

count_in_ggaga(x1, x2, x3, x4, x5)  =  count_in_ggaga(x1, x2, x4)

1  =  1

count_out_ggaga(x1, x2, x3, x4, x5)  =  count_out_ggaga(x3)

U3_ggaga(x1, x2, x3)  =  U3_ggaga(x3)

>_in_gg(x1, x2)  =  >_in_gg(x1, x2)

>_out_gg(x1, x2)  =  >_out_gg

U4_ggaga(x1, x2, x3, x4)  =  U4_ggaga(x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U5_ggaga(x1, x2, x3, x4, x5)  =  U5_ggaga(x1, x2, x3, x5)

U6_ggaga(x1, x2, x3, x4, x5)  =  U6_ggaga(x2, x3, x5)

U7_ggaga(x1, x2, x3, x4, x5, x6)  =  U7_ggaga(x1, x2, x6)

is_in_ag(x1, x2)  =  is_in_ag(x2)

is_out_ag(x1, x2)  =  is_out_ag

+(x1, x2)  =  +(x1, x2)

U8_ggaga(x1, x2, x3, x4, x5, x6)  =  U8_ggaga(x6)

count_in_ggaaa(x1, x2, x3, x4, x5)  =  count_in_ggaaa(x1, x2)

count_out_ggaaa(x1, x2, x3, x4, x5)  =  count_out_ggaaa(x3)

U3_ggaaa(x1, x2, x3)  =  U3_ggaaa(x3)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

U4_ggaaa(x1, x2, x3, x4)  =  U4_ggaaa(x2, x3, x4)

U5_ggaaa(x1, x2, x3, x4, x5)  =  U5_ggaaa(x1, x2, x3, x5)

U6_ggaaa(x1, x2, x3, x4, x5)  =  U6_ggaaa(x2, x3, x5)

U7_ggaaa(x1, x2, x3, x4, x5, x6)  =  U7_ggaaa(x1, x2, x6)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

U8_ggaaa(x1, x2, x3, x4, x5, x6)  =  U8_ggaaa(x6)

U2_ga(x1, x2, x3, x4, x5)  =  U2_ga(x5)



----------------------------------------

(5) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   ENCODE_DIRECT_IN_GA(.(X, Xs), .(Z, Zs)) -> U1_GA(X, Xs, Z, Zs, count_in_ggaga(X, Xs, Ys, 1, Z))
   ENCODE_DIRECT_IN_GA(.(X, Xs), .(Z, Zs)) -> COUNT_IN_GGAGA(X, Xs, Ys, 1, Z)
   COUNT_IN_GGAGA(X, [], [], N, .(N, .(X, []))) -> U3_GGAGA(X, N, >_in_gg(N, 1))
   COUNT_IN_GGAGA(X, [], [], N, .(N, .(X, []))) -> >_IN_GG(N, 1)
   COUNT_IN_GGAGA(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_GGAGA(X, Y, Ys, \=_in_gg(X, Y))
   COUNT_IN_GGAGA(X, .(Y, Ys), .(Y, Ys), 1, X) -> \=_IN_GG(X, Y)
   COUNT_IN_GGAGA(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_GGAGA(X, Y, Ys, N, >_in_gg(N, 1))
   COUNT_IN_GGAGA(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> >_IN_GG(N, 1)
   U5_GGAGA(X, Y, Ys, N, >_out_gg(N, 1)) -> U6_GGAGA(X, Y, Ys, N, \=_in_gg(X, Y))
   U5_GGAGA(X, Y, Ys, N, >_out_gg(N, 1)) -> \=_IN_GG(X, Y)
   COUNT_IN_GGAGA(X, .(X, Xs), Ys, K, T) -> U7_GGAGA(X, Xs, Ys, K, T, is_in_ag(K1, +(K, 1)))
   COUNT_IN_GGAGA(X, .(X, Xs), Ys, K, T) -> IS_IN_AG(K1, +(K, 1))
   U7_GGAGA(X, Xs, Ys, K, T, is_out_ag(K1, +(K, 1))) -> U8_GGAGA(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   U7_GGAGA(X, Xs, Ys, K, T, is_out_ag(K1, +(K, 1))) -> COUNT_IN_GGAAA(X, Xs, Ys, K1, T)
   COUNT_IN_GGAAA(X, [], [], N, .(N, .(X, []))) -> U3_GGAAA(X, N, >_in_ag(N, 1))
   COUNT_IN_GGAAA(X, [], [], N, .(N, .(X, []))) -> >_IN_AG(N, 1)
   COUNT_IN_GGAAA(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_GGAAA(X, Y, Ys, \=_in_gg(X, Y))
   COUNT_IN_GGAAA(X, .(Y, Ys), .(Y, Ys), 1, X) -> \=_IN_GG(X, Y)
   COUNT_IN_GGAAA(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_GGAAA(X, Y, Ys, N, >_in_ag(N, 1))
   COUNT_IN_GGAAA(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> >_IN_AG(N, 1)
   U5_GGAAA(X, Y, Ys, N, >_out_ag(N, 1)) -> U6_GGAAA(X, Y, Ys, N, \=_in_gg(X, Y))
   U5_GGAAA(X, Y, Ys, N, >_out_ag(N, 1)) -> \=_IN_GG(X, Y)
   COUNT_IN_GGAAA(X, .(X, Xs), Ys, K, T) -> U7_GGAAA(X, Xs, Ys, K, T, is_in_aa(K1, +(K, 1)))
   COUNT_IN_GGAAA(X, .(X, Xs), Ys, K, T) -> IS_IN_AA(K1, +(K, 1))
   U7_GGAAA(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> U8_GGAAA(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   U7_GGAAA(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> COUNT_IN_GGAAA(X, Xs, Ys, K1, T)
   U1_GA(X, Xs, Z, Zs, count_out_ggaga(X, Xs, Ys, 1, Z)) -> U2_GA(X, Xs, Z, Zs, encode_direct_in_ga(Ys, Zs))
   U1_GA(X, Xs, Z, Zs, count_out_ggaga(X, Xs, Ys, 1, Z)) -> ENCODE_DIRECT_IN_GA(Ys, Zs)

The TRS R consists of the following rules:

   encode_direct_in_ga([], []) -> encode_direct_out_ga([], [])
   encode_direct_in_ga(.(X, Xs), .(Z, Zs)) -> U1_ga(X, Xs, Z, Zs, count_in_ggaga(X, Xs, Ys, 1, Z))
   count_in_ggaga(X, [], [], 1, X) -> count_out_ggaga(X, [], [], 1, X)
   count_in_ggaga(X, [], [], N, .(N, .(X, []))) -> U3_ggaga(X, N, >_in_gg(N, 1))
   >_in_gg(X0, X1) -> >_out_gg(X0, X1)
   U3_ggaga(X, N, >_out_gg(N, 1)) -> count_out_ggaga(X, [], [], N, .(N, .(X, [])))
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaga(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U4_ggaga(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X)
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaga(X, Y, Ys, N, >_in_gg(N, 1))
   U5_ggaga(X, Y, Ys, N, >_out_gg(N, 1)) -> U6_ggaga(X, Y, Ys, N, \=_in_gg(X, Y))
   U6_ggaga(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   count_in_ggaga(X, .(X, Xs), Ys, K, T) -> U7_ggaga(X, Xs, Ys, K, T, is_in_ag(K1, +(K, 1)))
   is_in_ag(X0, X1) -> is_out_ag(X0, X1)
   U7_ggaga(X, Xs, Ys, K, T, is_out_ag(K1, +(K, 1))) -> U8_ggaga(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   count_in_ggaaa(X, [], [], 1, X) -> count_out_ggaaa(X, [], [], 1, X)
   count_in_ggaaa(X, [], [], N, .(N, .(X, []))) -> U3_ggaaa(X, N, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U3_ggaaa(X, N, >_out_ag(N, 1)) -> count_out_ggaaa(X, [], [], N, .(N, .(X, [])))
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaaa(X, Y, Ys, \=_in_gg(X, Y))
   U4_ggaaa(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X)
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaaa(X, Y, Ys, N, >_in_ag(N, 1))
   U5_ggaaa(X, Y, Ys, N, >_out_ag(N, 1)) -> U6_ggaaa(X, Y, Ys, N, \=_in_gg(X, Y))
   U6_ggaaa(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   count_in_ggaaa(X, .(X, Xs), Ys, K, T) -> U7_ggaaa(X, Xs, Ys, K, T, is_in_aa(K1, +(K, 1)))
   is_in_aa(X0, X1) -> is_out_aa(X0, X1)
   U7_ggaaa(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> U8_ggaaa(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   U8_ggaaa(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaaa(X, .(X, Xs), Ys, K, T)
   U8_ggaga(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaga(X, .(X, Xs), Ys, K, T)
   U1_ga(X, Xs, Z, Zs, count_out_ggaga(X, Xs, Ys, 1, Z)) -> U2_ga(X, Xs, Z, Zs, encode_direct_in_ga(Ys, Zs))
   U2_ga(X, Xs, Z, Zs, encode_direct_out_ga(Ys, Zs)) -> encode_direct_out_ga(.(X, Xs), .(Z, Zs))

The argument filtering Pi contains the following mapping:
encode_direct_in_ga(x1, x2)  =  encode_direct_in_ga(x1)

[]  =  []

encode_direct_out_ga(x1, x2)  =  encode_direct_out_ga

.(x1, x2)  =  .(x1, x2)

U1_ga(x1, x2, x3, x4, x5)  =  U1_ga(x5)

count_in_ggaga(x1, x2, x3, x4, x5)  =  count_in_ggaga(x1, x2, x4)

1  =  1

count_out_ggaga(x1, x2, x3, x4, x5)  =  count_out_ggaga(x3)

U3_ggaga(x1, x2, x3)  =  U3_ggaga(x3)

>_in_gg(x1, x2)  =  >_in_gg(x1, x2)

>_out_gg(x1, x2)  =  >_out_gg

U4_ggaga(x1, x2, x3, x4)  =  U4_ggaga(x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U5_ggaga(x1, x2, x3, x4, x5)  =  U5_ggaga(x1, x2, x3, x5)

U6_ggaga(x1, x2, x3, x4, x5)  =  U6_ggaga(x2, x3, x5)

U7_ggaga(x1, x2, x3, x4, x5, x6)  =  U7_ggaga(x1, x2, x6)

is_in_ag(x1, x2)  =  is_in_ag(x2)

is_out_ag(x1, x2)  =  is_out_ag

+(x1, x2)  =  +(x1, x2)

U8_ggaga(x1, x2, x3, x4, x5, x6)  =  U8_ggaga(x6)

count_in_ggaaa(x1, x2, x3, x4, x5)  =  count_in_ggaaa(x1, x2)

count_out_ggaaa(x1, x2, x3, x4, x5)  =  count_out_ggaaa(x3)

U3_ggaaa(x1, x2, x3)  =  U3_ggaaa(x3)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

U4_ggaaa(x1, x2, x3, x4)  =  U4_ggaaa(x2, x3, x4)

U5_ggaaa(x1, x2, x3, x4, x5)  =  U5_ggaaa(x1, x2, x3, x5)

U6_ggaaa(x1, x2, x3, x4, x5)  =  U6_ggaaa(x2, x3, x5)

U7_ggaaa(x1, x2, x3, x4, x5, x6)  =  U7_ggaaa(x1, x2, x6)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

U8_ggaaa(x1, x2, x3, x4, x5, x6)  =  U8_ggaaa(x6)

U2_ga(x1, x2, x3, x4, x5)  =  U2_ga(x5)

ENCODE_DIRECT_IN_GA(x1, x2)  =  ENCODE_DIRECT_IN_GA(x1)

U1_GA(x1, x2, x3, x4, x5)  =  U1_GA(x5)

COUNT_IN_GGAGA(x1, x2, x3, x4, x5)  =  COUNT_IN_GGAGA(x1, x2, x4)

U3_GGAGA(x1, x2, x3)  =  U3_GGAGA(x3)

>_IN_GG(x1, x2)  =  >_IN_GG(x1, x2)

U4_GGAGA(x1, x2, x3, x4)  =  U4_GGAGA(x2, x3, x4)

\=_IN_GG(x1, x2)  =  \=_IN_GG(x1, x2)

U5_GGAGA(x1, x2, x3, x4, x5)  =  U5_GGAGA(x1, x2, x3, x5)

U6_GGAGA(x1, x2, x3, x4, x5)  =  U6_GGAGA(x2, x3, x5)

U7_GGAGA(x1, x2, x3, x4, x5, x6)  =  U7_GGAGA(x1, x2, x6)

IS_IN_AG(x1, x2)  =  IS_IN_AG(x2)

U8_GGAGA(x1, x2, x3, x4, x5, x6)  =  U8_GGAGA(x6)

COUNT_IN_GGAAA(x1, x2, x3, x4, x5)  =  COUNT_IN_GGAAA(x1, x2)

U3_GGAAA(x1, x2, x3)  =  U3_GGAAA(x3)

>_IN_AG(x1, x2)  =  >_IN_AG(x2)

U4_GGAAA(x1, x2, x3, x4)  =  U4_GGAAA(x2, x3, x4)

U5_GGAAA(x1, x2, x3, x4, x5)  =  U5_GGAAA(x1, x2, x3, x5)

U6_GGAAA(x1, x2, x3, x4, x5)  =  U6_GGAAA(x2, x3, x5)

U7_GGAAA(x1, x2, x3, x4, x5, x6)  =  U7_GGAAA(x1, x2, x6)

IS_IN_AA(x1, x2)  =  IS_IN_AA

U8_GGAAA(x1, x2, x3, x4, x5, x6)  =  U8_GGAAA(x6)

U2_GA(x1, x2, x3, x4, x5)  =  U2_GA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(6)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ENCODE_DIRECT_IN_GA(.(X, Xs), .(Z, Zs)) -> U1_GA(X, Xs, Z, Zs, count_in_ggaga(X, Xs, Ys, 1, Z))
   ENCODE_DIRECT_IN_GA(.(X, Xs), .(Z, Zs)) -> COUNT_IN_GGAGA(X, Xs, Ys, 1, Z)
   COUNT_IN_GGAGA(X, [], [], N, .(N, .(X, []))) -> U3_GGAGA(X, N, >_in_gg(N, 1))
   COUNT_IN_GGAGA(X, [], [], N, .(N, .(X, []))) -> >_IN_GG(N, 1)
   COUNT_IN_GGAGA(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_GGAGA(X, Y, Ys, \=_in_gg(X, Y))
   COUNT_IN_GGAGA(X, .(Y, Ys), .(Y, Ys), 1, X) -> \=_IN_GG(X, Y)
   COUNT_IN_GGAGA(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_GGAGA(X, Y, Ys, N, >_in_gg(N, 1))
   COUNT_IN_GGAGA(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> >_IN_GG(N, 1)
   U5_GGAGA(X, Y, Ys, N, >_out_gg(N, 1)) -> U6_GGAGA(X, Y, Ys, N, \=_in_gg(X, Y))
   U5_GGAGA(X, Y, Ys, N, >_out_gg(N, 1)) -> \=_IN_GG(X, Y)
   COUNT_IN_GGAGA(X, .(X, Xs), Ys, K, T) -> U7_GGAGA(X, Xs, Ys, K, T, is_in_ag(K1, +(K, 1)))
   COUNT_IN_GGAGA(X, .(X, Xs), Ys, K, T) -> IS_IN_AG(K1, +(K, 1))
   U7_GGAGA(X, Xs, Ys, K, T, is_out_ag(K1, +(K, 1))) -> U8_GGAGA(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   U7_GGAGA(X, Xs, Ys, K, T, is_out_ag(K1, +(K, 1))) -> COUNT_IN_GGAAA(X, Xs, Ys, K1, T)
   COUNT_IN_GGAAA(X, [], [], N, .(N, .(X, []))) -> U3_GGAAA(X, N, >_in_ag(N, 1))
   COUNT_IN_GGAAA(X, [], [], N, .(N, .(X, []))) -> >_IN_AG(N, 1)
   COUNT_IN_GGAAA(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_GGAAA(X, Y, Ys, \=_in_gg(X, Y))
   COUNT_IN_GGAAA(X, .(Y, Ys), .(Y, Ys), 1, X) -> \=_IN_GG(X, Y)
   COUNT_IN_GGAAA(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_GGAAA(X, Y, Ys, N, >_in_ag(N, 1))
   COUNT_IN_GGAAA(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> >_IN_AG(N, 1)
   U5_GGAAA(X, Y, Ys, N, >_out_ag(N, 1)) -> U6_GGAAA(X, Y, Ys, N, \=_in_gg(X, Y))
   U5_GGAAA(X, Y, Ys, N, >_out_ag(N, 1)) -> \=_IN_GG(X, Y)
   COUNT_IN_GGAAA(X, .(X, Xs), Ys, K, T) -> U7_GGAAA(X, Xs, Ys, K, T, is_in_aa(K1, +(K, 1)))
   COUNT_IN_GGAAA(X, .(X, Xs), Ys, K, T) -> IS_IN_AA(K1, +(K, 1))
   U7_GGAAA(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> U8_GGAAA(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   U7_GGAAA(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> COUNT_IN_GGAAA(X, Xs, Ys, K1, T)
   U1_GA(X, Xs, Z, Zs, count_out_ggaga(X, Xs, Ys, 1, Z)) -> U2_GA(X, Xs, Z, Zs, encode_direct_in_ga(Ys, Zs))
   U1_GA(X, Xs, Z, Zs, count_out_ggaga(X, Xs, Ys, 1, Z)) -> ENCODE_DIRECT_IN_GA(Ys, Zs)

The TRS R consists of the following rules:

   encode_direct_in_ga([], []) -> encode_direct_out_ga([], [])
   encode_direct_in_ga(.(X, Xs), .(Z, Zs)) -> U1_ga(X, Xs, Z, Zs, count_in_ggaga(X, Xs, Ys, 1, Z))
   count_in_ggaga(X, [], [], 1, X) -> count_out_ggaga(X, [], [], 1, X)
   count_in_ggaga(X, [], [], N, .(N, .(X, []))) -> U3_ggaga(X, N, >_in_gg(N, 1))
   >_in_gg(X0, X1) -> >_out_gg(X0, X1)
   U3_ggaga(X, N, >_out_gg(N, 1)) -> count_out_ggaga(X, [], [], N, .(N, .(X, [])))
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaga(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U4_ggaga(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X)
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaga(X, Y, Ys, N, >_in_gg(N, 1))
   U5_ggaga(X, Y, Ys, N, >_out_gg(N, 1)) -> U6_ggaga(X, Y, Ys, N, \=_in_gg(X, Y))
   U6_ggaga(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   count_in_ggaga(X, .(X, Xs), Ys, K, T) -> U7_ggaga(X, Xs, Ys, K, T, is_in_ag(K1, +(K, 1)))
   is_in_ag(X0, X1) -> is_out_ag(X0, X1)
   U7_ggaga(X, Xs, Ys, K, T, is_out_ag(K1, +(K, 1))) -> U8_ggaga(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   count_in_ggaaa(X, [], [], 1, X) -> count_out_ggaaa(X, [], [], 1, X)
   count_in_ggaaa(X, [], [], N, .(N, .(X, []))) -> U3_ggaaa(X, N, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U3_ggaaa(X, N, >_out_ag(N, 1)) -> count_out_ggaaa(X, [], [], N, .(N, .(X, [])))
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaaa(X, Y, Ys, \=_in_gg(X, Y))
   U4_ggaaa(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X)
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaaa(X, Y, Ys, N, >_in_ag(N, 1))
   U5_ggaaa(X, Y, Ys, N, >_out_ag(N, 1)) -> U6_ggaaa(X, Y, Ys, N, \=_in_gg(X, Y))
   U6_ggaaa(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   count_in_ggaaa(X, .(X, Xs), Ys, K, T) -> U7_ggaaa(X, Xs, Ys, K, T, is_in_aa(K1, +(K, 1)))
   is_in_aa(X0, X1) -> is_out_aa(X0, X1)
   U7_ggaaa(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> U8_ggaaa(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   U8_ggaaa(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaaa(X, .(X, Xs), Ys, K, T)
   U8_ggaga(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaga(X, .(X, Xs), Ys, K, T)
   U1_ga(X, Xs, Z, Zs, count_out_ggaga(X, Xs, Ys, 1, Z)) -> U2_ga(X, Xs, Z, Zs, encode_direct_in_ga(Ys, Zs))
   U2_ga(X, Xs, Z, Zs, encode_direct_out_ga(Ys, Zs)) -> encode_direct_out_ga(.(X, Xs), .(Z, Zs))

The argument filtering Pi contains the following mapping:
encode_direct_in_ga(x1, x2)  =  encode_direct_in_ga(x1)

[]  =  []

encode_direct_out_ga(x1, x2)  =  encode_direct_out_ga

.(x1, x2)  =  .(x1, x2)

U1_ga(x1, x2, x3, x4, x5)  =  U1_ga(x5)

count_in_ggaga(x1, x2, x3, x4, x5)  =  count_in_ggaga(x1, x2, x4)

1  =  1

count_out_ggaga(x1, x2, x3, x4, x5)  =  count_out_ggaga(x3)

U3_ggaga(x1, x2, x3)  =  U3_ggaga(x3)

>_in_gg(x1, x2)  =  >_in_gg(x1, x2)

>_out_gg(x1, x2)  =  >_out_gg

U4_ggaga(x1, x2, x3, x4)  =  U4_ggaga(x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U5_ggaga(x1, x2, x3, x4, x5)  =  U5_ggaga(x1, x2, x3, x5)

U6_ggaga(x1, x2, x3, x4, x5)  =  U6_ggaga(x2, x3, x5)

U7_ggaga(x1, x2, x3, x4, x5, x6)  =  U7_ggaga(x1, x2, x6)

is_in_ag(x1, x2)  =  is_in_ag(x2)

is_out_ag(x1, x2)  =  is_out_ag

+(x1, x2)  =  +(x1, x2)

U8_ggaga(x1, x2, x3, x4, x5, x6)  =  U8_ggaga(x6)

count_in_ggaaa(x1, x2, x3, x4, x5)  =  count_in_ggaaa(x1, x2)

count_out_ggaaa(x1, x2, x3, x4, x5)  =  count_out_ggaaa(x3)

U3_ggaaa(x1, x2, x3)  =  U3_ggaaa(x3)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

U4_ggaaa(x1, x2, x3, x4)  =  U4_ggaaa(x2, x3, x4)

U5_ggaaa(x1, x2, x3, x4, x5)  =  U5_ggaaa(x1, x2, x3, x5)

U6_ggaaa(x1, x2, x3, x4, x5)  =  U6_ggaaa(x2, x3, x5)

U7_ggaaa(x1, x2, x3, x4, x5, x6)  =  U7_ggaaa(x1, x2, x6)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

U8_ggaaa(x1, x2, x3, x4, x5, x6)  =  U8_ggaaa(x6)

U2_ga(x1, x2, x3, x4, x5)  =  U2_ga(x5)

ENCODE_DIRECT_IN_GA(x1, x2)  =  ENCODE_DIRECT_IN_GA(x1)

U1_GA(x1, x2, x3, x4, x5)  =  U1_GA(x5)

COUNT_IN_GGAGA(x1, x2, x3, x4, x5)  =  COUNT_IN_GGAGA(x1, x2, x4)

U3_GGAGA(x1, x2, x3)  =  U3_GGAGA(x3)

>_IN_GG(x1, x2)  =  >_IN_GG(x1, x2)

U4_GGAGA(x1, x2, x3, x4)  =  U4_GGAGA(x2, x3, x4)

\=_IN_GG(x1, x2)  =  \=_IN_GG(x1, x2)

U5_GGAGA(x1, x2, x3, x4, x5)  =  U5_GGAGA(x1, x2, x3, x5)

U6_GGAGA(x1, x2, x3, x4, x5)  =  U6_GGAGA(x2, x3, x5)

U7_GGAGA(x1, x2, x3, x4, x5, x6)  =  U7_GGAGA(x1, x2, x6)

IS_IN_AG(x1, x2)  =  IS_IN_AG(x2)

U8_GGAGA(x1, x2, x3, x4, x5, x6)  =  U8_GGAGA(x6)

COUNT_IN_GGAAA(x1, x2, x3, x4, x5)  =  COUNT_IN_GGAAA(x1, x2)

U3_GGAAA(x1, x2, x3)  =  U3_GGAAA(x3)

>_IN_AG(x1, x2)  =  >_IN_AG(x2)

U4_GGAAA(x1, x2, x3, x4)  =  U4_GGAAA(x2, x3, x4)

U5_GGAAA(x1, x2, x3, x4, x5)  =  U5_GGAAA(x1, x2, x3, x5)

U6_GGAAA(x1, x2, x3, x4, x5)  =  U6_GGAAA(x2, x3, x5)

U7_GGAAA(x1, x2, x3, x4, x5, x6)  =  U7_GGAAA(x1, x2, x6)

IS_IN_AA(x1, x2)  =  IS_IN_AA

U8_GGAAA(x1, x2, x3, x4, x5, x6)  =  U8_GGAAA(x6)

U2_GA(x1, x2, x3, x4, x5)  =  U2_GA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(7) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 2 SCCs with 24 less nodes.
----------------------------------------

(8)
Complex Obligation (AND)

----------------------------------------

(9)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   COUNT_IN_GGAAA(X, .(X, Xs), Ys, K, T) -> U7_GGAAA(X, Xs, Ys, K, T, is_in_aa(K1, +(K, 1)))
   U7_GGAAA(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> COUNT_IN_GGAAA(X, Xs, Ys, K1, T)

The TRS R consists of the following rules:

   encode_direct_in_ga([], []) -> encode_direct_out_ga([], [])
   encode_direct_in_ga(.(X, Xs), .(Z, Zs)) -> U1_ga(X, Xs, Z, Zs, count_in_ggaga(X, Xs, Ys, 1, Z))
   count_in_ggaga(X, [], [], 1, X) -> count_out_ggaga(X, [], [], 1, X)
   count_in_ggaga(X, [], [], N, .(N, .(X, []))) -> U3_ggaga(X, N, >_in_gg(N, 1))
   >_in_gg(X0, X1) -> >_out_gg(X0, X1)
   U3_ggaga(X, N, >_out_gg(N, 1)) -> count_out_ggaga(X, [], [], N, .(N, .(X, [])))
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaga(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U4_ggaga(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X)
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaga(X, Y, Ys, N, >_in_gg(N, 1))
   U5_ggaga(X, Y, Ys, N, >_out_gg(N, 1)) -> U6_ggaga(X, Y, Ys, N, \=_in_gg(X, Y))
   U6_ggaga(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   count_in_ggaga(X, .(X, Xs), Ys, K, T) -> U7_ggaga(X, Xs, Ys, K, T, is_in_ag(K1, +(K, 1)))
   is_in_ag(X0, X1) -> is_out_ag(X0, X1)
   U7_ggaga(X, Xs, Ys, K, T, is_out_ag(K1, +(K, 1))) -> U8_ggaga(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   count_in_ggaaa(X, [], [], 1, X) -> count_out_ggaaa(X, [], [], 1, X)
   count_in_ggaaa(X, [], [], N, .(N, .(X, []))) -> U3_ggaaa(X, N, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U3_ggaaa(X, N, >_out_ag(N, 1)) -> count_out_ggaaa(X, [], [], N, .(N, .(X, [])))
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaaa(X, Y, Ys, \=_in_gg(X, Y))
   U4_ggaaa(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X)
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaaa(X, Y, Ys, N, >_in_ag(N, 1))
   U5_ggaaa(X, Y, Ys, N, >_out_ag(N, 1)) -> U6_ggaaa(X, Y, Ys, N, \=_in_gg(X, Y))
   U6_ggaaa(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   count_in_ggaaa(X, .(X, Xs), Ys, K, T) -> U7_ggaaa(X, Xs, Ys, K, T, is_in_aa(K1, +(K, 1)))
   is_in_aa(X0, X1) -> is_out_aa(X0, X1)
   U7_ggaaa(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> U8_ggaaa(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   U8_ggaaa(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaaa(X, .(X, Xs), Ys, K, T)
   U8_ggaga(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaga(X, .(X, Xs), Ys, K, T)
   U1_ga(X, Xs, Z, Zs, count_out_ggaga(X, Xs, Ys, 1, Z)) -> U2_ga(X, Xs, Z, Zs, encode_direct_in_ga(Ys, Zs))
   U2_ga(X, Xs, Z, Zs, encode_direct_out_ga(Ys, Zs)) -> encode_direct_out_ga(.(X, Xs), .(Z, Zs))

The argument filtering Pi contains the following mapping:
encode_direct_in_ga(x1, x2)  =  encode_direct_in_ga(x1)

[]  =  []

encode_direct_out_ga(x1, x2)  =  encode_direct_out_ga

.(x1, x2)  =  .(x1, x2)

U1_ga(x1, x2, x3, x4, x5)  =  U1_ga(x5)

count_in_ggaga(x1, x2, x3, x4, x5)  =  count_in_ggaga(x1, x2, x4)

1  =  1

count_out_ggaga(x1, x2, x3, x4, x5)  =  count_out_ggaga(x3)

U3_ggaga(x1, x2, x3)  =  U3_ggaga(x3)

>_in_gg(x1, x2)  =  >_in_gg(x1, x2)

>_out_gg(x1, x2)  =  >_out_gg

U4_ggaga(x1, x2, x3, x4)  =  U4_ggaga(x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U5_ggaga(x1, x2, x3, x4, x5)  =  U5_ggaga(x1, x2, x3, x5)

U6_ggaga(x1, x2, x3, x4, x5)  =  U6_ggaga(x2, x3, x5)

U7_ggaga(x1, x2, x3, x4, x5, x6)  =  U7_ggaga(x1, x2, x6)

is_in_ag(x1, x2)  =  is_in_ag(x2)

is_out_ag(x1, x2)  =  is_out_ag

+(x1, x2)  =  +(x1, x2)

U8_ggaga(x1, x2, x3, x4, x5, x6)  =  U8_ggaga(x6)

count_in_ggaaa(x1, x2, x3, x4, x5)  =  count_in_ggaaa(x1, x2)

count_out_ggaaa(x1, x2, x3, x4, x5)  =  count_out_ggaaa(x3)

U3_ggaaa(x1, x2, x3)  =  U3_ggaaa(x3)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

U4_ggaaa(x1, x2, x3, x4)  =  U4_ggaaa(x2, x3, x4)

U5_ggaaa(x1, x2, x3, x4, x5)  =  U5_ggaaa(x1, x2, x3, x5)

U6_ggaaa(x1, x2, x3, x4, x5)  =  U6_ggaaa(x2, x3, x5)

U7_ggaaa(x1, x2, x3, x4, x5, x6)  =  U7_ggaaa(x1, x2, x6)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

U8_ggaaa(x1, x2, x3, x4, x5, x6)  =  U8_ggaaa(x6)

U2_ga(x1, x2, x3, x4, x5)  =  U2_ga(x5)

COUNT_IN_GGAAA(x1, x2, x3, x4, x5)  =  COUNT_IN_GGAAA(x1, x2)

U7_GGAAA(x1, x2, x3, x4, x5, x6)  =  U7_GGAAA(x1, x2, x6)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(10) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(11)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   COUNT_IN_GGAAA(X, .(X, Xs), Ys, K, T) -> U7_GGAAA(X, Xs, Ys, K, T, is_in_aa(K1, +(K, 1)))
   U7_GGAAA(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> COUNT_IN_GGAAA(X, Xs, Ys, K1, T)

The TRS R consists of the following rules:

   is_in_aa(X0, X1) -> is_out_aa(X0, X1)

The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

1  =  1

+(x1, x2)  =  +(x1, x2)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

COUNT_IN_GGAAA(x1, x2, x3, x4, x5)  =  COUNT_IN_GGAAA(x1, x2)

U7_GGAAA(x1, x2, x3, x4, x5, x6)  =  U7_GGAAA(x1, x2, x6)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(12) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(13)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   COUNT_IN_GGAAA(X, .(X, Xs)) -> U7_GGAAA(X, Xs, is_in_aa)
   U7_GGAAA(X, Xs, is_out_aa) -> COUNT_IN_GGAAA(X, Xs)

The TRS R consists of the following rules:

   is_in_aa -> is_out_aa

The set Q consists of the following terms:

   is_in_aa

We have to consider all (P,Q,R)-chains.
----------------------------------------

(14) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*U7_GGAAA(X, Xs, is_out_aa) -> COUNT_IN_GGAAA(X, Xs)
The graph contains the following edges 1 >= 1, 2 >= 2


*COUNT_IN_GGAAA(X, .(X, Xs)) -> U7_GGAAA(X, Xs, is_in_aa)
The graph contains the following edges 1 >= 1, 2 > 1, 2 > 2


----------------------------------------

(15)
YES

----------------------------------------

(16)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_GA(X, Xs, Z, Zs, count_out_ggaga(X, Xs, Ys, 1, Z)) -> ENCODE_DIRECT_IN_GA(Ys, Zs)
   ENCODE_DIRECT_IN_GA(.(X, Xs), .(Z, Zs)) -> U1_GA(X, Xs, Z, Zs, count_in_ggaga(X, Xs, Ys, 1, Z))

The TRS R consists of the following rules:

   encode_direct_in_ga([], []) -> encode_direct_out_ga([], [])
   encode_direct_in_ga(.(X, Xs), .(Z, Zs)) -> U1_ga(X, Xs, Z, Zs, count_in_ggaga(X, Xs, Ys, 1, Z))
   count_in_ggaga(X, [], [], 1, X) -> count_out_ggaga(X, [], [], 1, X)
   count_in_ggaga(X, [], [], N, .(N, .(X, []))) -> U3_ggaga(X, N, >_in_gg(N, 1))
   >_in_gg(X0, X1) -> >_out_gg(X0, X1)
   U3_ggaga(X, N, >_out_gg(N, 1)) -> count_out_ggaga(X, [], [], N, .(N, .(X, [])))
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaga(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U4_ggaga(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X)
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaga(X, Y, Ys, N, >_in_gg(N, 1))
   U5_ggaga(X, Y, Ys, N, >_out_gg(N, 1)) -> U6_ggaga(X, Y, Ys, N, \=_in_gg(X, Y))
   U6_ggaga(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   count_in_ggaga(X, .(X, Xs), Ys, K, T) -> U7_ggaga(X, Xs, Ys, K, T, is_in_ag(K1, +(K, 1)))
   is_in_ag(X0, X1) -> is_out_ag(X0, X1)
   U7_ggaga(X, Xs, Ys, K, T, is_out_ag(K1, +(K, 1))) -> U8_ggaga(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   count_in_ggaaa(X, [], [], 1, X) -> count_out_ggaaa(X, [], [], 1, X)
   count_in_ggaaa(X, [], [], N, .(N, .(X, []))) -> U3_ggaaa(X, N, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U3_ggaaa(X, N, >_out_ag(N, 1)) -> count_out_ggaaa(X, [], [], N, .(N, .(X, [])))
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaaa(X, Y, Ys, \=_in_gg(X, Y))
   U4_ggaaa(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X)
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaaa(X, Y, Ys, N, >_in_ag(N, 1))
   U5_ggaaa(X, Y, Ys, N, >_out_ag(N, 1)) -> U6_ggaaa(X, Y, Ys, N, \=_in_gg(X, Y))
   U6_ggaaa(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   count_in_ggaaa(X, .(X, Xs), Ys, K, T) -> U7_ggaaa(X, Xs, Ys, K, T, is_in_aa(K1, +(K, 1)))
   is_in_aa(X0, X1) -> is_out_aa(X0, X1)
   U7_ggaaa(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> U8_ggaaa(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   U8_ggaaa(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaaa(X, .(X, Xs), Ys, K, T)
   U8_ggaga(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaga(X, .(X, Xs), Ys, K, T)
   U1_ga(X, Xs, Z, Zs, count_out_ggaga(X, Xs, Ys, 1, Z)) -> U2_ga(X, Xs, Z, Zs, encode_direct_in_ga(Ys, Zs))
   U2_ga(X, Xs, Z, Zs, encode_direct_out_ga(Ys, Zs)) -> encode_direct_out_ga(.(X, Xs), .(Z, Zs))

The argument filtering Pi contains the following mapping:
encode_direct_in_ga(x1, x2)  =  encode_direct_in_ga(x1)

[]  =  []

encode_direct_out_ga(x1, x2)  =  encode_direct_out_ga

.(x1, x2)  =  .(x1, x2)

U1_ga(x1, x2, x3, x4, x5)  =  U1_ga(x5)

count_in_ggaga(x1, x2, x3, x4, x5)  =  count_in_ggaga(x1, x2, x4)

1  =  1

count_out_ggaga(x1, x2, x3, x4, x5)  =  count_out_ggaga(x3)

U3_ggaga(x1, x2, x3)  =  U3_ggaga(x3)

>_in_gg(x1, x2)  =  >_in_gg(x1, x2)

>_out_gg(x1, x2)  =  >_out_gg

U4_ggaga(x1, x2, x3, x4)  =  U4_ggaga(x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U5_ggaga(x1, x2, x3, x4, x5)  =  U5_ggaga(x1, x2, x3, x5)

U6_ggaga(x1, x2, x3, x4, x5)  =  U6_ggaga(x2, x3, x5)

U7_ggaga(x1, x2, x3, x4, x5, x6)  =  U7_ggaga(x1, x2, x6)

is_in_ag(x1, x2)  =  is_in_ag(x2)

is_out_ag(x1, x2)  =  is_out_ag

+(x1, x2)  =  +(x1, x2)

U8_ggaga(x1, x2, x3, x4, x5, x6)  =  U8_ggaga(x6)

count_in_ggaaa(x1, x2, x3, x4, x5)  =  count_in_ggaaa(x1, x2)

count_out_ggaaa(x1, x2, x3, x4, x5)  =  count_out_ggaaa(x3)

U3_ggaaa(x1, x2, x3)  =  U3_ggaaa(x3)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

U4_ggaaa(x1, x2, x3, x4)  =  U4_ggaaa(x2, x3, x4)

U5_ggaaa(x1, x2, x3, x4, x5)  =  U5_ggaaa(x1, x2, x3, x5)

U6_ggaaa(x1, x2, x3, x4, x5)  =  U6_ggaaa(x2, x3, x5)

U7_ggaaa(x1, x2, x3, x4, x5, x6)  =  U7_ggaaa(x1, x2, x6)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

U8_ggaaa(x1, x2, x3, x4, x5, x6)  =  U8_ggaaa(x6)

U2_ga(x1, x2, x3, x4, x5)  =  U2_ga(x5)

ENCODE_DIRECT_IN_GA(x1, x2)  =  ENCODE_DIRECT_IN_GA(x1)

U1_GA(x1, x2, x3, x4, x5)  =  U1_GA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(17) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(18)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_GA(X, Xs, Z, Zs, count_out_ggaga(X, Xs, Ys, 1, Z)) -> ENCODE_DIRECT_IN_GA(Ys, Zs)
   ENCODE_DIRECT_IN_GA(.(X, Xs), .(Z, Zs)) -> U1_GA(X, Xs, Z, Zs, count_in_ggaga(X, Xs, Ys, 1, Z))

The TRS R consists of the following rules:

   count_in_ggaga(X, [], [], 1, X) -> count_out_ggaga(X, [], [], 1, X)
   count_in_ggaga(X, [], [], N, .(N, .(X, []))) -> U3_ggaga(X, N, >_in_gg(N, 1))
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaga(X, Y, Ys, \=_in_gg(X, Y))
   count_in_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaga(X, Y, Ys, N, >_in_gg(N, 1))
   count_in_ggaga(X, .(X, Xs), Ys, K, T) -> U7_ggaga(X, Xs, Ys, K, T, is_in_ag(K1, +(K, 1)))
   U3_ggaga(X, N, >_out_gg(N, 1)) -> count_out_ggaga(X, [], [], N, .(N, .(X, [])))
   U4_ggaga(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), 1, X)
   U5_ggaga(X, Y, Ys, N, >_out_gg(N, 1)) -> U6_ggaga(X, Y, Ys, N, \=_in_gg(X, Y))
   U7_ggaga(X, Xs, Ys, K, T, is_out_ag(K1, +(K, 1))) -> U8_ggaga(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   >_in_gg(X0, X1) -> >_out_gg(X0, X1)
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U6_ggaga(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaga(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   is_in_ag(X0, X1) -> is_out_ag(X0, X1)
   U8_ggaga(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaga(X, .(X, Xs), Ys, K, T)
   count_in_ggaaa(X, [], [], 1, X) -> count_out_ggaaa(X, [], [], 1, X)
   count_in_ggaaa(X, [], [], N, .(N, .(X, []))) -> U3_ggaaa(X, N, >_in_ag(N, 1))
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X) -> U4_ggaaa(X, Y, Ys, \=_in_gg(X, Y))
   count_in_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, []))) -> U5_ggaaa(X, Y, Ys, N, >_in_ag(N, 1))
   count_in_ggaaa(X, .(X, Xs), Ys, K, T) -> U7_ggaaa(X, Xs, Ys, K, T, is_in_aa(K1, +(K, 1)))
   U3_ggaaa(X, N, >_out_ag(N, 1)) -> count_out_ggaaa(X, [], [], N, .(N, .(X, [])))
   U4_ggaaa(X, Y, Ys, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), 1, X)
   U5_ggaaa(X, Y, Ys, N, >_out_ag(N, 1)) -> U6_ggaaa(X, Y, Ys, N, \=_in_gg(X, Y))
   U7_ggaaa(X, Xs, Ys, K, T, is_out_aa(K1, +(K, 1))) -> U8_ggaaa(X, Xs, Ys, K, T, count_in_ggaaa(X, Xs, Ys, K1, T))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U6_ggaaa(X, Y, Ys, N, \=_out_gg(X, Y)) -> count_out_ggaaa(X, .(Y, Ys), .(Y, Ys), N, .(N, .(X, [])))
   is_in_aa(X0, X1) -> is_out_aa(X0, X1)
   U8_ggaaa(X, Xs, Ys, K, T, count_out_ggaaa(X, Xs, Ys, K1, T)) -> count_out_ggaaa(X, .(X, Xs), Ys, K, T)

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

count_in_ggaga(x1, x2, x3, x4, x5)  =  count_in_ggaga(x1, x2, x4)

1  =  1

count_out_ggaga(x1, x2, x3, x4, x5)  =  count_out_ggaga(x3)

U3_ggaga(x1, x2, x3)  =  U3_ggaga(x3)

>_in_gg(x1, x2)  =  >_in_gg(x1, x2)

>_out_gg(x1, x2)  =  >_out_gg

U4_ggaga(x1, x2, x3, x4)  =  U4_ggaga(x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U5_ggaga(x1, x2, x3, x4, x5)  =  U5_ggaga(x1, x2, x3, x5)

U6_ggaga(x1, x2, x3, x4, x5)  =  U6_ggaga(x2, x3, x5)

U7_ggaga(x1, x2, x3, x4, x5, x6)  =  U7_ggaga(x1, x2, x6)

is_in_ag(x1, x2)  =  is_in_ag(x2)

is_out_ag(x1, x2)  =  is_out_ag

+(x1, x2)  =  +(x1, x2)

U8_ggaga(x1, x2, x3, x4, x5, x6)  =  U8_ggaga(x6)

count_in_ggaaa(x1, x2, x3, x4, x5)  =  count_in_ggaaa(x1, x2)

count_out_ggaaa(x1, x2, x3, x4, x5)  =  count_out_ggaaa(x3)

U3_ggaaa(x1, x2, x3)  =  U3_ggaaa(x3)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

U4_ggaaa(x1, x2, x3, x4)  =  U4_ggaaa(x2, x3, x4)

U5_ggaaa(x1, x2, x3, x4, x5)  =  U5_ggaaa(x1, x2, x3, x5)

U6_ggaaa(x1, x2, x3, x4, x5)  =  U6_ggaaa(x2, x3, x5)

U7_ggaaa(x1, x2, x3, x4, x5, x6)  =  U7_ggaaa(x1, x2, x6)

is_in_aa(x1, x2)  =  is_in_aa

is_out_aa(x1, x2)  =  is_out_aa

U8_ggaaa(x1, x2, x3, x4, x5, x6)  =  U8_ggaaa(x6)

ENCODE_DIRECT_IN_GA(x1, x2)  =  ENCODE_DIRECT_IN_GA(x1)

U1_GA(x1, x2, x3, x4, x5)  =  U1_GA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(19) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GA(count_out_ggaga(Ys)) -> ENCODE_DIRECT_IN_GA(Ys)
   ENCODE_DIRECT_IN_GA(.(X, Xs)) -> U1_GA(count_in_ggaga(X, Xs, 1))

The TRS R consists of the following rules:

   count_in_ggaga(X, [], 1) -> count_out_ggaga([])
   count_in_ggaga(X, [], N) -> U3_ggaga(>_in_gg(N, 1))
   count_in_ggaga(X, .(Y, Ys), 1) -> U4_ggaga(Y, Ys, \=_in_gg(X, Y))
   count_in_ggaga(X, .(Y, Ys), N) -> U5_ggaga(X, Y, Ys, >_in_gg(N, 1))
   count_in_ggaga(X, .(X, Xs), K) -> U7_ggaga(X, Xs, is_in_ag(+(K, 1)))
   U3_ggaga(>_out_gg) -> count_out_ggaga([])
   U4_ggaga(Y, Ys, \=_out_gg) -> count_out_ggaga(.(Y, Ys))
   U5_ggaga(X, Y, Ys, >_out_gg) -> U6_ggaga(Y, Ys, \=_in_gg(X, Y))
   U7_ggaga(X, Xs, is_out_ag) -> U8_ggaga(count_in_ggaaa(X, Xs))
   >_in_gg(X0, X1) -> >_out_gg
   \=_in_gg(X0, X1) -> \=_out_gg
   U6_ggaga(Y, Ys, \=_out_gg) -> count_out_ggaga(.(Y, Ys))
   is_in_ag(X1) -> is_out_ag
   U8_ggaga(count_out_ggaaa(Ys)) -> count_out_ggaga(Ys)
   count_in_ggaaa(X, []) -> count_out_ggaaa([])
   count_in_ggaaa(X, []) -> U3_ggaaa(>_in_ag(1))
   count_in_ggaaa(X, .(Y, Ys)) -> U4_ggaaa(Y, Ys, \=_in_gg(X, Y))
   count_in_ggaaa(X, .(Y, Ys)) -> U5_ggaaa(X, Y, Ys, >_in_ag(1))
   count_in_ggaaa(X, .(X, Xs)) -> U7_ggaaa(X, Xs, is_in_aa)
   U3_ggaaa(>_out_ag) -> count_out_ggaaa([])
   U4_ggaaa(Y, Ys, \=_out_gg) -> count_out_ggaaa(.(Y, Ys))
   U5_ggaaa(X, Y, Ys, >_out_ag) -> U6_ggaaa(Y, Ys, \=_in_gg(X, Y))
   U7_ggaaa(X, Xs, is_out_aa) -> U8_ggaaa(count_in_ggaaa(X, Xs))
   >_in_ag(X1) -> >_out_ag
   U6_ggaaa(Y, Ys, \=_out_gg) -> count_out_ggaaa(.(Y, Ys))
   is_in_aa -> is_out_aa
   U8_ggaaa(count_out_ggaaa(Ys)) -> count_out_ggaaa(Ys)

The set Q consists of the following terms:

   count_in_ggaga(x0, x1, x2)
   U3_ggaga(x0)
   U4_ggaga(x0, x1, x2)
   U5_ggaga(x0, x1, x2, x3)
   U7_ggaga(x0, x1, x2)
   >_in_gg(x0, x1)
   \=_in_gg(x0, x1)
   U6_ggaga(x0, x1, x2)
   is_in_ag(x0)
   U8_ggaga(x0)
   count_in_ggaaa(x0, x1)
   U3_ggaaa(x0)
   U4_ggaaa(x0, x1, x2)
   U5_ggaaa(x0, x1, x2, x3)
   U7_ggaaa(x0, x1, x2)
   >_in_ag(x0)
   U6_ggaaa(x0, x1, x2)
   is_in_aa
   U8_ggaaa(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(21) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   U1_GA(count_out_ggaga(Ys)) -> ENCODE_DIRECT_IN_GA(Ys)
   ENCODE_DIRECT_IN_GA(.(X, Xs)) -> U1_GA(count_in_ggaga(X, Xs, 1))

Strictly oriented rules of the TRS R:

   count_in_ggaga(X, .(Y, Ys), N) -> U5_ggaga(X, Y, Ys, >_in_gg(N, 1))
   count_in_ggaga(X, .(X, Xs), K) -> U7_ggaga(X, Xs, is_in_ag(+(K, 1)))
   U4_ggaga(Y, Ys, \=_out_gg) -> count_out_ggaga(.(Y, Ys))
   count_in_ggaaa(X, .(Y, Ys)) -> U4_ggaaa(Y, Ys, \=_in_gg(X, Y))
   count_in_ggaaa(X, .(Y, Ys)) -> U5_ggaaa(X, Y, Ys, >_in_ag(1))
   count_in_ggaaa(X, .(X, Xs)) -> U7_ggaaa(X, Xs, is_in_aa)

Used ordering: Polynomial interpretation [POLO]:

   POL(+(x_1, x_2)) = x_1 + x_2
   POL(.(x_1, x_2)) = 1 + x_1 + 2*x_2
   POL(1) = 0
   POL(>_in_ag(x_1)) = x_1
   POL(>_in_gg(x_1, x_2)) = x_1 + x_2
   POL(>_out_ag) = 0
   POL(>_out_gg) = 0
   POL(ENCODE_DIRECT_IN_GA(x_1)) = 2*x_1
   POL(U1_GA(x_1)) = 1 + 2*x_1
   POL(U3_ggaaa(x_1)) = 2*x_1
   POL(U3_ggaga(x_1)) = x_1
   POL(U4_ggaaa(x_1, x_2, x_3)) = 1 + x_1 + 2*x_2 + x_3
   POL(U4_ggaga(x_1, x_2, x_3)) = 2 + x_1 + 2*x_2 + x_3
   POL(U5_ggaaa(x_1, x_2, x_3, x_4)) = 1 + x_1 + 2*x_2 + 2*x_3 + 2*x_4
   POL(U5_ggaga(x_1, x_2, x_3, x_4)) = 1 + x_1 + 2*x_2 + 2*x_3 + x_4
   POL(U6_ggaaa(x_1, x_2, x_3)) = 1 + x_1 + 2*x_2 + x_3
   POL(U6_ggaga(x_1, x_2, x_3)) = 1 + x_1 + 2*x_2 + x_3
   POL(U7_ggaaa(x_1, x_2, x_3)) = 2*x_1 + 2*x_2 + 2*x_3
   POL(U7_ggaga(x_1, x_2, x_3)) = 2*x_1 + 2*x_2 + 2*x_3
   POL(U8_ggaaa(x_1)) = x_1
   POL(U8_ggaga(x_1)) = x_1
   POL([]) = 0
   POL(\=_in_gg(x_1, x_2)) = x_1 + x_2
   POL(\=_out_gg) = 0
   POL(count_in_ggaaa(x_1, x_2)) = x_1 + 2*x_2
   POL(count_in_ggaga(x_1, x_2, x_3)) = x_1 + 2*x_2 + 2*x_3
   POL(count_out_ggaaa(x_1)) = x_1
   POL(count_out_ggaga(x_1)) = x_1
   POL(is_in_aa) = 0
   POL(is_in_ag(x_1)) = x_1
   POL(is_out_aa) = 0
   POL(is_out_ag) = 0


----------------------------------------

(22)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   count_in_ggaga(X, [], 1) -> count_out_ggaga([])
   count_in_ggaga(X, [], N) -> U3_ggaga(>_in_gg(N, 1))
   count_in_ggaga(X, .(Y, Ys), 1) -> U4_ggaga(Y, Ys, \=_in_gg(X, Y))
   U3_ggaga(>_out_gg) -> count_out_ggaga([])
   U5_ggaga(X, Y, Ys, >_out_gg) -> U6_ggaga(Y, Ys, \=_in_gg(X, Y))
   U7_ggaga(X, Xs, is_out_ag) -> U8_ggaga(count_in_ggaaa(X, Xs))
   >_in_gg(X0, X1) -> >_out_gg
   \=_in_gg(X0, X1) -> \=_out_gg
   U6_ggaga(Y, Ys, \=_out_gg) -> count_out_ggaga(.(Y, Ys))
   is_in_ag(X1) -> is_out_ag
   U8_ggaga(count_out_ggaaa(Ys)) -> count_out_ggaga(Ys)
   count_in_ggaaa(X, []) -> count_out_ggaaa([])
   count_in_ggaaa(X, []) -> U3_ggaaa(>_in_ag(1))
   U3_ggaaa(>_out_ag) -> count_out_ggaaa([])
   U4_ggaaa(Y, Ys, \=_out_gg) -> count_out_ggaaa(.(Y, Ys))
   U5_ggaaa(X, Y, Ys, >_out_ag) -> U6_ggaaa(Y, Ys, \=_in_gg(X, Y))
   U7_ggaaa(X, Xs, is_out_aa) -> U8_ggaaa(count_in_ggaaa(X, Xs))
   >_in_ag(X1) -> >_out_ag
   U6_ggaaa(Y, Ys, \=_out_gg) -> count_out_ggaaa(.(Y, Ys))
   is_in_aa -> is_out_aa
   U8_ggaaa(count_out_ggaaa(Ys)) -> count_out_ggaaa(Ys)

The set Q consists of the following terms:

   count_in_ggaga(x0, x1, x2)
   U3_ggaga(x0)
   U4_ggaga(x0, x1, x2)
   U5_ggaga(x0, x1, x2, x3)
   U7_ggaga(x0, x1, x2)
   >_in_gg(x0, x1)
   \=_in_gg(x0, x1)
   U6_ggaga(x0, x1, x2)
   is_in_ag(x0)
   U8_ggaga(x0)
   count_in_ggaaa(x0, x1)
   U3_ggaaa(x0)
   U4_ggaaa(x0, x1, x2)
   U5_ggaaa(x0, x1, x2, x3)
   U7_ggaaa(x0, x1, x2)
   >_in_ag(x0)
   U6_ggaaa(x0, x1, x2)
   is_in_aa
   U8_ggaaa(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(23) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(24)
YES
