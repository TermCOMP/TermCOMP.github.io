YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/L5gQz.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

dyck(g)

w.r.t. the given Prolog program could successfully be proven:

(0) Prolog
(1) PrologToTRSTransformerProof [SOUND, 0 ms]
(2) QTRS
(3) RisEmptyProof [EQUIVALENT, 0 ms]
(4) YES


----------------------------------------

(0)
Obligation:
Clauses:

dyck(X) :- ','(grammar(G), ','(-(terminal, string(X)), produces(G, X))).
grammar(S) :- =(S, or(e, or(and(S, S), and(o, and(S, c))))).
equal(X, X).
-(terminal, string(nil)).
-(terminal, string(and(A, X))) :- ','(terminal(A), -(terminal, string(X))).
terminal(o).
terminal(c).
terminal(e).
produces(G, X) :- gives(G, X, nil).
gives(or(P, Q), X, Y) :- gives(P, X, Y).
gives(or(P, Q), X, Y) :- gives(Q, X, Y).
gives(and(P, Q), X, Z) :- ','(gives(P, X, Y), gives(Q, Y, Z)).
gives(A, and(A, X), X) :- terminal(A).


Query: dyck(g)
----------------------------------------

(1) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(dyck X)",
                "(',' (grammar G) (',' (- (terminal) (string X)) (produces G X)))"
            ],
            [
                "(grammar S)",
                "(= S (or (e) (or (and S S) (and (o) (and S (c))))))"
            ],
            [
                "(equal X X)",
                null
            ],
            [
                "(- (terminal) (string (nil)))",
                null
            ],
            [
                "(- (terminal) (string (and A X)))",
                "(',' (terminal A) (- (terminal) (string X)))"
            ],
            [
                "(terminal (o))",
                null
            ],
            [
                "(terminal (c))",
                null
            ],
            [
                "(terminal (e))",
                null
            ],
            [
                "(produces G X)",
                "(gives G X (nil))"
            ],
            [
                "(gives (or P Q) X Y)",
                "(gives P X Y)"
            ],
            [
                "(gives (or P Q) X Y)",
                "(gives Q X Y)"
            ],
            [
                "(gives (and P Q) X Z)",
                "(',' (gives P X Y) (gives Q Y Z))"
            ],
            [
                "(gives A (and A X) X)",
                "(terminal A)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(dyck T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "2": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(dyck T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "38": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (= X11 (or (e) (or (and X11 X11) (and (o) (and X11 (c)))))) (',' (- (terminal) (string T4)) (produces X11 T4)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "39": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "9": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (grammar X5) (',' (- (terminal) (string T4)) (produces X5 T4)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": ["X5"],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "31": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(',' (grammar X5) (',' (- (terminal) (string T4)) (produces X5 T4)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": ["X5"],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 1,
                "to": 2,
                "label": "CASE"
            },
            {
                "from": 2,
                "to": 9,
                "label": "ONLY EVAL with clause\ndyck(X4) :- ','(grammar(X5), ','(-(terminal, string(X4)), produces(X5, X4))).\nand substitutionT1 -> T4,\nX4 -> T4"
            },
            {
                "from": 9,
                "to": 31,
                "label": "CASE"
            },
            {
                "from": 31,
                "to": 38,
                "label": "ONLY EVAL with clause\ngrammar(X10) :- =(X10, or(e, or(and(X10, X10), and(o, and(X10, c))))).\nand substitutionX5 -> X11,\nX10 -> X11"
            },
            {
                "from": 38,
                "to": 39,
                "label": "UNIFY-FAIL\nbecause of non-unification"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
R is empty.
Q is empty.

----------------------------------------

(3) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(4)
YES
