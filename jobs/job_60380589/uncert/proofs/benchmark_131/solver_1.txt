Graph construction failed
Graph construction failed
Graph construction failed
MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/HtH7Q.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

encode_modified(g,a)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) IntegerArithmeticTransformerProof [SOUND, 0 ms]
(2) Prolog
    (3) UnifyTransformerProof [EQUIVALENT, 0 ms]
    (4) Prolog
    (5) UndefinedPredicateHandlerProof [SOUND, 0 ms]
    (6) Prolog
    (7) PrologToPiTRSProof [SOUND, 0 ms]
    (8) PiTRS
        (9) DependencyPairsProof [EQUIVALENT, 9 ms]
        (10) PiDP
        (11) DependencyGraphProof [EQUIVALENT, 0 ms]
        (12) AND
            (13) PiDP
                (14) UsableRulesProof [EQUIVALENT, 0 ms]
                (15) PiDP
                (16) PiDPToQDPProof [SOUND, 0 ms]
                (17) QDP
                (18) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                (19) YES
            (20) PiDP
                (21) UsableRulesProof [EQUIVALENT, 0 ms]
                (22) PiDP
                (23) PiDPToQDPProof [SOUND, 0 ms]
                (24) QDP
                (25) MRRProof [EQUIVALENT, 30 ms]
                (26) QDP
                (27) UsableRulesReductionPairsProof [EQUIVALENT, 9 ms]
                (28) QDP
                (29) QReductionProof [EQUIVALENT, 0 ms]
                (30) QDP
                (31) TransformationProof [EQUIVALENT, 0 ms]
                (32) QDP
                (33) UsableRulesProof [EQUIVALENT, 0 ms]
                (34) QDP
                (35) QReductionProof [EQUIVALENT, 0 ms]
                (36) QDP
                (37) TransformationProof [EQUIVALENT, 0 ms]
                (38) QDP
                (39) UsableRulesProof [EQUIVALENT, 0 ms]
                (40) QDP
                (41) QReductionProof [EQUIVALENT, 0 ms]
                (42) QDP
                (43) TransformationProof [EQUIVALENT, 0 ms]
                (44) QDP
                (45) TransformationProof [EQUIVALENT, 0 ms]
                (46) QDP
                (47) UsableRulesProof [EQUIVALENT, 0 ms]
                (48) QDP
                (49) TransformationProof [EQUIVALENT, 0 ms]
                (50) QDP
                (51) UsableRulesProof [EQUIVALENT, 0 ms]
                (52) QDP
                (53) QReductionProof [EQUIVALENT, 0 ms]
                (54) QDP
                (55) TransformationProof [EQUIVALENT, 0 ms]
                (56) QDP
                (57) UsableRulesProof [EQUIVALENT, 0 ms]
                (58) QDP
                (59) QReductionProof [EQUIVALENT, 0 ms]
                (60) QDP
                (61) TransformationProof [EQUIVALENT, 0 ms]
                (62) QDP
                (63) NonTerminationLoopProof [COMPLETE, 0 ms]
                (64) NO
            (65) PiDP
                (66) UsableRulesProof [EQUIVALENT, 0 ms]
                (67) PiDP
                (68) PiDPToQDPProof [SOUND, 0 ms]
                (69) QDP
                (70) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                (71) YES
            (72) PiDP
                (73) UsableRulesProof [EQUIVALENT, 0 ms]
                (74) PiDP
                (75) PiDPToQDPProof [SOUND, 0 ms]
                (76) QDP
                (77) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                (78) YES
            (79) PiDP
                (80) UsableRulesProof [EQUIVALENT, 0 ms]
                (81) PiDP
                (82) PiDPToQDPProof [SOUND, 0 ms]
                (83) QDP
                (84) QDPQMonotonicMRRProof [EQUIVALENT, 8 ms]
                (85) QDP
                (86) DependencyGraphProof [EQUIVALENT, 0 ms]
                (87) TRUE
    (88) PrologToPiTRSProof [SOUND, 11 ms]
    (89) PiTRS
        (90) DependencyPairsProof [EQUIVALENT, 0 ms]
        (91) PiDP
        (92) DependencyGraphProof [EQUIVALENT, 0 ms]
        (93) AND
            (94) PiDP
                (95) UsableRulesProof [EQUIVALENT, 0 ms]
                (96) PiDP
                (97) PiDPToQDPProof [SOUND, 0 ms]
                (98) QDP
                (99) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                (100) YES
            (101) PiDP
                (102) UsableRulesProof [EQUIVALENT, 0 ms]
                (103) PiDP
                (104) PiDPToQDPProof [SOUND, 0 ms]
                (105) QDP
                (106) UsableRulesReductionPairsProof [EQUIVALENT, 20 ms]
                (107) QDP
                (108) UsableRulesProof [EQUIVALENT, 0 ms]
                (109) QDP
                (110) QReductionProof [EQUIVALENT, 0 ms]
                (111) QDP
                (112) TransformationProof [EQUIVALENT, 0 ms]
                (113) QDP
                (114) UsableRulesProof [EQUIVALENT, 0 ms]
                (115) QDP
                (116) QReductionProof [EQUIVALENT, 0 ms]
                (117) QDP
                (118) TransformationProof [EQUIVALENT, 0 ms]
                (119) QDP
                (120) UsableRulesProof [EQUIVALENT, 0 ms]
                (121) QDP
                (122) QReductionProof [EQUIVALENT, 0 ms]
                (123) QDP
                (124) TransformationProof [EQUIVALENT, 0 ms]
                (125) QDP
                (126) TransformationProof [EQUIVALENT, 0 ms]
                (127) QDP
                (128) UsableRulesProof [EQUIVALENT, 0 ms]
                (129) QDP
                (130) TransformationProof [EQUIVALENT, 0 ms]
                (131) QDP
                (132) UsableRulesProof [EQUIVALENT, 0 ms]
                (133) QDP
                (134) QReductionProof [EQUIVALENT, 0 ms]
                (135) QDP
                (136) TransformationProof [EQUIVALENT, 0 ms]
                (137) QDP
                (138) UsableRulesProof [EQUIVALENT, 0 ms]
                (139) QDP
                (140) QReductionProof [EQUIVALENT, 0 ms]
                (141) QDP
                (142) NonTerminationLoopProof [COMPLETE, 0 ms]
                (143) NO
            (144) PiDP
                (145) UsableRulesProof [EQUIVALENT, 0 ms]
                (146) PiDP
                (147) PiDPToQDPProof [SOUND, 0 ms]
                (148) QDP
                (149) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                (150) YES
            (151) PiDP
                (152) UsableRulesProof [EQUIVALENT, 0 ms]
                (153) PiDP
                (154) PiDPToQDPProof [SOUND, 0 ms]
                (155) QDP
                (156) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                (157) YES
            (158) PiDP
                (159) UsableRulesProof [EQUIVALENT, 0 ms]
                (160) PiDP
                (161) PiDPToQDPProof [SOUND, 0 ms]
                (162) QDP
                (163) QDPQMonotonicMRRProof [EQUIVALENT, 5 ms]
                (164) QDP
                (165) DependencyGraphProof [EQUIVALENT, 0 ms]
                (166) TRUE
(167) UndefinedPredicateHandlerProof [SOUND, 0 ms]
(168) Prolog
    (169) PrologToPiTRSProof [SOUND, 0 ms]
    (170) PiTRS
        (171) DependencyPairsProof [EQUIVALENT, 6 ms]
        (172) PiDP
        (173) DependencyGraphProof [EQUIVALENT, 0 ms]
        (174) AND
            (175) PiDP
                (176) UsableRulesProof [EQUIVALENT, 0 ms]
                (177) PiDP
                (178) PiDPToQDPProof [SOUND, 0 ms]
                (179) QDP
                (180) TransformationProof [EQUIVALENT, 0 ms]
                (181) QDP
                (182) UsableRulesProof [EQUIVALENT, 0 ms]
                (183) QDP
                (184) QReductionProof [EQUIVALENT, 0 ms]
                (185) QDP
                (186) NonTerminationLoopProof [COMPLETE, 0 ms]
                (187) NO
            (188) PiDP
                (189) UsableRulesProof [EQUIVALENT, 0 ms]
                (190) PiDP
                (191) PiDPToQDPProof [SOUND, 0 ms]
                (192) QDP
                (193) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                (194) YES
            (195) PiDP
                (196) UsableRulesProof [EQUIVALENT, 0 ms]
                (197) PiDP
                (198) PiDPToQDPProof [SOUND, 0 ms]
                (199) QDP
                (200) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                (201) YES
            (202) PiDP
                (203) UsableRulesProof [EQUIVALENT, 0 ms]
                (204) PiDP
                (205) PiDPToQDPProof [SOUND, 0 ms]
                (206) QDP
                (207) QDPQMonotonicMRRProof [EQUIVALENT, 9 ms]
                (208) QDP
                (209) DependencyGraphProof [EQUIVALENT, 0 ms]
                (210) TRUE
    (211) PrologToPiTRSProof [SOUND, 0 ms]
    (212) PiTRS
        (213) DependencyPairsProof [EQUIVALENT, 11 ms]
        (214) PiDP
        (215) DependencyGraphProof [EQUIVALENT, 0 ms]
        (216) AND
            (217) PiDP
                (218) UsableRulesProof [EQUIVALENT, 0 ms]
                (219) PiDP
                (220) PiDPToQDPProof [SOUND, 0 ms]
                (221) QDP
                (222) TransformationProof [EQUIVALENT, 0 ms]
                (223) QDP
                (224) UsableRulesProof [EQUIVALENT, 0 ms]
                (225) QDP
                (226) QReductionProof [EQUIVALENT, 0 ms]
                (227) QDP
                (228) NonTerminationLoopProof [COMPLETE, 0 ms]
                (229) NO
            (230) PiDP
                (231) UsableRulesProof [EQUIVALENT, 0 ms]
                (232) PiDP
                (233) PiDPToQDPProof [SOUND, 0 ms]
                (234) QDP
                (235) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                (236) YES
            (237) PiDP
                (238) UsableRulesProof [EQUIVALENT, 0 ms]
                (239) PiDP
                (240) PiDPToQDPProof [SOUND, 0 ms]
                (241) QDP
                (242) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                (243) YES
            (244) PiDP
                (245) UsableRulesProof [EQUIVALENT, 0 ms]
                (246) PiDP
                (247) PiDPToQDPProof [SOUND, 0 ms]
                (248) QDP
                (249) QDPQMonotonicMRRProof [EQUIVALENT, 14 ms]
                (250) QDP
                (251) DependencyGraphProof [EQUIVALENT, 0 ms]
                (252) TRUE


----------------------------------------

(0)
Obligation:
Clauses:

encode_modified(L1, L2) :- ','(encode(L1, L), strip(L, L2)).
strip([], []).
strip(.(.(1, .(X, [])), Ys), .(X, Zs)) :- strip(Ys, Zs).
strip(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) :- ','(>(N, 1), strip(Ys, Zs)).
encode(L1, L2) :- ','(pack(L1, L), transform(L, L2)).
transform([], []).
transform(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) :- ','(length(.(X, Xs), N), transform(Ys, Zs)).
pack([], []).
pack(.(X, Xs), .(Z, Zs)) :- ','(transfer(X, Xs, Ys, Z), pack(Ys, Zs)).
transfer(X, [], [], .(X, [])).
transfer(X, .(Y, Ys), .(Y, Ys), .(X, [])) :- \=(X, Y).
transfer(X, .(X, Xs), Ys, .(X, Zs)) :- transfer(X, Xs, Ys, Zs).


Query: encode_modified(g,a)
----------------------------------------

(1) IntegerArithmeticTransformerProof (SOUND)
Added definitions of predefined predicates [PROLOG].
----------------------------------------

(2)
Obligation:
Clauses:

encode_modified(L1, L2) :- ','(encode(L1, L), strip(L, L2)).
strip([], []).
strip(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) :- strip(Ys, Zs).
strip(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) :- ','(=(X1, N), ','(=(X2, succ(zero)), ','(isGreater(X1, X2), strip(Ys, Zs)))).
encode(L1, L2) :- ','(pack(L1, L), transform(L, L2)).
transform([], []).
transform(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) :- ','(length(.(X, Xs), N), transform(Ys, Zs)).
pack([], []).
pack(.(X, Xs), .(Z, Zs)) :- ','(transfer(X, Xs, Ys, Z), pack(Ys, Zs)).
transfer(X, [], [], .(X, [])).
transfer(X, .(Y, Ys), .(Y, Ys), .(X, [])) :- \=(X, Y).
transfer(X, .(X, Xs), Ys, .(X, Zs)) :- transfer(X, Xs, Ys, Zs).
isPlus(zero, X, X).
isPlus(succ(X), zero, succ(X)).
isPlus(succ(X), succ(Y), succ(succ(Z))) :- isPlus(X, Y, Z).
isPlus(succ(X), pred(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), zero, pred(X)).
isPlus(pred(X), succ(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), pred(Y), pred(pred(Z))) :- isPlus(X, Y, Z).
isMinus(X, zero, X).
isMinus(zero, succ(Y), pred(Z)) :- isMinus(zero, Y, Z).
isMinus(zero, pred(Y), succ(Z)) :- isMinus(zero, Y, Z).
isMinus(succ(X), succ(Y), Z) :- isMinus(X, Y, Z).
isMinus(succ(X), pred(Y), succ(succ(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), succ(Y), pred(pred(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), pred(Y), Z) :- isMinus(X, Y, Z).
isTimes(X, zero, zero).
isTimes(zero, succ(Y), zero).
isTimes(zero, pred(Y), zero).
isTimes(succ(X), succ(Y), Z) :- ','(isTimes(succ(X), Y, A), isPlus(A, succ(X), Z)).
isTimes(succ(X), pred(Y), Z) :- ','(isTimes(succ(X), Y, A), isMinus(A, succ(X), Z)).
isTimes(pred(X), succ(Y), Z) :- ','(isTimes(pred(X), Y, A), isPlus(A, pred(X), Z)).
isTimes(pred(X), pred(Y), Z) :- ','(isTimes(pred(X), Y, A), isMinus(A, pred(X), Z)).
isDiv(zero, succ(Y), zero).
isDiv(zero, pred(Y), zero).
isDiv(succ(X), succ(Y), zero) :- isMinus(succ(X), succ(Y), pred(Z)).
isDiv(succ(X), succ(Y), succ(Z)) :- ','(isMinus(succ(X), succ(Y), A), isDiv(A, succ(Y), Z)).
isDiv(succ(X), pred(Y), Z) :- ','(isMinus(zero, pred(Y), A), ','(isDiv(succ(X), A, B), isMinus(zero, B, Z))).
isDiv(pred(X), pred(Y), zero) :- isMinus(pred(X), pred(Y), succ(Z)).
isDiv(pred(X), pred(Y), succ(Z)) :- ','(isMinus(pred(X), pred(Y), A), isDiv(A, pred(Y), Z)).
isDiv(pred(X), succ(Y), Z) :- ','(isMinus(zero, pred(X), A), ','(isDiv(A, succ(Y), B), isMinus(zero, B, Z))).
isModulo(X, Y, Z) :- ','(isDiv(X, Y, A), ','(isTimes(A, Y, B), isMinus(X, B, Z))).
isGreater(succ(X), zero).
isGreater(succ(X), pred(Y)).
isGreater(succ(X), succ(Y)) :- isGreater(X, Y).
isGreater(zero, pred(Y)).
isGreater(pred(X), pred(Y)) :- isGreater(X, Y).


Query: encode_modified(g,a)
----------------------------------------

(3) UnifyTransformerProof (EQUIVALENT)
Added a fact for the built-in = predicate [PROLOG].
----------------------------------------

(4)
Obligation:
Clauses:

encode_modified(L1, L2) :- ','(encode(L1, L), strip(L, L2)).
strip([], []).
strip(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) :- strip(Ys, Zs).
strip(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) :- ','(=(X1, N), ','(=(X2, succ(zero)), ','(isGreater(X1, X2), strip(Ys, Zs)))).
encode(L1, L2) :- ','(pack(L1, L), transform(L, L2)).
transform([], []).
transform(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) :- ','(length(.(X, Xs), N), transform(Ys, Zs)).
pack([], []).
pack(.(X, Xs), .(Z, Zs)) :- ','(transfer(X, Xs, Ys, Z), pack(Ys, Zs)).
transfer(X, [], [], .(X, [])).
transfer(X, .(Y, Ys), .(Y, Ys), .(X, [])) :- \=(X, Y).
transfer(X, .(X, Xs), Ys, .(X, Zs)) :- transfer(X, Xs, Ys, Zs).
isPlus(zero, X, X).
isPlus(succ(X), zero, succ(X)).
isPlus(succ(X), succ(Y), succ(succ(Z))) :- isPlus(X, Y, Z).
isPlus(succ(X), pred(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), zero, pred(X)).
isPlus(pred(X), succ(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), pred(Y), pred(pred(Z))) :- isPlus(X, Y, Z).
isMinus(X, zero, X).
isMinus(zero, succ(Y), pred(Z)) :- isMinus(zero, Y, Z).
isMinus(zero, pred(Y), succ(Z)) :- isMinus(zero, Y, Z).
isMinus(succ(X), succ(Y), Z) :- isMinus(X, Y, Z).
isMinus(succ(X), pred(Y), succ(succ(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), succ(Y), pred(pred(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), pred(Y), Z) :- isMinus(X, Y, Z).
isTimes(X, zero, zero).
isTimes(zero, succ(Y), zero).
isTimes(zero, pred(Y), zero).
isTimes(succ(X), succ(Y), Z) :- ','(isTimes(succ(X), Y, A), isPlus(A, succ(X), Z)).
isTimes(succ(X), pred(Y), Z) :- ','(isTimes(succ(X), Y, A), isMinus(A, succ(X), Z)).
isTimes(pred(X), succ(Y), Z) :- ','(isTimes(pred(X), Y, A), isPlus(A, pred(X), Z)).
isTimes(pred(X), pred(Y), Z) :- ','(isTimes(pred(X), Y, A), isMinus(A, pred(X), Z)).
isDiv(zero, succ(Y), zero).
isDiv(zero, pred(Y), zero).
isDiv(succ(X), succ(Y), zero) :- isMinus(succ(X), succ(Y), pred(Z)).
isDiv(succ(X), succ(Y), succ(Z)) :- ','(isMinus(succ(X), succ(Y), A), isDiv(A, succ(Y), Z)).
isDiv(succ(X), pred(Y), Z) :- ','(isMinus(zero, pred(Y), A), ','(isDiv(succ(X), A, B), isMinus(zero, B, Z))).
isDiv(pred(X), pred(Y), zero) :- isMinus(pred(X), pred(Y), succ(Z)).
isDiv(pred(X), pred(Y), succ(Z)) :- ','(isMinus(pred(X), pred(Y), A), isDiv(A, pred(Y), Z)).
isDiv(pred(X), succ(Y), Z) :- ','(isMinus(zero, pred(X), A), ','(isDiv(A, succ(Y), B), isMinus(zero, B, Z))).
isModulo(X, Y, Z) :- ','(isDiv(X, Y, A), ','(isTimes(A, Y, B), isMinus(X, B, Z))).
isGreater(succ(X), zero).
isGreater(succ(X), pred(Y)).
isGreater(succ(X), succ(Y)) :- isGreater(X, Y).
isGreater(zero, pred(Y)).
isGreater(pred(X), pred(Y)) :- isGreater(X, Y).
=(X, X).


Query: encode_modified(g,a)
----------------------------------------

(5) UndefinedPredicateHandlerProof (SOUND)
Added facts for all undefined predicates [PROLOG].
----------------------------------------

(6)
Obligation:
Clauses:

encode_modified(L1, L2) :- ','(encode(L1, L), strip(L, L2)).
strip([], []).
strip(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) :- strip(Ys, Zs).
strip(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) :- ','(=(X1, N), ','(=(X2, succ(zero)), ','(isGreater(X1, X2), strip(Ys, Zs)))).
encode(L1, L2) :- ','(pack(L1, L), transform(L, L2)).
transform([], []).
transform(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) :- ','(length(.(X, Xs), N), transform(Ys, Zs)).
pack([], []).
pack(.(X, Xs), .(Z, Zs)) :- ','(transfer(X, Xs, Ys, Z), pack(Ys, Zs)).
transfer(X, [], [], .(X, [])).
transfer(X, .(Y, Ys), .(Y, Ys), .(X, [])) :- \=(X, Y).
transfer(X, .(X, Xs), Ys, .(X, Zs)) :- transfer(X, Xs, Ys, Zs).
isPlus(zero, X, X).
isPlus(succ(X), zero, succ(X)).
isPlus(succ(X), succ(Y), succ(succ(Z))) :- isPlus(X, Y, Z).
isPlus(succ(X), pred(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), zero, pred(X)).
isPlus(pred(X), succ(Y), Z) :- isPlus(X, Y, Z).
isPlus(pred(X), pred(Y), pred(pred(Z))) :- isPlus(X, Y, Z).
isMinus(X, zero, X).
isMinus(zero, succ(Y), pred(Z)) :- isMinus(zero, Y, Z).
isMinus(zero, pred(Y), succ(Z)) :- isMinus(zero, Y, Z).
isMinus(succ(X), succ(Y), Z) :- isMinus(X, Y, Z).
isMinus(succ(X), pred(Y), succ(succ(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), succ(Y), pred(pred(Z))) :- isMinus(X, Y, Z).
isMinus(pred(X), pred(Y), Z) :- isMinus(X, Y, Z).
isTimes(X, zero, zero).
isTimes(zero, succ(Y), zero).
isTimes(zero, pred(Y), zero).
isTimes(succ(X), succ(Y), Z) :- ','(isTimes(succ(X), Y, A), isPlus(A, succ(X), Z)).
isTimes(succ(X), pred(Y), Z) :- ','(isTimes(succ(X), Y, A), isMinus(A, succ(X), Z)).
isTimes(pred(X), succ(Y), Z) :- ','(isTimes(pred(X), Y, A), isPlus(A, pred(X), Z)).
isTimes(pred(X), pred(Y), Z) :- ','(isTimes(pred(X), Y, A), isMinus(A, pred(X), Z)).
isDiv(zero, succ(Y), zero).
isDiv(zero, pred(Y), zero).
isDiv(succ(X), succ(Y), zero) :- isMinus(succ(X), succ(Y), pred(Z)).
isDiv(succ(X), succ(Y), succ(Z)) :- ','(isMinus(succ(X), succ(Y), A), isDiv(A, succ(Y), Z)).
isDiv(succ(X), pred(Y), Z) :- ','(isMinus(zero, pred(Y), A), ','(isDiv(succ(X), A, B), isMinus(zero, B, Z))).
isDiv(pred(X), pred(Y), zero) :- isMinus(pred(X), pred(Y), succ(Z)).
isDiv(pred(X), pred(Y), succ(Z)) :- ','(isMinus(pred(X), pred(Y), A), isDiv(A, pred(Y), Z)).
isDiv(pred(X), succ(Y), Z) :- ','(isMinus(zero, pred(X), A), ','(isDiv(A, succ(Y), B), isMinus(zero, B, Z))).
isModulo(X, Y, Z) :- ','(isDiv(X, Y, A), ','(isTimes(A, Y, B), isMinus(X, B, Z))).
isGreater(succ(X), zero).
isGreater(succ(X), pred(Y)).
isGreater(succ(X), succ(Y)) :- isGreater(X, Y).
isGreater(zero, pred(Y)).
isGreater(pred(X), pred(Y)) :- isGreater(X, Y).
=(X, X).
length(X0, X1).
\=(X0, X1).


Query: encode_modified(g,a)
----------------------------------------

(7) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

encode_modified_in_2: (b,f)

encode_in_2: (b,f)

pack_in_2: (b,f)

transfer_in_4: (b,b,f,f)

transform_in_2: (b,f)

strip_in_2: (f,f)

isGreater_in_2: (f,b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x2, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x1, x2, x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag(x2)

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x2, x3)

U50_ag(x1, x2, x3)  =  U50_ag(x2, x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(8)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x2, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x1, x2, x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag(x2)

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x2, x3)

U50_ag(x1, x2, x3)  =  U50_ag(x2, x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)



----------------------------------------

(9) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   ENCODE_MODIFIED_IN_GA(L1, L2) -> U1_GA(L1, L2, encode_in_ga(L1, L))
   ENCODE_MODIFIED_IN_GA(L1, L2) -> ENCODE_IN_GA(L1, L)
   ENCODE_IN_GA(L1, L2) -> U8_GA(L1, L2, pack_in_ga(L1, L))
   ENCODE_IN_GA(L1, L2) -> PACK_IN_GA(L1, L)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U12_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Z)
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_GGAA(X, Y, Ys, \=_in_gg(X, Y))
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> \=_IN_GG(X, Y)
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> U15_GGAA(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)
   U12_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_GA(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U12_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   U8_GA(L1, L2, pack_out_ga(L1, L)) -> U9_GA(L1, L2, transform_in_ga(L, L2))
   U8_GA(L1, L2, pack_out_ga(L1, L)) -> TRANSFORM_IN_GA(L, L2)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> LENGTH_IN_GA(.(X, Xs), N)
   U10_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_GA(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U10_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> U2_GA(L1, L2, strip_in_aa(L, L2))
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> STRIP_IN_AA(L, L2)
   STRIP_IN_AA(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_AA(X, Ys, Zs, strip_in_aa(Ys, Zs))
   STRIP_IN_AA(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, =_in_aa(X1, N))
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> =_IN_AA(X1, N)
   U4_AA(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_AA(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   U4_AA(N, X, Ys, Zs, =_out_aa(X1, N)) -> =_IN_AG(X2, succ(zero))
   U5_AA(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_AA(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   U5_AA(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> ISGREATER_IN_AG(X1, X2)
   ISGREATER_IN_AG(succ(X), succ(Y)) -> U49_AG(X, Y, isGreater_in_ag(X, Y))
   ISGREATER_IN_AG(succ(X), succ(Y)) -> ISGREATER_IN_AG(X, Y)
   ISGREATER_IN_AG(pred(X), pred(Y)) -> U50_AG(X, Y, isGreater_in_ag(X, Y))
   ISGREATER_IN_AG(pred(X), pred(Y)) -> ISGREATER_IN_AG(X, Y)
   U6_AA(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_AA(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U6_AA(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x2, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x1, x2, x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag(x2)

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x2, x3)

U50_ag(x1, x2, x3)  =  U50_ag(x2, x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

ENCODE_MODIFIED_IN_GA(x1, x2)  =  ENCODE_MODIFIED_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x1, x3)

ENCODE_IN_GA(x1, x2)  =  ENCODE_IN_GA(x1)

U8_GA(x1, x2, x3)  =  U8_GA(x1, x3)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U12_GA(x1, x2, x3, x4, x5)  =  U12_GA(x1, x2, x5)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)

U14_GGAA(x1, x2, x3, x4)  =  U14_GGAA(x1, x2, x3, x4)

\=_IN_GG(x1, x2)  =  \=_IN_GG(x1, x2)

U15_GGAA(x1, x2, x3, x4, x5)  =  U15_GGAA(x1, x2, x5)

U13_GA(x1, x2, x3, x4, x5)  =  U13_GA(x1, x2, x3, x5)

U9_GA(x1, x2, x3)  =  U9_GA(x1, x3)

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5, x6)  =  U10_GA(x1, x2, x3, x6)

LENGTH_IN_GA(x1, x2)  =  LENGTH_IN_GA(x1)

U11_GA(x1, x2, x3, x4, x5, x6)  =  U11_GA(x1, x2, x3, x6)

U2_GA(x1, x2, x3)  =  U2_GA(x1, x3)

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U3_AA(x1, x2, x3, x4)  =  U3_AA(x4)

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)

=_IN_AA(x1, x2)  =  =_IN_AA

U5_AA(x1, x2, x3, x4, x5, x6)  =  U5_AA(x6)

=_IN_AG(x1, x2)  =  =_IN_AG(x2)

U6_AA(x1, x2, x3, x4, x5)  =  U6_AA(x5)

ISGREATER_IN_AG(x1, x2)  =  ISGREATER_IN_AG(x2)

U49_AG(x1, x2, x3)  =  U49_AG(x2, x3)

U50_AG(x1, x2, x3)  =  U50_AG(x2, x3)

U7_AA(x1, x2, x3, x4, x5)  =  U7_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(10)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ENCODE_MODIFIED_IN_GA(L1, L2) -> U1_GA(L1, L2, encode_in_ga(L1, L))
   ENCODE_MODIFIED_IN_GA(L1, L2) -> ENCODE_IN_GA(L1, L)
   ENCODE_IN_GA(L1, L2) -> U8_GA(L1, L2, pack_in_ga(L1, L))
   ENCODE_IN_GA(L1, L2) -> PACK_IN_GA(L1, L)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U12_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Z)
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_GGAA(X, Y, Ys, \=_in_gg(X, Y))
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> \=_IN_GG(X, Y)
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> U15_GGAA(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)
   U12_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_GA(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U12_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   U8_GA(L1, L2, pack_out_ga(L1, L)) -> U9_GA(L1, L2, transform_in_ga(L, L2))
   U8_GA(L1, L2, pack_out_ga(L1, L)) -> TRANSFORM_IN_GA(L, L2)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> LENGTH_IN_GA(.(X, Xs), N)
   U10_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_GA(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U10_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> U2_GA(L1, L2, strip_in_aa(L, L2))
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> STRIP_IN_AA(L, L2)
   STRIP_IN_AA(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_AA(X, Ys, Zs, strip_in_aa(Ys, Zs))
   STRIP_IN_AA(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, =_in_aa(X1, N))
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> =_IN_AA(X1, N)
   U4_AA(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_AA(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   U4_AA(N, X, Ys, Zs, =_out_aa(X1, N)) -> =_IN_AG(X2, succ(zero))
   U5_AA(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_AA(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   U5_AA(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> ISGREATER_IN_AG(X1, X2)
   ISGREATER_IN_AG(succ(X), succ(Y)) -> U49_AG(X, Y, isGreater_in_ag(X, Y))
   ISGREATER_IN_AG(succ(X), succ(Y)) -> ISGREATER_IN_AG(X, Y)
   ISGREATER_IN_AG(pred(X), pred(Y)) -> U50_AG(X, Y, isGreater_in_ag(X, Y))
   ISGREATER_IN_AG(pred(X), pred(Y)) -> ISGREATER_IN_AG(X, Y)
   U6_AA(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_AA(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U6_AA(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x2, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x1, x2, x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag(x2)

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x2, x3)

U50_ag(x1, x2, x3)  =  U50_ag(x2, x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

ENCODE_MODIFIED_IN_GA(x1, x2)  =  ENCODE_MODIFIED_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x1, x3)

ENCODE_IN_GA(x1, x2)  =  ENCODE_IN_GA(x1)

U8_GA(x1, x2, x3)  =  U8_GA(x1, x3)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U12_GA(x1, x2, x3, x4, x5)  =  U12_GA(x1, x2, x5)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)

U14_GGAA(x1, x2, x3, x4)  =  U14_GGAA(x1, x2, x3, x4)

\=_IN_GG(x1, x2)  =  \=_IN_GG(x1, x2)

U15_GGAA(x1, x2, x3, x4, x5)  =  U15_GGAA(x1, x2, x5)

U13_GA(x1, x2, x3, x4, x5)  =  U13_GA(x1, x2, x3, x5)

U9_GA(x1, x2, x3)  =  U9_GA(x1, x3)

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5, x6)  =  U10_GA(x1, x2, x3, x6)

LENGTH_IN_GA(x1, x2)  =  LENGTH_IN_GA(x1)

U11_GA(x1, x2, x3, x4, x5, x6)  =  U11_GA(x1, x2, x3, x6)

U2_GA(x1, x2, x3)  =  U2_GA(x1, x3)

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U3_AA(x1, x2, x3, x4)  =  U3_AA(x4)

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)

=_IN_AA(x1, x2)  =  =_IN_AA

U5_AA(x1, x2, x3, x4, x5, x6)  =  U5_AA(x6)

=_IN_AG(x1, x2)  =  =_IN_AG(x2)

U6_AA(x1, x2, x3, x4, x5)  =  U6_AA(x5)

ISGREATER_IN_AG(x1, x2)  =  ISGREATER_IN_AG(x2)

U49_AG(x1, x2, x3)  =  U49_AG(x2, x3)

U50_AG(x1, x2, x3)  =  U50_AG(x2, x3)

U7_AA(x1, x2, x3, x4, x5)  =  U7_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(11) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 5 SCCs with 22 less nodes.
----------------------------------------

(12)
Complex Obligation (AND)

----------------------------------------

(13)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ISGREATER_IN_AG(pred(X), pred(Y)) -> ISGREATER_IN_AG(X, Y)
   ISGREATER_IN_AG(succ(X), succ(Y)) -> ISGREATER_IN_AG(X, Y)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x2, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x1, x2, x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag(x2)

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x2, x3)

U50_ag(x1, x2, x3)  =  U50_ag(x2, x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

ISGREATER_IN_AG(x1, x2)  =  ISGREATER_IN_AG(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(14) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(15)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ISGREATER_IN_AG(pred(X), pred(Y)) -> ISGREATER_IN_AG(X, Y)
   ISGREATER_IN_AG(succ(X), succ(Y)) -> ISGREATER_IN_AG(X, Y)

R is empty.
The argument filtering Pi contains the following mapping:
succ(x1)  =  succ(x1)

pred(x1)  =  pred(x1)

ISGREATER_IN_AG(x1, x2)  =  ISGREATER_IN_AG(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(16) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(17)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISGREATER_IN_AG(pred(Y)) -> ISGREATER_IN_AG(Y)
   ISGREATER_IN_AG(succ(Y)) -> ISGREATER_IN_AG(Y)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(18) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*ISGREATER_IN_AG(pred(Y)) -> ISGREATER_IN_AG(Y)
The graph contains the following edges 1 > 1


*ISGREATER_IN_AG(succ(Y)) -> ISGREATER_IN_AG(Y)
The graph contains the following edges 1 > 1


----------------------------------------

(19)
YES

----------------------------------------

(20)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, =_in_aa(X1, N))
   U4_AA(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_AA(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   U5_AA(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_AA(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   U6_AA(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x2, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x1, x2, x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag(x2)

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x2, x3)

U50_ag(x1, x2, x3)  =  U50_ag(x2, x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)

U5_AA(x1, x2, x3, x4, x5, x6)  =  U5_AA(x6)

U6_AA(x1, x2, x3, x4, x5)  =  U6_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(21) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(22)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, =_in_aa(X1, N))
   U4_AA(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_AA(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   U5_AA(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_AA(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   U6_AA(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   =_in_aa(X, X) -> =_out_aa(X, X)
   =_in_ag(X, X) -> =_out_ag(X, X)
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag(x2)

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x2, x3)

U50_ag(x1, x2, x3)  =  U50_ag(x2, x3)

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)

U5_AA(x1, x2, x3, x4, x5, x6)  =  U5_AA(x6)

U6_AA(x1, x2, x3, x4, x5)  =  U6_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(23) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(24)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA -> U4_AA(=_in_aa)
   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2, succ(zero))) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA

The TRS R consists of the following rules:

   =_in_aa -> =_out_aa
   =_in_ag(X) -> =_out_ag(X, X)
   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   isGreater_in_ag(pred(Y)) -> isGreater_out_ag(pred(Y))
   isGreater_in_ag(succ(Y)) -> U49_ag(Y, isGreater_in_ag(Y))
   isGreater_in_ag(pred(Y)) -> U50_ag(Y, isGreater_in_ag(Y))
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))
   U50_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(pred(Y))

The set Q consists of the following terms:

   =_in_aa
   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0, x1)
   U50_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(25) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   isGreater_in_ag(pred(Y)) -> isGreater_out_ag(pred(Y))
   U50_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(pred(Y))

Used ordering: Polynomial interpretation [POLO]:

   POL(=_in_aa) = 0
   POL(=_in_ag(x_1)) = 2*x_1
   POL(=_out_aa) = 0
   POL(=_out_ag(x_1, x_2)) = x_1 + x_2
   POL(STRIP_IN_AA) = 0
   POL(U49_ag(x_1, x_2)) = 2*x_1 + x_2
   POL(U4_AA(x_1)) = 2*x_1
   POL(U50_ag(x_1, x_2)) = 2 + 2*x_1 + x_2
   POL(U5_AA(x_1)) = 2*x_1
   POL(U6_AA(x_1)) = x_1
   POL(isGreater_in_ag(x_1)) = 2*x_1
   POL(isGreater_out_ag(x_1)) = x_1
   POL(pred(x_1)) = 1 + 2*x_1
   POL(succ(x_1)) = 2*x_1
   POL(zero) = 0


----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA -> U4_AA(=_in_aa)
   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2, succ(zero))) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA

The TRS R consists of the following rules:

   =_in_aa -> =_out_aa
   =_in_ag(X) -> =_out_ag(X, X)
   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   isGreater_in_ag(succ(Y)) -> U49_ag(Y, isGreater_in_ag(Y))
   isGreater_in_ag(pred(Y)) -> U50_ag(Y, isGreater_in_ag(Y))
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))

The set Q consists of the following terms:

   =_in_aa
   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0, x1)
   U50_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(27) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   isGreater_in_ag(pred(Y)) -> U50_ag(Y, isGreater_in_ag(Y))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(=_in_aa) = 0
   POL(=_in_ag(x_1)) = 2*x_1
   POL(=_out_aa) = 0
   POL(=_out_ag(x_1, x_2)) = x_1 + x_2
   POL(STRIP_IN_AA) = 0
   POL(U49_ag(x_1, x_2)) = x_1 + x_2
   POL(U4_AA(x_1)) = 2*x_1
   POL(U50_ag(x_1, x_2)) = x_1 + x_2
   POL(U5_AA(x_1)) = x_1
   POL(U6_AA(x_1)) = x_1
   POL(isGreater_in_ag(x_1)) = x_1
   POL(isGreater_out_ag(x_1)) = x_1
   POL(pred(x_1)) = 2*x_1
   POL(succ(x_1)) = 2*x_1
   POL(zero) = 0


----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA -> U4_AA(=_in_aa)
   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2, succ(zero))) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   isGreater_in_ag(succ(Y)) -> U49_ag(Y, isGreater_in_ag(Y))
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))
   =_in_ag(X) -> =_out_ag(X, X)
   =_in_aa -> =_out_aa

The set Q consists of the following terms:

   =_in_aa
   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0, x1)
   U50_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(29) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   U50_ag(x0, x1)


----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA -> U4_AA(=_in_aa)
   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2, succ(zero))) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   isGreater_in_ag(succ(Y)) -> U49_ag(Y, isGreater_in_ag(Y))
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))
   =_in_ag(X) -> =_out_ag(X, X)
   =_in_aa -> =_out_aa

The set Q consists of the following terms:

   =_in_aa
   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(31) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule STRIP_IN_AA -> U4_AA(=_in_aa) at position [0] we obtained the following new rules [LPAR04]:

   (STRIP_IN_AA -> U4_AA(=_out_aa),STRIP_IN_AA -> U4_AA(=_out_aa))


----------------------------------------

(32)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2, succ(zero))) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   isGreater_in_ag(succ(Y)) -> U49_ag(Y, isGreater_in_ag(Y))
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))
   =_in_ag(X) -> =_out_ag(X, X)
   =_in_aa -> =_out_aa

The set Q consists of the following terms:

   =_in_aa
   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(33) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(34)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2, succ(zero))) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   isGreater_in_ag(succ(Y)) -> U49_ag(Y, isGreater_in_ag(Y))
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))
   =_in_ag(X) -> =_out_ag(X, X)

The set Q consists of the following terms:

   =_in_aa
   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(35) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   =_in_aa


----------------------------------------

(36)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2, succ(zero))) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   isGreater_in_ag(succ(Y)) -> U49_ag(Y, isGreater_in_ag(Y))
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))
   =_in_ag(X) -> =_out_ag(X, X)

The set Q consists of the following terms:

   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(37) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero))) at position [0] we obtained the following new rules [LPAR04]:

   (U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero))),U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero))))


----------------------------------------

(38)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_AA(=_out_ag(X2, succ(zero))) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   isGreater_in_ag(succ(Y)) -> U49_ag(Y, isGreater_in_ag(Y))
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))
   =_in_ag(X) -> =_out_ag(X, X)

The set Q consists of the following terms:

   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(39) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_AA(=_out_ag(X2, succ(zero))) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   isGreater_in_ag(succ(Y)) -> U49_ag(Y, isGreater_in_ag(Y))
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))

The set Q consists of the following terms:

   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(41) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   =_in_ag(x0)


----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_AA(=_out_ag(X2, succ(zero))) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   isGreater_in_ag(succ(Y)) -> U49_ag(Y, isGreater_in_ag(Y))
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))

The set Q consists of the following terms:

   isGreater_in_ag(x0)
   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(43) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U5_AA(=_out_ag(X2, succ(zero))) -> U6_AA(isGreater_in_ag(X2)) we obtained the following new rules [LPAR04]:

   (U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(isGreater_in_ag(succ(zero))),U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(isGreater_in_ag(succ(zero))))


----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))
   U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(isGreater_in_ag(succ(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   isGreater_in_ag(succ(Y)) -> U49_ag(Y, isGreater_in_ag(Y))
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))

The set Q consists of the following terms:

   isGreater_in_ag(x0)
   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(45) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(isGreater_in_ag(succ(zero))) at position [0] we obtained the following new rules [LPAR04]:

   (U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(U49_ag(zero, isGreater_in_ag(zero))),U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(U49_ag(zero, isGreater_in_ag(zero))))


----------------------------------------

(46)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))
   U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(U49_ag(zero, isGreater_in_ag(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   isGreater_in_ag(succ(Y)) -> U49_ag(Y, isGreater_in_ag(Y))
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))

The set Q consists of the following terms:

   isGreater_in_ag(x0)
   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(47) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(48)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))
   U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(U49_ag(zero, isGreater_in_ag(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))

The set Q consists of the following terms:

   isGreater_in_ag(x0)
   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(49) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(U49_ag(zero, isGreater_in_ag(zero))) at position [0,1] we obtained the following new rules [LPAR04]:

   (U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(U49_ag(zero, isGreater_out_ag(zero))),U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(U49_ag(zero, isGreater_out_ag(zero))))


----------------------------------------

(50)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))
   U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(U49_ag(zero, isGreater_out_ag(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag(zero)
   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))

The set Q consists of the following terms:

   isGreater_in_ag(x0)
   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(51) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(52)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))
   U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(U49_ag(zero, isGreater_out_ag(zero)))

The TRS R consists of the following rules:

   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))

The set Q consists of the following terms:

   isGreater_in_ag(x0)
   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(53) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   isGreater_in_ag(x0)


----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))
   U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(U49_ag(zero, isGreater_out_ag(zero)))

The TRS R consists of the following rules:

   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))

The set Q consists of the following terms:

   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(55) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(U49_ag(zero, isGreater_out_ag(zero))) at position [0] we obtained the following new rules [LPAR04]:

   (U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(isGreater_out_ag(succ(zero))),U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(isGreater_out_ag(succ(zero))))


----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))
   U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(isGreater_out_ag(succ(zero)))

The TRS R consists of the following rules:

   U49_ag(Y, isGreater_out_ag(Y)) -> isGreater_out_ag(succ(Y))

The set Q consists of the following terms:

   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(57) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))
   U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(isGreater_out_ag(succ(zero)))

R is empty.
The set Q consists of the following terms:

   U49_ag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(59) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   U49_ag(x0, x1)


----------------------------------------

(60)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))
   U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(isGreater_out_ag(succ(zero)))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(61) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U6_AA(isGreater_out_ag(X2)) -> STRIP_IN_AA we obtained the following new rules [LPAR04]:

   (U6_AA(isGreater_out_ag(succ(zero))) -> STRIP_IN_AA,U6_AA(isGreater_out_ag(succ(zero))) -> STRIP_IN_AA)


----------------------------------------

(62)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero), succ(zero)))
   U5_AA(=_out_ag(succ(zero), succ(zero))) -> U6_AA(isGreater_out_ag(succ(zero)))
   U6_AA(isGreater_out_ag(succ(zero))) -> STRIP_IN_AA

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(63) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = STRIP_IN_AA evaluates to  t =STRIP_IN_AA

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from STRIP_IN_AA to STRIP_IN_AA.




----------------------------------------

(64)
NO

----------------------------------------

(65)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U10_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x2, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x1, x2, x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag(x2)

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x2, x3)

U50_ag(x1, x2, x3)  =  U50_ag(x2, x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5, x6)  =  U10_GA(x1, x2, x3, x6)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(66) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(67)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U10_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))

The TRS R consists of the following rules:

   length_in_ga(X0, X1) -> length_out_ga(X0, X1)

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5, x6)  =  U10_GA(x1, x2, x3, x6)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(68) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(69)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U10_GA(X, Xs, Ys, length_out_ga(.(X, Xs))) -> TRANSFORM_IN_GA(Ys)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys)) -> U10_GA(X, Xs, Ys, length_in_ga(.(X, Xs)))

The TRS R consists of the following rules:

   length_in_ga(X0) -> length_out_ga(X0)

The set Q consists of the following terms:

   length_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(70) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*TRANSFORM_IN_GA(.(.(X, Xs), Ys)) -> U10_GA(X, Xs, Ys, length_in_ga(.(X, Xs)))
The graph contains the following edges 1 > 1, 1 > 2, 1 > 3


*U10_GA(X, Xs, Ys, length_out_ga(.(X, Xs))) -> TRANSFORM_IN_GA(Ys)
The graph contains the following edges 3 >= 1


----------------------------------------

(71)
YES

----------------------------------------

(72)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x2, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x1, x2, x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag(x2)

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x2, x3)

U50_ag(x1, x2, x3)  =  U50_ag(x2, x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(73) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(74)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(75) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(76)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TRANSFER_IN_GGAA(X, .(X, Xs)) -> TRANSFER_IN_GGAA(X, Xs)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(77) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*TRANSFER_IN_GGAA(X, .(X, Xs)) -> TRANSFER_IN_GGAA(X, Xs)
The graph contains the following edges 1 >= 1, 2 > 1, 2 > 2


----------------------------------------

(78)
YES

----------------------------------------

(79)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U12_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U12_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x2, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x1, x2, x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1, x2)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag(x2)

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x2, x3)

U50_ag(x1, x2, x3)  =  U50_ag(x2, x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U12_GA(x1, x2, x3, x4, x5)  =  U12_GA(x1, x2, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(80) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(81)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U12_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U12_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))

The TRS R consists of the following rules:

   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x2, x5)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U12_GA(x1, x2, x3, x4, x5)  =  U12_GA(x1, x2, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(82) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(83)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U12_GA(X, Xs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys)
   PACK_IN_GA(.(X, Xs)) -> U12_GA(X, Xs, transfer_in_ggaa(X, Xs))

The TRS R consists of the following rules:

   transfer_in_ggaa(X, []) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys)) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   transfer_in_ggaa(X, .(X, Xs)) -> U15_ggaa(X, Xs, transfer_in_ggaa(X, Xs))
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   U15_ggaa(X, Xs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)

The set Q consists of the following terms:

   transfer_in_ggaa(x0, x1)
   U14_ggaa(x0, x1, x2, x3)
   U15_ggaa(x0, x1, x2)
   \=_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(84) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   PACK_IN_GA(.(X, Xs)) -> U12_GA(X, Xs, transfer_in_ggaa(X, Xs))

Strictly oriented rules of the TRS R:

   transfer_in_ggaa(X, .(X, Xs)) -> U15_ggaa(X, Xs, transfer_in_ggaa(X, Xs))

Used ordering: Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 1 + 2*x_2
   POL(PACK_IN_GA(x_1)) = 2*x_1
   POL(U12_GA(x_1, x_2, x_3)) = 2*x_3
   POL(U14_ggaa(x_1, x_2, x_3, x_4)) = 2*x_3 + x_4
   POL(U15_ggaa(x_1, x_2, x_3)) = x_3
   POL([]) = 0
   POL(\=_in_gg(x_1, x_2)) = 1
   POL(\=_out_gg(x_1, x_2)) = 1
   POL(transfer_in_ggaa(x_1, x_2)) = x_2
   POL(transfer_out_ggaa(x_1, x_2, x_3, x_4)) = x_3


----------------------------------------

(85)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U12_GA(X, Xs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys)

The TRS R consists of the following rules:

   transfer_in_ggaa(X, []) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys)) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   U15_ggaa(X, Xs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)

The set Q consists of the following terms:

   transfer_in_ggaa(x0, x1)
   U14_ggaa(x0, x1, x2, x3)
   U15_ggaa(x0, x1, x2)
   \=_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(86) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(87)
TRUE

----------------------------------------

(88) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

encode_modified_in_2: (b,f)

encode_in_2: (b,f)

pack_in_2: (b,f)

transfer_in_4: (b,b,f,f)

transform_in_2: (b,f)

strip_in_2: (f,f)

isGreater_in_2: (f,b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x3)

U50_ag(x1, x2, x3)  =  U50_ag(x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(89)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x3)

U50_ag(x1, x2, x3)  =  U50_ag(x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga



----------------------------------------

(90) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   ENCODE_MODIFIED_IN_GA(L1, L2) -> U1_GA(L1, L2, encode_in_ga(L1, L))
   ENCODE_MODIFIED_IN_GA(L1, L2) -> ENCODE_IN_GA(L1, L)
   ENCODE_IN_GA(L1, L2) -> U8_GA(L1, L2, pack_in_ga(L1, L))
   ENCODE_IN_GA(L1, L2) -> PACK_IN_GA(L1, L)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U12_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Z)
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_GGAA(X, Y, Ys, \=_in_gg(X, Y))
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> \=_IN_GG(X, Y)
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> U15_GGAA(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)
   U12_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_GA(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U12_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   U8_GA(L1, L2, pack_out_ga(L1, L)) -> U9_GA(L1, L2, transform_in_ga(L, L2))
   U8_GA(L1, L2, pack_out_ga(L1, L)) -> TRANSFORM_IN_GA(L, L2)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> LENGTH_IN_GA(.(X, Xs), N)
   U10_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_GA(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U10_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> U2_GA(L1, L2, strip_in_aa(L, L2))
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> STRIP_IN_AA(L, L2)
   STRIP_IN_AA(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_AA(X, Ys, Zs, strip_in_aa(Ys, Zs))
   STRIP_IN_AA(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, =_in_aa(X1, N))
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> =_IN_AA(X1, N)
   U4_AA(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_AA(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   U4_AA(N, X, Ys, Zs, =_out_aa(X1, N)) -> =_IN_AG(X2, succ(zero))
   U5_AA(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_AA(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   U5_AA(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> ISGREATER_IN_AG(X1, X2)
   ISGREATER_IN_AG(succ(X), succ(Y)) -> U49_AG(X, Y, isGreater_in_ag(X, Y))
   ISGREATER_IN_AG(succ(X), succ(Y)) -> ISGREATER_IN_AG(X, Y)
   ISGREATER_IN_AG(pred(X), pred(Y)) -> U50_AG(X, Y, isGreater_in_ag(X, Y))
   ISGREATER_IN_AG(pred(X), pred(Y)) -> ISGREATER_IN_AG(X, Y)
   U6_AA(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_AA(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U6_AA(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x3)

U50_ag(x1, x2, x3)  =  U50_ag(x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

ENCODE_MODIFIED_IN_GA(x1, x2)  =  ENCODE_MODIFIED_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x3)

ENCODE_IN_GA(x1, x2)  =  ENCODE_IN_GA(x1)

U8_GA(x1, x2, x3)  =  U8_GA(x3)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U12_GA(x1, x2, x3, x4, x5)  =  U12_GA(x5)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)

U14_GGAA(x1, x2, x3, x4)  =  U14_GGAA(x1, x2, x3, x4)

\=_IN_GG(x1, x2)  =  \=_IN_GG(x1, x2)

U15_GGAA(x1, x2, x3, x4, x5)  =  U15_GGAA(x1, x5)

U13_GA(x1, x2, x3, x4, x5)  =  U13_GA(x3, x5)

U9_GA(x1, x2, x3)  =  U9_GA(x3)

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5, x6)  =  U10_GA(x3, x6)

LENGTH_IN_GA(x1, x2)  =  LENGTH_IN_GA(x1)

U11_GA(x1, x2, x3, x4, x5, x6)  =  U11_GA(x6)

U2_GA(x1, x2, x3)  =  U2_GA(x3)

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U3_AA(x1, x2, x3, x4)  =  U3_AA(x4)

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)

=_IN_AA(x1, x2)  =  =_IN_AA

U5_AA(x1, x2, x3, x4, x5, x6)  =  U5_AA(x6)

=_IN_AG(x1, x2)  =  =_IN_AG(x2)

U6_AA(x1, x2, x3, x4, x5)  =  U6_AA(x5)

ISGREATER_IN_AG(x1, x2)  =  ISGREATER_IN_AG(x2)

U49_AG(x1, x2, x3)  =  U49_AG(x3)

U50_AG(x1, x2, x3)  =  U50_AG(x3)

U7_AA(x1, x2, x3, x4, x5)  =  U7_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(91)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ENCODE_MODIFIED_IN_GA(L1, L2) -> U1_GA(L1, L2, encode_in_ga(L1, L))
   ENCODE_MODIFIED_IN_GA(L1, L2) -> ENCODE_IN_GA(L1, L)
   ENCODE_IN_GA(L1, L2) -> U8_GA(L1, L2, pack_in_ga(L1, L))
   ENCODE_IN_GA(L1, L2) -> PACK_IN_GA(L1, L)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U12_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Z)
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_GGAA(X, Y, Ys, \=_in_gg(X, Y))
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> \=_IN_GG(X, Y)
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> U15_GGAA(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)
   U12_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_GA(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U12_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   U8_GA(L1, L2, pack_out_ga(L1, L)) -> U9_GA(L1, L2, transform_in_ga(L, L2))
   U8_GA(L1, L2, pack_out_ga(L1, L)) -> TRANSFORM_IN_GA(L, L2)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> LENGTH_IN_GA(.(X, Xs), N)
   U10_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_GA(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U10_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> U2_GA(L1, L2, strip_in_aa(L, L2))
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> STRIP_IN_AA(L, L2)
   STRIP_IN_AA(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_AA(X, Ys, Zs, strip_in_aa(Ys, Zs))
   STRIP_IN_AA(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, =_in_aa(X1, N))
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> =_IN_AA(X1, N)
   U4_AA(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_AA(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   U4_AA(N, X, Ys, Zs, =_out_aa(X1, N)) -> =_IN_AG(X2, succ(zero))
   U5_AA(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_AA(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   U5_AA(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> ISGREATER_IN_AG(X1, X2)
   ISGREATER_IN_AG(succ(X), succ(Y)) -> U49_AG(X, Y, isGreater_in_ag(X, Y))
   ISGREATER_IN_AG(succ(X), succ(Y)) -> ISGREATER_IN_AG(X, Y)
   ISGREATER_IN_AG(pred(X), pred(Y)) -> U50_AG(X, Y, isGreater_in_ag(X, Y))
   ISGREATER_IN_AG(pred(X), pred(Y)) -> ISGREATER_IN_AG(X, Y)
   U6_AA(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_AA(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U6_AA(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x3)

U50_ag(x1, x2, x3)  =  U50_ag(x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

ENCODE_MODIFIED_IN_GA(x1, x2)  =  ENCODE_MODIFIED_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x3)

ENCODE_IN_GA(x1, x2)  =  ENCODE_IN_GA(x1)

U8_GA(x1, x2, x3)  =  U8_GA(x3)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U12_GA(x1, x2, x3, x4, x5)  =  U12_GA(x5)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)

U14_GGAA(x1, x2, x3, x4)  =  U14_GGAA(x1, x2, x3, x4)

\=_IN_GG(x1, x2)  =  \=_IN_GG(x1, x2)

U15_GGAA(x1, x2, x3, x4, x5)  =  U15_GGAA(x1, x5)

U13_GA(x1, x2, x3, x4, x5)  =  U13_GA(x3, x5)

U9_GA(x1, x2, x3)  =  U9_GA(x3)

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5, x6)  =  U10_GA(x3, x6)

LENGTH_IN_GA(x1, x2)  =  LENGTH_IN_GA(x1)

U11_GA(x1, x2, x3, x4, x5, x6)  =  U11_GA(x6)

U2_GA(x1, x2, x3)  =  U2_GA(x3)

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U3_AA(x1, x2, x3, x4)  =  U3_AA(x4)

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)

=_IN_AA(x1, x2)  =  =_IN_AA

U5_AA(x1, x2, x3, x4, x5, x6)  =  U5_AA(x6)

=_IN_AG(x1, x2)  =  =_IN_AG(x2)

U6_AA(x1, x2, x3, x4, x5)  =  U6_AA(x5)

ISGREATER_IN_AG(x1, x2)  =  ISGREATER_IN_AG(x2)

U49_AG(x1, x2, x3)  =  U49_AG(x3)

U50_AG(x1, x2, x3)  =  U50_AG(x3)

U7_AA(x1, x2, x3, x4, x5)  =  U7_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(92) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 5 SCCs with 22 less nodes.
----------------------------------------

(93)
Complex Obligation (AND)

----------------------------------------

(94)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ISGREATER_IN_AG(pred(X), pred(Y)) -> ISGREATER_IN_AG(X, Y)
   ISGREATER_IN_AG(succ(X), succ(Y)) -> ISGREATER_IN_AG(X, Y)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x3)

U50_ag(x1, x2, x3)  =  U50_ag(x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

ISGREATER_IN_AG(x1, x2)  =  ISGREATER_IN_AG(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(95) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(96)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ISGREATER_IN_AG(pred(X), pred(Y)) -> ISGREATER_IN_AG(X, Y)
   ISGREATER_IN_AG(succ(X), succ(Y)) -> ISGREATER_IN_AG(X, Y)

R is empty.
The argument filtering Pi contains the following mapping:
succ(x1)  =  succ(x1)

pred(x1)  =  pred(x1)

ISGREATER_IN_AG(x1, x2)  =  ISGREATER_IN_AG(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(97) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(98)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISGREATER_IN_AG(pred(Y)) -> ISGREATER_IN_AG(Y)
   ISGREATER_IN_AG(succ(Y)) -> ISGREATER_IN_AG(Y)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(99) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*ISGREATER_IN_AG(pred(Y)) -> ISGREATER_IN_AG(Y)
The graph contains the following edges 1 > 1


*ISGREATER_IN_AG(succ(Y)) -> ISGREATER_IN_AG(Y)
The graph contains the following edges 1 > 1


----------------------------------------

(100)
YES

----------------------------------------

(101)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, =_in_aa(X1, N))
   U4_AA(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_AA(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   U5_AA(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_AA(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   U6_AA(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x3)

U50_ag(x1, x2, x3)  =  U50_ag(x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)

U5_AA(x1, x2, x3, x4, x5, x6)  =  U5_AA(x6)

U6_AA(x1, x2, x3, x4, x5)  =  U6_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(102) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(103)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, =_in_aa(X1, N))
   U4_AA(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_AA(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   U5_AA(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_AA(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   U6_AA(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   =_in_aa(X, X) -> =_out_aa(X, X)
   =_in_ag(X, X) -> =_out_ag(X, X)
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1)

succ(x1)  =  succ(x1)

zero  =  zero

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x3)

U50_ag(x1, x2, x3)  =  U50_ag(x3)

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)

U5_AA(x1, x2, x3, x4, x5, x6)  =  U5_AA(x6)

U6_AA(x1, x2, x3, x4, x5)  =  U6_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(104) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(105)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA -> U4_AA(=_in_aa)
   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2)) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA

The TRS R consists of the following rules:

   =_in_aa -> =_out_aa
   =_in_ag(X) -> =_out_ag(X)
   isGreater_in_ag(zero) -> isGreater_out_ag
   isGreater_in_ag(pred(Y)) -> isGreater_out_ag
   isGreater_in_ag(succ(Y)) -> U49_ag(isGreater_in_ag(Y))
   isGreater_in_ag(pred(Y)) -> U50_ag(isGreater_in_ag(Y))
   U49_ag(isGreater_out_ag) -> isGreater_out_ag
   U50_ag(isGreater_out_ag) -> isGreater_out_ag

The set Q consists of the following terms:

   =_in_aa
   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0)
   U50_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(106) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   isGreater_in_ag(pred(Y)) -> isGreater_out_ag
   isGreater_in_ag(pred(Y)) -> U50_ag(isGreater_in_ag(Y))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(=_in_aa) = 0
   POL(=_in_ag(x_1)) = 2*x_1
   POL(=_out_aa) = 0
   POL(=_out_ag(x_1)) = 2*x_1
   POL(STRIP_IN_AA) = 0
   POL(U49_ag(x_1)) = 2*x_1
   POL(U4_AA(x_1)) = 2*x_1
   POL(U50_ag(x_1)) = 2*x_1
   POL(U5_AA(x_1)) = 2*x_1
   POL(U6_AA(x_1)) = x_1
   POL(isGreater_in_ag(x_1)) = 2*x_1
   POL(isGreater_out_ag) = 0
   POL(pred(x_1)) = 2*x_1
   POL(succ(x_1)) = 2*x_1
   POL(zero) = 0


----------------------------------------

(107)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA -> U4_AA(=_in_aa)
   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2)) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   isGreater_in_ag(succ(Y)) -> U49_ag(isGreater_in_ag(Y))
   U50_ag(isGreater_out_ag) -> isGreater_out_ag
   U49_ag(isGreater_out_ag) -> isGreater_out_ag
   =_in_ag(X) -> =_out_ag(X)
   =_in_aa -> =_out_aa

The set Q consists of the following terms:

   =_in_aa
   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0)
   U50_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(108) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(109)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA -> U4_AA(=_in_aa)
   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2)) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   isGreater_in_ag(succ(Y)) -> U49_ag(isGreater_in_ag(Y))
   U49_ag(isGreater_out_ag) -> isGreater_out_ag
   =_in_ag(X) -> =_out_ag(X)
   =_in_aa -> =_out_aa

The set Q consists of the following terms:

   =_in_aa
   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0)
   U50_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(110) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   U50_ag(x0)


----------------------------------------

(111)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA -> U4_AA(=_in_aa)
   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2)) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   isGreater_in_ag(succ(Y)) -> U49_ag(isGreater_in_ag(Y))
   U49_ag(isGreater_out_ag) -> isGreater_out_ag
   =_in_ag(X) -> =_out_ag(X)
   =_in_aa -> =_out_aa

The set Q consists of the following terms:

   =_in_aa
   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(112) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule STRIP_IN_AA -> U4_AA(=_in_aa) at position [0] we obtained the following new rules [LPAR04]:

   (STRIP_IN_AA -> U4_AA(=_out_aa),STRIP_IN_AA -> U4_AA(=_out_aa))


----------------------------------------

(113)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2)) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   isGreater_in_ag(succ(Y)) -> U49_ag(isGreater_in_ag(Y))
   U49_ag(isGreater_out_ag) -> isGreater_out_ag
   =_in_ag(X) -> =_out_ag(X)
   =_in_aa -> =_out_aa

The set Q consists of the following terms:

   =_in_aa
   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(114) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(115)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2)) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   isGreater_in_ag(succ(Y)) -> U49_ag(isGreater_in_ag(Y))
   U49_ag(isGreater_out_ag) -> isGreater_out_ag
   =_in_ag(X) -> =_out_ag(X)

The set Q consists of the following terms:

   =_in_aa
   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(116) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   =_in_aa


----------------------------------------

(117)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero)))
   U5_AA(=_out_ag(X2)) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   isGreater_in_ag(succ(Y)) -> U49_ag(isGreater_in_ag(Y))
   U49_ag(isGreater_out_ag) -> isGreater_out_ag
   =_in_ag(X) -> =_out_ag(X)

The set Q consists of the following terms:

   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(118) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4_AA(=_out_aa) -> U5_AA(=_in_ag(succ(zero))) at position [0] we obtained the following new rules [LPAR04]:

   (U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero))),U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero))))


----------------------------------------

(119)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_AA(=_out_ag(X2)) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   isGreater_in_ag(succ(Y)) -> U49_ag(isGreater_in_ag(Y))
   U49_ag(isGreater_out_ag) -> isGreater_out_ag
   =_in_ag(X) -> =_out_ag(X)

The set Q consists of the following terms:

   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(120) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(121)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_AA(=_out_ag(X2)) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   isGreater_in_ag(succ(Y)) -> U49_ag(isGreater_in_ag(Y))
   U49_ag(isGreater_out_ag) -> isGreater_out_ag

The set Q consists of the following terms:

   =_in_ag(x0)
   isGreater_in_ag(x0)
   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(122) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   =_in_ag(x0)


----------------------------------------

(123)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_AA(=_out_ag(X2)) -> U6_AA(isGreater_in_ag(X2))
   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   isGreater_in_ag(succ(Y)) -> U49_ag(isGreater_in_ag(Y))
   U49_ag(isGreater_out_ag) -> isGreater_out_ag

The set Q consists of the following terms:

   isGreater_in_ag(x0)
   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(124) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U5_AA(=_out_ag(X2)) -> U6_AA(isGreater_in_ag(X2)) we obtained the following new rules [LPAR04]:

   (U5_AA(=_out_ag(succ(zero))) -> U6_AA(isGreater_in_ag(succ(zero))),U5_AA(=_out_ag(succ(zero))) -> U6_AA(isGreater_in_ag(succ(zero))))


----------------------------------------

(125)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero)))
   U5_AA(=_out_ag(succ(zero))) -> U6_AA(isGreater_in_ag(succ(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   isGreater_in_ag(succ(Y)) -> U49_ag(isGreater_in_ag(Y))
   U49_ag(isGreater_out_ag) -> isGreater_out_ag

The set Q consists of the following terms:

   isGreater_in_ag(x0)
   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(126) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U5_AA(=_out_ag(succ(zero))) -> U6_AA(isGreater_in_ag(succ(zero))) at position [0] we obtained the following new rules [LPAR04]:

   (U5_AA(=_out_ag(succ(zero))) -> U6_AA(U49_ag(isGreater_in_ag(zero))),U5_AA(=_out_ag(succ(zero))) -> U6_AA(U49_ag(isGreater_in_ag(zero))))


----------------------------------------

(127)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero)))
   U5_AA(=_out_ag(succ(zero))) -> U6_AA(U49_ag(isGreater_in_ag(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   isGreater_in_ag(succ(Y)) -> U49_ag(isGreater_in_ag(Y))
   U49_ag(isGreater_out_ag) -> isGreater_out_ag

The set Q consists of the following terms:

   isGreater_in_ag(x0)
   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(128) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(129)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero)))
   U5_AA(=_out_ag(succ(zero))) -> U6_AA(U49_ag(isGreater_in_ag(zero)))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   U49_ag(isGreater_out_ag) -> isGreater_out_ag

The set Q consists of the following terms:

   isGreater_in_ag(x0)
   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(130) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U5_AA(=_out_ag(succ(zero))) -> U6_AA(U49_ag(isGreater_in_ag(zero))) at position [0,0] we obtained the following new rules [LPAR04]:

   (U5_AA(=_out_ag(succ(zero))) -> U6_AA(U49_ag(isGreater_out_ag)),U5_AA(=_out_ag(succ(zero))) -> U6_AA(U49_ag(isGreater_out_ag)))


----------------------------------------

(131)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero)))
   U5_AA(=_out_ag(succ(zero))) -> U6_AA(U49_ag(isGreater_out_ag))

The TRS R consists of the following rules:

   isGreater_in_ag(zero) -> isGreater_out_ag
   U49_ag(isGreater_out_ag) -> isGreater_out_ag

The set Q consists of the following terms:

   isGreater_in_ag(x0)
   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(132) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(133)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero)))
   U5_AA(=_out_ag(succ(zero))) -> U6_AA(U49_ag(isGreater_out_ag))

The TRS R consists of the following rules:

   U49_ag(isGreater_out_ag) -> isGreater_out_ag

The set Q consists of the following terms:

   isGreater_in_ag(x0)
   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(134) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   isGreater_in_ag(x0)


----------------------------------------

(135)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero)))
   U5_AA(=_out_ag(succ(zero))) -> U6_AA(U49_ag(isGreater_out_ag))

The TRS R consists of the following rules:

   U49_ag(isGreater_out_ag) -> isGreater_out_ag

The set Q consists of the following terms:

   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(136) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U5_AA(=_out_ag(succ(zero))) -> U6_AA(U49_ag(isGreater_out_ag)) at position [0] we obtained the following new rules [LPAR04]:

   (U5_AA(=_out_ag(succ(zero))) -> U6_AA(isGreater_out_ag),U5_AA(=_out_ag(succ(zero))) -> U6_AA(isGreater_out_ag))


----------------------------------------

(137)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero)))
   U5_AA(=_out_ag(succ(zero))) -> U6_AA(isGreater_out_ag)

The TRS R consists of the following rules:

   U49_ag(isGreater_out_ag) -> isGreater_out_ag

The set Q consists of the following terms:

   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(138) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(139)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero)))
   U5_AA(=_out_ag(succ(zero))) -> U6_AA(isGreater_out_ag)

R is empty.
The set Q consists of the following terms:

   U49_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(140) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   U49_ag(x0)


----------------------------------------

(141)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_AA(isGreater_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(=_out_aa)
   U4_AA(=_out_aa) -> U5_AA(=_out_ag(succ(zero)))
   U5_AA(=_out_ag(succ(zero))) -> U6_AA(isGreater_out_ag)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(142) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = STRIP_IN_AA evaluates to  t =STRIP_IN_AA

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from STRIP_IN_AA to STRIP_IN_AA.




----------------------------------------

(143)
NO

----------------------------------------

(144)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U10_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x3)

U50_ag(x1, x2, x3)  =  U50_ag(x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5, x6)  =  U10_GA(x3, x6)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(145) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(146)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U10_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))

The TRS R consists of the following rules:

   length_in_ga(X0, X1) -> length_out_ga(X0, X1)

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5, x6)  =  U10_GA(x3, x6)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(147) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(148)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U10_GA(Ys, length_out_ga) -> TRANSFORM_IN_GA(Ys)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys)) -> U10_GA(Ys, length_in_ga(.(X, Xs)))

The TRS R consists of the following rules:

   length_in_ga(X0) -> length_out_ga

The set Q consists of the following terms:

   length_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(149) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*TRANSFORM_IN_GA(.(.(X, Xs), Ys)) -> U10_GA(Ys, length_in_ga(.(X, Xs)))
The graph contains the following edges 1 > 1


*U10_GA(Ys, length_out_ga) -> TRANSFORM_IN_GA(Ys)
The graph contains the following edges 1 >= 1


----------------------------------------

(150)
YES

----------------------------------------

(151)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x3)

U50_ag(x1, x2, x3)  =  U50_ag(x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(152) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(153)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(154) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(155)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TRANSFER_IN_GGAA(X, .(X, Xs)) -> TRANSFER_IN_GGAA(X, Xs)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(156) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*TRANSFER_IN_GGAA(X, .(X, Xs)) -> TRANSFER_IN_GGAA(X, Xs)
The graph contains the following edges 1 >= 1, 2 > 1, 2 > 2


----------------------------------------

(157)
YES

----------------------------------------

(158)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U12_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U12_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U8_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U12_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U12_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U13_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U13_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U8_ga(L1, L2, pack_out_ga(L1, L)) -> U9_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U10_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U10_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U11_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U11_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U9_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, =_in_aa(X1, N))
   =_in_aa(X, X) -> =_out_aa(X, X)
   U4_aa(N, X, Ys, Zs, =_out_aa(X1, N)) -> U5_aa(N, X, Ys, Zs, X1, =_in_ag(X2, succ(zero)))
   =_in_ag(X, X) -> =_out_ag(X, X)
   U5_aa(N, X, Ys, Zs, X1, =_out_ag(X2, succ(zero))) -> U6_aa(N, X, Ys, Zs, isGreater_in_ag(X1, X2))
   isGreater_in_ag(succ(X), zero) -> isGreater_out_ag(succ(X), zero)
   isGreater_in_ag(succ(X), pred(Y)) -> isGreater_out_ag(succ(X), pred(Y))
   isGreater_in_ag(succ(X), succ(Y)) -> U49_ag(X, Y, isGreater_in_ag(X, Y))
   isGreater_in_ag(zero, pred(Y)) -> isGreater_out_ag(zero, pred(Y))
   isGreater_in_ag(pred(X), pred(Y)) -> U50_ag(X, Y, isGreater_in_ag(X, Y))
   U50_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(pred(X), pred(Y))
   U49_ag(X, Y, isGreater_out_ag(X, Y)) -> isGreater_out_ag(succ(X), succ(Y))
   U6_aa(N, X, Ys, Zs, isGreater_out_ag(X1, X2)) -> U7_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U7_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(succ(zero), .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U8_ga(x1, x2, x3)  =  U8_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U12_ga(x1, x2, x3, x4, x5)  =  U12_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x5)

U13_ga(x1, x2, x3, x4, x5)  =  U13_ga(x3, x5)

U9_ga(x1, x2, x3)  =  U9_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U10_ga(x1, x2, x3, x4, x5, x6)  =  U10_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U11_ga(x1, x2, x3, x4, x5, x6)  =  U11_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

=_in_aa(x1, x2)  =  =_in_aa

=_out_aa(x1, x2)  =  =_out_aa

U5_aa(x1, x2, x3, x4, x5, x6)  =  U5_aa(x6)

=_in_ag(x1, x2)  =  =_in_ag(x2)

=_out_ag(x1, x2)  =  =_out_ag(x1)

succ(x1)  =  succ(x1)

zero  =  zero

U6_aa(x1, x2, x3, x4, x5)  =  U6_aa(x5)

isGreater_in_ag(x1, x2)  =  isGreater_in_ag(x2)

isGreater_out_ag(x1, x2)  =  isGreater_out_ag

pred(x1)  =  pred(x1)

U49_ag(x1, x2, x3)  =  U49_ag(x3)

U50_ag(x1, x2, x3)  =  U50_ag(x3)

U7_aa(x1, x2, x3, x4, x5)  =  U7_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U12_GA(x1, x2, x3, x4, x5)  =  U12_GA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(159) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(160)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U12_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U12_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))

The TRS R consists of the following rules:

   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U15_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U14_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   U15_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U14_ggaa(x1, x2, x3, x4)  =  U14_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U15_ggaa(x1, x2, x3, x4, x5)  =  U15_ggaa(x1, x5)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U12_GA(x1, x2, x3, x4, x5)  =  U12_GA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(161) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(162)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U12_GA(transfer_out_ggaa(Ys, Z)) -> PACK_IN_GA(Ys)
   PACK_IN_GA(.(X, Xs)) -> U12_GA(transfer_in_ggaa(X, Xs))

The TRS R consists of the following rules:

   transfer_in_ggaa(X, []) -> transfer_out_ggaa([], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys)) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   transfer_in_ggaa(X, .(X, Xs)) -> U15_ggaa(X, transfer_in_ggaa(X, Xs))
   U14_ggaa(X, Y, Ys, \=_out_gg) -> transfer_out_ggaa(.(Y, Ys), .(X, []))
   U15_ggaa(X, transfer_out_ggaa(Ys, Zs)) -> transfer_out_ggaa(Ys, .(X, Zs))
   \=_in_gg(X0, X1) -> \=_out_gg

The set Q consists of the following terms:

   transfer_in_ggaa(x0, x1)
   U14_ggaa(x0, x1, x2, x3)
   U15_ggaa(x0, x1)
   \=_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(163) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   PACK_IN_GA(.(X, Xs)) -> U12_GA(transfer_in_ggaa(X, Xs))

Strictly oriented rules of the TRS R:

   U15_ggaa(X, transfer_out_ggaa(Ys, Zs)) -> transfer_out_ggaa(Ys, .(X, Zs))

Used ordering: Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 2 + x_2
   POL(PACK_IN_GA(x_1)) = 2*x_1
   POL(U12_GA(x_1)) = 2*x_1
   POL(U14_ggaa(x_1, x_2, x_3, x_4)) = 2 + x_3
   POL(U15_ggaa(x_1, x_2)) = 2 + x_2
   POL([]) = 0
   POL(\=_in_gg(x_1, x_2)) = x_1 + 2*x_2
   POL(\=_out_gg) = 0
   POL(transfer_in_ggaa(x_1, x_2)) = x_2
   POL(transfer_out_ggaa(x_1, x_2)) = x_1


----------------------------------------

(164)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U12_GA(transfer_out_ggaa(Ys, Z)) -> PACK_IN_GA(Ys)

The TRS R consists of the following rules:

   transfer_in_ggaa(X, []) -> transfer_out_ggaa([], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys)) -> U14_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   transfer_in_ggaa(X, .(X, Xs)) -> U15_ggaa(X, transfer_in_ggaa(X, Xs))
   U14_ggaa(X, Y, Ys, \=_out_gg) -> transfer_out_ggaa(.(Y, Ys), .(X, []))
   \=_in_gg(X0, X1) -> \=_out_gg

The set Q consists of the following terms:

   transfer_in_ggaa(x0, x1)
   U14_ggaa(x0, x1, x2, x3)
   U15_ggaa(x0, x1)
   \=_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(165) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(166)
TRUE

----------------------------------------

(167) UndefinedPredicateHandlerProof (SOUND)
Added facts for all undefined predicates [PROLOG].
----------------------------------------

(168)
Obligation:
Clauses:

encode_modified(L1, L2) :- ','(encode(L1, L), strip(L, L2)).
strip([], []).
strip(.(.(1, .(X, [])), Ys), .(X, Zs)) :- strip(Ys, Zs).
strip(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) :- ','(>(N, 1), strip(Ys, Zs)).
encode(L1, L2) :- ','(pack(L1, L), transform(L, L2)).
transform([], []).
transform(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) :- ','(length(.(X, Xs), N), transform(Ys, Zs)).
pack([], []).
pack(.(X, Xs), .(Z, Zs)) :- ','(transfer(X, Xs, Ys, Z), pack(Ys, Zs)).
transfer(X, [], [], .(X, [])).
transfer(X, .(Y, Ys), .(Y, Ys), .(X, [])) :- \=(X, Y).
transfer(X, .(X, Xs), Ys, .(X, Zs)) :- transfer(X, Xs, Ys, Zs).
>(X0, X1).
length(X0, X1).
\=(X0, X1).


Query: encode_modified(g,a)
----------------------------------------

(169) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

encode_modified_in_2: (b,f)

encode_in_2: (b,f)

pack_in_2: (b,f)

transfer_in_4: (b,b,f,f)

transform_in_2: (b,f)

strip_in_2: (f,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(170)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga



----------------------------------------

(171) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   ENCODE_MODIFIED_IN_GA(L1, L2) -> U1_GA(L1, L2, encode_in_ga(L1, L))
   ENCODE_MODIFIED_IN_GA(L1, L2) -> ENCODE_IN_GA(L1, L)
   ENCODE_IN_GA(L1, L2) -> U6_GA(L1, L2, pack_in_ga(L1, L))
   ENCODE_IN_GA(L1, L2) -> PACK_IN_GA(L1, L)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U10_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Z)
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_GGAA(X, Y, Ys, \=_in_gg(X, Y))
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> \=_IN_GG(X, Y)
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> U13_GGAA(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)
   U10_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_GA(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U10_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   U6_GA(L1, L2, pack_out_ga(L1, L)) -> U7_GA(L1, L2, transform_in_ga(L, L2))
   U6_GA(L1, L2, pack_out_ga(L1, L)) -> TRANSFORM_IN_GA(L, L2)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> LENGTH_IN_GA(.(X, Xs), N)
   U8_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_GA(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U8_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> U2_GA(L1, L2, strip_in_aa(L, L2))
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> STRIP_IN_AA(L, L2)
   STRIP_IN_AA(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_AA(X, Ys, Zs, strip_in_aa(Ys, Zs))
   STRIP_IN_AA(.(.(1, .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, >_in_ag(N, 1))
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> >_IN_AG(N, 1)
   U4_AA(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_AA(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U4_AA(N, X, Ys, Zs, >_out_ag(N, 1)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

ENCODE_MODIFIED_IN_GA(x1, x2)  =  ENCODE_MODIFIED_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x3)

ENCODE_IN_GA(x1, x2)  =  ENCODE_IN_GA(x1)

U6_GA(x1, x2, x3)  =  U6_GA(x3)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5)  =  U10_GA(x5)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)

U12_GGAA(x1, x2, x3, x4)  =  U12_GGAA(x1, x2, x3, x4)

\=_IN_GG(x1, x2)  =  \=_IN_GG(x1, x2)

U13_GGAA(x1, x2, x3, x4, x5)  =  U13_GGAA(x1, x5)

U11_GA(x1, x2, x3, x4, x5)  =  U11_GA(x3, x5)

U7_GA(x1, x2, x3)  =  U7_GA(x3)

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U8_GA(x1, x2, x3, x4, x5, x6)  =  U8_GA(x3, x6)

LENGTH_IN_GA(x1, x2)  =  LENGTH_IN_GA(x1)

U9_GA(x1, x2, x3, x4, x5, x6)  =  U9_GA(x6)

U2_GA(x1, x2, x3)  =  U2_GA(x3)

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U3_AA(x1, x2, x3, x4)  =  U3_AA(x4)

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)

>_IN_AG(x1, x2)  =  >_IN_AG(x2)

U5_AA(x1, x2, x3, x4, x5)  =  U5_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(172)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ENCODE_MODIFIED_IN_GA(L1, L2) -> U1_GA(L1, L2, encode_in_ga(L1, L))
   ENCODE_MODIFIED_IN_GA(L1, L2) -> ENCODE_IN_GA(L1, L)
   ENCODE_IN_GA(L1, L2) -> U6_GA(L1, L2, pack_in_ga(L1, L))
   ENCODE_IN_GA(L1, L2) -> PACK_IN_GA(L1, L)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U10_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Z)
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_GGAA(X, Y, Ys, \=_in_gg(X, Y))
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> \=_IN_GG(X, Y)
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> U13_GGAA(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)
   U10_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_GA(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U10_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   U6_GA(L1, L2, pack_out_ga(L1, L)) -> U7_GA(L1, L2, transform_in_ga(L, L2))
   U6_GA(L1, L2, pack_out_ga(L1, L)) -> TRANSFORM_IN_GA(L, L2)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> LENGTH_IN_GA(.(X, Xs), N)
   U8_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_GA(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U8_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> U2_GA(L1, L2, strip_in_aa(L, L2))
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> STRIP_IN_AA(L, L2)
   STRIP_IN_AA(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_AA(X, Ys, Zs, strip_in_aa(Ys, Zs))
   STRIP_IN_AA(.(.(1, .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, >_in_ag(N, 1))
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> >_IN_AG(N, 1)
   U4_AA(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_AA(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U4_AA(N, X, Ys, Zs, >_out_ag(N, 1)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

ENCODE_MODIFIED_IN_GA(x1, x2)  =  ENCODE_MODIFIED_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x3)

ENCODE_IN_GA(x1, x2)  =  ENCODE_IN_GA(x1)

U6_GA(x1, x2, x3)  =  U6_GA(x3)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5)  =  U10_GA(x5)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)

U12_GGAA(x1, x2, x3, x4)  =  U12_GGAA(x1, x2, x3, x4)

\=_IN_GG(x1, x2)  =  \=_IN_GG(x1, x2)

U13_GGAA(x1, x2, x3, x4, x5)  =  U13_GGAA(x1, x5)

U11_GA(x1, x2, x3, x4, x5)  =  U11_GA(x3, x5)

U7_GA(x1, x2, x3)  =  U7_GA(x3)

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U8_GA(x1, x2, x3, x4, x5, x6)  =  U8_GA(x3, x6)

LENGTH_IN_GA(x1, x2)  =  LENGTH_IN_GA(x1)

U9_GA(x1, x2, x3, x4, x5, x6)  =  U9_GA(x6)

U2_GA(x1, x2, x3)  =  U2_GA(x3)

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U3_AA(x1, x2, x3, x4)  =  U3_AA(x4)

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)

>_IN_AG(x1, x2)  =  >_IN_AG(x2)

U5_AA(x1, x2, x3, x4, x5)  =  U5_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(173) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 4 SCCs with 18 less nodes.
----------------------------------------

(174)
Complex Obligation (AND)

----------------------------------------

(175)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, >_in_ag(N, 1))
   U4_AA(N, X, Ys, Zs, >_out_ag(N, 1)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(1, .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(176) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(177)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, >_in_ag(N, 1))
   U4_AA(N, X, Ys, Zs, >_out_ag(N, 1)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(1, .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   >_in_ag(X0, X1) -> >_out_ag(X0, X1)

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

1  =  1

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(178) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(179)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA -> U4_AA(>_in_ag(1))
   U4_AA(>_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA

The TRS R consists of the following rules:

   >_in_ag(X1) -> >_out_ag

The set Q consists of the following terms:

   >_in_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(180) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule STRIP_IN_AA -> U4_AA(>_in_ag(1)) at position [0] we obtained the following new rules [LPAR04]:

   (STRIP_IN_AA -> U4_AA(>_out_ag),STRIP_IN_AA -> U4_AA(>_out_ag))


----------------------------------------

(181)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4_AA(>_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(>_out_ag)

The TRS R consists of the following rules:

   >_in_ag(X1) -> >_out_ag

The set Q consists of the following terms:

   >_in_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(182) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(183)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4_AA(>_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(>_out_ag)

R is empty.
The set Q consists of the following terms:

   >_in_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(184) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   >_in_ag(x0)


----------------------------------------

(185)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4_AA(>_out_ag) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(>_out_ag)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(186) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = STRIP_IN_AA evaluates to  t =STRIP_IN_AA

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from STRIP_IN_AA to STRIP_IN_AA.




----------------------------------------

(187)
NO

----------------------------------------

(188)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U8_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U8_GA(x1, x2, x3, x4, x5, x6)  =  U8_GA(x3, x6)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(189) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(190)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U8_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))

The TRS R consists of the following rules:

   length_in_ga(X0, X1) -> length_out_ga(X0, X1)

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U8_GA(x1, x2, x3, x4, x5, x6)  =  U8_GA(x3, x6)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(191) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(192)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U8_GA(Ys, length_out_ga) -> TRANSFORM_IN_GA(Ys)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys)) -> U8_GA(Ys, length_in_ga(.(X, Xs)))

The TRS R consists of the following rules:

   length_in_ga(X0) -> length_out_ga

The set Q consists of the following terms:

   length_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(193) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*TRANSFORM_IN_GA(.(.(X, Xs), Ys)) -> U8_GA(Ys, length_in_ga(.(X, Xs)))
The graph contains the following edges 1 > 1


*U8_GA(Ys, length_out_ga) -> TRANSFORM_IN_GA(Ys)
The graph contains the following edges 1 >= 1


----------------------------------------

(194)
YES

----------------------------------------

(195)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(196) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(197)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(198) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(199)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TRANSFER_IN_GGAA(X, .(X, Xs)) -> TRANSFER_IN_GGAA(X, Xs)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(200) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*TRANSFER_IN_GGAA(X, .(X, Xs)) -> TRANSFER_IN_GGAA(X, Xs)
The graph contains the following edges 1 >= 1, 2 > 1, 2 > 2


----------------------------------------

(201)
YES

----------------------------------------

(202)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U10_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U10_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x6)

encode_out_ga(x1, x2)  =  encode_out_ga

U2_ga(x1, x2, x3)  =  U2_ga(x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5)  =  U10_GA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(203) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(204)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U10_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U10_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))

The TRS R consists of the following rules:

   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x5)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5)  =  U10_GA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(205) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(206)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U10_GA(transfer_out_ggaa(Ys, Z)) -> PACK_IN_GA(Ys)
   PACK_IN_GA(.(X, Xs)) -> U10_GA(transfer_in_ggaa(X, Xs))

The TRS R consists of the following rules:

   transfer_in_ggaa(X, []) -> transfer_out_ggaa([], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys)) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   transfer_in_ggaa(X, .(X, Xs)) -> U13_ggaa(X, transfer_in_ggaa(X, Xs))
   U12_ggaa(X, Y, Ys, \=_out_gg) -> transfer_out_ggaa(.(Y, Ys), .(X, []))
   U13_ggaa(X, transfer_out_ggaa(Ys, Zs)) -> transfer_out_ggaa(Ys, .(X, Zs))
   \=_in_gg(X0, X1) -> \=_out_gg

The set Q consists of the following terms:

   transfer_in_ggaa(x0, x1)
   U12_ggaa(x0, x1, x2, x3)
   U13_ggaa(x0, x1)
   \=_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(207) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   PACK_IN_GA(.(X, Xs)) -> U10_GA(transfer_in_ggaa(X, Xs))

Strictly oriented rules of the TRS R:

   U13_ggaa(X, transfer_out_ggaa(Ys, Zs)) -> transfer_out_ggaa(Ys, .(X, Zs))

Used ordering: Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 2 + x_2
   POL(PACK_IN_GA(x_1)) = 2*x_1
   POL(U10_GA(x_1)) = 2*x_1
   POL(U12_ggaa(x_1, x_2, x_3, x_4)) = 2 + x_3
   POL(U13_ggaa(x_1, x_2)) = 2 + x_2
   POL([]) = 0
   POL(\=_in_gg(x_1, x_2)) = x_1 + 2*x_2
   POL(\=_out_gg) = 0
   POL(transfer_in_ggaa(x_1, x_2)) = x_2
   POL(transfer_out_ggaa(x_1, x_2)) = x_1


----------------------------------------

(208)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U10_GA(transfer_out_ggaa(Ys, Z)) -> PACK_IN_GA(Ys)

The TRS R consists of the following rules:

   transfer_in_ggaa(X, []) -> transfer_out_ggaa([], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys)) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   transfer_in_ggaa(X, .(X, Xs)) -> U13_ggaa(X, transfer_in_ggaa(X, Xs))
   U12_ggaa(X, Y, Ys, \=_out_gg) -> transfer_out_ggaa(.(Y, Ys), .(X, []))
   \=_in_gg(X0, X1) -> \=_out_gg

The set Q consists of the following terms:

   transfer_in_ggaa(x0, x1)
   U12_ggaa(x0, x1, x2, x3)
   U13_ggaa(x0, x1)
   \=_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(209) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(210)
TRUE

----------------------------------------

(211) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

encode_modified_in_2: (b,f)

encode_in_2: (b,f)

pack_in_2: (b,f)

transfer_in_4: (b,b,f,f)

transform_in_2: (b,f)

strip_in_2: (f,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x2, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x1, x2, x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag(x2)

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(212)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x2, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x1, x2, x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag(x2)

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)



----------------------------------------

(213) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   ENCODE_MODIFIED_IN_GA(L1, L2) -> U1_GA(L1, L2, encode_in_ga(L1, L))
   ENCODE_MODIFIED_IN_GA(L1, L2) -> ENCODE_IN_GA(L1, L)
   ENCODE_IN_GA(L1, L2) -> U6_GA(L1, L2, pack_in_ga(L1, L))
   ENCODE_IN_GA(L1, L2) -> PACK_IN_GA(L1, L)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U10_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Z)
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_GGAA(X, Y, Ys, \=_in_gg(X, Y))
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> \=_IN_GG(X, Y)
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> U13_GGAA(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)
   U10_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_GA(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U10_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   U6_GA(L1, L2, pack_out_ga(L1, L)) -> U7_GA(L1, L2, transform_in_ga(L, L2))
   U6_GA(L1, L2, pack_out_ga(L1, L)) -> TRANSFORM_IN_GA(L, L2)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> LENGTH_IN_GA(.(X, Xs), N)
   U8_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_GA(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U8_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> U2_GA(L1, L2, strip_in_aa(L, L2))
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> STRIP_IN_AA(L, L2)
   STRIP_IN_AA(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_AA(X, Ys, Zs, strip_in_aa(Ys, Zs))
   STRIP_IN_AA(.(.(1, .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, >_in_ag(N, 1))
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> >_IN_AG(N, 1)
   U4_AA(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_AA(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U4_AA(N, X, Ys, Zs, >_out_ag(N, 1)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x2, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x1, x2, x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag(x2)

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

ENCODE_MODIFIED_IN_GA(x1, x2)  =  ENCODE_MODIFIED_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x1, x3)

ENCODE_IN_GA(x1, x2)  =  ENCODE_IN_GA(x1)

U6_GA(x1, x2, x3)  =  U6_GA(x1, x3)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5)  =  U10_GA(x1, x2, x5)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)

U12_GGAA(x1, x2, x3, x4)  =  U12_GGAA(x1, x2, x3, x4)

\=_IN_GG(x1, x2)  =  \=_IN_GG(x1, x2)

U13_GGAA(x1, x2, x3, x4, x5)  =  U13_GGAA(x1, x2, x5)

U11_GA(x1, x2, x3, x4, x5)  =  U11_GA(x1, x2, x3, x5)

U7_GA(x1, x2, x3)  =  U7_GA(x1, x3)

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U8_GA(x1, x2, x3, x4, x5, x6)  =  U8_GA(x1, x2, x3, x6)

LENGTH_IN_GA(x1, x2)  =  LENGTH_IN_GA(x1)

U9_GA(x1, x2, x3, x4, x5, x6)  =  U9_GA(x1, x2, x3, x6)

U2_GA(x1, x2, x3)  =  U2_GA(x1, x3)

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U3_AA(x1, x2, x3, x4)  =  U3_AA(x4)

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)

>_IN_AG(x1, x2)  =  >_IN_AG(x2)

U5_AA(x1, x2, x3, x4, x5)  =  U5_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(214)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ENCODE_MODIFIED_IN_GA(L1, L2) -> U1_GA(L1, L2, encode_in_ga(L1, L))
   ENCODE_MODIFIED_IN_GA(L1, L2) -> ENCODE_IN_GA(L1, L)
   ENCODE_IN_GA(L1, L2) -> U6_GA(L1, L2, pack_in_ga(L1, L))
   ENCODE_IN_GA(L1, L2) -> PACK_IN_GA(L1, L)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U10_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Z)
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_GGAA(X, Y, Ys, \=_in_gg(X, Y))
   TRANSFER_IN_GGAA(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> \=_IN_GG(X, Y)
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> U13_GGAA(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)
   U10_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_GA(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U10_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   U6_GA(L1, L2, pack_out_ga(L1, L)) -> U7_GA(L1, L2, transform_in_ga(L, L2))
   U6_GA(L1, L2, pack_out_ga(L1, L)) -> TRANSFORM_IN_GA(L, L2)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> LENGTH_IN_GA(.(X, Xs), N)
   U8_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_GA(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U8_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> U2_GA(L1, L2, strip_in_aa(L, L2))
   U1_GA(L1, L2, encode_out_ga(L1, L)) -> STRIP_IN_AA(L, L2)
   STRIP_IN_AA(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_AA(X, Ys, Zs, strip_in_aa(Ys, Zs))
   STRIP_IN_AA(.(.(1, .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, >_in_ag(N, 1))
   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> >_IN_AG(N, 1)
   U4_AA(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_AA(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U4_AA(N, X, Ys, Zs, >_out_ag(N, 1)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x2, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x1, x2, x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag(x2)

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

ENCODE_MODIFIED_IN_GA(x1, x2)  =  ENCODE_MODIFIED_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x1, x3)

ENCODE_IN_GA(x1, x2)  =  ENCODE_IN_GA(x1)

U6_GA(x1, x2, x3)  =  U6_GA(x1, x3)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5)  =  U10_GA(x1, x2, x5)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)

U12_GGAA(x1, x2, x3, x4)  =  U12_GGAA(x1, x2, x3, x4)

\=_IN_GG(x1, x2)  =  \=_IN_GG(x1, x2)

U13_GGAA(x1, x2, x3, x4, x5)  =  U13_GGAA(x1, x2, x5)

U11_GA(x1, x2, x3, x4, x5)  =  U11_GA(x1, x2, x3, x5)

U7_GA(x1, x2, x3)  =  U7_GA(x1, x3)

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U8_GA(x1, x2, x3, x4, x5, x6)  =  U8_GA(x1, x2, x3, x6)

LENGTH_IN_GA(x1, x2)  =  LENGTH_IN_GA(x1)

U9_GA(x1, x2, x3, x4, x5, x6)  =  U9_GA(x1, x2, x3, x6)

U2_GA(x1, x2, x3)  =  U2_GA(x1, x3)

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U3_AA(x1, x2, x3, x4)  =  U3_AA(x4)

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)

>_IN_AG(x1, x2)  =  >_IN_AG(x2)

U5_AA(x1, x2, x3, x4, x5)  =  U5_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(215) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 4 SCCs with 18 less nodes.
----------------------------------------

(216)
Complex Obligation (AND)

----------------------------------------

(217)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, >_in_ag(N, 1))
   U4_AA(N, X, Ys, Zs, >_out_ag(N, 1)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(1, .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x2, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x1, x2, x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag(x2)

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(218) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(219)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_AA(N, X, Ys, Zs, >_in_ag(N, 1))
   U4_AA(N, X, Ys, Zs, >_out_ag(N, 1)) -> STRIP_IN_AA(Ys, Zs)
   STRIP_IN_AA(.(.(1, .(X, [])), Ys), .(X, Zs)) -> STRIP_IN_AA(Ys, Zs)

The TRS R consists of the following rules:

   >_in_ag(X0, X1) -> >_out_ag(X0, X1)

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag(x2)

1  =  1

STRIP_IN_AA(x1, x2)  =  STRIP_IN_AA

U4_AA(x1, x2, x3, x4, x5)  =  U4_AA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(220) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(221)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   STRIP_IN_AA -> U4_AA(>_in_ag(1))
   U4_AA(>_out_ag(1)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA

The TRS R consists of the following rules:

   >_in_ag(X1) -> >_out_ag(X1)

The set Q consists of the following terms:

   >_in_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(222) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule STRIP_IN_AA -> U4_AA(>_in_ag(1)) at position [0] we obtained the following new rules [LPAR04]:

   (STRIP_IN_AA -> U4_AA(>_out_ag(1)),STRIP_IN_AA -> U4_AA(>_out_ag(1)))


----------------------------------------

(223)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4_AA(>_out_ag(1)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(>_out_ag(1))

The TRS R consists of the following rules:

   >_in_ag(X1) -> >_out_ag(X1)

The set Q consists of the following terms:

   >_in_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(224) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(225)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4_AA(>_out_ag(1)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(>_out_ag(1))

R is empty.
The set Q consists of the following terms:

   >_in_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(226) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   >_in_ag(x0)


----------------------------------------

(227)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4_AA(>_out_ag(1)) -> STRIP_IN_AA
   STRIP_IN_AA -> STRIP_IN_AA
   STRIP_IN_AA -> U4_AA(>_out_ag(1))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(228) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = STRIP_IN_AA evaluates to  t =STRIP_IN_AA

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from STRIP_IN_AA to STRIP_IN_AA.




----------------------------------------

(229)
NO

----------------------------------------

(230)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U8_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x2, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x1, x2, x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag(x2)

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U8_GA(x1, x2, x3, x4, x5, x6)  =  U8_GA(x1, x2, x3, x6)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(231) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(232)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U8_GA(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> TRANSFORM_IN_GA(Ys, Zs)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_GA(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))

The TRS R consists of the following rules:

   length_in_ga(X0, X1) -> length_out_ga(X0, X1)

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

TRANSFORM_IN_GA(x1, x2)  =  TRANSFORM_IN_GA(x1)

U8_GA(x1, x2, x3, x4, x5, x6)  =  U8_GA(x1, x2, x3, x6)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(233) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(234)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U8_GA(X, Xs, Ys, length_out_ga(.(X, Xs))) -> TRANSFORM_IN_GA(Ys)
   TRANSFORM_IN_GA(.(.(X, Xs), Ys)) -> U8_GA(X, Xs, Ys, length_in_ga(.(X, Xs)))

The TRS R consists of the following rules:

   length_in_ga(X0) -> length_out_ga(X0)

The set Q consists of the following terms:

   length_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(235) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*TRANSFORM_IN_GA(.(.(X, Xs), Ys)) -> U8_GA(X, Xs, Ys, length_in_ga(.(X, Xs)))
The graph contains the following edges 1 > 1, 1 > 2, 1 > 3


*U8_GA(X, Xs, Ys, length_out_ga(.(X, Xs))) -> TRANSFORM_IN_GA(Ys)
The graph contains the following edges 3 >= 1


----------------------------------------

(236)
YES

----------------------------------------

(237)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x2, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x1, x2, x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag(x2)

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(238) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(239)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   TRANSFER_IN_GGAA(X, .(X, Xs), Ys, .(X, Zs)) -> TRANSFER_IN_GGAA(X, Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

TRANSFER_IN_GGAA(x1, x2, x3, x4)  =  TRANSFER_IN_GGAA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(240) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(241)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TRANSFER_IN_GGAA(X, .(X, Xs)) -> TRANSFER_IN_GGAA(X, Xs)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(242) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*TRANSFER_IN_GGAA(X, .(X, Xs)) -> TRANSFER_IN_GGAA(X, Xs)
The graph contains the following edges 1 >= 1, 2 > 1, 2 > 2


----------------------------------------

(243)
YES

----------------------------------------

(244)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U10_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U10_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))

The TRS R consists of the following rules:

   encode_modified_in_ga(L1, L2) -> U1_ga(L1, L2, encode_in_ga(L1, L))
   encode_in_ga(L1, L2) -> U6_ga(L1, L2, pack_in_ga(L1, L))
   pack_in_ga([], []) -> pack_out_ga([], [])
   pack_in_ga(.(X, Xs), .(Z, Zs)) -> U10_ga(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))
   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   U10_ga(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> U11_ga(X, Xs, Z, Zs, pack_in_ga(Ys, Zs))
   U11_ga(X, Xs, Z, Zs, pack_out_ga(Ys, Zs)) -> pack_out_ga(.(X, Xs), .(Z, Zs))
   U6_ga(L1, L2, pack_out_ga(L1, L)) -> U7_ga(L1, L2, transform_in_ga(L, L2))
   transform_in_ga([], []) -> transform_out_ga([], [])
   transform_in_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs)) -> U8_ga(X, Xs, Ys, N, Zs, length_in_ga(.(X, Xs), N))
   length_in_ga(X0, X1) -> length_out_ga(X0, X1)
   U8_ga(X, Xs, Ys, N, Zs, length_out_ga(.(X, Xs), N)) -> U9_ga(X, Xs, Ys, N, Zs, transform_in_ga(Ys, Zs))
   U9_ga(X, Xs, Ys, N, Zs, transform_out_ga(Ys, Zs)) -> transform_out_ga(.(.(X, Xs), Ys), .(.(N, .(X, [])), Zs))
   U7_ga(L1, L2, transform_out_ga(L, L2)) -> encode_out_ga(L1, L2)
   U1_ga(L1, L2, encode_out_ga(L1, L)) -> U2_ga(L1, L2, strip_in_aa(L, L2))
   strip_in_aa([], []) -> strip_out_aa([], [])
   strip_in_aa(.(.(1, .(X, [])), Ys), .(X, Zs)) -> U3_aa(X, Ys, Zs, strip_in_aa(Ys, Zs))
   strip_in_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs)) -> U4_aa(N, X, Ys, Zs, >_in_ag(N, 1))
   >_in_ag(X0, X1) -> >_out_ag(X0, X1)
   U4_aa(N, X, Ys, Zs, >_out_ag(N, 1)) -> U5_aa(N, X, Ys, Zs, strip_in_aa(Ys, Zs))
   U5_aa(N, X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(N, .(X, [])), Ys), .(.(N, .(X, [])), Zs))
   U3_aa(X, Ys, Zs, strip_out_aa(Ys, Zs)) -> strip_out_aa(.(.(1, .(X, [])), Ys), .(X, Zs))
   U2_ga(L1, L2, strip_out_aa(L, L2)) -> encode_modified_out_ga(L1, L2)

The argument filtering Pi contains the following mapping:
encode_modified_in_ga(x1, x2)  =  encode_modified_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

encode_in_ga(x1, x2)  =  encode_in_ga(x1)

U6_ga(x1, x2, x3)  =  U6_ga(x1, x3)

pack_in_ga(x1, x2)  =  pack_in_ga(x1)

[]  =  []

pack_out_ga(x1, x2)  =  pack_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U10_ga(x1, x2, x3, x4, x5)  =  U10_ga(x1, x2, x5)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x2, x5)

U11_ga(x1, x2, x3, x4, x5)  =  U11_ga(x1, x2, x3, x5)

U7_ga(x1, x2, x3)  =  U7_ga(x1, x3)

transform_in_ga(x1, x2)  =  transform_in_ga(x1)

transform_out_ga(x1, x2)  =  transform_out_ga(x1)

U8_ga(x1, x2, x3, x4, x5, x6)  =  U8_ga(x1, x2, x3, x6)

length_in_ga(x1, x2)  =  length_in_ga(x1)

length_out_ga(x1, x2)  =  length_out_ga(x1)

U9_ga(x1, x2, x3, x4, x5, x6)  =  U9_ga(x1, x2, x3, x6)

encode_out_ga(x1, x2)  =  encode_out_ga(x1)

U2_ga(x1, x2, x3)  =  U2_ga(x1, x3)

strip_in_aa(x1, x2)  =  strip_in_aa

strip_out_aa(x1, x2)  =  strip_out_aa

U3_aa(x1, x2, x3, x4)  =  U3_aa(x4)

U4_aa(x1, x2, x3, x4, x5)  =  U4_aa(x5)

>_in_ag(x1, x2)  =  >_in_ag(x2)

>_out_ag(x1, x2)  =  >_out_ag(x2)

1  =  1

U5_aa(x1, x2, x3, x4, x5)  =  U5_aa(x5)

encode_modified_out_ga(x1, x2)  =  encode_modified_out_ga(x1)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5)  =  U10_GA(x1, x2, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(245) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(246)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U10_GA(X, Xs, Z, Zs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys, Zs)
   PACK_IN_GA(.(X, Xs), .(Z, Zs)) -> U10_GA(X, Xs, Z, Zs, transfer_in_ggaa(X, Xs, Ys, Z))

The TRS R consists of the following rules:

   transfer_in_ggaa(X, [], [], .(X, [])) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, [])) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   transfer_in_ggaa(X, .(X, Xs), Ys, .(X, Zs)) -> U13_ggaa(X, Xs, Ys, Zs, transfer_in_ggaa(X, Xs, Ys, Zs))
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   U13_ggaa(X, Xs, Ys, Zs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

transfer_in_ggaa(x1, x2, x3, x4)  =  transfer_in_ggaa(x1, x2)

transfer_out_ggaa(x1, x2, x3, x4)  =  transfer_out_ggaa(x1, x2, x3, x4)

U12_ggaa(x1, x2, x3, x4)  =  U12_ggaa(x1, x2, x3, x4)

\=_in_gg(x1, x2)  =  \=_in_gg(x1, x2)

\=_out_gg(x1, x2)  =  \=_out_gg(x1, x2)

U13_ggaa(x1, x2, x3, x4, x5)  =  U13_ggaa(x1, x2, x5)

PACK_IN_GA(x1, x2)  =  PACK_IN_GA(x1)

U10_GA(x1, x2, x3, x4, x5)  =  U10_GA(x1, x2, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(247) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(248)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U10_GA(X, Xs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys)
   PACK_IN_GA(.(X, Xs)) -> U10_GA(X, Xs, transfer_in_ggaa(X, Xs))

The TRS R consists of the following rules:

   transfer_in_ggaa(X, []) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys)) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   transfer_in_ggaa(X, .(X, Xs)) -> U13_ggaa(X, Xs, transfer_in_ggaa(X, Xs))
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   U13_ggaa(X, Xs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)

The set Q consists of the following terms:

   transfer_in_ggaa(x0, x1)
   U12_ggaa(x0, x1, x2, x3)
   U13_ggaa(x0, x1, x2)
   \=_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(249) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   PACK_IN_GA(.(X, Xs)) -> U10_GA(X, Xs, transfer_in_ggaa(X, Xs))

Strictly oriented rules of the TRS R:

   transfer_in_ggaa(X, .(X, Xs)) -> U13_ggaa(X, Xs, transfer_in_ggaa(X, Xs))

Used ordering: Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 1 + 2*x_2
   POL(PACK_IN_GA(x_1)) = 2*x_1
   POL(U10_GA(x_1, x_2, x_3)) = 2*x_3
   POL(U12_ggaa(x_1, x_2, x_3, x_4)) = 2*x_3 + x_4
   POL(U13_ggaa(x_1, x_2, x_3)) = x_3
   POL([]) = 0
   POL(\=_in_gg(x_1, x_2)) = 1
   POL(\=_out_gg(x_1, x_2)) = 1
   POL(transfer_in_ggaa(x_1, x_2)) = x_2
   POL(transfer_out_ggaa(x_1, x_2, x_3, x_4)) = x_3


----------------------------------------

(250)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U10_GA(X, Xs, transfer_out_ggaa(X, Xs, Ys, Z)) -> PACK_IN_GA(Ys)

The TRS R consists of the following rules:

   transfer_in_ggaa(X, []) -> transfer_out_ggaa(X, [], [], .(X, []))
   transfer_in_ggaa(X, .(Y, Ys)) -> U12_ggaa(X, Y, Ys, \=_in_gg(X, Y))
   U12_ggaa(X, Y, Ys, \=_out_gg(X, Y)) -> transfer_out_ggaa(X, .(Y, Ys), .(Y, Ys), .(X, []))
   U13_ggaa(X, Xs, transfer_out_ggaa(X, Xs, Ys, Zs)) -> transfer_out_ggaa(X, .(X, Xs), Ys, .(X, Zs))
   \=_in_gg(X0, X1) -> \=_out_gg(X0, X1)

The set Q consists of the following terms:

   transfer_in_ggaa(x0, x1)
   U12_ggaa(x0, x1, x2, x3)
   U13_ggaa(x0, x1, x2)
   \=_in_gg(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(251) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(252)
TRUE
