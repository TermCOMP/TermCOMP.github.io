YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/R2n9S.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

q(g)

w.r.t. the given Prolog program could successfully be proven:

(0) Prolog
(1) PrologToTRSTransformerProof [SOUND, 0 ms]
(2) QTRS
(3) RisEmptyProof [EQUIVALENT, 0 ms]
(4) YES


----------------------------------------

(0)
Obligation:
Clauses:

q(X) :- ','(grammar(G), ','(-(terminal, string(X)), produces(G, X))).
grammar(S) :- ','(equal(S, or(N, and(a, and(S, b)))), equal(N, or(c, and(c, N)))).
equal(X, X).
-(terminal, string(nil)).
-(terminal, string(and(A, X))) :- ','(terminal(A), -(terminal, string(X))).
terminal(a).
terminal(b).
terminal(c).
produces(G, X) :- gives(G, X, nil).
gives(or(P, Q), X, Y) :- gives(P, X, Y).
gives(or(P, Q), X, Y) :- gives(Q, X, Y).
gives(and(P, Q), X, Z) :- ','(gives(P, X, Y), gives(Q, Y, Z)).
gives(A, and(A, X), X) :- terminal(A).


Query: q(g)
----------------------------------------

(1) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 39,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(q X)",
                "(',' (grammar G) (',' (- (terminal) (string X)) (produces G X)))"
            ],
            [
                "(grammar S)",
                "(',' (equal S (or N (and (a) (and S (b))))) (equal N (or (c) (and (c) N))))"
            ],
            [
                "(equal X X)",
                null
            ],
            [
                "(- (terminal) (string (nil)))",
                null
            ],
            [
                "(- (terminal) (string (and A X)))",
                "(',' (terminal A) (- (terminal) (string X)))"
            ],
            [
                "(terminal (a))",
                null
            ],
            [
                "(terminal (b))",
                null
            ],
            [
                "(terminal (c))",
                null
            ],
            [
                "(produces G X)",
                "(gives G X (nil))"
            ],
            [
                "(gives (or P Q) X Y)",
                "(gives P X Y)"
            ],
            [
                "(gives (or P Q) X Y)",
                "(gives Q X Y)"
            ],
            [
                "(gives (and P Q) X Z)",
                "(',' (gives P X Y) (gives Q Y Z))"
            ],
            [
                "(gives A (and A X) X)",
                "(terminal A)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "46": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (',' (equal X13 (or X12 (and (a) (and X13 (b))))) (equal X12 (or (c) (and (c) X12)))) (',' (- (terminal) (string T4)) (produces X13 T4)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [
                        "X13",
                        "X12"
                    ],
                    "exprvars": []
                }
            },
            "47": {
                "goal": [{
                    "clause": 2,
                    "scope": 3,
                    "term": "(',' (',' (equal X13 (or X12 (and (a) (and X13 (b))))) (equal X12 (or (c) (and (c) X12)))) (',' (- (terminal) (string T4)) (produces X13 T4)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [
                        "X13",
                        "X12"
                    ],
                    "exprvars": []
                }
            },
            "48": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "39": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(q T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "40": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(q T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "42": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (grammar X5) (',' (- (terminal) (string T4)) (produces X5 T4)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": ["X5"],
                    "exprvars": []
                }
            },
            "43": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(',' (grammar X5) (',' (- (terminal) (string T4)) (produces X5 T4)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": ["X5"],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 39,
                "to": 40,
                "label": "CASE"
            },
            {
                "from": 40,
                "to": 42,
                "label": "ONLY EVAL with clause\nq(X4) :- ','(grammar(X5), ','(-(terminal, string(X4)), produces(X5, X4))).\nand substitutionT1 -> T4,\nX4 -> T4"
            },
            {
                "from": 42,
                "to": 43,
                "label": "CASE"
            },
            {
                "from": 43,
                "to": 46,
                "label": "ONLY EVAL with clause\ngrammar(X11) :- ','(equal(X11, or(X12, and(a, and(X11, b)))), equal(X12, or(c, and(c, X12)))).\nand substitutionX5 -> X13,\nX11 -> X13"
            },
            {
                "from": 46,
                "to": 47,
                "label": "CASE"
            },
            {
                "from": 47,
                "to": 48,
                "label": "BACKTRACK\nfor clause: equal(X, X)because of non-unification"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
R is empty.
Q is empty.

----------------------------------------

(3) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(4)
YES
