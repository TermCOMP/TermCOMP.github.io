YES

Problem 1: 

(VAR vu95NonEmpty rest x y z1 z2)
(RULES
cons(x,cons(x,rest)) -> cons(x,rest)
cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
orient(s(x),num0) -> pair(num0,s(x))
orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
)


Problem 1: 
Valid CTRS Processor:
-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
-> The system is a deterministic 3-CTRS.

Problem 1: 

2D Dependency Pair Processor:

Conditional Termination Problem 1:
-> Pairs:
 CONS(x,cons(y,rest)) -> CONS(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 CONS(x,cons(y,rest)) -> CONS(z2,rest) | orient(x,y) ->* pair(z1,z2)
-> QPairs:
 Empty
-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)

Conditional Termination Problem 2:
-> Pairs:
 CONS(x,cons(y,rest)) -> ORIENT(x,y)
 ORIENT(s(x),s(y)) -> ORIENT(x,y)
-> QPairs:
 Empty
-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)


The problem is decomposed in 2 subproblems.

Problem 1.1: 

SCC Processor:
-> Pairs:
 CONS(x,cons(y,rest)) -> CONS(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 CONS(x,cons(y,rest)) -> CONS(z2,rest) | orient(x,y) ->* pair(z1,z2)
-> QPairs:
 Empty
-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 CONS(x,cons(y,rest)) -> CONS(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 CONS(x,cons(y,rest)) -> CONS(z2,rest) | orient(x,y) ->* pair(z1,z2)
-> QPairs:
 Empty
->->-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)

Problem 1.1: 

Removal Triple Processor:
-> Pairs:
 CONS(x,cons(y,rest)) -> CONS(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 CONS(x,cons(y,rest)) -> CONS(z2,rest) | orient(x,y) ->* pair(z1,z2)
-> QPairs:
 Empty
-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
-> Usable rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[cons](X1,X2) = 2.X2 + 2
[orient](X1,X2) = 2.X1 + 2.X2 + 1
[num0] = 2
[fSNonEmpty] = 0
[pair](X1,X2) = 1
[s](X) = 2.X + 2
[CONS](X1,X2) = 2.X2
[ORIENT](X1,X2) = 0

Problem 1.1: 

SCC Processor:
-> Pairs:
 CONS(x,cons(y,rest)) -> CONS(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
-> QPairs:
 Empty
-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 CONS(x,cons(y,rest)) -> CONS(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
-> QPairs:
 Empty
->->-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)

Problem 1.1: 

Semantic Removal Triple Processor:
-> Pairs:
 CONS(x,cons(y,rest)) -> CONS(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
-> Usable rules:
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
-> Needed rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
->AGES Output:
 
Model Results

System:
mod InTheory is
sort S .
sort Bool .
sort PSharp .


op _->*_ : S S -> Bool [m = 2] .
op _->_ : S S -> Bool [m = 2] .
op cons : S S -> S .
op orient : S S -> S .
op num0 :  -> S .
op fSNonEmpty :  -> S .
op pair : S S -> S .
op s : S -> S .
op _->P_ : PSharp PSharp -> Bool .
op _->Q_ : PSharp PSharp -> Bool .
op CONS : S S -> PSharp .
op ORIENT : S S -> PSharp .
op pi : S S -> S .
op gtrsim : PSharp PSharp -> Bool .
op succeq : PSharp PSharp -> Bool .
op sqsupset : PSharp PSharp -> Bool [wellfounded m = 1] .
op _->N_ : S S -> Bool .
op _->N_ : PSharp PSharp -> Bool .

endm


Property:
x ->R* x
x ->R y /\ y ->R* z => x ->R* z
gtrsim(x,y) /\ sqsupset(y,z) => sqsupset(x,z)
succeq(x,y) /\ sqsupset(y,z) => sqsupset(x,z)
gtrsim(x,y) /\ succeq(y,z) => gtrsim(x,z)
_->N_(x,y) => gtrsim(x,y)
_->P_(x,y) => gtrsim(x,y) \/ succeq(x,y) \/ sqsupset(x,y)
_->Q_(x,y) => gtrsim(x,y) \/ succeq(x,y) \/ sqsupset(x,y)
x1 ->R y1 => cons(x1,x2) ->R cons(y1,x2)
x2 ->R y2 => cons(x1,x2) ->R cons(x1,y2)
x1 ->R y1 => orient(x1,x2) ->R orient(y1,x2)
x2 ->R y2 => orient(x1,x2) ->R orient(x1,y2)
x1 ->R y1 => pair(x1,x2) ->R pair(y1,x2)
x2 ->R y2 => pair(x1,x2) ->R pair(x1,y2)
x1 ->R y1 => s(x1) ->R s(y1)
_->N_(x1,y1) => _->N_(cons(x1,x2),cons(y1,x2))
_->N_(x2,y2) => _->N_(cons(x1,x2),cons(x1,y2))
_->N_(x1,y1) => _->N_(orient(x1,x2),orient(y1,x2))
_->N_(x2,y2) => _->N_(orient(x1,x2),orient(x1,y2))
_->N_(x1,y1) => _->N_(pair(x1,x2),pair(y1,x2))
_->N_(x2,y2) => _->N_(pair(x1,x2),pair(x1,y2))
_->N_(x1,y1) => _->N_(s(x1),s(y1))
_->N_(x1,y1) => _->N_(CONS(x1,x2),CONS(y1,x2))
_->N_(x2,y2) => _->N_(CONS(x1,x2),CONS(x1,y2))
orient(s(x),num0) ->R pair(num0,s(x))
orient(x,y) ->R* pair(z1,z2) => orient(s(x),s(y)) ->R pair(s(z1),s(z2))
pi(x6,x7) ->R x6
pi(x6,x7) ->R x7
_->N_(cons(x,cons(x,rest)),cons(x,rest))
orient(x,y) ->R* pair(z1,z2) => _->N_(cons(x,cons(y,rest)),cons(z1,cons(z2,rest)))
_->N_(orient(s(x),num0),pair(num0,s(x)))
orient(x,y) ->R* pair(z1,z2) => _->N_(orient(s(x),s(y)),pair(s(z1),s(z2)))
orient(x,y) ->R* pair(z1,z2) => sqsupset(CONS(x,cons(y,rest)),CONS(z1,cons(z2,rest)))

Results:


Domains:
S: |N U {-1}
PSharp: -|N \ {0}

Function Interpretations:
|[CONS(x_1_1:S,x_2_1:S)]| = - 3 - x_1_1:S - x_2_1:S
|[ORIENT(x_1_1:S,x_2_1:S)]| = - 1
|[cons(x_1_1:S,x_2_1:S)]| = x_2_1:S
|[fSNonEmpty]| = 0
|[num0]| = 1
|[orient(x_1_1:S,x_2_1:S)]| = x_1_1:S
|[pair(x_1_1:S,x_2_1:S)]| = 1 + x_1_1:S
|[pi(x_1_1:S,x_2_1:S)]| = 3 + 2.x_1_1:S + 2.x_2_1:S
|[s(x_1_1:S)]| = 3 + x_1_1:S

Predicate Interpretations:
 x_1_1:S ->* x_2_1:S <=> (x_1_1:S >= x_2_1:S)
 x_1_1:S ->N x_2_1:S <=> (x_1_1:S >= x_2_1:S)
 x_1_1:PSharp ->N x_2_1:PSharp <=> (x_2_1:PSharp >= x_1_1:PSharp)
 x_1_1:PSharp ->P x_2_1:PSharp <=> (2.x_2_1:PSharp >= 1)
 x_1_1:PSharp ->Q x_2_1:PSharp <=> (x_1_1:PSharp + 3.x_2_1:PSharp >= 1)
 x_1_1:S -> x_2_1:S <=> (x_1_1:S >= x_2_1:S)
gtrsim(x_1_1:PSharp,x_2_1:PSharp) <=> (x_2_1:PSharp >= x_1_1:PSharp)
sqsupset(x_1_1:PSharp,x_2_1:PSharp) <=> (x_2_1:PSharp >= 1 + x_1_1:PSharp)
succeq(x_1_1:PSharp,x_2_1:PSharp) <=> (x_2_1:PSharp >= 0)

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> QPairs:
 Empty
-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

SCC Processor:
-> Pairs:
 CONS(x,cons(y,rest)) -> ORIENT(x,y)
 ORIENT(s(x),s(y)) -> ORIENT(x,y)
-> QPairs:
 Empty
-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 ORIENT(s(x),s(y)) -> ORIENT(x,y)
-> QPairs:
 Empty
->->-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)

Problem 1.2: 

Subterm Processor:
-> Pairs:
 ORIENT(s(x),s(y)) -> ORIENT(x,y)
-> QPairs:
 Empty
-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
->Projection:
 pi(ORIENT) = 1

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> QPairs:
 Empty
-> Rules:
 cons(x,cons(x,rest)) -> cons(x,rest)
 cons(x,cons(y,rest)) -> cons(z1,cons(z2,rest)) | orient(x,y) ->* pair(z1,z2)
 orient(s(x),num0) -> pair(num0,s(x))
 orient(s(x),s(y)) -> pair(s(z1),s(z2)) | orient(x,y) ->* pair(z1,z2)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
