YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/M9vJn.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Quasi decreasingness of the given CTRS could be proven:

(0) CTRS
(1) CTRSToQTRSProof [SOUND, 0 ms]
(2) QTRS
(3) DependencyPairsProof [EQUIVALENT, 0 ms]
(4) QDP
(5) DependencyGraphProof [EQUIVALENT, 0 ms]
(6) QDP
(7) UsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
(8) QDP
(9) TransformationProof [EQUIVALENT, 0 ms]
(10) QDP
(11) TransformationProof [EQUIVALENT, 0 ms]
(12) QDP
(13) TransformationProof [EQUIVALENT, 0 ms]
(14) QDP
(15) TransformationProof [EQUIVALENT, 0 ms]
(16) QDP
(17) TransformationProof [EQUIVALENT, 0 ms]
(18) QDP
(19) TransformationProof [EQUIVALENT, 0 ms]
(20) QDP
(21) TransformationProof [EQUIVALENT, 0 ms]
(22) QDP
(23) TransformationProof [EQUIVALENT, 0 ms]
(24) QDP
(25) TransformationProof [EQUIVALENT, 0 ms]
(26) QDP
(27) TransformationProof [EQUIVALENT, 0 ms]
(28) QDP
(29) TransformationProof [EQUIVALENT, 0 ms]
(30) QDP
(31) TransformationProof [EQUIVALENT, 0 ms]
(32) QDP
(33) TransformationProof [EQUIVALENT, 0 ms]
(34) QDP
(35) TransformationProof [EQUIVALENT, 0 ms]
(36) QDP
(37) TransformationProof [EQUIVALENT, 0 ms]
(38) QDP
(39) TransformationProof [EQUIVALENT, 0 ms]
(40) QDP
(41) TransformationProof [EQUIVALENT, 0 ms]
(42) QDP
(43) TransformationProof [EQUIVALENT, 0 ms]
(44) QDP
(45) TransformationProof [EQUIVALENT, 0 ms]
(46) QDP
(47) TransformationProof [EQUIVALENT, 0 ms]
(48) QDP
(49) TransformationProof [EQUIVALENT, 0 ms]
(50) QDP
(51) TransformationProof [EQUIVALENT, 0 ms]
(52) QDP
(53) TransformationProof [EQUIVALENT, 0 ms]
(54) QDP
(55) TransformationProof [EQUIVALENT, 0 ms]
(56) QDP
(57) TransformationProof [EQUIVALENT, 0 ms]
(58) QDP
(59) TransformationProof [EQUIVALENT, 0 ms]
(60) QDP
(61) TransformationProof [EQUIVALENT, 0 ms]
(62) QDP
(63) TransformationProof [EQUIVALENT, 0 ms]
(64) QDP
(65) TransformationProof [EQUIVALENT, 0 ms]
(66) QDP
(67) TransformationProof [EQUIVALENT, 0 ms]
(68) QDP
(69) TransformationProof [EQUIVALENT, 0 ms]
(70) QDP
(71) TransformationProof [EQUIVALENT, 0 ms]
(72) QDP
(73) TransformationProof [EQUIVALENT, 0 ms]
(74) QDP
(75) TransformationProof [EQUIVALENT, 0 ms]
(76) QDP
(77) TransformationProof [EQUIVALENT, 0 ms]
(78) QDP
(79) TransformationProof [EQUIVALENT, 0 ms]
(80) QDP
(81) TransformationProof [EQUIVALENT, 0 ms]
(82) QDP
(83) TransformationProof [EQUIVALENT, 0 ms]
(84) QDP
(85) TransformationProof [EQUIVALENT, 0 ms]
(86) QDP
(87) TransformationProof [EQUIVALENT, 0 ms]
(88) QDP
(89) TransformationProof [EQUIVALENT, 0 ms]
(90) QDP
(91) TransformationProof [EQUIVALENT, 0 ms]
(92) QDP
(93) TransformationProof [EQUIVALENT, 0 ms]
(94) QDP
(95) TransformationProof [EQUIVALENT, 0 ms]
(96) QDP
(97) TransformationProof [EQUIVALENT, 0 ms]
(98) QDP
(99) TransformationProof [EQUIVALENT, 0 ms]
(100) QDP
(101) TransformationProof [EQUIVALENT, 0 ms]
(102) QDP
(103) TransformationProof [EQUIVALENT, 0 ms]
(104) QDP
(105) TransformationProof [EQUIVALENT, 0 ms]
(106) QDP
(107) TransformationProof [EQUIVALENT, 0 ms]
(108) QDP
(109) TransformationProof [EQUIVALENT, 0 ms]
(110) QDP
(111) TransformationProof [EQUIVALENT, 0 ms]
(112) QDP
(113) TransformationProof [EQUIVALENT, 0 ms]
(114) QDP
(115) TransformationProof [EQUIVALENT, 0 ms]
(116) QDP
(117) TransformationProof [EQUIVALENT, 0 ms]
(118) QDP
(119) TransformationProof [EQUIVALENT, 0 ms]
(120) QDP
(121) TransformationProof [EQUIVALENT, 0 ms]
(122) QDP
(123) TransformationProof [EQUIVALENT, 0 ms]
(124) QDP
(125) TransformationProof [EQUIVALENT, 0 ms]
(126) QDP
(127) TransformationProof [EQUIVALENT, 0 ms]
(128) QDP
(129) TransformationProof [EQUIVALENT, 0 ms]
(130) QDP
(131) TransformationProof [EQUIVALENT, 0 ms]
(132) QDP
(133) TransformationProof [EQUIVALENT, 0 ms]
(134) QDP
(135) TransformationProof [EQUIVALENT, 0 ms]
(136) QDP
(137) TransformationProof [EQUIVALENT, 0 ms]
(138) QDP
(139) TransformationProof [EQUIVALENT, 0 ms]
(140) QDP
(141) TransformationProof [EQUIVALENT, 0 ms]
(142) QDP
(143) TransformationProof [EQUIVALENT, 0 ms]
(144) QDP
(145) TransformationProof [EQUIVALENT, 0 ms]
(146) QDP
(147) TransformationProof [EQUIVALENT, 0 ms]
(148) QDP
(149) TransformationProof [EQUIVALENT, 0 ms]
(150) QDP
(151) TransformationProof [EQUIVALENT, 0 ms]
(152) QDP
(153) TransformationProof [EQUIVALENT, 0 ms]
(154) QDP
(155) TransformationProof [EQUIVALENT, 0 ms]
(156) QDP
(157) TransformationProof [EQUIVALENT, 0 ms]
(158) QDP
(159) TransformationProof [EQUIVALENT, 0 ms]
(160) QDP
(161) TransformationProof [EQUIVALENT, 0 ms]
(162) QDP
(163) TransformationProof [EQUIVALENT, 0 ms]
(164) QDP
(165) TransformationProof [EQUIVALENT, 0 ms]
(166) QDP
(167) TransformationProof [EQUIVALENT, 0 ms]
(168) QDP
(169) TransformationProof [EQUIVALENT, 0 ms]
(170) QDP
(171) TransformationProof [EQUIVALENT, 0 ms]
(172) QDP
(173) TransformationProof [EQUIVALENT, 0 ms]
(174) QDP
(175) TransformationProof [EQUIVALENT, 0 ms]
(176) QDP
(177) TransformationProof [EQUIVALENT, 0 ms]
(178) QDP
(179) TransformationProof [EQUIVALENT, 0 ms]
(180) QDP
(181) DependencyGraphProof [EQUIVALENT, 0 ms]
(182) QDP
(183) TransformationProof [EQUIVALENT, 0 ms]
(184) QDP
(185) TransformationProof [EQUIVALENT, 0 ms]
(186) QDP
(187) TransformationProof [EQUIVALENT, 0 ms]
(188) QDP
(189) TransformationProof [EQUIVALENT, 0 ms]
(190) QDP
(191) TransformationProof [EQUIVALENT, 0 ms]
(192) QDP
(193) DependencyGraphProof [EQUIVALENT, 0 ms]
(194) QDP
(195) TransformationProof [EQUIVALENT, 0 ms]
(196) QDP
(197) DependencyGraphProof [EQUIVALENT, 0 ms]
(198) QDP
(199) TransformationProof [EQUIVALENT, 0 ms]
(200) QDP
(201) TransformationProof [EQUIVALENT, 0 ms]
(202) QDP
(203) TransformationProof [EQUIVALENT, 0 ms]
(204) QDP
(205) TransformationProof [EQUIVALENT, 0 ms]
(206) QDP
(207) TransformationProof [EQUIVALENT, 0 ms]
(208) QDP
(209) TransformationProof [EQUIVALENT, 0 ms]
(210) QDP
(211) DependencyGraphProof [EQUIVALENT, 0 ms]
(212) QDP
(213) TransformationProof [EQUIVALENT, 0 ms]
(214) QDP
(215) TransformationProof [EQUIVALENT, 0 ms]
(216) QDP
(217) TransformationProof [EQUIVALENT, 0 ms]
(218) QDP
(219) TransformationProof [EQUIVALENT, 0 ms]
(220) QDP
(221) TransformationProof [EQUIVALENT, 0 ms]
(222) QDP
(223) TransformationProof [EQUIVALENT, 0 ms]
(224) QDP
(225) TransformationProof [EQUIVALENT, 0 ms]
(226) QDP
(227) TransformationProof [EQUIVALENT, 0 ms]
(228) QDP
(229) TransformationProof [EQUIVALENT, 0 ms]
(230) QDP
(231) TransformationProof [EQUIVALENT, 0 ms]
(232) QDP
(233) DependencyGraphProof [EQUIVALENT, 0 ms]
(234) QDP
(235) TransformationProof [EQUIVALENT, 0 ms]
(236) QDP
(237) DependencyGraphProof [EQUIVALENT, 0 ms]
(238) QDP
(239) TransformationProof [EQUIVALENT, 0 ms]
(240) QDP
(241) TransformationProof [EQUIVALENT, 0 ms]
(242) QDP
(243) DependencyGraphProof [EQUIVALENT, 0 ms]
(244) QDP
(245) TransformationProof [EQUIVALENT, 0 ms]
(246) QDP
(247) TransformationProof [EQUIVALENT, 0 ms]
(248) QDP
(249) DependencyGraphProof [EQUIVALENT, 0 ms]
(250) QDP
(251) TransformationProof [EQUIVALENT, 0 ms]
(252) QDP
(253) TransformationProof [EQUIVALENT, 0 ms]
(254) QDP
(255) TransformationProof [EQUIVALENT, 0 ms]
(256) QDP
(257) DependencyGraphProof [EQUIVALENT, 0 ms]
(258) QDP
(259) TransformationProof [EQUIVALENT, 0 ms]
(260) QDP
(261) TransformationProof [EQUIVALENT, 0 ms]
(262) QDP
(263) TransformationProof [EQUIVALENT, 0 ms]
(264) QDP
(265) TransformationProof [EQUIVALENT, 0 ms]
(266) QDP
(267) TransformationProof [EQUIVALENT, 0 ms]
(268) QDP
(269) DependencyGraphProof [EQUIVALENT, 0 ms]
(270) QDP
(271) TransformationProof [EQUIVALENT, 0 ms]
(272) QDP
(273) DependencyGraphProof [EQUIVALENT, 0 ms]
(274) QDP
(275) TransformationProof [EQUIVALENT, 0 ms]
(276) QDP
(277) TransformationProof [EQUIVALENT, 0 ms]
(278) QDP
(279) DependencyGraphProof [EQUIVALENT, 0 ms]
(280) QDP
(281) TransformationProof [EQUIVALENT, 0 ms]
(282) QDP
(283) TransformationProof [EQUIVALENT, 0 ms]
(284) QDP
(285) TransformationProof [EQUIVALENT, 0 ms]
(286) QDP
(287) DependencyGraphProof [EQUIVALENT, 0 ms]
(288) QDP
(289) TransformationProof [EQUIVALENT, 0 ms]
(290) QDP
(291) DependencyGraphProof [EQUIVALENT, 0 ms]
(292) QDP
(293) TransformationProof [EQUIVALENT, 0 ms]
(294) QDP
(295) TransformationProof [EQUIVALENT, 0 ms]
(296) QDP
(297) TransformationProof [EQUIVALENT, 0 ms]
(298) QDP
(299) DependencyGraphProof [EQUIVALENT, 0 ms]
(300) QDP
(301) TransformationProof [EQUIVALENT, 0 ms]
(302) QDP
(303) TransformationProof [EQUIVALENT, 0 ms]
(304) QDP
(305) DependencyGraphProof [EQUIVALENT, 0 ms]
(306) QDP
(307) TransformationProof [EQUIVALENT, 0 ms]
(308) QDP
(309) TransformationProof [EQUIVALENT, 0 ms]
(310) QDP
(311) DependencyGraphProof [EQUIVALENT, 0 ms]
(312) QDP
(313) TransformationProof [EQUIVALENT, 0 ms]
(314) QDP
(315) TransformationProof [EQUIVALENT, 0 ms]
(316) QDP
(317) TransformationProof [EQUIVALENT, 0 ms]
(318) QDP
(319) TransformationProof [EQUIVALENT, 0 ms]
(320) QDP
(321) DependencyGraphProof [EQUIVALENT, 0 ms]
(322) QDP
(323) TransformationProof [EQUIVALENT, 0 ms]
(324) QDP
(325) TransformationProof [EQUIVALENT, 0 ms]
(326) QDP
(327) DependencyGraphProof [EQUIVALENT, 0 ms]
(328) QDP
(329) TransformationProof [EQUIVALENT, 0 ms]
(330) QDP
(331) TransformationProof [EQUIVALENT, 0 ms]
(332) QDP
(333) TransformationProof [EQUIVALENT, 0 ms]
(334) QDP
(335) TransformationProof [EQUIVALENT, 0 ms]
(336) QDP
(337) DependencyGraphProof [EQUIVALENT, 0 ms]
(338) QDP
(339) TransformationProof [EQUIVALENT, 0 ms]
(340) QDP
(341) TransformationProof [EQUIVALENT, 0 ms]
(342) QDP
(343) TransformationProof [EQUIVALENT, 0 ms]
(344) QDP
(345) TransformationProof [EQUIVALENT, 0 ms]
(346) QDP
(347) TransformationProof [EQUIVALENT, 0 ms]
(348) QDP
(349) TransformationProof [EQUIVALENT, 0 ms]
(350) QDP
(351) DependencyGraphProof [EQUIVALENT, 0 ms]
(352) QDP
(353) TransformationProof [EQUIVALENT, 0 ms]
(354) QDP
(355) TransformationProof [EQUIVALENT, 0 ms]
(356) QDP
(357) DependencyGraphProof [EQUIVALENT, 0 ms]
(358) QDP
(359) TransformationProof [EQUIVALENT, 0 ms]
(360) QDP
(361) DependencyGraphProof [EQUIVALENT, 0 ms]
(362) QDP
(363) TransformationProof [EQUIVALENT, 0 ms]
(364) QDP
(365) DependencyGraphProof [EQUIVALENT, 0 ms]
(366) QDP
(367) TransformationProof [EQUIVALENT, 0 ms]
(368) QDP
(369) DependencyGraphProof [EQUIVALENT, 0 ms]
(370) QDP
(371) TransformationProof [EQUIVALENT, 0 ms]
(372) QDP
(373) DependencyGraphProof [EQUIVALENT, 0 ms]
(374) QDP
(375) TransformationProof [EQUIVALENT, 0 ms]
(376) QDP
(377) TransformationProof [EQUIVALENT, 0 ms]
(378) QDP
(379) TransformationProof [EQUIVALENT, 0 ms]
(380) QDP
(381) TransformationProof [EQUIVALENT, 0 ms]
(382) QDP
(383) DependencyGraphProof [EQUIVALENT, 0 ms]
(384) QDP
(385) TransformationProof [EQUIVALENT, 0 ms]
(386) QDP
(387) TransformationProof [EQUIVALENT, 0 ms]
(388) QDP
(389) TransformationProof [EQUIVALENT, 0 ms]
(390) QDP
(391) DependencyGraphProof [EQUIVALENT, 0 ms]
(392) QDP
(393) TransformationProof [EQUIVALENT, 0 ms]
(394) QDP
(395) DependencyGraphProof [EQUIVALENT, 0 ms]
(396) QDP
(397) TransformationProof [EQUIVALENT, 0 ms]
(398) QDP
(399) DependencyGraphProof [EQUIVALENT, 0 ms]
(400) QDP
(401) TransformationProof [EQUIVALENT, 0 ms]
(402) QDP
(403) TransformationProof [EQUIVALENT, 0 ms]
(404) QDP
(405) DependencyGraphProof [EQUIVALENT, 0 ms]
(406) QDP
(407) TransformationProof [EQUIVALENT, 0 ms]
(408) QDP
(409) DependencyGraphProof [EQUIVALENT, 0 ms]
(410) QDP
(411) TransformationProof [EQUIVALENT, 0 ms]
(412) QDP
(413) TransformationProof [EQUIVALENT, 0 ms]
(414) QDP
(415) TransformationProof [EQUIVALENT, 0 ms]
(416) QDP
(417) TransformationProof [EQUIVALENT, 0 ms]
(418) QDP
(419) DependencyGraphProof [EQUIVALENT, 0 ms]
(420) QDP
(421) TransformationProof [EQUIVALENT, 0 ms]
(422) QDP
(423) TransformationProof [EQUIVALENT, 0 ms]
(424) QDP
(425) DependencyGraphProof [EQUIVALENT, 0 ms]
(426) QDP
(427) TransformationProof [EQUIVALENT, 0 ms]
(428) QDP
(429) DependencyGraphProof [EQUIVALENT, 0 ms]
(430) QDP
(431) TransformationProof [EQUIVALENT, 0 ms]
(432) QDP
(433) DependencyGraphProof [EQUIVALENT, 0 ms]
(434) QDP
(435) TransformationProof [EQUIVALENT, 0 ms]
(436) QDP
(437) TransformationProof [EQUIVALENT, 0 ms]
(438) QDP
(439) TransformationProof [EQUIVALENT, 0 ms]
(440) QDP
(441) DependencyGraphProof [EQUIVALENT, 0 ms]
(442) QDP
(443) TransformationProof [EQUIVALENT, 0 ms]
(444) QDP
(445) DependencyGraphProof [EQUIVALENT, 0 ms]
(446) QDP
(447) TransformationProof [EQUIVALENT, 0 ms]
(448) QDP
(449) DependencyGraphProof [EQUIVALENT, 0 ms]
(450) QDP
(451) TransformationProof [EQUIVALENT, 0 ms]
(452) QDP
(453) TransformationProof [EQUIVALENT, 0 ms]
(454) QDP
(455) TransformationProof [EQUIVALENT, 0 ms]
(456) QDP
(457) DependencyGraphProof [EQUIVALENT, 0 ms]
(458) QDP
(459) TransformationProof [EQUIVALENT, 0 ms]
(460) QDP
(461) DependencyGraphProof [EQUIVALENT, 0 ms]
(462) QDP
(463) TransformationProof [EQUIVALENT, 0 ms]
(464) QDP
(465) TransformationProof [EQUIVALENT, 0 ms]
(466) QDP
(467) DependencyGraphProof [EQUIVALENT, 0 ms]
(468) QDP
(469) TransformationProof [EQUIVALENT, 0 ms]
(470) QDP
(471) DependencyGraphProof [EQUIVALENT, 0 ms]
(472) QDP
(473) TransformationProof [EQUIVALENT, 0 ms]
(474) QDP
(475) TransformationProof [EQUIVALENT, 0 ms]
(476) QDP
(477) DependencyGraphProof [EQUIVALENT, 0 ms]
(478) QDP
(479) TransformationProof [EQUIVALENT, 0 ms]
(480) QDP
(481) DependencyGraphProof [EQUIVALENT, 0 ms]
(482) QDP
(483) TransformationProof [EQUIVALENT, 0 ms]
(484) QDP
(485) DependencyGraphProof [EQUIVALENT, 0 ms]
(486) QDP
(487) TransformationProof [EQUIVALENT, 0 ms]
(488) QDP
(489) DependencyGraphProof [EQUIVALENT, 0 ms]
(490) QDP
(491) TransformationProof [EQUIVALENT, 0 ms]
(492) QDP
(493) DependencyGraphProof [EQUIVALENT, 0 ms]
(494) QDP
(495) TransformationProof [EQUIVALENT, 0 ms]
(496) QDP
(497) DependencyGraphProof [EQUIVALENT, 0 ms]
(498) QDP
(499) TransformationProof [EQUIVALENT, 0 ms]
(500) QDP
(501) DependencyGraphProof [EQUIVALENT, 0 ms]
(502) QDP
(503) TransformationProof [EQUIVALENT, 0 ms]
(504) QDP
(505) DependencyGraphProof [EQUIVALENT, 0 ms]
(506) QDP
(507) TransformationProof [EQUIVALENT, 0 ms]
(508) QDP
(509) TransformationProof [EQUIVALENT, 0 ms]
(510) QDP
(511) DependencyGraphProof [EQUIVALENT, 0 ms]
(512) QDP
(513) TransformationProof [EQUIVALENT, 0 ms]
(514) QDP
(515) UsableRulesReductionPairsProof [EQUIVALENT, 0 ms]
(516) QDP
(517) MNOCProof [EQUIVALENT, 0 ms]
(518) QDP
(519) DependencyGraphProof [EQUIVALENT, 0 ms]
(520) TRUE


----------------------------------------

(0)
Obligation:
Conditional term rewrite system:
The TRS R consists of the following rules:

   a -> d
   b -> d
   a -> e
   b -> e
   A -> h(f(a), f(b))
   h(x, x) -> g(x, x)
   g(d, e) -> A

The conditional TRS C consists of the following conditional rules:

   f(x) -> x <= x -> d


----------------------------------------

(1) CTRSToQTRSProof (SOUND)
The conditional rules have been transormed into unconditional rules according to [CTRS,AAECCNOC].
----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f(x) -> U1(x, x)
   U1(d, x) -> x
   a -> d
   b -> d
   a -> e
   b -> e
   A -> h(f(a), f(b))
   h(x, x) -> g(x, x)
   g(d, e) -> A

Q is empty.

----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(4)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F(x) -> U1^1(x, x)
   A^1 -> H(f(a), f(b))
   A^1 -> F(a)
   A^1 -> A^2
   A^1 -> F(b)
   A^1 -> B
   H(x, x) -> G(x, x)
   G(d, e) -> A^1

The TRS R consists of the following rules:

   f(x) -> U1(x, x)
   U1(d, x) -> x
   a -> d
   b -> d
   a -> e
   b -> e
   A -> h(f(a), f(b))
   h(x, x) -> g(x, x)
   g(d, e) -> A

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 5 less nodes.
----------------------------------------

(6)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(a), f(b))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1

The TRS R consists of the following rules:

   f(x) -> U1(x, x)
   U1(d, x) -> x
   a -> d
   b -> d
   a -> e
   b -> e
   A -> h(f(a), f(b))
   h(x, x) -> g(x, x)
   g(d, e) -> A

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(7) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   A -> h(f(a), f(b))
   h(x, x) -> g(x, x)
   g(d, e) -> A
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(A^1) = 0
   POL(G(x_1, x_2)) = x_1 + x_2
   POL(H(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(U1(x_1, x_2)) = x_1 + x_2
   POL(a) = 0
   POL(b) = 0
   POL(d) = 0
   POL(e) = 0
   POL(f(x_1)) = 2*x_1


----------------------------------------

(8)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(a), f(b))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(9) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), f(b)),A^1 -> H(U1(a, a), f(b)))
   (A^1 -> H(f(d), f(b)),A^1 -> H(f(d), f(b)))
   (A^1 -> H(f(e), f(b)),A^1 -> H(f(e), f(b)))
   (A^1 -> H(f(a), U1(b, b)),A^1 -> H(f(a), U1(b, b)))
   (A^1 -> H(f(a), f(d)),A^1 -> H(f(a), f(d)))
   (A^1 -> H(f(a), f(e)),A^1 -> H(f(a), f(e)))


----------------------------------------

(10)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(U1(a, a), f(b))
   A^1 -> H(f(d), f(b))
   A^1 -> H(f(e), f(b))
   A^1 -> H(f(a), U1(b, b))
   A^1 -> H(f(a), f(d))
   A^1 -> H(f(a), f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(11) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), f(b)),A^1 -> H(U1(d, a), f(b)))
   (A^1 -> H(U1(e, a), f(b)),A^1 -> H(U1(e, a), f(b)))
   (A^1 -> H(U1(a, d), f(b)),A^1 -> H(U1(a, d), f(b)))
   (A^1 -> H(U1(a, e), f(b)),A^1 -> H(U1(a, e), f(b)))
   (A^1 -> H(U1(a, a), U1(b, b)),A^1 -> H(U1(a, a), U1(b, b)))
   (A^1 -> H(U1(a, a), f(d)),A^1 -> H(U1(a, a), f(d)))
   (A^1 -> H(U1(a, a), f(e)),A^1 -> H(U1(a, a), f(e)))


----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(b))
   A^1 -> H(f(e), f(b))
   A^1 -> H(f(a), U1(b, b))
   A^1 -> H(f(a), f(d))
   A^1 -> H(f(a), f(e))
   A^1 -> H(U1(d, a), f(b))
   A^1 -> H(U1(e, a), f(b))
   A^1 -> H(U1(a, d), f(b))
   A^1 -> H(U1(a, e), f(b))
   A^1 -> H(U1(a, a), U1(b, b))
   A^1 -> H(U1(a, a), f(d))
   A^1 -> H(U1(a, a), f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(13) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), f(b)),A^1 -> H(U1(d, d), f(b)))
   (A^1 -> H(f(d), U1(b, b)),A^1 -> H(f(d), U1(b, b)))
   (A^1 -> H(f(d), f(d)),A^1 -> H(f(d), f(d)))
   (A^1 -> H(f(d), f(e)),A^1 -> H(f(d), f(e)))


----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(b))
   A^1 -> H(f(a), U1(b, b))
   A^1 -> H(f(a), f(d))
   A^1 -> H(f(a), f(e))
   A^1 -> H(U1(d, a), f(b))
   A^1 -> H(U1(e, a), f(b))
   A^1 -> H(U1(a, d), f(b))
   A^1 -> H(U1(a, e), f(b))
   A^1 -> H(U1(a, a), U1(b, b))
   A^1 -> H(U1(a, a), f(d))
   A^1 -> H(U1(a, a), f(e))
   A^1 -> H(U1(d, d), f(b))
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(15) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), f(b)),A^1 -> H(U1(e, e), f(b)))
   (A^1 -> H(f(e), U1(b, b)),A^1 -> H(f(e), U1(b, b)))
   (A^1 -> H(f(e), f(d)),A^1 -> H(f(e), f(d)))
   (A^1 -> H(f(e), f(e)),A^1 -> H(f(e), f(e)))


----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(a), U1(b, b))
   A^1 -> H(f(a), f(d))
   A^1 -> H(f(a), f(e))
   A^1 -> H(U1(d, a), f(b))
   A^1 -> H(U1(e, a), f(b))
   A^1 -> H(U1(a, d), f(b))
   A^1 -> H(U1(a, e), f(b))
   A^1 -> H(U1(a, a), U1(b, b))
   A^1 -> H(U1(a, a), f(d))
   A^1 -> H(U1(a, a), f(e))
   A^1 -> H(U1(d, d), f(b))
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(17) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), U1(b, b)),A^1 -> H(U1(a, a), U1(b, b)))
   (A^1 -> H(f(d), U1(b, b)),A^1 -> H(f(d), U1(b, b)))
   (A^1 -> H(f(e), U1(b, b)),A^1 -> H(f(e), U1(b, b)))
   (A^1 -> H(f(a), U1(d, b)),A^1 -> H(f(a), U1(d, b)))
   (A^1 -> H(f(a), U1(e, b)),A^1 -> H(f(a), U1(e, b)))
   (A^1 -> H(f(a), U1(b, d)),A^1 -> H(f(a), U1(b, d)))
   (A^1 -> H(f(a), U1(b, e)),A^1 -> H(f(a), U1(b, e)))


----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(a), f(d))
   A^1 -> H(f(a), f(e))
   A^1 -> H(U1(d, a), f(b))
   A^1 -> H(U1(e, a), f(b))
   A^1 -> H(U1(a, d), f(b))
   A^1 -> H(U1(a, e), f(b))
   A^1 -> H(U1(a, a), U1(b, b))
   A^1 -> H(U1(a, a), f(d))
   A^1 -> H(U1(a, a), f(e))
   A^1 -> H(U1(d, d), f(b))
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(19) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), f(d)),A^1 -> H(U1(a, a), f(d)))
   (A^1 -> H(f(d), f(d)),A^1 -> H(f(d), f(d)))
   (A^1 -> H(f(e), f(d)),A^1 -> H(f(e), f(d)))
   (A^1 -> H(f(a), U1(d, d)),A^1 -> H(f(a), U1(d, d)))


----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(a), f(e))
   A^1 -> H(U1(d, a), f(b))
   A^1 -> H(U1(e, a), f(b))
   A^1 -> H(U1(a, d), f(b))
   A^1 -> H(U1(a, e), f(b))
   A^1 -> H(U1(a, a), U1(b, b))
   A^1 -> H(U1(a, a), f(d))
   A^1 -> H(U1(a, a), f(e))
   A^1 -> H(U1(d, d), f(b))
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(21) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), f(e)),A^1 -> H(U1(a, a), f(e)))
   (A^1 -> H(f(d), f(e)),A^1 -> H(f(d), f(e)))
   (A^1 -> H(f(e), f(e)),A^1 -> H(f(e), f(e)))
   (A^1 -> H(f(a), U1(e, e)),A^1 -> H(f(a), U1(e, e)))


----------------------------------------

(22)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(U1(d, a), f(b))
   A^1 -> H(U1(e, a), f(b))
   A^1 -> H(U1(a, d), f(b))
   A^1 -> H(U1(a, e), f(b))
   A^1 -> H(U1(a, a), U1(b, b))
   A^1 -> H(U1(a, a), f(d))
   A^1 -> H(U1(a, a), f(e))
   A^1 -> H(U1(d, d), f(b))
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(23) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, f(b)),A^1 -> H(a, f(b)))
   (A^1 -> H(U1(d, d), f(b)),A^1 -> H(U1(d, d), f(b)))
   (A^1 -> H(U1(d, e), f(b)),A^1 -> H(U1(d, e), f(b)))
   (A^1 -> H(U1(d, a), U1(b, b)),A^1 -> H(U1(d, a), U1(b, b)))
   (A^1 -> H(U1(d, a), f(d)),A^1 -> H(U1(d, a), f(d)))
   (A^1 -> H(U1(d, a), f(e)),A^1 -> H(U1(d, a), f(e)))


----------------------------------------

(24)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(U1(e, a), f(b))
   A^1 -> H(U1(a, d), f(b))
   A^1 -> H(U1(a, e), f(b))
   A^1 -> H(U1(a, a), U1(b, b))
   A^1 -> H(U1(a, a), f(d))
   A^1 -> H(U1(a, a), f(e))
   A^1 -> H(U1(d, d), f(b))
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(25) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), f(b)),A^1 -> H(U1(e, d), f(b)))
   (A^1 -> H(U1(e, e), f(b)),A^1 -> H(U1(e, e), f(b)))
   (A^1 -> H(U1(e, a), U1(b, b)),A^1 -> H(U1(e, a), U1(b, b)))
   (A^1 -> H(U1(e, a), f(d)),A^1 -> H(U1(e, a), f(d)))
   (A^1 -> H(U1(e, a), f(e)),A^1 -> H(U1(e, a), f(e)))


----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(U1(a, d), f(b))
   A^1 -> H(U1(a, e), f(b))
   A^1 -> H(U1(a, a), U1(b, b))
   A^1 -> H(U1(a, a), f(d))
   A^1 -> H(U1(a, a), f(e))
   A^1 -> H(U1(d, d), f(b))
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(27) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), f(b)),A^1 -> H(U1(d, d), f(b)))
   (A^1 -> H(U1(e, d), f(b)),A^1 -> H(U1(e, d), f(b)))
   (A^1 -> H(U1(a, d), U1(b, b)),A^1 -> H(U1(a, d), U1(b, b)))
   (A^1 -> H(U1(a, d), f(d)),A^1 -> H(U1(a, d), f(d)))
   (A^1 -> H(U1(a, d), f(e)),A^1 -> H(U1(a, d), f(e)))


----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(U1(a, e), f(b))
   A^1 -> H(U1(a, a), U1(b, b))
   A^1 -> H(U1(a, a), f(d))
   A^1 -> H(U1(a, a), f(e))
   A^1 -> H(U1(d, d), f(b))
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(29) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), f(b)),A^1 -> H(U1(d, e), f(b)))
   (A^1 -> H(U1(e, e), f(b)),A^1 -> H(U1(e, e), f(b)))
   (A^1 -> H(U1(a, e), U1(b, b)),A^1 -> H(U1(a, e), U1(b, b)))
   (A^1 -> H(U1(a, e), f(d)),A^1 -> H(U1(a, e), f(d)))
   (A^1 -> H(U1(a, e), f(e)),A^1 -> H(U1(a, e), f(e)))


----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(U1(a, a), U1(b, b))
   A^1 -> H(U1(a, a), f(d))
   A^1 -> H(U1(a, a), f(e))
   A^1 -> H(U1(d, d), f(b))
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(31) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), U1(b, b)),A^1 -> H(U1(d, a), U1(b, b)))
   (A^1 -> H(U1(e, a), U1(b, b)),A^1 -> H(U1(e, a), U1(b, b)))
   (A^1 -> H(U1(a, d), U1(b, b)),A^1 -> H(U1(a, d), U1(b, b)))
   (A^1 -> H(U1(a, e), U1(b, b)),A^1 -> H(U1(a, e), U1(b, b)))
   (A^1 -> H(U1(a, a), U1(d, b)),A^1 -> H(U1(a, a), U1(d, b)))
   (A^1 -> H(U1(a, a), U1(e, b)),A^1 -> H(U1(a, a), U1(e, b)))
   (A^1 -> H(U1(a, a), U1(b, d)),A^1 -> H(U1(a, a), U1(b, d)))
   (A^1 -> H(U1(a, a), U1(b, e)),A^1 -> H(U1(a, a), U1(b, e)))


----------------------------------------

(32)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(U1(a, a), f(d))
   A^1 -> H(U1(a, a), f(e))
   A^1 -> H(U1(d, d), f(b))
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(33) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), f(d)),A^1 -> H(U1(d, a), f(d)))
   (A^1 -> H(U1(e, a), f(d)),A^1 -> H(U1(e, a), f(d)))
   (A^1 -> H(U1(a, d), f(d)),A^1 -> H(U1(a, d), f(d)))
   (A^1 -> H(U1(a, e), f(d)),A^1 -> H(U1(a, e), f(d)))
   (A^1 -> H(U1(a, a), U1(d, d)),A^1 -> H(U1(a, a), U1(d, d)))


----------------------------------------

(34)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(U1(a, a), f(e))
   A^1 -> H(U1(d, d), f(b))
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(35) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), f(e)),A^1 -> H(U1(d, a), f(e)))
   (A^1 -> H(U1(e, a), f(e)),A^1 -> H(U1(e, a), f(e)))
   (A^1 -> H(U1(a, d), f(e)),A^1 -> H(U1(a, d), f(e)))
   (A^1 -> H(U1(a, e), f(e)),A^1 -> H(U1(a, e), f(e)))
   (A^1 -> H(U1(a, a), U1(e, e)),A^1 -> H(U1(a, a), U1(e, e)))


----------------------------------------

(36)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(U1(d, d), f(b))
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(37) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, f(b)),A^1 -> H(d, f(b)))
   (A^1 -> H(U1(d, d), U1(b, b)),A^1 -> H(U1(d, d), U1(b, b)))
   (A^1 -> H(U1(d, d), f(d)),A^1 -> H(U1(d, d), f(d)))
   (A^1 -> H(U1(d, d), f(e)),A^1 -> H(U1(d, d), f(e)))


----------------------------------------

(38)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), U1(b, b))
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(39) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(b, b)),A^1 -> H(U1(d, d), U1(b, b)))
   (A^1 -> H(f(d), U1(d, b)),A^1 -> H(f(d), U1(d, b)))
   (A^1 -> H(f(d), U1(e, b)),A^1 -> H(f(d), U1(e, b)))
   (A^1 -> H(f(d), U1(b, d)),A^1 -> H(f(d), U1(b, d)))
   (A^1 -> H(f(d), U1(b, e)),A^1 -> H(f(d), U1(b, e)))


----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(d), f(e))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(41) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), f(e)),A^1 -> H(U1(d, d), f(e)))
   (A^1 -> H(f(d), U1(e, e)),A^1 -> H(f(d), U1(e, e)))


----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(U1(e, e), f(b))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(43) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, e), f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(b, b)),A^1 -> H(U1(e, e), U1(b, b)))
   (A^1 -> H(U1(e, e), f(d)),A^1 -> H(U1(e, e), f(d)))
   (A^1 -> H(U1(e, e), f(e)),A^1 -> H(U1(e, e), f(e)))


----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), U1(b, b))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(45) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(b, b)),A^1 -> H(U1(e, e), U1(b, b)))
   (A^1 -> H(f(e), U1(d, b)),A^1 -> H(f(e), U1(d, b)))
   (A^1 -> H(f(e), U1(e, b)),A^1 -> H(f(e), U1(e, b)))
   (A^1 -> H(f(e), U1(b, d)),A^1 -> H(f(e), U1(b, d)))
   (A^1 -> H(f(e), U1(b, e)),A^1 -> H(f(e), U1(b, e)))


----------------------------------------

(46)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(47) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), f(d)),A^1 -> H(U1(e, e), f(d)))
   (A^1 -> H(f(e), U1(d, d)),A^1 -> H(f(e), U1(d, d)))


----------------------------------------

(48)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, b))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(49) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), U1(d, b)),A^1 -> H(U1(a, a), U1(d, b)))
   (A^1 -> H(f(d), U1(d, b)),A^1 -> H(f(d), U1(d, b)))
   (A^1 -> H(f(e), U1(d, b)),A^1 -> H(f(e), U1(d, b)))
   (A^1 -> H(f(a), b),A^1 -> H(f(a), b))
   (A^1 -> H(f(a), U1(d, d)),A^1 -> H(f(a), U1(d, d)))
   (A^1 -> H(f(a), U1(d, e)),A^1 -> H(f(a), U1(d, e)))


----------------------------------------

(50)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(e, b))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(51) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), U1(e, b)),A^1 -> H(U1(a, a), U1(e, b)))
   (A^1 -> H(f(d), U1(e, b)),A^1 -> H(f(d), U1(e, b)))
   (A^1 -> H(f(e), U1(e, b)),A^1 -> H(f(e), U1(e, b)))
   (A^1 -> H(f(a), U1(e, d)),A^1 -> H(f(a), U1(e, d)))
   (A^1 -> H(f(a), U1(e, e)),A^1 -> H(f(a), U1(e, e)))


----------------------------------------

(52)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(b, d))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(53) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), U1(b, d)),A^1 -> H(U1(a, a), U1(b, d)))
   (A^1 -> H(f(d), U1(b, d)),A^1 -> H(f(d), U1(b, d)))
   (A^1 -> H(f(e), U1(b, d)),A^1 -> H(f(e), U1(b, d)))
   (A^1 -> H(f(a), U1(d, d)),A^1 -> H(f(a), U1(d, d)))
   (A^1 -> H(f(a), U1(e, d)),A^1 -> H(f(a), U1(e, d)))


----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(b, e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(55) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), U1(b, e)),A^1 -> H(U1(a, a), U1(b, e)))
   (A^1 -> H(f(d), U1(b, e)),A^1 -> H(f(d), U1(b, e)))
   (A^1 -> H(f(e), U1(b, e)),A^1 -> H(f(e), U1(b, e)))
   (A^1 -> H(f(a), U1(d, e)),A^1 -> H(f(a), U1(d, e)))
   (A^1 -> H(f(a), U1(e, e)),A^1 -> H(f(a), U1(e, e)))


----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, d))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(57) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), U1(d, d)),A^1 -> H(U1(a, a), U1(d, d)))
   (A^1 -> H(f(d), U1(d, d)),A^1 -> H(f(d), U1(d, d)))
   (A^1 -> H(f(e), U1(d, d)),A^1 -> H(f(e), U1(d, d)))
   (A^1 -> H(f(a), d),A^1 -> H(f(a), d))


----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(e, e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(59) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), U1(e, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), U1(e, e)),A^1 -> H(U1(a, a), U1(e, e)))
   (A^1 -> H(f(d), U1(e, e)),A^1 -> H(f(d), U1(e, e)))
   (A^1 -> H(f(e), U1(e, e)),A^1 -> H(f(e), U1(e, e)))


----------------------------------------

(60)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(a, f(b))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(61) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, f(b)),A^1 -> H(d, f(b)))
   (A^1 -> H(e, f(b)),A^1 -> H(e, f(b)))
   (A^1 -> H(a, U1(b, b)),A^1 -> H(a, U1(b, b)))
   (A^1 -> H(a, f(d)),A^1 -> H(a, f(d)))
   (A^1 -> H(a, f(e)),A^1 -> H(a, f(e)))


----------------------------------------

(62)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, e), f(b))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(63) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, f(b)),A^1 -> H(e, f(b)))
   (A^1 -> H(U1(d, e), U1(b, b)),A^1 -> H(U1(d, e), U1(b, b)))
   (A^1 -> H(U1(d, e), f(d)),A^1 -> H(U1(d, e), f(d)))
   (A^1 -> H(U1(d, e), f(e)),A^1 -> H(U1(d, e), f(e)))


----------------------------------------

(64)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, a), U1(b, b))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(65) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, U1(b, b)),A^1 -> H(a, U1(b, b)))
   (A^1 -> H(U1(d, d), U1(b, b)),A^1 -> H(U1(d, d), U1(b, b)))
   (A^1 -> H(U1(d, e), U1(b, b)),A^1 -> H(U1(d, e), U1(b, b)))
   (A^1 -> H(U1(d, a), U1(d, b)),A^1 -> H(U1(d, a), U1(d, b)))
   (A^1 -> H(U1(d, a), U1(e, b)),A^1 -> H(U1(d, a), U1(e, b)))
   (A^1 -> H(U1(d, a), U1(b, d)),A^1 -> H(U1(d, a), U1(b, d)))
   (A^1 -> H(U1(d, a), U1(b, e)),A^1 -> H(U1(d, a), U1(b, e)))


----------------------------------------

(66)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, a), f(d))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(67) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, f(d)),A^1 -> H(a, f(d)))
   (A^1 -> H(U1(d, d), f(d)),A^1 -> H(U1(d, d), f(d)))
   (A^1 -> H(U1(d, e), f(d)),A^1 -> H(U1(d, e), f(d)))
   (A^1 -> H(U1(d, a), U1(d, d)),A^1 -> H(U1(d, a), U1(d, d)))


----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, a), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(69) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, f(e)),A^1 -> H(a, f(e)))
   (A^1 -> H(U1(d, d), f(e)),A^1 -> H(U1(d, d), f(e)))
   (A^1 -> H(U1(d, e), f(e)),A^1 -> H(U1(d, e), f(e)))
   (A^1 -> H(U1(d, a), U1(e, e)),A^1 -> H(U1(d, a), U1(e, e)))


----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, d), f(b))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(71) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, d), f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(b, b)),A^1 -> H(U1(e, d), U1(b, b)))
   (A^1 -> H(U1(e, d), f(d)),A^1 -> H(U1(e, d), f(d)))
   (A^1 -> H(U1(e, d), f(e)),A^1 -> H(U1(e, d), f(e)))


----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, a), U1(b, b))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(73) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(b, b)),A^1 -> H(U1(e, d), U1(b, b)))
   (A^1 -> H(U1(e, e), U1(b, b)),A^1 -> H(U1(e, e), U1(b, b)))
   (A^1 -> H(U1(e, a), U1(d, b)),A^1 -> H(U1(e, a), U1(d, b)))
   (A^1 -> H(U1(e, a), U1(e, b)),A^1 -> H(U1(e, a), U1(e, b)))
   (A^1 -> H(U1(e, a), U1(b, d)),A^1 -> H(U1(e, a), U1(b, d)))
   (A^1 -> H(U1(e, a), U1(b, e)),A^1 -> H(U1(e, a), U1(b, e)))


----------------------------------------

(74)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, a), f(d))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(75) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), f(d)),A^1 -> H(U1(e, d), f(d)))
   (A^1 -> H(U1(e, e), f(d)),A^1 -> H(U1(e, e), f(d)))
   (A^1 -> H(U1(e, a), U1(d, d)),A^1 -> H(U1(e, a), U1(d, d)))


----------------------------------------

(76)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, a), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(77) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), f(e)),A^1 -> H(U1(e, d), f(e)))
   (A^1 -> H(U1(e, e), f(e)),A^1 -> H(U1(e, e), f(e)))
   (A^1 -> H(U1(e, a), U1(e, e)),A^1 -> H(U1(e, a), U1(e, e)))


----------------------------------------

(78)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, d), U1(b, b))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(79) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(b, b)),A^1 -> H(U1(d, d), U1(b, b)))
   (A^1 -> H(U1(e, d), U1(b, b)),A^1 -> H(U1(e, d), U1(b, b)))
   (A^1 -> H(U1(a, d), U1(d, b)),A^1 -> H(U1(a, d), U1(d, b)))
   (A^1 -> H(U1(a, d), U1(e, b)),A^1 -> H(U1(a, d), U1(e, b)))
   (A^1 -> H(U1(a, d), U1(b, d)),A^1 -> H(U1(a, d), U1(b, d)))
   (A^1 -> H(U1(a, d), U1(b, e)),A^1 -> H(U1(a, d), U1(b, e)))


----------------------------------------

(80)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, d), f(d))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(81) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), f(d)),A^1 -> H(U1(d, d), f(d)))
   (A^1 -> H(U1(e, d), f(d)),A^1 -> H(U1(e, d), f(d)))
   (A^1 -> H(U1(a, d), U1(d, d)),A^1 -> H(U1(a, d), U1(d, d)))


----------------------------------------

(82)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, d), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(83) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), f(e)),A^1 -> H(U1(d, d), f(e)))
   (A^1 -> H(U1(e, d), f(e)),A^1 -> H(U1(e, d), f(e)))
   (A^1 -> H(U1(a, d), U1(e, e)),A^1 -> H(U1(a, d), U1(e, e)))


----------------------------------------

(84)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, e), U1(b, b))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(85) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), U1(b, b)),A^1 -> H(U1(d, e), U1(b, b)))
   (A^1 -> H(U1(e, e), U1(b, b)),A^1 -> H(U1(e, e), U1(b, b)))
   (A^1 -> H(U1(a, e), U1(d, b)),A^1 -> H(U1(a, e), U1(d, b)))
   (A^1 -> H(U1(a, e), U1(e, b)),A^1 -> H(U1(a, e), U1(e, b)))
   (A^1 -> H(U1(a, e), U1(b, d)),A^1 -> H(U1(a, e), U1(b, d)))
   (A^1 -> H(U1(a, e), U1(b, e)),A^1 -> H(U1(a, e), U1(b, e)))


----------------------------------------

(86)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, e), f(d))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(87) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), f(d)),A^1 -> H(U1(d, e), f(d)))
   (A^1 -> H(U1(e, e), f(d)),A^1 -> H(U1(e, e), f(d)))
   (A^1 -> H(U1(a, e), U1(d, d)),A^1 -> H(U1(a, e), U1(d, d)))


----------------------------------------

(88)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(89) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), f(e)),A^1 -> H(U1(d, e), f(e)))
   (A^1 -> H(U1(e, e), f(e)),A^1 -> H(U1(e, e), f(e)))
   (A^1 -> H(U1(a, e), U1(e, e)),A^1 -> H(U1(a, e), U1(e, e)))


----------------------------------------

(90)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, a), U1(d, b))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(91) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), U1(d, b)),A^1 -> H(U1(d, a), U1(d, b)))
   (A^1 -> H(U1(e, a), U1(d, b)),A^1 -> H(U1(e, a), U1(d, b)))
   (A^1 -> H(U1(a, d), U1(d, b)),A^1 -> H(U1(a, d), U1(d, b)))
   (A^1 -> H(U1(a, e), U1(d, b)),A^1 -> H(U1(a, e), U1(d, b)))
   (A^1 -> H(U1(a, a), b),A^1 -> H(U1(a, a), b))
   (A^1 -> H(U1(a, a), U1(d, d)),A^1 -> H(U1(a, a), U1(d, d)))
   (A^1 -> H(U1(a, a), U1(d, e)),A^1 -> H(U1(a, a), U1(d, e)))


----------------------------------------

(92)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, a), U1(e, b))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(93) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), U1(e, b)),A^1 -> H(U1(d, a), U1(e, b)))
   (A^1 -> H(U1(e, a), U1(e, b)),A^1 -> H(U1(e, a), U1(e, b)))
   (A^1 -> H(U1(a, d), U1(e, b)),A^1 -> H(U1(a, d), U1(e, b)))
   (A^1 -> H(U1(a, e), U1(e, b)),A^1 -> H(U1(a, e), U1(e, b)))
   (A^1 -> H(U1(a, a), U1(e, d)),A^1 -> H(U1(a, a), U1(e, d)))
   (A^1 -> H(U1(a, a), U1(e, e)),A^1 -> H(U1(a, a), U1(e, e)))


----------------------------------------

(94)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, a), U1(b, d))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(95) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), U1(b, d)),A^1 -> H(U1(d, a), U1(b, d)))
   (A^1 -> H(U1(e, a), U1(b, d)),A^1 -> H(U1(e, a), U1(b, d)))
   (A^1 -> H(U1(a, d), U1(b, d)),A^1 -> H(U1(a, d), U1(b, d)))
   (A^1 -> H(U1(a, e), U1(b, d)),A^1 -> H(U1(a, e), U1(b, d)))
   (A^1 -> H(U1(a, a), U1(d, d)),A^1 -> H(U1(a, a), U1(d, d)))
   (A^1 -> H(U1(a, a), U1(e, d)),A^1 -> H(U1(a, a), U1(e, d)))


----------------------------------------

(96)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, a), U1(b, e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(97) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), U1(b, e)),A^1 -> H(U1(d, a), U1(b, e)))
   (A^1 -> H(U1(e, a), U1(b, e)),A^1 -> H(U1(e, a), U1(b, e)))
   (A^1 -> H(U1(a, d), U1(b, e)),A^1 -> H(U1(a, d), U1(b, e)))
   (A^1 -> H(U1(a, e), U1(b, e)),A^1 -> H(U1(a, e), U1(b, e)))
   (A^1 -> H(U1(a, a), U1(d, e)),A^1 -> H(U1(a, a), U1(d, e)))
   (A^1 -> H(U1(a, a), U1(e, e)),A^1 -> H(U1(a, a), U1(e, e)))


----------------------------------------

(98)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, a), U1(d, d))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(99) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), U1(d, d)),A^1 -> H(U1(d, a), U1(d, d)))
   (A^1 -> H(U1(e, a), U1(d, d)),A^1 -> H(U1(e, a), U1(d, d)))
   (A^1 -> H(U1(a, d), U1(d, d)),A^1 -> H(U1(a, d), U1(d, d)))
   (A^1 -> H(U1(a, e), U1(d, d)),A^1 -> H(U1(a, e), U1(d, d)))
   (A^1 -> H(U1(a, a), d),A^1 -> H(U1(a, a), d))


----------------------------------------

(100)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, a), U1(e, e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(101) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), U1(e, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), U1(e, e)),A^1 -> H(U1(d, a), U1(e, e)))
   (A^1 -> H(U1(e, a), U1(e, e)),A^1 -> H(U1(e, a), U1(e, e)))
   (A^1 -> H(U1(a, d), U1(e, e)),A^1 -> H(U1(a, d), U1(e, e)))
   (A^1 -> H(U1(a, e), U1(e, e)),A^1 -> H(U1(a, e), U1(e, e)))


----------------------------------------

(102)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(d, f(b))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(103) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(d, f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(b, b)),A^1 -> H(d, U1(b, b)))
   (A^1 -> H(d, f(d)),A^1 -> H(d, f(d)))
   (A^1 -> H(d, f(e)),A^1 -> H(d, f(e)))


----------------------------------------

(104)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(b, b))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(105) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(b, b)),A^1 -> H(d, U1(b, b)))
   (A^1 -> H(U1(d, d), U1(d, b)),A^1 -> H(U1(d, d), U1(d, b)))
   (A^1 -> H(U1(d, d), U1(e, b)),A^1 -> H(U1(d, d), U1(e, b)))
   (A^1 -> H(U1(d, d), U1(b, d)),A^1 -> H(U1(d, d), U1(b, d)))
   (A^1 -> H(U1(d, d), U1(b, e)),A^1 -> H(U1(d, d), U1(b, e)))


----------------------------------------

(106)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), f(d))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(107) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, f(d)),A^1 -> H(d, f(d)))
   (A^1 -> H(U1(d, d), U1(d, d)),A^1 -> H(U1(d, d), U1(d, d)))


----------------------------------------

(108)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(109) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, f(e)),A^1 -> H(d, f(e)))
   (A^1 -> H(U1(d, d), U1(e, e)),A^1 -> H(U1(d, d), U1(e, e)))


----------------------------------------

(110)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(d), U1(d, b))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(111) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(d, b)),A^1 -> H(U1(d, d), U1(d, b)))
   (A^1 -> H(f(d), b),A^1 -> H(f(d), b))
   (A^1 -> H(f(d), U1(d, d)),A^1 -> H(f(d), U1(d, d)))
   (A^1 -> H(f(d), U1(d, e)),A^1 -> H(f(d), U1(d, e)))


----------------------------------------

(112)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(d), U1(e, b))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(113) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(e, b)),A^1 -> H(U1(d, d), U1(e, b)))
   (A^1 -> H(f(d), U1(e, d)),A^1 -> H(f(d), U1(e, d)))
   (A^1 -> H(f(d), U1(e, e)),A^1 -> H(f(d), U1(e, e)))


----------------------------------------

(114)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(d), U1(b, d))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(115) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(b, d)),A^1 -> H(U1(d, d), U1(b, d)))
   (A^1 -> H(f(d), U1(d, d)),A^1 -> H(f(d), U1(d, d)))
   (A^1 -> H(f(d), U1(e, d)),A^1 -> H(f(d), U1(e, d)))


----------------------------------------

(116)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(d), U1(b, e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(117) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(b, e)),A^1 -> H(U1(d, d), U1(b, e)))
   (A^1 -> H(f(d), U1(d, e)),A^1 -> H(f(d), U1(d, e)))
   (A^1 -> H(f(d), U1(e, e)),A^1 -> H(f(d), U1(e, e)))


----------------------------------------

(118)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(d), U1(e, e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(119) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), U1(e, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(e, e)),A^1 -> H(U1(d, d), U1(e, e)))


----------------------------------------

(120)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, e), U1(b, b))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(121) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, e), U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(d, b)),A^1 -> H(U1(e, e), U1(d, b)))
   (A^1 -> H(U1(e, e), U1(e, b)),A^1 -> H(U1(e, e), U1(e, b)))
   (A^1 -> H(U1(e, e), U1(b, d)),A^1 -> H(U1(e, e), U1(b, d)))
   (A^1 -> H(U1(e, e), U1(b, e)),A^1 -> H(U1(e, e), U1(b, e)))


----------------------------------------

(122)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, e), f(d))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(123) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, e), f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(d, d)),A^1 -> H(U1(e, e), U1(d, d)))


----------------------------------------

(124)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(125) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, e), f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(e, e)),A^1 -> H(U1(e, e), U1(e, e)))


----------------------------------------

(126)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(e), U1(d, b))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(127) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(d, b)),A^1 -> H(U1(e, e), U1(d, b)))
   (A^1 -> H(f(e), b),A^1 -> H(f(e), b))
   (A^1 -> H(f(e), U1(d, d)),A^1 -> H(f(e), U1(d, d)))
   (A^1 -> H(f(e), U1(d, e)),A^1 -> H(f(e), U1(d, e)))


----------------------------------------

(128)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(e), U1(e, b))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(129) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(e, b)),A^1 -> H(U1(e, e), U1(e, b)))
   (A^1 -> H(f(e), U1(e, d)),A^1 -> H(f(e), U1(e, d)))
   (A^1 -> H(f(e), U1(e, e)),A^1 -> H(f(e), U1(e, e)))


----------------------------------------

(130)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(e), U1(b, d))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(131) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(b, d)),A^1 -> H(U1(e, e), U1(b, d)))
   (A^1 -> H(f(e), U1(d, d)),A^1 -> H(f(e), U1(d, d)))
   (A^1 -> H(f(e), U1(e, d)),A^1 -> H(f(e), U1(e, d)))


----------------------------------------

(132)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(e), U1(b, e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(133) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(b, e)),A^1 -> H(U1(e, e), U1(b, e)))
   (A^1 -> H(f(e), U1(d, e)),A^1 -> H(f(e), U1(d, e)))
   (A^1 -> H(f(e), U1(e, e)),A^1 -> H(f(e), U1(e, e)))


----------------------------------------

(134)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(e), U1(d, d))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(135) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(d, d)),A^1 -> H(U1(e, e), U1(d, d)))
   (A^1 -> H(f(e), d),A^1 -> H(f(e), d))


----------------------------------------

(136)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), b)
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(137) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), b),A^1 -> H(U1(a, a), b))
   (A^1 -> H(f(d), b),A^1 -> H(f(d), b))
   (A^1 -> H(f(e), b),A^1 -> H(f(e), b))
   (A^1 -> H(f(a), d),A^1 -> H(f(a), d))
   (A^1 -> H(f(a), e),A^1 -> H(f(a), e))


----------------------------------------

(138)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(d, e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(139) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), U1(d, e)),A^1 -> H(U1(a, a), U1(d, e)))
   (A^1 -> H(f(d), U1(d, e)),A^1 -> H(f(d), U1(d, e)))
   (A^1 -> H(f(e), U1(d, e)),A^1 -> H(f(e), U1(d, e)))
   (A^1 -> H(f(a), e),A^1 -> H(f(a), e))


----------------------------------------

(140)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), U1(e, d))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(141) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), U1(e, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), U1(e, d)),A^1 -> H(U1(a, a), U1(e, d)))
   (A^1 -> H(f(d), U1(e, d)),A^1 -> H(f(d), U1(e, d)))
   (A^1 -> H(f(e), U1(e, d)),A^1 -> H(f(e), U1(e, d)))


----------------------------------------

(142)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(d), U1(d, d))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(143) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(d, d)),A^1 -> H(U1(d, d), U1(d, d)))
   (A^1 -> H(f(d), d),A^1 -> H(f(d), d))


----------------------------------------

(144)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(a), d)
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(145) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), d) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), d),A^1 -> H(U1(a, a), d))
   (A^1 -> H(f(d), d),A^1 -> H(f(d), d))
   (A^1 -> H(f(e), d),A^1 -> H(f(e), d))


----------------------------------------

(146)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(f(e), U1(e, e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(147) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), U1(e, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(e, e)),A^1 -> H(U1(e, e), U1(e, e)))


----------------------------------------

(148)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(e, f(b))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(149) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(e, f(b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(b, b)),A^1 -> H(e, U1(b, b)))
   (A^1 -> H(e, f(d)),A^1 -> H(e, f(d)))
   (A^1 -> H(e, f(e)),A^1 -> H(e, f(e)))


----------------------------------------

(150)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(a, U1(b, b))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(151) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(b, b)),A^1 -> H(d, U1(b, b)))
   (A^1 -> H(e, U1(b, b)),A^1 -> H(e, U1(b, b)))
   (A^1 -> H(a, U1(d, b)),A^1 -> H(a, U1(d, b)))
   (A^1 -> H(a, U1(e, b)),A^1 -> H(a, U1(e, b)))
   (A^1 -> H(a, U1(b, d)),A^1 -> H(a, U1(b, d)))
   (A^1 -> H(a, U1(b, e)),A^1 -> H(a, U1(b, e)))


----------------------------------------

(152)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(a, f(d))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(153) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, f(d)),A^1 -> H(d, f(d)))
   (A^1 -> H(e, f(d)),A^1 -> H(e, f(d)))
   (A^1 -> H(a, U1(d, d)),A^1 -> H(a, U1(d, d)))


----------------------------------------

(154)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(a, f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(155) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, f(e)),A^1 -> H(d, f(e)))
   (A^1 -> H(e, f(e)),A^1 -> H(e, f(e)))
   (A^1 -> H(a, U1(e, e)),A^1 -> H(a, U1(e, e)))


----------------------------------------

(156)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, e), U1(b, b))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(157) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(b, b)),A^1 -> H(e, U1(b, b)))
   (A^1 -> H(U1(d, e), U1(d, b)),A^1 -> H(U1(d, e), U1(d, b)))
   (A^1 -> H(U1(d, e), U1(e, b)),A^1 -> H(U1(d, e), U1(e, b)))
   (A^1 -> H(U1(d, e), U1(b, d)),A^1 -> H(U1(d, e), U1(b, d)))
   (A^1 -> H(U1(d, e), U1(b, e)),A^1 -> H(U1(d, e), U1(b, e)))


----------------------------------------

(158)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, e), f(d))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(159) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, f(d)),A^1 -> H(e, f(d)))
   (A^1 -> H(U1(d, e), U1(d, d)),A^1 -> H(U1(d, e), U1(d, d)))


----------------------------------------

(160)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(161) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, f(e)),A^1 -> H(e, f(e)))
   (A^1 -> H(U1(d, e), U1(e, e)),A^1 -> H(U1(d, e), U1(e, e)))


----------------------------------------

(162)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, a), U1(d, b))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(163) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, U1(d, b)),A^1 -> H(a, U1(d, b)))
   (A^1 -> H(U1(d, d), U1(d, b)),A^1 -> H(U1(d, d), U1(d, b)))
   (A^1 -> H(U1(d, e), U1(d, b)),A^1 -> H(U1(d, e), U1(d, b)))
   (A^1 -> H(U1(d, a), b),A^1 -> H(U1(d, a), b))
   (A^1 -> H(U1(d, a), U1(d, d)),A^1 -> H(U1(d, a), U1(d, d)))
   (A^1 -> H(U1(d, a), U1(d, e)),A^1 -> H(U1(d, a), U1(d, e)))


----------------------------------------

(164)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, a), U1(e, b))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(165) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, U1(e, b)),A^1 -> H(a, U1(e, b)))
   (A^1 -> H(U1(d, d), U1(e, b)),A^1 -> H(U1(d, d), U1(e, b)))
   (A^1 -> H(U1(d, e), U1(e, b)),A^1 -> H(U1(d, e), U1(e, b)))
   (A^1 -> H(U1(d, a), U1(e, d)),A^1 -> H(U1(d, a), U1(e, d)))
   (A^1 -> H(U1(d, a), U1(e, e)),A^1 -> H(U1(d, a), U1(e, e)))


----------------------------------------

(166)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, a), U1(b, d))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(167) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, U1(b, d)),A^1 -> H(a, U1(b, d)))
   (A^1 -> H(U1(d, d), U1(b, d)),A^1 -> H(U1(d, d), U1(b, d)))
   (A^1 -> H(U1(d, e), U1(b, d)),A^1 -> H(U1(d, e), U1(b, d)))
   (A^1 -> H(U1(d, a), U1(d, d)),A^1 -> H(U1(d, a), U1(d, d)))
   (A^1 -> H(U1(d, a), U1(e, d)),A^1 -> H(U1(d, a), U1(e, d)))


----------------------------------------

(168)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, a), U1(b, e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(169) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, U1(b, e)),A^1 -> H(a, U1(b, e)))
   (A^1 -> H(U1(d, d), U1(b, e)),A^1 -> H(U1(d, d), U1(b, e)))
   (A^1 -> H(U1(d, e), U1(b, e)),A^1 -> H(U1(d, e), U1(b, e)))
   (A^1 -> H(U1(d, a), U1(d, e)),A^1 -> H(U1(d, a), U1(d, e)))
   (A^1 -> H(U1(d, a), U1(e, e)),A^1 -> H(U1(d, a), U1(e, e)))


----------------------------------------

(170)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, a), U1(d, d))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(171) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, U1(d, d)),A^1 -> H(a, U1(d, d)))
   (A^1 -> H(U1(d, d), U1(d, d)),A^1 -> H(U1(d, d), U1(d, d)))
   (A^1 -> H(U1(d, e), U1(d, d)),A^1 -> H(U1(d, e), U1(d, d)))
   (A^1 -> H(U1(d, a), d),A^1 -> H(U1(d, a), d))


----------------------------------------

(172)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, a), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(173) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), U1(e, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, U1(e, e)),A^1 -> H(a, U1(e, e)))
   (A^1 -> H(U1(d, d), U1(e, e)),A^1 -> H(U1(d, d), U1(e, e)))
   (A^1 -> H(U1(d, e), U1(e, e)),A^1 -> H(U1(d, e), U1(e, e)))


----------------------------------------

(174)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, d), U1(b, b))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(175) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, d), U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(d, b)),A^1 -> H(U1(e, d), U1(d, b)))
   (A^1 -> H(U1(e, d), U1(e, b)),A^1 -> H(U1(e, d), U1(e, b)))
   (A^1 -> H(U1(e, d), U1(b, d)),A^1 -> H(U1(e, d), U1(b, d)))
   (A^1 -> H(U1(e, d), U1(b, e)),A^1 -> H(U1(e, d), U1(b, e)))


----------------------------------------

(176)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, d), f(d))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(177) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, d), f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(d, d)),A^1 -> H(U1(e, d), U1(d, d)))


----------------------------------------

(178)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, d), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(179) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, d), f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(e, e)),A^1 -> H(U1(e, d), U1(e, e)))


----------------------------------------

(180)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, d), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(181) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(182)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, a), U1(d, b))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(183) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(d, b)),A^1 -> H(U1(e, d), U1(d, b)))
   (A^1 -> H(U1(e, e), U1(d, b)),A^1 -> H(U1(e, e), U1(d, b)))
   (A^1 -> H(U1(e, a), b),A^1 -> H(U1(e, a), b))
   (A^1 -> H(U1(e, a), U1(d, d)),A^1 -> H(U1(e, a), U1(d, d)))
   (A^1 -> H(U1(e, a), U1(d, e)),A^1 -> H(U1(e, a), U1(d, e)))


----------------------------------------

(184)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, a), U1(e, b))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(185) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(e, b)),A^1 -> H(U1(e, d), U1(e, b)))
   (A^1 -> H(U1(e, e), U1(e, b)),A^1 -> H(U1(e, e), U1(e, b)))
   (A^1 -> H(U1(e, a), U1(e, d)),A^1 -> H(U1(e, a), U1(e, d)))
   (A^1 -> H(U1(e, a), U1(e, e)),A^1 -> H(U1(e, a), U1(e, e)))


----------------------------------------

(186)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, a), U1(b, d))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(187) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(b, d)),A^1 -> H(U1(e, d), U1(b, d)))
   (A^1 -> H(U1(e, e), U1(b, d)),A^1 -> H(U1(e, e), U1(b, d)))
   (A^1 -> H(U1(e, a), U1(d, d)),A^1 -> H(U1(e, a), U1(d, d)))
   (A^1 -> H(U1(e, a), U1(e, d)),A^1 -> H(U1(e, a), U1(e, d)))


----------------------------------------

(188)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, a), U1(b, e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(189) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(b, e)),A^1 -> H(U1(e, d), U1(b, e)))
   (A^1 -> H(U1(e, e), U1(b, e)),A^1 -> H(U1(e, e), U1(b, e)))
   (A^1 -> H(U1(e, a), U1(d, e)),A^1 -> H(U1(e, a), U1(d, e)))
   (A^1 -> H(U1(e, a), U1(e, e)),A^1 -> H(U1(e, a), U1(e, e)))


----------------------------------------

(190)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, a), U1(d, d))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(191) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(d, d)),A^1 -> H(U1(e, d), U1(d, d)))
   (A^1 -> H(U1(e, e), U1(d, d)),A^1 -> H(U1(e, e), U1(d, d)))
   (A^1 -> H(U1(e, a), d),A^1 -> H(U1(e, a), d))


----------------------------------------

(192)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(e, a), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(193) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(194)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(e, a), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(195) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), U1(e, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(e, e)),A^1 -> H(U1(e, d), U1(e, e)))
   (A^1 -> H(U1(e, e), U1(e, e)),A^1 -> H(U1(e, e), U1(e, e)))


----------------------------------------

(196)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(e, d), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(197) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(198)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, d), U1(d, b))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(199) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(d, b)),A^1 -> H(U1(d, d), U1(d, b)))
   (A^1 -> H(U1(e, d), U1(d, b)),A^1 -> H(U1(e, d), U1(d, b)))
   (A^1 -> H(U1(a, d), b),A^1 -> H(U1(a, d), b))
   (A^1 -> H(U1(a, d), U1(d, d)),A^1 -> H(U1(a, d), U1(d, d)))
   (A^1 -> H(U1(a, d), U1(d, e)),A^1 -> H(U1(a, d), U1(d, e)))


----------------------------------------

(200)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, d), U1(e, b))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(201) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(e, b)),A^1 -> H(U1(d, d), U1(e, b)))
   (A^1 -> H(U1(e, d), U1(e, b)),A^1 -> H(U1(e, d), U1(e, b)))
   (A^1 -> H(U1(a, d), U1(e, d)),A^1 -> H(U1(a, d), U1(e, d)))
   (A^1 -> H(U1(a, d), U1(e, e)),A^1 -> H(U1(a, d), U1(e, e)))


----------------------------------------

(202)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, d), U1(b, d))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(203) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(b, d)),A^1 -> H(U1(d, d), U1(b, d)))
   (A^1 -> H(U1(e, d), U1(b, d)),A^1 -> H(U1(e, d), U1(b, d)))
   (A^1 -> H(U1(a, d), U1(d, d)),A^1 -> H(U1(a, d), U1(d, d)))
   (A^1 -> H(U1(a, d), U1(e, d)),A^1 -> H(U1(a, d), U1(e, d)))


----------------------------------------

(204)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, d), U1(b, e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(205) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(b, e)),A^1 -> H(U1(d, d), U1(b, e)))
   (A^1 -> H(U1(e, d), U1(b, e)),A^1 -> H(U1(e, d), U1(b, e)))
   (A^1 -> H(U1(a, d), U1(d, e)),A^1 -> H(U1(a, d), U1(d, e)))
   (A^1 -> H(U1(a, d), U1(e, e)),A^1 -> H(U1(a, d), U1(e, e)))


----------------------------------------

(206)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, d), U1(d, d))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(207) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(d, d)),A^1 -> H(U1(d, d), U1(d, d)))
   (A^1 -> H(U1(e, d), U1(d, d)),A^1 -> H(U1(e, d), U1(d, d)))
   (A^1 -> H(U1(a, d), d),A^1 -> H(U1(a, d), d))


----------------------------------------

(208)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, d), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(209) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), U1(e, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(e, e)),A^1 -> H(U1(d, d), U1(e, e)))
   (A^1 -> H(U1(e, d), U1(e, e)),A^1 -> H(U1(e, d), U1(e, e)))


----------------------------------------

(210)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(e, d), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(211) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(212)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, e), U1(d, b))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(213) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), U1(d, b)),A^1 -> H(U1(d, e), U1(d, b)))
   (A^1 -> H(U1(e, e), U1(d, b)),A^1 -> H(U1(e, e), U1(d, b)))
   (A^1 -> H(U1(a, e), b),A^1 -> H(U1(a, e), b))
   (A^1 -> H(U1(a, e), U1(d, d)),A^1 -> H(U1(a, e), U1(d, d)))
   (A^1 -> H(U1(a, e), U1(d, e)),A^1 -> H(U1(a, e), U1(d, e)))


----------------------------------------

(214)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, e), U1(e, b))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(215) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), U1(e, b)),A^1 -> H(U1(d, e), U1(e, b)))
   (A^1 -> H(U1(e, e), U1(e, b)),A^1 -> H(U1(e, e), U1(e, b)))
   (A^1 -> H(U1(a, e), U1(e, d)),A^1 -> H(U1(a, e), U1(e, d)))
   (A^1 -> H(U1(a, e), U1(e, e)),A^1 -> H(U1(a, e), U1(e, e)))


----------------------------------------

(216)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, e), U1(b, d))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(217) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), U1(b, d)),A^1 -> H(U1(d, e), U1(b, d)))
   (A^1 -> H(U1(e, e), U1(b, d)),A^1 -> H(U1(e, e), U1(b, d)))
   (A^1 -> H(U1(a, e), U1(d, d)),A^1 -> H(U1(a, e), U1(d, d)))
   (A^1 -> H(U1(a, e), U1(e, d)),A^1 -> H(U1(a, e), U1(e, d)))


----------------------------------------

(218)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, e), U1(b, e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(219) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), U1(b, e)),A^1 -> H(U1(d, e), U1(b, e)))
   (A^1 -> H(U1(e, e), U1(b, e)),A^1 -> H(U1(e, e), U1(b, e)))
   (A^1 -> H(U1(a, e), U1(d, e)),A^1 -> H(U1(a, e), U1(d, e)))
   (A^1 -> H(U1(a, e), U1(e, e)),A^1 -> H(U1(a, e), U1(e, e)))


----------------------------------------

(220)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, e), U1(d, d))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(221) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), U1(d, d)),A^1 -> H(U1(d, e), U1(d, d)))
   (A^1 -> H(U1(e, e), U1(d, d)),A^1 -> H(U1(e, e), U1(d, d)))
   (A^1 -> H(U1(a, e), d),A^1 -> H(U1(a, e), d))


----------------------------------------

(222)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, e), U1(e, e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(223) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), U1(e, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), U1(e, e)),A^1 -> H(U1(d, e), U1(e, e)))
   (A^1 -> H(U1(e, e), U1(e, e)),A^1 -> H(U1(e, e), U1(e, e)))


----------------------------------------

(224)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, a), b)
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(225) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), b),A^1 -> H(U1(d, a), b))
   (A^1 -> H(U1(e, a), b),A^1 -> H(U1(e, a), b))
   (A^1 -> H(U1(a, d), b),A^1 -> H(U1(a, d), b))
   (A^1 -> H(U1(a, e), b),A^1 -> H(U1(a, e), b))
   (A^1 -> H(U1(a, a), d),A^1 -> H(U1(a, a), d))
   (A^1 -> H(U1(a, a), e),A^1 -> H(U1(a, a), e))


----------------------------------------

(226)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, a), U1(d, e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(227) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), U1(d, e)),A^1 -> H(U1(d, a), U1(d, e)))
   (A^1 -> H(U1(e, a), U1(d, e)),A^1 -> H(U1(e, a), U1(d, e)))
   (A^1 -> H(U1(a, d), U1(d, e)),A^1 -> H(U1(a, d), U1(d, e)))
   (A^1 -> H(U1(a, e), U1(d, e)),A^1 -> H(U1(a, e), U1(d, e)))
   (A^1 -> H(U1(a, a), e),A^1 -> H(U1(a, a), e))


----------------------------------------

(228)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, a), U1(e, d))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(229) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), U1(e, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), U1(e, d)),A^1 -> H(U1(d, a), U1(e, d)))
   (A^1 -> H(U1(e, a), U1(e, d)),A^1 -> H(U1(e, a), U1(e, d)))
   (A^1 -> H(U1(a, d), U1(e, d)),A^1 -> H(U1(a, d), U1(e, d)))
   (A^1 -> H(U1(a, e), U1(e, d)),A^1 -> H(U1(a, e), U1(e, d)))


----------------------------------------

(230)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(a, a), d)
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(231) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), d) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), d),A^1 -> H(U1(d, a), d))
   (A^1 -> H(U1(e, a), d),A^1 -> H(U1(e, a), d))
   (A^1 -> H(U1(a, d), d),A^1 -> H(U1(a, d), d))
   (A^1 -> H(U1(a, e), d),A^1 -> H(U1(a, e), d))


----------------------------------------

(232)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(U1(e, a), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(233) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(234)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(d, U1(b, b))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(235) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(d, U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(d, b)),A^1 -> H(d, U1(d, b)))
   (A^1 -> H(d, U1(e, b)),A^1 -> H(d, U1(e, b)))
   (A^1 -> H(d, U1(b, d)),A^1 -> H(d, U1(b, d)))
   (A^1 -> H(d, U1(b, e)),A^1 -> H(d, U1(b, e)))


----------------------------------------

(236)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(e, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(237) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(238)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(d, f(d))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(239) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(d, f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(d, d)),A^1 -> H(d, U1(d, d)))


----------------------------------------

(240)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(d, f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(241) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(d, f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(e, e)),A^1 -> H(d, U1(e, e)))


----------------------------------------

(242)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(d, U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(243) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(244)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, b))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(245) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(d, b)),A^1 -> H(d, U1(d, b)))
   (A^1 -> H(U1(d, d), b),A^1 -> H(U1(d, d), b))
   (A^1 -> H(U1(d, d), U1(d, d)),A^1 -> H(U1(d, d), U1(d, d)))
   (A^1 -> H(U1(d, d), U1(d, e)),A^1 -> H(U1(d, d), U1(d, e)))


----------------------------------------

(246)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(e, b))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(247) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(e, b)),A^1 -> H(d, U1(e, b)))
   (A^1 -> H(U1(d, d), U1(e, d)),A^1 -> H(U1(d, d), U1(e, d)))
   (A^1 -> H(U1(d, d), U1(e, e)),A^1 -> H(U1(d, d), U1(e, e)))


----------------------------------------

(248)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(d, U1(e, b))
   A^1 -> H(U1(d, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(249) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(250)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(b, d))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(251) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(b, d)),A^1 -> H(d, U1(b, d)))
   (A^1 -> H(U1(d, d), U1(d, d)),A^1 -> H(U1(d, d), U1(d, d)))
   (A^1 -> H(U1(d, d), U1(e, d)),A^1 -> H(U1(d, d), U1(e, d)))


----------------------------------------

(252)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(b, e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(253) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(b, e)),A^1 -> H(d, U1(b, e)))
   (A^1 -> H(U1(d, d), U1(d, e)),A^1 -> H(U1(d, d), U1(d, e)))
   (A^1 -> H(U1(d, d), U1(e, e)),A^1 -> H(U1(d, d), U1(e, e)))


----------------------------------------

(254)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(d, d), U1(e, e))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(255) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), U1(e, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(e, e)),A^1 -> H(d, U1(e, e)))


----------------------------------------

(256)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(d, U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(257) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(258)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(f(d), b)
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(259) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), b),A^1 -> H(U1(d, d), b))
   (A^1 -> H(f(d), d),A^1 -> H(f(d), d))
   (A^1 -> H(f(d), e),A^1 -> H(f(d), e))


----------------------------------------

(260)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(f(d), U1(d, e))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(261) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(d, e)),A^1 -> H(U1(d, d), U1(d, e)))
   (A^1 -> H(f(d), e),A^1 -> H(f(d), e))


----------------------------------------

(262)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(f(d), U1(e, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(263) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), U1(e, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(e, d)),A^1 -> H(U1(d, d), U1(e, d)))


----------------------------------------

(264)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(d, b))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(265) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, e), U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), b),A^1 -> H(U1(e, e), b))
   (A^1 -> H(U1(e, e), U1(d, d)),A^1 -> H(U1(e, e), U1(d, d)))
   (A^1 -> H(U1(e, e), U1(d, e)),A^1 -> H(U1(e, e), U1(d, e)))


----------------------------------------

(266)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, b))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(267) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, e), U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(e, d)),A^1 -> H(U1(e, e), U1(e, d)))
   (A^1 -> H(U1(e, e), U1(e, e)),A^1 -> H(U1(e, e), U1(e, e)))


----------------------------------------

(268)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(U1(e, e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(269) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(270)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(b, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(271) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, e), U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(d, d)),A^1 -> H(U1(e, e), U1(d, d)))
   (A^1 -> H(U1(e, e), U1(e, d)),A^1 -> H(U1(e, e), U1(e, d)))


----------------------------------------

(272)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(U1(e, e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(273) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(274)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(b, e))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(275) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, e), U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(d, e)),A^1 -> H(U1(e, e), U1(d, e)))
   (A^1 -> H(U1(e, e), U1(e, e)),A^1 -> H(U1(e, e), U1(e, e)))


----------------------------------------

(276)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(277) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, e), U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), d),A^1 -> H(U1(e, e), d))


----------------------------------------

(278)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(U1(e, e), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(279) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(280)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), b)
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(281) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), b),A^1 -> H(U1(e, e), b))
   (A^1 -> H(f(e), d),A^1 -> H(f(e), d))
   (A^1 -> H(f(e), e),A^1 -> H(f(e), e))


----------------------------------------

(282)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), U1(d, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(283) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(d, e)),A^1 -> H(U1(e, e), U1(d, e)))
   (A^1 -> H(f(e), e),A^1 -> H(f(e), e))


----------------------------------------

(284)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), U1(e, d))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(285) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), U1(e, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), U1(e, d)),A^1 -> H(U1(e, e), U1(e, d)))


----------------------------------------

(286)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(e, e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(287) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(288)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), d)
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(289) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), d) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), d),A^1 -> H(U1(e, e), d))


----------------------------------------

(290)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(e, e), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(291) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(292)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(a), e)
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(293) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(a), e) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(a, a), e),A^1 -> H(U1(a, a), e))
   (A^1 -> H(f(d), e),A^1 -> H(f(d), e))
   (A^1 -> H(f(e), e),A^1 -> H(f(e), e))


----------------------------------------

(294)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(d), d)
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(295) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), d) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), d),A^1 -> H(U1(d, d), d))


----------------------------------------

(296)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(e, U1(b, b))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(297) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(e, U1(b, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(d, b)),A^1 -> H(e, U1(d, b)))
   (A^1 -> H(e, U1(e, b)),A^1 -> H(e, U1(e, b)))
   (A^1 -> H(e, U1(b, d)),A^1 -> H(e, U1(b, d)))
   (A^1 -> H(e, U1(b, e)),A^1 -> H(e, U1(b, e)))


----------------------------------------

(298)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(e, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(299) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(300)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(e, f(d))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(301) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(e, f(d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(d, d)),A^1 -> H(e, U1(d, d)))


----------------------------------------

(302)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(e, f(e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(303) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(e, f(e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(e, e)),A^1 -> H(e, U1(e, e)))


----------------------------------------

(304)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(e, U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(305) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(306)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, U1(d, b))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(307) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(d, b)),A^1 -> H(d, U1(d, b)))
   (A^1 -> H(e, U1(d, b)),A^1 -> H(e, U1(d, b)))
   (A^1 -> H(a, b),A^1 -> H(a, b))
   (A^1 -> H(a, U1(d, d)),A^1 -> H(a, U1(d, d)))
   (A^1 -> H(a, U1(d, e)),A^1 -> H(a, U1(d, e)))


----------------------------------------

(308)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, U1(e, b))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(309) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(e, b)),A^1 -> H(d, U1(e, b)))
   (A^1 -> H(e, U1(e, b)),A^1 -> H(e, U1(e, b)))
   (A^1 -> H(a, U1(e, d)),A^1 -> H(a, U1(e, d)))
   (A^1 -> H(a, U1(e, e)),A^1 -> H(a, U1(e, e)))


----------------------------------------

(310)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(d, U1(e, b))
   A^1 -> H(e, U1(e, b))
   A^1 -> H(a, U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(311) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(312)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, U1(b, d))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(313) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(b, d)),A^1 -> H(d, U1(b, d)))
   (A^1 -> H(e, U1(b, d)),A^1 -> H(e, U1(b, d)))
   (A^1 -> H(a, U1(d, d)),A^1 -> H(a, U1(d, d)))
   (A^1 -> H(a, U1(e, d)),A^1 -> H(a, U1(e, d)))


----------------------------------------

(314)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, U1(b, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(315) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(b, e)),A^1 -> H(d, U1(b, e)))
   (A^1 -> H(e, U1(b, e)),A^1 -> H(e, U1(b, e)))
   (A^1 -> H(a, U1(d, e)),A^1 -> H(a, U1(d, e)))
   (A^1 -> H(a, U1(e, e)),A^1 -> H(a, U1(e, e)))


----------------------------------------

(316)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, U1(d, d))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(317) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(d, d)),A^1 -> H(d, U1(d, d)))
   (A^1 -> H(e, U1(d, d)),A^1 -> H(e, U1(d, d)))
   (A^1 -> H(a, d),A^1 -> H(a, d))


----------------------------------------

(318)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(319) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, U1(e, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(e, e)),A^1 -> H(d, U1(e, e)))
   (A^1 -> H(e, U1(e, e)),A^1 -> H(e, U1(e, e)))


----------------------------------------

(320)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(d, U1(e, e))
   A^1 -> H(e, U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(321) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(322)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, b))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(323) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(d, b)),A^1 -> H(e, U1(d, b)))
   (A^1 -> H(U1(d, e), b),A^1 -> H(U1(d, e), b))
   (A^1 -> H(U1(d, e), U1(d, d)),A^1 -> H(U1(d, e), U1(d, d)))
   (A^1 -> H(U1(d, e), U1(d, e)),A^1 -> H(U1(d, e), U1(d, e)))


----------------------------------------

(324)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(e, b))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(325) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(e, b)),A^1 -> H(e, U1(e, b)))
   (A^1 -> H(U1(d, e), U1(e, d)),A^1 -> H(U1(d, e), U1(e, d)))
   (A^1 -> H(U1(d, e), U1(e, e)),A^1 -> H(U1(d, e), U1(e, e)))


----------------------------------------

(326)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(e, U1(e, b))
   A^1 -> H(U1(d, e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(327) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(328)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(b, d))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(329) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(b, d)),A^1 -> H(e, U1(b, d)))
   (A^1 -> H(U1(d, e), U1(d, d)),A^1 -> H(U1(d, e), U1(d, d)))
   (A^1 -> H(U1(d, e), U1(e, d)),A^1 -> H(U1(d, e), U1(e, d)))


----------------------------------------

(330)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(b, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(331) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(b, e)),A^1 -> H(e, U1(b, e)))
   (A^1 -> H(U1(d, e), U1(d, e)),A^1 -> H(U1(d, e), U1(d, e)))
   (A^1 -> H(U1(d, e), U1(e, e)),A^1 -> H(U1(d, e), U1(e, e)))


----------------------------------------

(332)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, d))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(333) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(d, d)),A^1 -> H(e, U1(d, d)))
   (A^1 -> H(U1(d, e), d),A^1 -> H(U1(d, e), d))


----------------------------------------

(334)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(335) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), U1(e, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(e, e)),A^1 -> H(e, U1(e, e)))


----------------------------------------

(336)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(e, U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(337) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(338)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, a), b)
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(339) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, b),A^1 -> H(a, b))
   (A^1 -> H(U1(d, d), b),A^1 -> H(U1(d, d), b))
   (A^1 -> H(U1(d, e), b),A^1 -> H(U1(d, e), b))
   (A^1 -> H(U1(d, a), d),A^1 -> H(U1(d, a), d))
   (A^1 -> H(U1(d, a), e),A^1 -> H(U1(d, a), e))


----------------------------------------

(340)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, a), U1(d, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(341) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, U1(d, e)),A^1 -> H(a, U1(d, e)))
   (A^1 -> H(U1(d, d), U1(d, e)),A^1 -> H(U1(d, d), U1(d, e)))
   (A^1 -> H(U1(d, e), U1(d, e)),A^1 -> H(U1(d, e), U1(d, e)))
   (A^1 -> H(U1(d, a), e),A^1 -> H(U1(d, a), e))


----------------------------------------

(342)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, a), U1(e, d))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(343) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), U1(e, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, U1(e, d)),A^1 -> H(a, U1(e, d)))
   (A^1 -> H(U1(d, d), U1(e, d)),A^1 -> H(U1(d, d), U1(e, d)))
   (A^1 -> H(U1(d, e), U1(e, d)),A^1 -> H(U1(d, e), U1(e, d)))


----------------------------------------

(344)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, a), d)
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(345) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), d) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, d),A^1 -> H(a, d))
   (A^1 -> H(U1(d, d), d),A^1 -> H(U1(d, d), d))
   (A^1 -> H(U1(d, e), d),A^1 -> H(U1(d, e), d))


----------------------------------------

(346)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, d), U1(d, b))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(347) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, d), U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), b),A^1 -> H(U1(e, d), b))
   (A^1 -> H(U1(e, d), U1(d, d)),A^1 -> H(U1(e, d), U1(d, d)))
   (A^1 -> H(U1(e, d), U1(d, e)),A^1 -> H(U1(e, d), U1(d, e)))


----------------------------------------

(348)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, d), U1(e, b))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(349) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, d), U1(e, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(e, d)),A^1 -> H(U1(e, d), U1(e, d)))
   (A^1 -> H(U1(e, d), U1(e, e)),A^1 -> H(U1(e, d), U1(e, e)))


----------------------------------------

(350)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(e, d), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(351) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(352)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, d))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(353) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, d), U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(d, d)),A^1 -> H(U1(e, d), U1(d, d)))
   (A^1 -> H(U1(e, d), U1(e, d)),A^1 -> H(U1(e, d), U1(e, d)))


----------------------------------------

(354)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, d), U1(b, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(355) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, d), U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(d, e)),A^1 -> H(U1(e, d), U1(d, e)))
   (A^1 -> H(U1(e, d), U1(e, e)),A^1 -> H(U1(e, d), U1(e, e)))


----------------------------------------

(356)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(e, d), U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(357) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(358)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, d), U1(d, d))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(359) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, d), U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), d),A^1 -> H(U1(e, d), d))


----------------------------------------

(360)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(e, d), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(361) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(362)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, a), b)
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(363) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), b),A^1 -> H(U1(e, d), b))
   (A^1 -> H(U1(e, e), b),A^1 -> H(U1(e, e), b))
   (A^1 -> H(U1(e, a), d),A^1 -> H(U1(e, a), d))
   (A^1 -> H(U1(e, a), e),A^1 -> H(U1(e, a), e))


----------------------------------------

(364)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(e, a), d)
   A^1 -> H(U1(e, a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(365) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(366)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, a), U1(d, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(367) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(d, e)),A^1 -> H(U1(e, d), U1(d, e)))
   (A^1 -> H(U1(e, e), U1(d, e)),A^1 -> H(U1(e, e), U1(d, e)))
   (A^1 -> H(U1(e, a), e),A^1 -> H(U1(e, a), e))


----------------------------------------

(368)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(e, a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(369) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(370)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, a), U1(e, d))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(371) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, a), U1(e, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), U1(e, d)),A^1 -> H(U1(e, d), U1(e, d)))
   (A^1 -> H(U1(e, e), U1(e, d)),A^1 -> H(U1(e, e), U1(e, d)))


----------------------------------------

(372)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(e, e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(373) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(374)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, d), b)
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(375) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), b),A^1 -> H(U1(d, d), b))
   (A^1 -> H(U1(e, d), b),A^1 -> H(U1(e, d), b))
   (A^1 -> H(U1(a, d), d),A^1 -> H(U1(a, d), d))
   (A^1 -> H(U1(a, d), e),A^1 -> H(U1(a, d), e))


----------------------------------------

(376)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, d), U1(d, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(377) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(d, e)),A^1 -> H(U1(d, d), U1(d, e)))
   (A^1 -> H(U1(e, d), U1(d, e)),A^1 -> H(U1(e, d), U1(d, e)))
   (A^1 -> H(U1(a, d), e),A^1 -> H(U1(a, d), e))


----------------------------------------

(378)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, d), U1(e, d))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(379) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), U1(e, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), U1(e, d)),A^1 -> H(U1(d, d), U1(e, d)))
   (A^1 -> H(U1(e, d), U1(e, d)),A^1 -> H(U1(e, d), U1(e, d)))


----------------------------------------

(380)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, d), d)
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(381) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), d) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), d),A^1 -> H(U1(d, d), d))
   (A^1 -> H(U1(e, d), d),A^1 -> H(U1(e, d), d))


----------------------------------------

(382)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(e, d), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(383) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(384)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, e), b)
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(385) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), b),A^1 -> H(U1(d, e), b))
   (A^1 -> H(U1(e, e), b),A^1 -> H(U1(e, e), b))
   (A^1 -> H(U1(a, e), d),A^1 -> H(U1(a, e), d))
   (A^1 -> H(U1(a, e), e),A^1 -> H(U1(a, e), e))


----------------------------------------

(386)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, e), U1(d, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(387) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), U1(d, e)),A^1 -> H(U1(d, e), U1(d, e)))
   (A^1 -> H(U1(e, e), U1(d, e)),A^1 -> H(U1(e, e), U1(d, e)))
   (A^1 -> H(U1(a, e), e),A^1 -> H(U1(a, e), e))


----------------------------------------

(388)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, e), U1(e, d))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(389) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), U1(e, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), U1(e, d)),A^1 -> H(U1(d, e), U1(e, d)))
   (A^1 -> H(U1(e, e), U1(e, d)),A^1 -> H(U1(e, e), U1(e, d)))


----------------------------------------

(390)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(U1(e, e), U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(391) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(392)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, e), d)
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(393) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), d) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), d),A^1 -> H(U1(d, e), d))
   (A^1 -> H(U1(e, e), d),A^1 -> H(U1(e, e), d))


----------------------------------------

(394)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(U1(e, e), d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(395) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(396)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(a, a), e)
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(397) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, a), e) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, a), e),A^1 -> H(U1(d, a), e))
   (A^1 -> H(U1(e, a), e),A^1 -> H(U1(e, a), e))
   (A^1 -> H(U1(a, d), e),A^1 -> H(U1(a, d), e))
   (A^1 -> H(U1(a, e), e),A^1 -> H(U1(a, e), e))


----------------------------------------

(398)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(U1(e, a), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(399) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(400)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(d, U1(d, b))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(401) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(d, U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, b),A^1 -> H(d, b))
   (A^1 -> H(d, U1(d, d)),A^1 -> H(d, U1(d, d)))
   (A^1 -> H(d, U1(d, e)),A^1 -> H(d, U1(d, e)))


----------------------------------------

(402)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(d, U1(b, d))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(403) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(d, U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(d, d)),A^1 -> H(d, U1(d, d)))
   (A^1 -> H(d, U1(e, d)),A^1 -> H(d, U1(e, d)))


----------------------------------------

(404)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(405) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(406)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(d, U1(b, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(407) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(d, U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(d, e)),A^1 -> H(d, U1(d, e)))
   (A^1 -> H(d, U1(e, e)),A^1 -> H(d, U1(e, e)))


----------------------------------------

(408)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(409) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(410)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(d, U1(d, d))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(411) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(d, U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, d),A^1 -> H(d, d))


----------------------------------------

(412)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, d), b)
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(413) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, b),A^1 -> H(d, b))
   (A^1 -> H(U1(d, d), d),A^1 -> H(U1(d, d), d))
   (A^1 -> H(U1(d, d), e),A^1 -> H(U1(d, d), e))


----------------------------------------

(414)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, d), U1(d, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(415) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(d, e)),A^1 -> H(d, U1(d, e)))
   (A^1 -> H(U1(d, d), e),A^1 -> H(U1(d, d), e))


----------------------------------------

(416)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, d), U1(e, d))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(417) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), U1(e, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(e, d)),A^1 -> H(d, U1(e, d)))


----------------------------------------

(418)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(d, U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(419) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(420)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(d), e)
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(421) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(d), e) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), e),A^1 -> H(U1(d, d), e))


----------------------------------------

(422)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, e), b)
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(423) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, e), b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), d),A^1 -> H(U1(e, e), d))
   (A^1 -> H(U1(e, e), e),A^1 -> H(U1(e, e), e))


----------------------------------------

(424)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(U1(e, e), d)
   A^1 -> H(U1(e, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(425) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(426)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(e, e), U1(d, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(427) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, e), U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), e),A^1 -> H(U1(e, e), e))


----------------------------------------

(428)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(U1(e, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(429) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(430)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(f(e), e)
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(431) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(f(e), e) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, e), e),A^1 -> H(U1(e, e), e))


----------------------------------------

(432)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(U1(e, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(433) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(434)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, d), d)
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(435) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), d) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, d),A^1 -> H(d, d))


----------------------------------------

(436)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(e, U1(d, b))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(437) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(e, U1(d, b)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, b),A^1 -> H(e, b))
   (A^1 -> H(e, U1(d, d)),A^1 -> H(e, U1(d, d)))
   (A^1 -> H(e, U1(d, e)),A^1 -> H(e, U1(d, e)))


----------------------------------------

(438)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(e, U1(b, d))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(439) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(e, U1(b, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(d, d)),A^1 -> H(e, U1(d, d)))
   (A^1 -> H(e, U1(e, d)),A^1 -> H(e, U1(e, d)))


----------------------------------------

(440)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(e, U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(441) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(442)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(e, U1(b, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(443) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(e, U1(b, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(d, e)),A^1 -> H(e, U1(d, e)))
   (A^1 -> H(e, U1(e, e)),A^1 -> H(e, U1(e, e)))


----------------------------------------

(444)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(e, U1(e, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(445) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(446)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(e, U1(d, d))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(447) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(e, U1(d, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, d),A^1 -> H(e, d))


----------------------------------------

(448)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(e, d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(449) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(450)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, b)
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(451) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, b),A^1 -> H(d, b))
   (A^1 -> H(e, b),A^1 -> H(e, b))
   (A^1 -> H(a, d),A^1 -> H(a, d))
   (A^1 -> H(a, e),A^1 -> H(a, e))


----------------------------------------

(452)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, U1(d, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(453) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(d, e)),A^1 -> H(d, U1(d, e)))
   (A^1 -> H(e, U1(d, e)),A^1 -> H(e, U1(d, e)))
   (A^1 -> H(a, e),A^1 -> H(a, e))


----------------------------------------

(454)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, U1(e, d))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(455) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, U1(e, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, U1(e, d)),A^1 -> H(d, U1(e, d)))
   (A^1 -> H(e, U1(e, d)),A^1 -> H(e, U1(e, d)))


----------------------------------------

(456)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(d, U1(e, d))
   A^1 -> H(e, U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(457) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(458)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(a, d)
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(459) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, d) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, d),A^1 -> H(d, d))
   (A^1 -> H(e, d),A^1 -> H(e, d))


----------------------------------------

(460)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(e, d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(461) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(462)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), b)
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(463) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, b),A^1 -> H(e, b))
   (A^1 -> H(U1(d, e), d),A^1 -> H(U1(d, e), d))
   (A^1 -> H(U1(d, e), e),A^1 -> H(U1(d, e), e))


----------------------------------------

(464)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), U1(e, d))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(465) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), U1(e, d)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, U1(e, d)),A^1 -> H(e, U1(e, d)))


----------------------------------------

(466)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(e, U1(e, d))

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(467) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(468)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, e), d)
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(469) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), d) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, d),A^1 -> H(e, d))


----------------------------------------

(470)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(e, d)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(471) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(472)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(d, a), e)
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(473) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, a), e) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(a, e),A^1 -> H(a, e))
   (A^1 -> H(U1(d, d), e),A^1 -> H(U1(d, d), e))
   (A^1 -> H(U1(d, e), e),A^1 -> H(U1(d, e), e))


----------------------------------------

(474)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), b)
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(475) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, d), b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), d),A^1 -> H(U1(e, d), d))
   (A^1 -> H(U1(e, d), e),A^1 -> H(U1(e, d), e))


----------------------------------------

(476)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(U1(e, d), d)
   A^1 -> H(U1(e, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(477) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(478)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(479) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(e, d), U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(e, d), e),A^1 -> H(U1(e, d), e))


----------------------------------------

(480)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(U1(e, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(481) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(482)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, d), e)
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(483) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, d), e) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, d), e),A^1 -> H(U1(d, d), e))
   (A^1 -> H(U1(e, d), e),A^1 -> H(U1(e, d), e))


----------------------------------------

(484)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(U1(e, d), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(485) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(486)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(U1(a, e), e)
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(487) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(a, e), e) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(U1(d, e), e),A^1 -> H(U1(d, e), e))
   (A^1 -> H(U1(e, e), e),A^1 -> H(U1(e, e), e))


----------------------------------------

(488)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(U1(e, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(489) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(490)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, b)
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(491) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(d, b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, d),A^1 -> H(d, d))
   (A^1 -> H(d, e),A^1 -> H(d, e))


----------------------------------------

(492)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(d, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(493) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(494)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, U1(d, e))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(495) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(d, U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, e),A^1 -> H(d, e))


----------------------------------------

(496)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(d, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(497) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(498)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, d), e)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(499) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, d), e) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, e),A^1 -> H(d, e))


----------------------------------------

(500)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, d)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(d, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(501) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(502)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, d)
   A^1 -> H(e, b)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(503) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(e, b) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, d),A^1 -> H(e, d))
   (A^1 -> H(e, e),A^1 -> H(e, e))


----------------------------------------

(504)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, d)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(e, d)
   A^1 -> H(e, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(505) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(506)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, d)
   A^1 -> H(e, U1(d, e))
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(e, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(507) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(e, U1(d, e)) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, e),A^1 -> H(e, e))


----------------------------------------

(508)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, d)
   A^1 -> H(a, e)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(e, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(509) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(a, e) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(d, e),A^1 -> H(d, e))
   (A^1 -> H(e, e),A^1 -> H(e, e))


----------------------------------------

(510)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(x, x) -> G(x, x)
   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(e, e)
   A^1 -> H(d, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(511) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(512)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, d)
   A^1 -> H(U1(d, e), e)
   A^1 -> H(e, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(513) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A^1 -> H(U1(d, e), e) at position [] we obtained the following new rules [LPAR04]:

   (A^1 -> H(e, e),A^1 -> H(e, e))


----------------------------------------

(514)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, d)
   A^1 -> H(e, e)

The TRS R consists of the following rules:

   a -> d
   a -> e
   f(x) -> U1(x, x)
   b -> d
   b -> e
   U1(d, x) -> x

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(515) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   a -> d
   a -> e
   b -> d
   b -> e
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(A^1) = 0
   POL(G(x_1, x_2)) = x_1 + x_2
   POL(H(x_1, x_2)) = x_1 + x_2
   POL(U1(x_1, x_2)) = x_1 + x_2
   POL(d) = 0
   POL(e) = 0
   POL(f(x_1)) = 2*x_1


----------------------------------------

(516)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, d)
   A^1 -> H(e, e)

The TRS R consists of the following rules:

   U1(d, x) -> x
   f(x) -> U1(x, x)

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(517) MNOCProof (EQUIVALENT)
We use the modular non-overlap check [LPAR04] to enlarge Q to all left-hand sides of R.
----------------------------------------

(518)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(d, e) -> A^1
   A^1 -> H(f(d), f(d))
   H(x, x) -> G(x, x)
   A^1 -> H(f(e), f(e))
   A^1 -> H(U1(d, d), U1(d, d))
   A^1 -> H(U1(e, e), U1(e, e))
   A^1 -> H(U1(d, e), U1(d, e))
   A^1 -> H(U1(e, d), U1(e, d))
   A^1 -> H(d, d)
   A^1 -> H(e, e)

The TRS R consists of the following rules:

   U1(d, x) -> x
   f(x) -> U1(x, x)

The set Q consists of the following terms:

   U1(d, x0)
   f(x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(519) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 10 less nodes.
----------------------------------------

(520)
TRUE
