YES

Problem 1: 

(VAR vu95NonEmpty l m n)
(RULES
insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
insert(nil,m) -> cons(m,nil)
lte(num0,n) -> ftrue
lte(s(m),num0) -> ffalse
lte(s(m),s(n)) -> lte(m,n)
ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
ordered(cons(m,nil)) -> ftrue
ordered(nil) -> ftrue
)


Problem 1: 
Valid CTRS Processor:
-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue
-> The system is a 2-CTRS.

Problem 1: 

2D Dependency Pair Processor:

Conditional Termination Problem 1:
-> Pairs:
 INSERT(cons(n,l),m) -> INSERT(l,m) | lte(m,n) ->* ffalse
 LTE(s(m),s(n)) -> LTE(m,n)
 ORDERED(cons(m,cons(n,l))) -> ORDERED(cons(n,l)) | lte(m,n) ->* ftrue
-> QPairs:
 Empty
-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue

Conditional Termination Problem 2:
-> Pairs:
 INSERT(cons(n,l),m) -> LTE(m,n)
 ORDERED(cons(m,cons(n,l))) -> LTE(m,n)
-> QPairs:
 LTE(s(m),s(n)) -> LTE(m,n)
-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue


The problem is decomposed in 2 subproblems.

Problem 1.1: 

SCC Processor:
-> Pairs:
 INSERT(cons(n,l),m) -> INSERT(l,m) | lte(m,n) ->* ffalse
 LTE(s(m),s(n)) -> LTE(m,n)
 ORDERED(cons(m,cons(n,l))) -> ORDERED(cons(n,l)) | lte(m,n) ->* ftrue
-> QPairs:
 Empty
-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 ORDERED(cons(m,cons(n,l))) -> ORDERED(cons(n,l)) | lte(m,n) ->* ftrue
-> QPairs:
 Empty
->->-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue
->->Cycle:
->->-> Pairs:
 LTE(s(m),s(n)) -> LTE(m,n)
-> QPairs:
 Empty
->->-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue
->->Cycle:
->->-> Pairs:
 INSERT(cons(n,l),m) -> INSERT(l,m) | lte(m,n) ->* ffalse
-> QPairs:
 Empty
->->-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue


The problem is decomposed in 3 subproblems.

Problem 1.1.1: 

Subterm Processor:
-> Pairs:
 ORDERED(cons(m,cons(n,l))) -> ORDERED(cons(n,l)) | lte(m,n) ->* ftrue
-> QPairs:
 Empty
-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue
->Projection:
 pi(ORDERED) = 1

Problem 1.1.1: 

SCC Processor:
-> Pairs:
 Empty
-> QPairs:
 Empty
-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.1.2: 

Subterm Processor:
-> Pairs:
 LTE(s(m),s(n)) -> LTE(m,n)
-> QPairs:
 Empty
-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue
->Projection:
 pi(LTE) = 1

Problem 1.1.2: 

SCC Processor:
-> Pairs:
 Empty
-> QPairs:
 Empty
-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.1.3: 

Subterm Processor:
-> Pairs:
 INSERT(cons(n,l),m) -> INSERT(l,m) | lte(m,n) ->* ffalse
-> QPairs:
 Empty
-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue
->Projection:
 pi(INSERT) = 1

Problem 1.1.3: 

SCC Processor:
-> Pairs:
 Empty
-> QPairs:
 Empty
-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

SCC Processor:
-> Pairs:
 INSERT(cons(n,l),m) -> LTE(m,n)
 ORDERED(cons(m,cons(n,l))) -> LTE(m,n)
-> QPairs:
 LTE(s(m),s(n)) -> LTE(m,n)
-> Rules:
 insert(cons(n,l),m) -> cons(m,cons(n,l)) | lte(m,n) ->* ftrue
 insert(cons(n,l),m) -> cons(n,insert(l,m)) | lte(m,n) ->* ffalse
 insert(nil,m) -> cons(m,nil)
 lte(num0,n) -> ftrue
 lte(s(m),num0) -> ffalse
 lte(s(m),s(n)) -> lte(m,n)
 ordered(cons(m,cons(n,l))) -> ordered(cons(n,l)) | lte(m,n) ->* ftrue
 ordered(cons(m,cons(n,l))) -> ffalse | lte(m,n) ->* ffalse
 ordered(cons(m,nil)) -> ftrue
 ordered(nil) -> ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
