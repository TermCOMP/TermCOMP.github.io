YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/p1Oko.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Quasi decreasingness of the given CTRS could be proven:

(0) CTRS
(1) CTRSToQTRSProof [SOUND, 0 ms]
(2) QTRS
(3) AAECC Innermost [EQUIVALENT, 0 ms]
(4) QTRS
(5) DependencyPairsProof [EQUIVALENT, 0 ms]
(6) QDP
(7) DependencyGraphProof [EQUIVALENT, 0 ms]
(8) AND
    (9) QDP
        (10) UsableRulesProof [EQUIVALENT, 0 ms]
        (11) QDP
        (12) QReductionProof [EQUIVALENT, 0 ms]
        (13) QDP
        (14) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (15) YES
    (16) QDP
        (17) UsableRulesProof [EQUIVALENT, 0 ms]
        (18) QDP
        (19) QReductionProof [EQUIVALENT, 0 ms]
        (20) QDP
        (21) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (22) YES
    (23) QDP
        (24) UsableRulesProof [EQUIVALENT, 0 ms]
        (25) QDP
        (26) QReductionProof [EQUIVALENT, 0 ms]
        (27) QDP
        (28) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (29) YES
    (30) QDP
        (31) UsableRulesProof [EQUIVALENT, 0 ms]
        (32) QDP
        (33) QReductionProof [EQUIVALENT, 0 ms]
        (34) QDP
        (35) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (36) YES
    (37) QDP
        (38) UsableRulesProof [EQUIVALENT, 0 ms]
        (39) QDP
        (40) QReductionProof [EQUIVALENT, 0 ms]
        (41) QDP
        (42) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (43) YES
    (44) QDP
        (45) UsableRulesProof [EQUIVALENT, 0 ms]
        (46) QDP
        (47) QReductionProof [EQUIVALENT, 0 ms]
        (48) QDP
        (49) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (50) YES
    (51) QDP
        (52) UsableRulesProof [EQUIVALENT, 0 ms]
        (53) QDP
        (54) QReductionProof [EQUIVALENT, 0 ms]
        (55) QDP
        (56) TransformationProof [EQUIVALENT, 0 ms]
        (57) QDP
        (58) TransformationProof [EQUIVALENT, 0 ms]
        (59) QDP
        (60) QDPQMonotonicMRRProof [EQUIVALENT, 86 ms]
        (61) QDP
        (62) NonInfProof [EQUIVALENT, 127 ms]
        (63) QDP
        (64) DependencyGraphProof [EQUIVALENT, 0 ms]
        (65) QDP
        (66) QDPOrderProof [EQUIVALENT, 253 ms]
        (67) QDP
        (68) DependencyGraphProof [EQUIVALENT, 0 ms]
        (69) QDP
        (70) NonInfProof [EQUIVALENT, 195 ms]
        (71) AND
            (72) QDP
                (73) DependencyGraphProof [EQUIVALENT, 0 ms]
                (74) QDP
                (75) NonInfProof [EQUIVALENT, 1193 ms]
                (76) AND
                    (77) QDP
                        (78) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (79) QDP
                        (80) QDPQMonotonicMRRProof [EQUIVALENT, 41 ms]
                        (81) QDP
                        (82) TransformationProof [EQUIVALENT, 0 ms]
                        (83) QDP
                        (84) TransformationProof [EQUIVALENT, 0 ms]
                        (85) QDP
                        (86) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (87) QDP
                        (88) TransformationProof [EQUIVALENT, 0 ms]
                        (89) QDP
                        (90) TransformationProof [EQUIVALENT, 0 ms]
                        (91) QDP
                        (92) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (93) QDP
                        (94) TransformationProof [EQUIVALENT, 0 ms]
                        (95) QDP
                        (96) TransformationProof [EQUIVALENT, 0 ms]
                        (97) QDP
                        (98) TransformationProof [EQUIVALENT, 0 ms]
                        (99) QDP
                        (100) TransformationProof [EQUIVALENT, 0 ms]
                        (101) QDP
                        (102) TransformationProof [EQUIVALENT, 0 ms]
                        (103) QDP
                        (104) TransformationProof [EQUIVALENT, 0 ms]
                        (105) QDP
                        (106) TransformationProof [EQUIVALENT, 0 ms]
                        (107) QDP
                        (108) TransformationProof [EQUIVALENT, 0 ms]
                        (109) QDP
                        (110) TransformationProof [EQUIVALENT, 0 ms]
                        (111) QDP
                        (112) TransformationProof [EQUIVALENT, 0 ms]
                        (113) QDP
                        (114) TransformationProof [EQUIVALENT, 0 ms]
                        (115) QDP
                        (116) TransformationProof [EQUIVALENT, 0 ms]
                        (117) QDP
                        (118) TransformationProof [EQUIVALENT, 0 ms]
                        (119) QDP
                        (120) TransformationProof [EQUIVALENT, 0 ms]
                        (121) QDP
                        (122) UsableRulesProof [EQUIVALENT, 0 ms]
                        (123) QDP
                        (124) QReductionProof [EQUIVALENT, 0 ms]
                        (125) QDP
                        (126) TransformationProof [EQUIVALENT, 0 ms]
                        (127) QDP
                        (128) TransformationProof [EQUIVALENT, 0 ms]
                        (129) QDP
                        (130) UsableRulesProof [EQUIVALENT, 0 ms]
                        (131) QDP
                        (132) QReductionProof [EQUIVALENT, 0 ms]
                        (133) QDP
                        (134) TransformationProof [EQUIVALENT, 0 ms]
                        (135) QDP
                        (136) TransformationProof [EQUIVALENT, 0 ms]
                        (137) QDP
                        (138) TransformationProof [EQUIVALENT, 0 ms]
                        (139) QDP
                        (140) TransformationProof [EQUIVALENT, 0 ms]
                        (141) QDP
                        (142) TransformationProof [EQUIVALENT, 0 ms]
                        (143) QDP
                        (144) TransformationProof [EQUIVALENT, 0 ms]
                        (145) QDP
                        (146) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                        (147) YES
                    (148) QDP
                        (149) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (150) QDP
                        (151) TransformationProof [EQUIVALENT, 0 ms]
                        (152) QDP
                        (153) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (154) QDP
                        (155) TransformationProof [EQUIVALENT, 0 ms]
                        (156) QDP
                        (157) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (158) QDP
                        (159) TransformationProof [EQUIVALENT, 0 ms]
                        (160) QDP
                        (161) TransformationProof [EQUIVALENT, 0 ms]
                        (162) QDP
                        (163) TransformationProof [EQUIVALENT, 0 ms]
                        (164) QDP
                        (165) TransformationProof [EQUIVALENT, 0 ms]
                        (166) QDP
                        (167) TransformationProof [EQUIVALENT, 0 ms]
                        (168) QDP
                        (169) TransformationProof [EQUIVALENT, 0 ms]
                        (170) QDP
                        (171) UsableRulesProof [EQUIVALENT, 0 ms]
                        (172) QDP
                        (173) QReductionProof [EQUIVALENT, 0 ms]
                        (174) QDP
                        (175) TransformationProof [EQUIVALENT, 0 ms]
                        (176) QDP
                        (177) TransformationProof [EQUIVALENT, 0 ms]
                        (178) QDP
                        (179) TransformationProof [EQUIVALENT, 0 ms]
                        (180) QDP
                        (181) TransformationProof [EQUIVALENT, 0 ms]
                        (182) QDP
                        (183) UsableRulesProof [EQUIVALENT, 0 ms]
                        (184) QDP
                        (185) QReductionProof [EQUIVALENT, 0 ms]
                        (186) QDP
                        (187) TransformationProof [EQUIVALENT, 0 ms]
                        (188) QDP
                        (189) TransformationProof [EQUIVALENT, 0 ms]
                        (190) QDP
                        (191) TransformationProof [EQUIVALENT, 0 ms]
                        (192) QDP
                        (193) TransformationProof [EQUIVALENT, 0 ms]
                        (194) QDP
                        (195) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                        (196) YES
            (197) QDP
                (198) DependencyGraphProof [EQUIVALENT, 0 ms]
                (199) QDP
                (200) QDPQMonotonicMRRProof [EQUIVALENT, 9 ms]
                (201) QDP
                (202) TransformationProof [EQUIVALENT, 0 ms]
                (203) QDP
                (204) DependencyGraphProof [EQUIVALENT, 0 ms]
                (205) QDP
                (206) NonInfProof [EQUIVALENT, 23 ms]
                (207) AND
                    (208) QDP
                        (209) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (210) QDP
                        (211) TransformationProof [EQUIVALENT, 0 ms]
                        (212) QDP
                        (213) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (214) QDP
                        (215) TransformationProof [EQUIVALENT, 0 ms]
                        (216) QDP
                        (217) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (218) QDP
                        (219) TransformationProof [EQUIVALENT, 0 ms]
                        (220) QDP
                        (221) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (222) QDP
                        (223) UsableRulesProof [EQUIVALENT, 0 ms]
                        (224) QDP
                        (225) QReductionProof [EQUIVALENT, 0 ms]
                        (226) QDP
                        (227) TransformationProof [EQUIVALENT, 0 ms]
                        (228) QDP
                        (229) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (230) TRUE
                    (231) QDP
                        (232) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (233) TRUE


----------------------------------------

(0)
Obligation:
Conditional term rewrite system:
The TRS R consists of the following rules:

   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   head(cons(h, t)) -> h
   tail(cons(h, t)) -> t

The conditional TRS C consists of the following conditional rules:

   ring(st_1, in_2, st_2, in_3, st_3, m) -> ring(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m) <= empty(fstsplit(m, st_1)) -> false
   ring(st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m) <= leq(m, length(st_2)) -> true, empty(fstsplit(m, st_2)) -> false
   ring(st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m) <= leq(m, length(st_2)) -> false, empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))) -> false
   ring(st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), st_2, in_3, st_3, m) <= empty(map_f(two, head(in_2))) -> true
   ring(st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m) <= leq(m, length(st_3)) -> true, empty(fstsplit(m, st_3)) -> false
   ring(st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m) <= leq(m, length(st_3)) -> false, empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))) -> false
   ring(st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), st_3, m) <= empty(map_f(three, head(in_3))) -> true


----------------------------------------

(1) CTRSToQTRSProof (SOUND)
The conditional rules have been transormed into unconditional rules according to [CTRS,AAECCNOC].
----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   ring(st_1, in_2, st_2, in_3, st_3, m) -> U1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   U1(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U2(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2(false, st_1, in_2, st_2, in_3, st_3, m) -> U4(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U2(true, st_1, in_2, st_2, in_3, st_3, m) -> U3(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U5(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U6(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6(true, st_1, in_2, st_2, in_3, st_3, m) -> U7(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6(false, st_1, in_2, st_2, in_3, st_3, m) -> U8(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U9(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), st_3, m)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   head(cons(h, t)) -> h
   tail(cons(h, t)) -> t

Q is empty.

----------------------------------------

(3) AAECC Innermost (EQUIVALENT)
We have applied [NOC,AAECCNOC] to switch to innermost. The TRS R 1 is 
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   head(cons(h, t)) -> h
   tail(cons(h, t)) -> t

The TRS R 2 is 
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   U1(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U2(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2(false, st_1, in_2, st_2, in_3, st_3, m) -> U4(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U2(true, st_1, in_2, st_2, in_3, st_3, m) -> U3(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U5(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U6(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6(true, st_1, in_2, st_2, in_3, st_3, m) -> U7(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6(false, st_1, in_2, st_2, in_3, st_3, m) -> U8(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U9(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), st_3, m)

The signature Sigma is {ring_6, U1_7, U2_7, U4_7, U3_7, U5_7, U6_7, U7_7, U8_7, U9_7}
----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   ring(st_1, in_2, st_2, in_3, st_3, m) -> U1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   U1(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U2(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2(false, st_1, in_2, st_2, in_3, st_3, m) -> U4(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U2(true, st_1, in_2, st_2, in_3, st_3, m) -> U3(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U5(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U6(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6(true, st_1, in_2, st_2, in_3, st_3, m) -> U7(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6(false, st_1, in_2, st_2, in_3, st_3, m) -> U8(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U9(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), st_3, m)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   head(cons(h, t)) -> h
   tail(cons(h, t)) -> t

The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))


----------------------------------------

(5) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(6)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U1^1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> EMPTY(fstsplit(m, st_1))
   RING(st_1, in_2, st_2, in_3, st_3, m) -> FSTSPLIT(m, st_1)
   U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> SNDSPLIT(m, st_1)
   U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> FSTSPLIT(m, st_1)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> LEQ(m, length(st_2))
   RING(st_1, in_2, st_2, in_3, st_3, m) -> LENGTH(st_2)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> EMPTY(fstsplit(m, app(map_f(two, head(in_2)), st_2)))
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> FSTSPLIT(m, app(map_f(two, head(in_2)), st_2))
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> APP(map_f(two, head(in_2)), st_2)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> MAP_F(two, head(in_2))
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> HEAD(in_2)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> TAIL(in_2)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> SNDSPLIT(m, app(map_f(two, head(in_2)), st_2))
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> APP(map_f(two, head(in_2)), st_2)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> MAP_F(two, head(in_2))
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> HEAD(in_2)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> FSTSPLIT(m, app(map_f(two, head(in_2)), st_2))
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> EMPTY(fstsplit(m, st_2))
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> FSTSPLIT(m, st_2)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> SNDSPLIT(m, st_2)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> FSTSPLIT(m, st_2)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U5^1(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> EMPTY(map_f(two, head(in_2)))
   RING(st_1, in_2, st_2, in_3, st_3, m) -> MAP_F(two, head(in_2))
   RING(st_1, in_2, st_2, in_3, st_3, m) -> HEAD(in_2)
   U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), st_2, in_3, st_3, m)
   U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> TAIL(in_2)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> LEQ(m, length(st_3))
   RING(st_1, in_2, st_2, in_3, st_3, m) -> LENGTH(st_3)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> EMPTY(fstsplit(m, st_3))
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> FSTSPLIT(m, st_3)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> SNDSPLIT(m, st_3)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> EMPTY(fstsplit(m, app(map_f(three, head(in_3)), st_3)))
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> FSTSPLIT(m, app(map_f(three, head(in_3)), st_3))
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> APP(map_f(three, head(in_3)), st_3)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> MAP_F(three, head(in_3))
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> HEAD(in_3)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> TAIL(in_3)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> SNDSPLIT(m, app(map_f(three, head(in_3)), st_3))
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> APP(map_f(three, head(in_3)), st_3)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> MAP_F(three, head(in_3))
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> HEAD(in_3)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U9^1(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> EMPTY(map_f(three, head(in_3)))
   RING(st_1, in_2, st_2, in_3, st_3, m) -> MAP_F(three, head(in_3))
   RING(st_1, in_2, st_2, in_3, st_3, m) -> HEAD(in_3)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> TAIL(in_3)
   FSTSPLIT(s(n), cons(h, t)) -> FSTSPLIT(n, t)
   SNDSPLIT(s(n), cons(h, t)) -> SNDSPLIT(n, t)
   LEQ(s(n), s(m)) -> LEQ(n, m)
   LENGTH(cons(h, t)) -> LENGTH(t)
   APP(cons(h, t), x) -> APP(t, x)
   MAP_F(pid, cons(h, t)) -> APP(f(pid, h), map_f(pid, t))
   MAP_F(pid, cons(h, t)) -> MAP_F(pid, t)

The TRS R consists of the following rules:

   ring(st_1, in_2, st_2, in_3, st_3, m) -> U1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   U1(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U2(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2(false, st_1, in_2, st_2, in_3, st_3, m) -> U4(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U2(true, st_1, in_2, st_2, in_3, st_3, m) -> U3(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U5(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U6(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6(true, st_1, in_2, st_2, in_3, st_3, m) -> U7(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6(false, st_1, in_2, st_2, in_3, st_3, m) -> U8(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U9(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), st_3, m)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   head(cons(h, t)) -> h
   tail(cons(h, t)) -> t

The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(7) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 7 SCCs with 45 less nodes.
----------------------------------------

(8)
Complex Obligation (AND)

----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APP(cons(h, t), x) -> APP(t, x)

The TRS R consists of the following rules:

   ring(st_1, in_2, st_2, in_3, st_3, m) -> U1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   U1(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U2(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2(false, st_1, in_2, st_2, in_3, st_3, m) -> U4(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U2(true, st_1, in_2, st_2, in_3, st_3, m) -> U3(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U5(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U6(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6(true, st_1, in_2, st_2, in_3, st_3, m) -> U7(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6(false, st_1, in_2, st_2, in_3, st_3, m) -> U8(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U9(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), st_3, m)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   head(cons(h, t)) -> h
   tail(cons(h, t)) -> t

The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(10) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APP(cons(h, t), x) -> APP(t, x)

R is empty.
The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(12) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))


----------------------------------------

(13)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APP(cons(h, t), x) -> APP(t, x)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(14) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*APP(cons(h, t), x) -> APP(t, x)
The graph contains the following edges 1 > 1, 2 >= 2


----------------------------------------

(15)
YES

----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MAP_F(pid, cons(h, t)) -> MAP_F(pid, t)

The TRS R consists of the following rules:

   ring(st_1, in_2, st_2, in_3, st_3, m) -> U1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   U1(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U2(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2(false, st_1, in_2, st_2, in_3, st_3, m) -> U4(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U2(true, st_1, in_2, st_2, in_3, st_3, m) -> U3(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U5(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U6(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6(true, st_1, in_2, st_2, in_3, st_3, m) -> U7(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6(false, st_1, in_2, st_2, in_3, st_3, m) -> U8(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U9(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), st_3, m)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   head(cons(h, t)) -> h
   tail(cons(h, t)) -> t

The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(17) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MAP_F(pid, cons(h, t)) -> MAP_F(pid, t)

R is empty.
The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(19) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))


----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MAP_F(pid, cons(h, t)) -> MAP_F(pid, t)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(21) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MAP_F(pid, cons(h, t)) -> MAP_F(pid, t)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(22)
YES

----------------------------------------

(23)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENGTH(cons(h, t)) -> LENGTH(t)

The TRS R consists of the following rules:

   ring(st_1, in_2, st_2, in_3, st_3, m) -> U1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   U1(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U2(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2(false, st_1, in_2, st_2, in_3, st_3, m) -> U4(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U2(true, st_1, in_2, st_2, in_3, st_3, m) -> U3(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U5(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U6(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6(true, st_1, in_2, st_2, in_3, st_3, m) -> U7(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6(false, st_1, in_2, st_2, in_3, st_3, m) -> U8(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U9(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), st_3, m)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   head(cons(h, t)) -> h
   tail(cons(h, t)) -> t

The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(24) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(25)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENGTH(cons(h, t)) -> LENGTH(t)

R is empty.
The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(26) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))


----------------------------------------

(27)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENGTH(cons(h, t)) -> LENGTH(t)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(28) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*LENGTH(cons(h, t)) -> LENGTH(t)
The graph contains the following edges 1 > 1


----------------------------------------

(29)
YES

----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LEQ(s(n), s(m)) -> LEQ(n, m)

The TRS R consists of the following rules:

   ring(st_1, in_2, st_2, in_3, st_3, m) -> U1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   U1(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U2(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2(false, st_1, in_2, st_2, in_3, st_3, m) -> U4(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U2(true, st_1, in_2, st_2, in_3, st_3, m) -> U3(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U5(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U6(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6(true, st_1, in_2, st_2, in_3, st_3, m) -> U7(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6(false, st_1, in_2, st_2, in_3, st_3, m) -> U8(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U9(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), st_3, m)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   head(cons(h, t)) -> h
   tail(cons(h, t)) -> t

The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(31) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(32)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LEQ(s(n), s(m)) -> LEQ(n, m)

R is empty.
The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(33) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))


----------------------------------------

(34)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LEQ(s(n), s(m)) -> LEQ(n, m)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(35) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*LEQ(s(n), s(m)) -> LEQ(n, m)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(36)
YES

----------------------------------------

(37)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SNDSPLIT(s(n), cons(h, t)) -> SNDSPLIT(n, t)

The TRS R consists of the following rules:

   ring(st_1, in_2, st_2, in_3, st_3, m) -> U1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   U1(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U2(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2(false, st_1, in_2, st_2, in_3, st_3, m) -> U4(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U2(true, st_1, in_2, st_2, in_3, st_3, m) -> U3(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U5(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U6(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6(true, st_1, in_2, st_2, in_3, st_3, m) -> U7(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6(false, st_1, in_2, st_2, in_3, st_3, m) -> U8(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U9(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), st_3, m)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   head(cons(h, t)) -> h
   tail(cons(h, t)) -> t

The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(38) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(39)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SNDSPLIT(s(n), cons(h, t)) -> SNDSPLIT(n, t)

R is empty.
The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(40) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))


----------------------------------------

(41)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SNDSPLIT(s(n), cons(h, t)) -> SNDSPLIT(n, t)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(42) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*SNDSPLIT(s(n), cons(h, t)) -> SNDSPLIT(n, t)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(43)
YES

----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FSTSPLIT(s(n), cons(h, t)) -> FSTSPLIT(n, t)

The TRS R consists of the following rules:

   ring(st_1, in_2, st_2, in_3, st_3, m) -> U1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   U1(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U2(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2(false, st_1, in_2, st_2, in_3, st_3, m) -> U4(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U2(true, st_1, in_2, st_2, in_3, st_3, m) -> U3(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U5(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U6(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6(true, st_1, in_2, st_2, in_3, st_3, m) -> U7(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6(false, st_1, in_2, st_2, in_3, st_3, m) -> U8(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U9(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), st_3, m)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   head(cons(h, t)) -> h
   tail(cons(h, t)) -> t

The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(45) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(46)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FSTSPLIT(s(n), cons(h, t)) -> FSTSPLIT(n, t)

R is empty.
The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(47) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))


----------------------------------------

(48)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FSTSPLIT(s(n), cons(h, t)) -> FSTSPLIT(n, t)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(49) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*FSTSPLIT(s(n), cons(h, t)) -> FSTSPLIT(n, t)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(50)
YES

----------------------------------------

(51)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U1^1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U5^1(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U9^1(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)

The TRS R consists of the following rules:

   ring(st_1, in_2, st_2, in_3, st_3, m) -> U1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   U1(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U2(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2(false, st_1, in_2, st_2, in_3, st_3, m) -> U4(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U2(true, st_1, in_2, st_2, in_3, st_3, m) -> U3(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U5(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, tail(in_2), st_2, in_3, st_3, m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U6(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6(true, st_1, in_2, st_2, in_3, st_3, m) -> U7(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6(false, st_1, in_2, st_2, in_3, st_3, m) -> U8(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8(false, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   ring(st_1, in_2, st_2, in_3, st_3, m) -> U9(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9(true, st_1, in_2, st_2, in_3, st_3, m) -> ring(st_1, in_2, st_2, tail(in_3), st_3, m)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   head(cons(h, t)) -> h
   tail(cons(h, t)) -> t

The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(52) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(53)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U1^1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U5^1(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U9^1(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)
   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(54) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   ring(x0, x1, x2, x3, x4, x5)
   U1(false, x0, x1, x2, x3, x4, x5)
   U2(false, x0, x1, x2, x3, x4, x5)
   U4(false, x0, x1, x2, x3, x4, x5)
   U2(true, x0, x1, x2, x3, x4, x5)
   U3(false, x0, x1, x2, x3, x4, x5)
   U5(true, x0, x1, x2, x3, x4, x5)
   U6(true, x0, x1, x2, x3, x4, x5)
   U7(false, x0, x1, x2, x3, x4, x5)
   U6(false, x0, x1, x2, x3, x4, x5)
   U8(false, x0, x1, x2, x3, x4, x5)
   U9(true, x0, x1, x2, x3, x4, x5)


----------------------------------------

(55)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U1^1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U5^1(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m)
   U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U9^1(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(56) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule RING(st_1, in_2, st_2, in_3, st_3, m) -> U5^1(empty(map_f(two, head(in_2))), st_1, in_2, st_2, in_3, st_3, m) at position [0] we obtained the following new rules [LPAR04]:

   (RING(y0, cons(x0, x1), y2, y3, y4, y5) -> U5^1(empty(map_f(two, x0)), y0, cons(x0, x1), y2, y3, y4, y5),RING(y0, cons(x0, x1), y2, y3, y4, y5) -> U5^1(empty(map_f(two, x0)), y0, cons(x0, x1), y2, y3, y4, y5))


----------------------------------------

(57)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U1^1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U9^1(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   RING(y0, cons(x0, x1), y2, y3, y4, y5) -> U5^1(empty(map_f(two, x0)), y0, cons(x0, x1), y2, y3, y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(58) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule RING(st_1, in_2, st_2, in_3, st_3, m) -> U9^1(empty(map_f(three, head(in_3))), st_1, in_2, st_2, in_3, st_3, m) at position [0] we obtained the following new rules [LPAR04]:

   (RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5),RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5))


----------------------------------------

(59)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U1^1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   RING(y0, cons(x0, x1), y2, y3, y4, y5) -> U5^1(empty(map_f(two, x0)), y0, cons(x0, x1), y2, y3, y4, y5)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(60) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.


Strictly oriented rules of the TRS R:

   sndsplit(s(n), cons(h, t)) -> sndsplit(n, t)

Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(RING(x_1, x_2, x_3, x_4, x_5, x_6)) = x_1 + 2*x_3 + 2*x_5
   POL(U1^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_4 + 2*x_6
   POL(U2^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_4 + 2*x_6
   POL(U3^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_4 + 2*x_6
   POL(U4^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_4 + 2*x_6
   POL(U5^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_4 + 2*x_6
   POL(U6^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_4 + 2*x_6
   POL(U7^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_4 + 2*x_6
   POL(U8^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_4 + 2*x_6
   POL(U9^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_4 + 2*x_6
   POL(app(x_1, x_2)) = x_1 + x_2
   POL(cons(x_1, x_2)) = 2 + x_1 + x_2
   POL(empty(x_1)) = 0
   POL(f(x_1, x_2)) = 0
   POL(false) = 0
   POL(fstsplit(x_1, x_2)) = 2*x_2
   POL(head(x_1)) = 2*x_1
   POL(length(x_1)) = 0
   POL(leq(x_1, x_2)) = 0
   POL(map_f(x_1, x_2)) = 0
   POL(nil) = 0
   POL(s(x_1)) = 0
   POL(sndsplit(x_1, x_2)) = x_2
   POL(tail(x_1)) = 2*x_1
   POL(three) = 0
   POL(true) = 0
   POL(two) = 0


----------------------------------------

(61)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U1^1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   RING(y0, cons(x0, x1), y2, y3, y4, y5) -> U5^1(empty(map_f(two, x0)), y0, cons(x0, x1), y2, y3, y4, y5)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(62) NonInfProof (EQUIVALENT)
The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x6, x7, x8, x9, x10, x11) -> U1^1(empty(fstsplit(x11, x6)), x6, x7, x8, x9, x10, x11), U1^1(false, x12, x13, x14, x15, x16, x17) -> RING(sndsplit(x17, x12), cons(fstsplit(x17, x12), x13), x14, x15, x16, x17) which results in the following constraint:

(1)    (U1^1(empty(fstsplit(x11, x6)), x6, x7, x8, x9, x10, x11)=U1^1(false, x12, x13, x14, x15, x16, x17)  ==>  U1^1(false, x12, x13, x14, x15, x16, x17)_>=_RING(sndsplit(x17, x12), cons(fstsplit(x17, x12), x13), x14, x15, x16, x17))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (fstsplit(x11, x6)=x1858 & empty(x1858)=false  ==>  U1^1(false, x6, x7, x8, x9, x10, x11)_>=_RING(sndsplit(x11, x6), cons(fstsplit(x11, x6), x7), x8, x9, x10, x11))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x1858)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x11, x6)=cons(x1860, x1859)  ==>  U1^1(false, x6, x7, x8, x9, x10, x11)_>=_RING(sndsplit(x11, x6), cons(fstsplit(x11, x6), x7), x8, x9, x10, x11))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x11, x6)=cons(x1860, x1859)  ==>  U1^1(false, x6, x7, x8, x9, x10, x11)_>=_RING(sndsplit(x11, x6), cons(fstsplit(x11, x6), x7), x8, x9, x10, x11))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x11, x6)=cons(x1860, x1859) which results in the following new constraint:

(5)    (cons(x1864, fstsplit(x1865, x1863))=cons(x1860, x1859) & (\/x1866,x1867,x1868,x1869,x1870,x1871:fstsplit(x1865, x1863)=cons(x1866, x1867)  ==>  U1^1(false, x1863, x1868, x1869, x1870, x1871, x1865)_>=_RING(sndsplit(x1865, x1863), cons(fstsplit(x1865, x1863), x1868), x1869, x1870, x1871, x1865))  ==>  U1^1(false, cons(x1864, x1863), x7, x8, x9, x10, s(x1865))_>=_RING(sndsplit(s(x1865), cons(x1864, x1863)), cons(fstsplit(s(x1865), cons(x1864, x1863)), x7), x8, x9, x10, s(x1865)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U1^1(false, cons(x1864, x1863), x7, x8, x9, x10, s(x1865))_>=_RING(sndsplit(s(x1865), cons(x1864, x1863)), cons(fstsplit(s(x1865), cons(x1864, x1863)), x7), x8, x9, x10, s(x1865)))








For Pair RING(st_1, in_2, st_2, in_3, st_3, m) -> U1^1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain U1^1(false, x104, x105, x106, x107, x108, x109) -> RING(sndsplit(x109, x104), cons(fstsplit(x109, x104), x105), x106, x107, x108, x109), RING(x110, x111, x112, x113, x114, x115) -> U1^1(empty(fstsplit(x115, x110)), x110, x111, x112, x113, x114, x115) which results in the following constraint:

(1)    (RING(sndsplit(x109, x104), cons(fstsplit(x109, x104), x105), x106, x107, x108, x109)=RING(x110, x111, x112, x113, x114, x115)  ==>  RING(x110, x111, x112, x113, x114, x115)_>=_U1^1(empty(fstsplit(x115, x110)), x110, x111, x112, x113, x114, x115))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x110, x111, x106, x107, x108, x109)_>=_U1^1(empty(fstsplit(x109, x110)), x110, x111, x106, x107, x108, x109))




*We consider the chain U4^1(false, x134, x135, x136, x137, x138, x139) -> RING(x134, tail(x135), sndsplit(x139, app(map_f(two, head(x135)), x136)), cons(fstsplit(x139, app(map_f(two, head(x135)), x136)), x137), x138, x139), RING(x140, x141, x142, x143, x144, x145) -> U1^1(empty(fstsplit(x145, x140)), x140, x141, x142, x143, x144, x145) which results in the following constraint:

(1)    (RING(x134, tail(x135), sndsplit(x139, app(map_f(two, head(x135)), x136)), cons(fstsplit(x139, app(map_f(two, head(x135)), x136)), x137), x138, x139)=RING(x140, x141, x142, x143, x144, x145)  ==>  RING(x140, x141, x142, x143, x144, x145)_>=_U1^1(empty(fstsplit(x145, x140)), x140, x141, x142, x143, x144, x145))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x134, x141, x142, x143, x138, x139)_>=_U1^1(empty(fstsplit(x139, x134)), x134, x141, x142, x143, x138, x139))




*We consider the chain U5^1(true, x146, x147, x148, x149, x150, x151) -> RING(x146, tail(x147), x148, x149, x150, x151), RING(x152, x153, x154, x155, x156, x157) -> U1^1(empty(fstsplit(x157, x152)), x152, x153, x154, x155, x156, x157) which results in the following constraint:

(1)    (RING(x146, tail(x147), x148, x149, x150, x151)=RING(x152, x153, x154, x155, x156, x157)  ==>  RING(x152, x153, x154, x155, x156, x157)_>=_U1^1(empty(fstsplit(x157, x152)), x152, x153, x154, x155, x156, x157))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x146, x153, x148, x149, x150, x151)_>=_U1^1(empty(fstsplit(x151, x146)), x146, x153, x148, x149, x150, x151))




*We consider the chain U7^1(false, x170, x171, x172, x173, x174, x175) -> RING(x170, x171, x172, x173, sndsplit(x175, x174), x175), RING(x176, x177, x178, x179, x180, x181) -> U1^1(empty(fstsplit(x181, x176)), x176, x177, x178, x179, x180, x181) which results in the following constraint:

(1)    (RING(x170, x171, x172, x173, sndsplit(x175, x174), x175)=RING(x176, x177, x178, x179, x180, x181)  ==>  RING(x176, x177, x178, x179, x180, x181)_>=_U1^1(empty(fstsplit(x181, x176)), x176, x177, x178, x179, x180, x181))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x170, x171, x172, x173, x180, x175)_>=_U1^1(empty(fstsplit(x175, x170)), x170, x171, x172, x173, x180, x175))




*We consider the chain U9^1(true, x182, x183, x184, x185, x186, x187) -> RING(x182, x183, x184, tail(x185), x186, x187), RING(x188, x189, x190, x191, x192, x193) -> U1^1(empty(fstsplit(x193, x188)), x188, x189, x190, x191, x192, x193) which results in the following constraint:

(1)    (RING(x182, x183, x184, tail(x185), x186, x187)=RING(x188, x189, x190, x191, x192, x193)  ==>  RING(x188, x189, x190, x191, x192, x193)_>=_U1^1(empty(fstsplit(x193, x188)), x188, x189, x190, x191, x192, x193))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x182, x183, x184, x191, x186, x187)_>=_U1^1(empty(fstsplit(x187, x182)), x182, x183, x184, x191, x186, x187))




*We consider the chain U8^1(false, x200, x201, x202, x203, x204, x205) -> RING(x200, x201, x202, tail(x203), sndsplit(x205, app(map_f(three, head(x203)), x204)), x205), RING(x206, x207, x208, x209, x210, x211) -> U1^1(empty(fstsplit(x211, x206)), x206, x207, x208, x209, x210, x211) which results in the following constraint:

(1)    (RING(x200, x201, x202, tail(x203), sndsplit(x205, app(map_f(three, head(x203)), x204)), x205)=RING(x206, x207, x208, x209, x210, x211)  ==>  RING(x206, x207, x208, x209, x210, x211)_>=_U1^1(empty(fstsplit(x211, x206)), x206, x207, x208, x209, x210, x211))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x200, x201, x202, x209, x210, x205)_>=_U1^1(empty(fstsplit(x205, x200)), x200, x201, x202, x209, x210, x205))




*We consider the chain U3^1(false, x218, x219, x220, x221, x222, x223) -> RING(x218, x219, sndsplit(x223, x220), cons(fstsplit(x223, x220), x221), x222, x223), RING(x224, x225, x226, x227, x228, x229) -> U1^1(empty(fstsplit(x229, x224)), x224, x225, x226, x227, x228, x229) which results in the following constraint:

(1)    (RING(x218, x219, sndsplit(x223, x220), cons(fstsplit(x223, x220), x221), x222, x223)=RING(x224, x225, x226, x227, x228, x229)  ==>  RING(x224, x225, x226, x227, x228, x229)_>=_U1^1(empty(fstsplit(x229, x224)), x224, x225, x226, x227, x228, x229))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x218, x219, x226, x227, x222, x223)_>=_U1^1(empty(fstsplit(x223, x218)), x218, x219, x226, x227, x222, x223))








For Pair RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain U1^1(false, x244, x245, x246, x247, x248, x249) -> RING(sndsplit(x249, x244), cons(fstsplit(x249, x244), x245), x246, x247, x248, x249), RING(x250, x251, x252, x253, x254, x255) -> U2^1(leq(x255, length(x252)), x250, x251, x252, x253, x254, x255) which results in the following constraint:

(1)    (RING(sndsplit(x249, x244), cons(fstsplit(x249, x244), x245), x246, x247, x248, x249)=RING(x250, x251, x252, x253, x254, x255)  ==>  RING(x250, x251, x252, x253, x254, x255)_>=_U2^1(leq(x255, length(x252)), x250, x251, x252, x253, x254, x255))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x250, x251, x246, x247, x248, x249)_>=_U2^1(leq(x249, length(x246)), x250, x251, x246, x247, x248, x249))




*We consider the chain U4^1(false, x274, x275, x276, x277, x278, x279) -> RING(x274, tail(x275), sndsplit(x279, app(map_f(two, head(x275)), x276)), cons(fstsplit(x279, app(map_f(two, head(x275)), x276)), x277), x278, x279), RING(x280, x281, x282, x283, x284, x285) -> U2^1(leq(x285, length(x282)), x280, x281, x282, x283, x284, x285) which results in the following constraint:

(1)    (RING(x274, tail(x275), sndsplit(x279, app(map_f(two, head(x275)), x276)), cons(fstsplit(x279, app(map_f(two, head(x275)), x276)), x277), x278, x279)=RING(x280, x281, x282, x283, x284, x285)  ==>  RING(x280, x281, x282, x283, x284, x285)_>=_U2^1(leq(x285, length(x282)), x280, x281, x282, x283, x284, x285))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x274, x281, x282, x283, x278, x279)_>=_U2^1(leq(x279, length(x282)), x274, x281, x282, x283, x278, x279))




*We consider the chain U5^1(true, x286, x287, x288, x289, x290, x291) -> RING(x286, tail(x287), x288, x289, x290, x291), RING(x292, x293, x294, x295, x296, x297) -> U2^1(leq(x297, length(x294)), x292, x293, x294, x295, x296, x297) which results in the following constraint:

(1)    (RING(x286, tail(x287), x288, x289, x290, x291)=RING(x292, x293, x294, x295, x296, x297)  ==>  RING(x292, x293, x294, x295, x296, x297)_>=_U2^1(leq(x297, length(x294)), x292, x293, x294, x295, x296, x297))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x286, x293, x288, x289, x290, x291)_>=_U2^1(leq(x291, length(x288)), x286, x293, x288, x289, x290, x291))




*We consider the chain U7^1(false, x310, x311, x312, x313, x314, x315) -> RING(x310, x311, x312, x313, sndsplit(x315, x314), x315), RING(x316, x317, x318, x319, x320, x321) -> U2^1(leq(x321, length(x318)), x316, x317, x318, x319, x320, x321) which results in the following constraint:

(1)    (RING(x310, x311, x312, x313, sndsplit(x315, x314), x315)=RING(x316, x317, x318, x319, x320, x321)  ==>  RING(x316, x317, x318, x319, x320, x321)_>=_U2^1(leq(x321, length(x318)), x316, x317, x318, x319, x320, x321))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x310, x311, x312, x313, x320, x315)_>=_U2^1(leq(x315, length(x312)), x310, x311, x312, x313, x320, x315))




*We consider the chain U9^1(true, x322, x323, x324, x325, x326, x327) -> RING(x322, x323, x324, tail(x325), x326, x327), RING(x328, x329, x330, x331, x332, x333) -> U2^1(leq(x333, length(x330)), x328, x329, x330, x331, x332, x333) which results in the following constraint:

(1)    (RING(x322, x323, x324, tail(x325), x326, x327)=RING(x328, x329, x330, x331, x332, x333)  ==>  RING(x328, x329, x330, x331, x332, x333)_>=_U2^1(leq(x333, length(x330)), x328, x329, x330, x331, x332, x333))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x322, x323, x324, x331, x326, x327)_>=_U2^1(leq(x327, length(x324)), x322, x323, x324, x331, x326, x327))




*We consider the chain U8^1(false, x340, x341, x342, x343, x344, x345) -> RING(x340, x341, x342, tail(x343), sndsplit(x345, app(map_f(three, head(x343)), x344)), x345), RING(x346, x347, x348, x349, x350, x351) -> U2^1(leq(x351, length(x348)), x346, x347, x348, x349, x350, x351) which results in the following constraint:

(1)    (RING(x340, x341, x342, tail(x343), sndsplit(x345, app(map_f(three, head(x343)), x344)), x345)=RING(x346, x347, x348, x349, x350, x351)  ==>  RING(x346, x347, x348, x349, x350, x351)_>=_U2^1(leq(x351, length(x348)), x346, x347, x348, x349, x350, x351))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x340, x341, x342, x349, x350, x345)_>=_U2^1(leq(x345, length(x342)), x340, x341, x342, x349, x350, x345))




*We consider the chain U3^1(false, x358, x359, x360, x361, x362, x363) -> RING(x358, x359, sndsplit(x363, x360), cons(fstsplit(x363, x360), x361), x362, x363), RING(x364, x365, x366, x367, x368, x369) -> U2^1(leq(x369, length(x366)), x364, x365, x366, x367, x368, x369) which results in the following constraint:

(1)    (RING(x358, x359, sndsplit(x363, x360), cons(fstsplit(x363, x360), x361), x362, x363)=RING(x364, x365, x366, x367, x368, x369)  ==>  RING(x364, x365, x366, x367, x368, x369)_>=_U2^1(leq(x369, length(x366)), x364, x365, x366, x367, x368, x369))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x358, x359, x366, x367, x362, x363)_>=_U2^1(leq(x363, length(x366)), x358, x359, x366, x367, x362, x363))








For Pair U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x396, x397, x398, x399, x400, x401) -> U2^1(leq(x401, length(x398)), x396, x397, x398, x399, x400, x401), U2^1(false, x402, x403, x404, x405, x406, x407) -> U4^1(empty(fstsplit(x407, app(map_f(two, head(x403)), x404))), x402, x403, x404, x405, x406, x407) which results in the following constraint:

(1)    (U2^1(leq(x401, length(x398)), x396, x397, x398, x399, x400, x401)=U2^1(false, x402, x403, x404, x405, x406, x407)  ==>  U2^1(false, x402, x403, x404, x405, x406, x407)_>=_U4^1(empty(fstsplit(x407, app(map_f(two, head(x403)), x404))), x402, x403, x404, x405, x406, x407))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x398)=x1888 & leq(x401, x1888)=false  ==>  U2^1(false, x396, x397, x398, x399, x400, x401)_>=_U4^1(empty(fstsplit(x401, app(map_f(two, head(x397)), x398))), x396, x397, x398, x399, x400, x401))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x401, x1888)=false which results in the following new constraints:

(3)    (false=false & length(x398)=0  ==>  U2^1(false, x396, x397, x398, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), x398))), x396, x397, x398, x399, x400, s(x1890)))

(4)    (leq(x1892, x1891)=false & length(x398)=s(x1891) & (\/x1893,x1894,x1895,x1896,x1897:leq(x1892, x1891)=false & length(x1893)=x1891  ==>  U2^1(false, x1894, x1895, x1893, x1896, x1897, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x1895)), x1893))), x1894, x1895, x1893, x1896, x1897, x1892))  ==>  U2^1(false, x396, x397, x398, x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), x398))), x396, x397, x398, x399, x400, s(x1892)))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (length(x398)=0  ==>  U2^1(false, x396, x397, x398, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), x398))), x396, x397, x398, x399, x400, s(x1890)))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x398)=s(x1891) which results in the following new constraint:

(6)    (s(length(x1900))=s(x1891) & leq(x1892, x1891)=false & (\/x1893,x1894,x1895,x1896,x1897:leq(x1892, x1891)=false & length(x1893)=x1891  ==>  U2^1(false, x1894, x1895, x1893, x1896, x1897, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x1895)), x1893))), x1894, x1895, x1893, x1896, x1897, x1892)) & (\/x1902,x1903,x1904,x1905,x1906,x1907,x1908,x1909,x1910,x1911,x1912:length(x1900)=s(x1902) & leq(x1903, x1902)=false & (\/x1904,x1905,x1906,x1907,x1908:leq(x1903, x1902)=false & length(x1904)=x1902  ==>  U2^1(false, x1905, x1906, x1904, x1907, x1908, x1903)_>=_U4^1(empty(fstsplit(x1903, app(map_f(two, head(x1906)), x1904))), x1905, x1906, x1904, x1907, x1908, x1903))  ==>  U2^1(false, x1909, x1910, x1900, x1911, x1912, s(x1903))_>=_U4^1(empty(fstsplit(s(x1903), app(map_f(two, head(x1910)), x1900))), x1909, x1910, x1900, x1911, x1912, s(x1903)))  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))



We simplified constraint (5) using rule (V) (with possible (I) afterwards) using induction on length(x398)=0 which results in the following new constraint:

(7)    (0=0  ==>  U2^1(false, x396, x397, nil, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), nil))), x396, x397, nil, x399, x400, s(x1890)))



We simplified constraint (7) using rules (I), (II) which results in the following new constraint:

(8)    (U2^1(false, x396, x397, nil, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), nil))), x396, x397, nil, x399, x400, s(x1890)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(9)    (length(x1900)=x1891 & leq(x1892, x1891)=false & (\/x1893,x1894,x1895,x1896,x1897:leq(x1892, x1891)=false & length(x1893)=x1891  ==>  U2^1(false, x1894, x1895, x1893, x1896, x1897, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x1895)), x1893))), x1894, x1895, x1893, x1896, x1897, x1892)) & (\/x1902,x1903,x1904,x1905,x1906,x1907,x1908,x1909,x1910,x1911,x1912:length(x1900)=s(x1902) & leq(x1903, x1902)=false & (\/x1904,x1905,x1906,x1907,x1908:leq(x1903, x1902)=false & length(x1904)=x1902  ==>  U2^1(false, x1905, x1906, x1904, x1907, x1908, x1903)_>=_U4^1(empty(fstsplit(x1903, app(map_f(two, head(x1906)), x1904))), x1905, x1906, x1904, x1907, x1908, x1903))  ==>  U2^1(false, x1909, x1910, x1900, x1911, x1912, s(x1903))_>=_U4^1(empty(fstsplit(s(x1903), app(map_f(two, head(x1910)), x1900))), x1909, x1910, x1900, x1911, x1912, s(x1903)))  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))



We simplified constraint (9) using rule (VI) where we applied the induction hypothesis (\/x1893,x1894,x1895,x1896,x1897:leq(x1892, x1891)=false & length(x1893)=x1891  ==>  U2^1(false, x1894, x1895, x1893, x1896, x1897, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x1895)), x1893))), x1894, x1895, x1893, x1896, x1897, x1892)) with sigma = [x1893 / x1900, x1894 / x396, x1895 / x397, x1896 / x399, x1897 / x400] which results in the following new constraint:

(10)    (U2^1(false, x396, x397, x1900, x399, x400, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x397)), x1900))), x396, x397, x1900, x399, x400, x1892) & (\/x1902,x1903,x1904,x1905,x1906,x1907,x1908,x1909,x1910,x1911,x1912:length(x1900)=s(x1902) & leq(x1903, x1902)=false & (\/x1904,x1905,x1906,x1907,x1908:leq(x1903, x1902)=false & length(x1904)=x1902  ==>  U2^1(false, x1905, x1906, x1904, x1907, x1908, x1903)_>=_U4^1(empty(fstsplit(x1903, app(map_f(two, head(x1906)), x1904))), x1905, x1906, x1904, x1907, x1908, x1903))  ==>  U2^1(false, x1909, x1910, x1900, x1911, x1912, s(x1903))_>=_U4^1(empty(fstsplit(s(x1903), app(map_f(two, head(x1910)), x1900))), x1909, x1910, x1900, x1911, x1912, s(x1903)))  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))



We simplified constraint (10) using rule (IV) which results in the following new constraint:

(11)    (U2^1(false, x396, x397, x1900, x399, x400, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x397)), x1900))), x396, x397, x1900, x399, x400, x1892)  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))








For Pair U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m) the following chains were created:
*We consider the chain U2^1(false, x506, x507, x508, x509, x510, x511) -> U4^1(empty(fstsplit(x511, app(map_f(two, head(x507)), x508))), x506, x507, x508, x509, x510, x511), U4^1(false, x512, x513, x514, x515, x516, x517) -> RING(x512, tail(x513), sndsplit(x517, app(map_f(two, head(x513)), x514)), cons(fstsplit(x517, app(map_f(two, head(x513)), x514)), x515), x516, x517) which results in the following constraint:

(1)    (U4^1(empty(fstsplit(x511, app(map_f(two, head(x507)), x508))), x506, x507, x508, x509, x510, x511)=U4^1(false, x512, x513, x514, x515, x516, x517)  ==>  U4^1(false, x512, x513, x514, x515, x516, x517)_>=_RING(x512, tail(x513), sndsplit(x517, app(map_f(two, head(x513)), x514)), cons(fstsplit(x517, app(map_f(two, head(x513)), x514)), x515), x516, x517))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (fstsplit(x511, x1914)=x1913 & empty(x1913)=false  ==>  U4^1(false, x506, x507, x508, x509, x510, x511)_>=_RING(x506, tail(x507), sndsplit(x511, app(map_f(two, head(x507)), x508)), cons(fstsplit(x511, app(map_f(two, head(x507)), x508)), x509), x510, x511))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x1913)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x511, x1914)=cons(x1919, x1918)  ==>  U4^1(false, x506, x507, x508, x509, x510, x511)_>=_RING(x506, tail(x507), sndsplit(x511, app(map_f(two, head(x507)), x508)), cons(fstsplit(x511, app(map_f(two, head(x507)), x508)), x509), x510, x511))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x511, x1914)=cons(x1919, x1918)  ==>  U4^1(false, x506, x507, x508, x509, x510, x511)_>=_RING(x506, tail(x507), sndsplit(x511, app(map_f(two, head(x507)), x508)), cons(fstsplit(x511, app(map_f(two, head(x507)), x508)), x509), x510, x511))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x511, x1914)=cons(x1919, x1918) which results in the following new constraint:

(5)    (cons(x1923, fstsplit(x1924, x1922))=cons(x1919, x1918) & (\/x1925,x1926,x1927,x1928,x1929,x1930,x1931:fstsplit(x1924, x1922)=cons(x1925, x1926)  ==>  U4^1(false, x1927, x1928, x1929, x1930, x1931, x1924)_>=_RING(x1927, tail(x1928), sndsplit(x1924, app(map_f(two, head(x1928)), x1929)), cons(fstsplit(x1924, app(map_f(two, head(x1928)), x1929)), x1930), x1931, x1924))  ==>  U4^1(false, x506, x507, x508, x509, x510, s(x1924))_>=_RING(x506, tail(x507), sndsplit(s(x1924), app(map_f(two, head(x507)), x508)), cons(fstsplit(s(x1924), app(map_f(two, head(x507)), x508)), x509), x510, s(x1924)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U4^1(false, x506, x507, x508, x509, x510, s(x1924))_>=_RING(x506, tail(x507), sndsplit(s(x1924), app(map_f(two, head(x507)), x508)), cons(fstsplit(s(x1924), app(map_f(two, head(x507)), x508)), x509), x510, s(x1924)))








For Pair U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x676, cons(x677, x678), x679, x680, x681, x682) -> U5^1(empty(map_f(two, x677)), x676, cons(x677, x678), x679, x680, x681, x682), U5^1(true, x683, x684, x685, x686, x687, x688) -> RING(x683, tail(x684), x685, x686, x687, x688) which results in the following constraint:

(1)    (U5^1(empty(map_f(two, x677)), x676, cons(x677, x678), x679, x680, x681, x682)=U5^1(true, x683, x684, x685, x686, x687, x688)  ==>  U5^1(true, x683, x684, x685, x686, x687, x688)_>=_RING(x683, tail(x684), x685, x686, x687, x688))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (two=x1933 & map_f(x1933, x677)=x1932 & empty(x1932)=true  ==>  U5^1(true, x676, cons(x677, x678), x679, x680, x681, x682)_>=_RING(x676, tail(cons(x677, x678)), x679, x680, x681, x682))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x1932)=true which results in the following new constraint:

(3)    (true=true & two=x1933 & map_f(x1933, x677)=nil  ==>  U5^1(true, x676, cons(x677, x678), x679, x680, x681, x682)_>=_RING(x676, tail(cons(x677, x678)), x679, x680, x681, x682))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (two=x1933 & map_f(x1933, x677)=nil  ==>  U5^1(true, x676, cons(x677, x678), x679, x680, x681, x682)_>=_RING(x676, tail(cons(x677, x678)), x679, x680, x681, x682))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on map_f(x1933, x677)=nil which results in the following new constraints:

(5)    (nil=nil & two=x1936  ==>  U5^1(true, x676, cons(nil, x678), x679, x680, x681, x682)_>=_RING(x676, tail(cons(nil, x678)), x679, x680, x681, x682))

(6)    (app(f(x1939, x1938), map_f(x1939, x1937))=nil & two=x1939 & (\/x1940,x1941,x1942,x1943,x1944,x1945:map_f(x1939, x1937)=nil & two=x1939  ==>  U5^1(true, x1940, cons(x1937, x1941), x1942, x1943, x1944, x1945)_>=_RING(x1940, tail(cons(x1937, x1941)), x1942, x1943, x1944, x1945))  ==>  U5^1(true, x676, cons(cons(x1938, x1937), x678), x679, x680, x681, x682)_>=_RING(x676, tail(cons(cons(x1938, x1937), x678)), x679, x680, x681, x682))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(7)    (U5^1(true, x676, cons(nil, x678), x679, x680, x681, x682)_>=_RING(x676, tail(cons(nil, x678)), x679, x680, x681, x682))



We simplified constraint (6) using rules (IV), (VII) which results in the following new constraint:

(8)    (f(x1939, x1938)=x1946 & map_f(x1939, x1937)=x1947 & app(x1946, x1947)=nil & two=x1939  ==>  U5^1(true, x676, cons(cons(x1938, x1937), x678), x679, x680, x681, x682)_>=_RING(x676, tail(cons(cons(x1938, x1937), x678)), x679, x680, x681, x682))



We simplified constraint (8) using rule (V) (with possible (I) afterwards) using induction on app(x1946, x1947)=nil which results in the following new constraint:

(9)    (x1948=nil & f(x1939, x1938)=nil & map_f(x1939, x1937)=x1948 & two=x1939  ==>  U5^1(true, x676, cons(cons(x1938, x1937), x678), x679, x680, x681, x682)_>=_RING(x676, tail(cons(cons(x1938, x1937), x678)), x679, x680, x681, x682))



We solved constraint (9) using rules (I), (II).




For Pair RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain U1^1(false, x696, x697, x698, x699, x700, x701) -> RING(sndsplit(x701, x696), cons(fstsplit(x701, x696), x697), x698, x699, x700, x701), RING(x702, x703, x704, x705, x706, x707) -> U6^1(leq(x707, length(x706)), x702, x703, x704, x705, x706, x707) which results in the following constraint:

(1)    (RING(sndsplit(x701, x696), cons(fstsplit(x701, x696), x697), x698, x699, x700, x701)=RING(x702, x703, x704, x705, x706, x707)  ==>  RING(x702, x703, x704, x705, x706, x707)_>=_U6^1(leq(x707, length(x706)), x702, x703, x704, x705, x706, x707))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x702, x703, x698, x699, x700, x701)_>=_U6^1(leq(x701, length(x700)), x702, x703, x698, x699, x700, x701))




*We consider the chain U4^1(false, x726, x727, x728, x729, x730, x731) -> RING(x726, tail(x727), sndsplit(x731, app(map_f(two, head(x727)), x728)), cons(fstsplit(x731, app(map_f(two, head(x727)), x728)), x729), x730, x731), RING(x732, x733, x734, x735, x736, x737) -> U6^1(leq(x737, length(x736)), x732, x733, x734, x735, x736, x737) which results in the following constraint:

(1)    (RING(x726, tail(x727), sndsplit(x731, app(map_f(two, head(x727)), x728)), cons(fstsplit(x731, app(map_f(two, head(x727)), x728)), x729), x730, x731)=RING(x732, x733, x734, x735, x736, x737)  ==>  RING(x732, x733, x734, x735, x736, x737)_>=_U6^1(leq(x737, length(x736)), x732, x733, x734, x735, x736, x737))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x726, x733, x734, x735, x730, x731)_>=_U6^1(leq(x731, length(x730)), x726, x733, x734, x735, x730, x731))




*We consider the chain U5^1(true, x738, x739, x740, x741, x742, x743) -> RING(x738, tail(x739), x740, x741, x742, x743), RING(x744, x745, x746, x747, x748, x749) -> U6^1(leq(x749, length(x748)), x744, x745, x746, x747, x748, x749) which results in the following constraint:

(1)    (RING(x738, tail(x739), x740, x741, x742, x743)=RING(x744, x745, x746, x747, x748, x749)  ==>  RING(x744, x745, x746, x747, x748, x749)_>=_U6^1(leq(x749, length(x748)), x744, x745, x746, x747, x748, x749))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x738, x745, x740, x741, x742, x743)_>=_U6^1(leq(x743, length(x742)), x738, x745, x740, x741, x742, x743))




*We consider the chain U7^1(false, x762, x763, x764, x765, x766, x767) -> RING(x762, x763, x764, x765, sndsplit(x767, x766), x767), RING(x768, x769, x770, x771, x772, x773) -> U6^1(leq(x773, length(x772)), x768, x769, x770, x771, x772, x773) which results in the following constraint:

(1)    (RING(x762, x763, x764, x765, sndsplit(x767, x766), x767)=RING(x768, x769, x770, x771, x772, x773)  ==>  RING(x768, x769, x770, x771, x772, x773)_>=_U6^1(leq(x773, length(x772)), x768, x769, x770, x771, x772, x773))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x762, x763, x764, x765, x772, x767)_>=_U6^1(leq(x767, length(x772)), x762, x763, x764, x765, x772, x767))




*We consider the chain U9^1(true, x774, x775, x776, x777, x778, x779) -> RING(x774, x775, x776, tail(x777), x778, x779), RING(x780, x781, x782, x783, x784, x785) -> U6^1(leq(x785, length(x784)), x780, x781, x782, x783, x784, x785) which results in the following constraint:

(1)    (RING(x774, x775, x776, tail(x777), x778, x779)=RING(x780, x781, x782, x783, x784, x785)  ==>  RING(x780, x781, x782, x783, x784, x785)_>=_U6^1(leq(x785, length(x784)), x780, x781, x782, x783, x784, x785))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x774, x775, x776, x783, x778, x779)_>=_U6^1(leq(x779, length(x778)), x774, x775, x776, x783, x778, x779))




*We consider the chain U8^1(false, x792, x793, x794, x795, x796, x797) -> RING(x792, x793, x794, tail(x795), sndsplit(x797, app(map_f(three, head(x795)), x796)), x797), RING(x798, x799, x800, x801, x802, x803) -> U6^1(leq(x803, length(x802)), x798, x799, x800, x801, x802, x803) which results in the following constraint:

(1)    (RING(x792, x793, x794, tail(x795), sndsplit(x797, app(map_f(three, head(x795)), x796)), x797)=RING(x798, x799, x800, x801, x802, x803)  ==>  RING(x798, x799, x800, x801, x802, x803)_>=_U6^1(leq(x803, length(x802)), x798, x799, x800, x801, x802, x803))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x792, x793, x794, x801, x802, x797)_>=_U6^1(leq(x797, length(x802)), x792, x793, x794, x801, x802, x797))




*We consider the chain U3^1(false, x810, x811, x812, x813, x814, x815) -> RING(x810, x811, sndsplit(x815, x812), cons(fstsplit(x815, x812), x813), x814, x815), RING(x816, x817, x818, x819, x820, x821) -> U6^1(leq(x821, length(x820)), x816, x817, x818, x819, x820, x821) which results in the following constraint:

(1)    (RING(x810, x811, sndsplit(x815, x812), cons(fstsplit(x815, x812), x813), x814, x815)=RING(x816, x817, x818, x819, x820, x821)  ==>  RING(x816, x817, x818, x819, x820, x821)_>=_U6^1(leq(x821, length(x820)), x816, x817, x818, x819, x820, x821))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x810, x811, x818, x819, x814, x815)_>=_U6^1(leq(x815, length(x814)), x810, x811, x818, x819, x814, x815))








For Pair U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x872, x873, x874, x875, x876, x877) -> U6^1(leq(x877, length(x876)), x872, x873, x874, x875, x876, x877), U6^1(true, x878, x879, x880, x881, x882, x883) -> U7^1(empty(fstsplit(x883, x882)), x878, x879, x880, x881, x882, x883) which results in the following constraint:

(1)    (U6^1(leq(x877, length(x876)), x872, x873, x874, x875, x876, x877)=U6^1(true, x878, x879, x880, x881, x882, x883)  ==>  U6^1(true, x878, x879, x880, x881, x882, x883)_>=_U7^1(empty(fstsplit(x883, x882)), x878, x879, x880, x881, x882, x883))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x876)=x1960 & leq(x877, x1960)=true  ==>  U6^1(true, x872, x873, x874, x875, x876, x877)_>=_U7^1(empty(fstsplit(x877, x876)), x872, x873, x874, x875, x876, x877))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x877, x1960)=true which results in the following new constraints:

(3)    (true=true & length(x876)=x1961  ==>  U6^1(true, x872, x873, x874, x875, x876, 0)_>=_U7^1(empty(fstsplit(0, x876)), x872, x873, x874, x875, x876, 0))

(4)    (leq(x1964, x1963)=true & length(x876)=s(x1963) & (\/x1965,x1966,x1967,x1968,x1969:leq(x1964, x1963)=true & length(x1965)=x1963  ==>  U6^1(true, x1966, x1967, x1968, x1969, x1965, x1964)_>=_U7^1(empty(fstsplit(x1964, x1965)), x1966, x1967, x1968, x1969, x1965, x1964))  ==>  U6^1(true, x872, x873, x874, x875, x876, s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), x876)), x872, x873, x874, x875, x876, s(x1964)))



We simplified constraint (3) using rules (I), (II), (IV) which results in the following new constraint:

(5)    (U6^1(true, x872, x873, x874, x875, x876, 0)_>=_U7^1(empty(fstsplit(0, x876)), x872, x873, x874, x875, x876, 0))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x876)=s(x1963) which results in the following new constraint:

(6)    (s(length(x1970))=s(x1963) & leq(x1964, x1963)=true & (\/x1965,x1966,x1967,x1968,x1969:leq(x1964, x1963)=true & length(x1965)=x1963  ==>  U6^1(true, x1966, x1967, x1968, x1969, x1965, x1964)_>=_U7^1(empty(fstsplit(x1964, x1965)), x1966, x1967, x1968, x1969, x1965, x1964)) & (\/x1972,x1973,x1974,x1975,x1976,x1977,x1978,x1979,x1980,x1981,x1982:length(x1970)=s(x1972) & leq(x1973, x1972)=true & (\/x1974,x1975,x1976,x1977,x1978:leq(x1973, x1972)=true & length(x1974)=x1972  ==>  U6^1(true, x1975, x1976, x1977, x1978, x1974, x1973)_>=_U7^1(empty(fstsplit(x1973, x1974)), x1975, x1976, x1977, x1978, x1974, x1973))  ==>  U6^1(true, x1979, x1980, x1981, x1982, x1970, s(x1973))_>=_U7^1(empty(fstsplit(s(x1973), x1970)), x1979, x1980, x1981, x1982, x1970, s(x1973)))  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(7)    (length(x1970)=x1963 & leq(x1964, x1963)=true & (\/x1965,x1966,x1967,x1968,x1969:leq(x1964, x1963)=true & length(x1965)=x1963  ==>  U6^1(true, x1966, x1967, x1968, x1969, x1965, x1964)_>=_U7^1(empty(fstsplit(x1964, x1965)), x1966, x1967, x1968, x1969, x1965, x1964)) & (\/x1972,x1973,x1974,x1975,x1976,x1977,x1978,x1979,x1980,x1981,x1982:length(x1970)=s(x1972) & leq(x1973, x1972)=true & (\/x1974,x1975,x1976,x1977,x1978:leq(x1973, x1972)=true & length(x1974)=x1972  ==>  U6^1(true, x1975, x1976, x1977, x1978, x1974, x1973)_>=_U7^1(empty(fstsplit(x1973, x1974)), x1975, x1976, x1977, x1978, x1974, x1973))  ==>  U6^1(true, x1979, x1980, x1981, x1982, x1970, s(x1973))_>=_U7^1(empty(fstsplit(s(x1973), x1970)), x1979, x1980, x1981, x1982, x1970, s(x1973)))  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))



We simplified constraint (7) using rule (VI) where we applied the induction hypothesis (\/x1965,x1966,x1967,x1968,x1969:leq(x1964, x1963)=true & length(x1965)=x1963  ==>  U6^1(true, x1966, x1967, x1968, x1969, x1965, x1964)_>=_U7^1(empty(fstsplit(x1964, x1965)), x1966, x1967, x1968, x1969, x1965, x1964)) with sigma = [x1965 / x1970, x1966 / x872, x1967 / x873, x1968 / x874, x1969 / x875] which results in the following new constraint:

(8)    (U6^1(true, x872, x873, x874, x875, x1970, x1964)_>=_U7^1(empty(fstsplit(x1964, x1970)), x872, x873, x874, x875, x1970, x1964) & (\/x1972,x1973,x1974,x1975,x1976,x1977,x1978,x1979,x1980,x1981,x1982:length(x1970)=s(x1972) & leq(x1973, x1972)=true & (\/x1974,x1975,x1976,x1977,x1978:leq(x1973, x1972)=true & length(x1974)=x1972  ==>  U6^1(true, x1975, x1976, x1977, x1978, x1974, x1973)_>=_U7^1(empty(fstsplit(x1973, x1974)), x1975, x1976, x1977, x1978, x1974, x1973))  ==>  U6^1(true, x1979, x1980, x1981, x1982, x1970, s(x1973))_>=_U7^1(empty(fstsplit(s(x1973), x1970)), x1979, x1980, x1981, x1982, x1970, s(x1973)))  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))



We simplified constraint (8) using rule (IV) which results in the following new constraint:

(9)    (U6^1(true, x872, x873, x874, x875, x1970, x1964)_>=_U7^1(empty(fstsplit(x1964, x1970)), x872, x873, x874, x875, x1970, x1964)  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))








For Pair U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m) the following chains were created:
*We consider the chain U6^1(true, x982, x983, x984, x985, x986, x987) -> U7^1(empty(fstsplit(x987, x986)), x982, x983, x984, x985, x986, x987), U7^1(false, x988, x989, x990, x991, x992, x993) -> RING(x988, x989, x990, x991, sndsplit(x993, x992), x993) which results in the following constraint:

(1)    (U7^1(empty(fstsplit(x987, x986)), x982, x983, x984, x985, x986, x987)=U7^1(false, x988, x989, x990, x991, x992, x993)  ==>  U7^1(false, x988, x989, x990, x991, x992, x993)_>=_RING(x988, x989, x990, x991, sndsplit(x993, x992), x993))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (fstsplit(x987, x986)=x1983 & empty(x1983)=false  ==>  U7^1(false, x982, x983, x984, x985, x986, x987)_>=_RING(x982, x983, x984, x985, sndsplit(x987, x986), x987))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x1983)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x987, x986)=cons(x1985, x1984)  ==>  U7^1(false, x982, x983, x984, x985, x986, x987)_>=_RING(x982, x983, x984, x985, sndsplit(x987, x986), x987))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x987, x986)=cons(x1985, x1984)  ==>  U7^1(false, x982, x983, x984, x985, x986, x987)_>=_RING(x982, x983, x984, x985, sndsplit(x987, x986), x987))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x987, x986)=cons(x1985, x1984) which results in the following new constraint:

(5)    (cons(x1989, fstsplit(x1990, x1988))=cons(x1985, x1984) & (\/x1991,x1992,x1993,x1994,x1995,x1996:fstsplit(x1990, x1988)=cons(x1991, x1992)  ==>  U7^1(false, x1993, x1994, x1995, x1996, x1988, x1990)_>=_RING(x1993, x1994, x1995, x1996, sndsplit(x1990, x1988), x1990))  ==>  U7^1(false, x982, x983, x984, x985, cons(x1989, x1988), s(x1990))_>=_RING(x982, x983, x984, x985, sndsplit(s(x1990), cons(x1989, x1988)), s(x1990)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U7^1(false, x982, x983, x984, x985, cons(x1989, x1988), s(x1990))_>=_RING(x982, x983, x984, x985, sndsplit(s(x1990), cons(x1989, x1988)), s(x1990)))








For Pair U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m) the following chains were created:
*We consider the chain RING(x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141) -> U9^1(empty(map_f(three, x1138)), x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141), U9^1(true, x1142, x1143, x1144, x1145, x1146, x1147) -> RING(x1142, x1143, x1144, tail(x1145), x1146, x1147) which results in the following constraint:

(1)    (U9^1(empty(map_f(three, x1138)), x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141)=U9^1(true, x1142, x1143, x1144, x1145, x1146, x1147)  ==>  U9^1(true, x1142, x1143, x1144, x1145, x1146, x1147)_>=_RING(x1142, x1143, x1144, tail(x1145), x1146, x1147))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (three=x1998 & map_f(x1998, x1138)=x1997 & empty(x1997)=true  ==>  U9^1(true, x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(x1138, x1139)), x1140, x1141))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x1997)=true which results in the following new constraint:

(3)    (true=true & three=x1998 & map_f(x1998, x1138)=nil  ==>  U9^1(true, x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(x1138, x1139)), x1140, x1141))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (three=x1998 & map_f(x1998, x1138)=nil  ==>  U9^1(true, x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(x1138, x1139)), x1140, x1141))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on map_f(x1998, x1138)=nil which results in the following new constraints:

(5)    (nil=nil & three=x2001  ==>  U9^1(true, x1135, x1136, x1137, cons(nil, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(nil, x1139)), x1140, x1141))

(6)    (app(f(x2004, x2003), map_f(x2004, x2002))=nil & three=x2004 & (\/x2005,x2006,x2007,x2008,x2009,x2010:map_f(x2004, x2002)=nil & three=x2004  ==>  U9^1(true, x2005, x2006, x2007, cons(x2002, x2008), x2009, x2010)_>=_RING(x2005, x2006, x2007, tail(cons(x2002, x2008)), x2009, x2010))  ==>  U9^1(true, x1135, x1136, x1137, cons(cons(x2003, x2002), x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(cons(x2003, x2002), x1139)), x1140, x1141))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(7)    (U9^1(true, x1135, x1136, x1137, cons(nil, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(nil, x1139)), x1140, x1141))



We simplified constraint (6) using rules (IV), (VII) which results in the following new constraint:

(8)    (f(x2004, x2003)=x2011 & map_f(x2004, x2002)=x2012 & app(x2011, x2012)=nil & three=x2004  ==>  U9^1(true, x1135, x1136, x1137, cons(cons(x2003, x2002), x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(cons(x2003, x2002), x1139)), x1140, x1141))



We simplified constraint (8) using rule (V) (with possible (I) afterwards) using induction on app(x2011, x2012)=nil which results in the following new constraint:

(9)    (x2013=nil & f(x2004, x2003)=nil & map_f(x2004, x2002)=x2013 & three=x2004  ==>  U9^1(true, x1135, x1136, x1137, cons(cons(x2003, x2002), x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(cons(x2003, x2002), x1139)), x1140, x1141))



We solved constraint (9) using rules (I), (II).




For Pair U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x1184, x1185, x1186, x1187, x1188, x1189) -> U6^1(leq(x1189, length(x1188)), x1184, x1185, x1186, x1187, x1188, x1189), U6^1(false, x1190, x1191, x1192, x1193, x1194, x1195) -> U8^1(empty(fstsplit(x1195, app(map_f(three, head(x1193)), x1194))), x1190, x1191, x1192, x1193, x1194, x1195) which results in the following constraint:

(1)    (U6^1(leq(x1189, length(x1188)), x1184, x1185, x1186, x1187, x1188, x1189)=U6^1(false, x1190, x1191, x1192, x1193, x1194, x1195)  ==>  U6^1(false, x1190, x1191, x1192, x1193, x1194, x1195)_>=_U8^1(empty(fstsplit(x1195, app(map_f(three, head(x1193)), x1194))), x1190, x1191, x1192, x1193, x1194, x1195))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x1188)=x2017 & leq(x1189, x2017)=false  ==>  U6^1(false, x1184, x1185, x1186, x1187, x1188, x1189)_>=_U8^1(empty(fstsplit(x1189, app(map_f(three, head(x1187)), x1188))), x1184, x1185, x1186, x1187, x1188, x1189))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x1189, x2017)=false which results in the following new constraints:

(3)    (false=false & length(x1188)=0  ==>  U6^1(false, x1184, x1185, x1186, x1187, x1188, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), x1188))), x1184, x1185, x1186, x1187, x1188, s(x2019)))

(4)    (leq(x2021, x2020)=false & length(x1188)=s(x2020) & (\/x2022,x2023,x2024,x2025,x2026:leq(x2021, x2020)=false & length(x2022)=x2020  ==>  U6^1(false, x2023, x2024, x2025, x2026, x2022, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x2026)), x2022))), x2023, x2024, x2025, x2026, x2022, x2021))  ==>  U6^1(false, x1184, x1185, x1186, x1187, x1188, s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), x1188))), x1184, x1185, x1186, x1187, x1188, s(x2021)))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (length(x1188)=0  ==>  U6^1(false, x1184, x1185, x1186, x1187, x1188, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), x1188))), x1184, x1185, x1186, x1187, x1188, s(x2019)))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x1188)=s(x2020) which results in the following new constraint:

(6)    (s(length(x2029))=s(x2020) & leq(x2021, x2020)=false & (\/x2022,x2023,x2024,x2025,x2026:leq(x2021, x2020)=false & length(x2022)=x2020  ==>  U6^1(false, x2023, x2024, x2025, x2026, x2022, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x2026)), x2022))), x2023, x2024, x2025, x2026, x2022, x2021)) & (\/x2031,x2032,x2033,x2034,x2035,x2036,x2037,x2038,x2039,x2040,x2041:length(x2029)=s(x2031) & leq(x2032, x2031)=false & (\/x2033,x2034,x2035,x2036,x2037:leq(x2032, x2031)=false & length(x2033)=x2031  ==>  U6^1(false, x2034, x2035, x2036, x2037, x2033, x2032)_>=_U8^1(empty(fstsplit(x2032, app(map_f(three, head(x2037)), x2033))), x2034, x2035, x2036, x2037, x2033, x2032))  ==>  U6^1(false, x2038, x2039, x2040, x2041, x2029, s(x2032))_>=_U8^1(empty(fstsplit(s(x2032), app(map_f(three, head(x2041)), x2029))), x2038, x2039, x2040, x2041, x2029, s(x2032)))  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))



We simplified constraint (5) using rule (V) (with possible (I) afterwards) using induction on length(x1188)=0 which results in the following new constraint:

(7)    (0=0  ==>  U6^1(false, x1184, x1185, x1186, x1187, nil, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), nil))), x1184, x1185, x1186, x1187, nil, s(x2019)))



We simplified constraint (7) using rules (I), (II) which results in the following new constraint:

(8)    (U6^1(false, x1184, x1185, x1186, x1187, nil, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), nil))), x1184, x1185, x1186, x1187, nil, s(x2019)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(9)    (length(x2029)=x2020 & leq(x2021, x2020)=false & (\/x2022,x2023,x2024,x2025,x2026:leq(x2021, x2020)=false & length(x2022)=x2020  ==>  U6^1(false, x2023, x2024, x2025, x2026, x2022, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x2026)), x2022))), x2023, x2024, x2025, x2026, x2022, x2021)) & (\/x2031,x2032,x2033,x2034,x2035,x2036,x2037,x2038,x2039,x2040,x2041:length(x2029)=s(x2031) & leq(x2032, x2031)=false & (\/x2033,x2034,x2035,x2036,x2037:leq(x2032, x2031)=false & length(x2033)=x2031  ==>  U6^1(false, x2034, x2035, x2036, x2037, x2033, x2032)_>=_U8^1(empty(fstsplit(x2032, app(map_f(three, head(x2037)), x2033))), x2034, x2035, x2036, x2037, x2033, x2032))  ==>  U6^1(false, x2038, x2039, x2040, x2041, x2029, s(x2032))_>=_U8^1(empty(fstsplit(s(x2032), app(map_f(three, head(x2041)), x2029))), x2038, x2039, x2040, x2041, x2029, s(x2032)))  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))



We simplified constraint (9) using rule (VI) where we applied the induction hypothesis (\/x2022,x2023,x2024,x2025,x2026:leq(x2021, x2020)=false & length(x2022)=x2020  ==>  U6^1(false, x2023, x2024, x2025, x2026, x2022, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x2026)), x2022))), x2023, x2024, x2025, x2026, x2022, x2021)) with sigma = [x2022 / x2029, x2023 / x1184, x2024 / x1185, x2025 / x1186, x2026 / x1187] which results in the following new constraint:

(10)    (U6^1(false, x1184, x1185, x1186, x1187, x2029, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x1187)), x2029))), x1184, x1185, x1186, x1187, x2029, x2021) & (\/x2031,x2032,x2033,x2034,x2035,x2036,x2037,x2038,x2039,x2040,x2041:length(x2029)=s(x2031) & leq(x2032, x2031)=false & (\/x2033,x2034,x2035,x2036,x2037:leq(x2032, x2031)=false & length(x2033)=x2031  ==>  U6^1(false, x2034, x2035, x2036, x2037, x2033, x2032)_>=_U8^1(empty(fstsplit(x2032, app(map_f(three, head(x2037)), x2033))), x2034, x2035, x2036, x2037, x2033, x2032))  ==>  U6^1(false, x2038, x2039, x2040, x2041, x2029, s(x2032))_>=_U8^1(empty(fstsplit(s(x2032), app(map_f(three, head(x2041)), x2029))), x2038, x2039, x2040, x2041, x2029, s(x2032)))  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))



We simplified constraint (10) using rule (IV) which results in the following new constraint:

(11)    (U6^1(false, x1184, x1185, x1186, x1187, x2029, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x1187)), x2029))), x1184, x1185, x1186, x1187, x2029, x2021)  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))








For Pair U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m) the following chains were created:
*We consider the chain U6^1(false, x1312, x1313, x1314, x1315, x1316, x1317) -> U8^1(empty(fstsplit(x1317, app(map_f(three, head(x1315)), x1316))), x1312, x1313, x1314, x1315, x1316, x1317), U8^1(false, x1318, x1319, x1320, x1321, x1322, x1323) -> RING(x1318, x1319, x1320, tail(x1321), sndsplit(x1323, app(map_f(three, head(x1321)), x1322)), x1323) which results in the following constraint:

(1)    (U8^1(empty(fstsplit(x1317, app(map_f(three, head(x1315)), x1316))), x1312, x1313, x1314, x1315, x1316, x1317)=U8^1(false, x1318, x1319, x1320, x1321, x1322, x1323)  ==>  U8^1(false, x1318, x1319, x1320, x1321, x1322, x1323)_>=_RING(x1318, x1319, x1320, tail(x1321), sndsplit(x1323, app(map_f(three, head(x1321)), x1322)), x1323))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (fstsplit(x1317, x2043)=x2042 & empty(x2042)=false  ==>  U8^1(false, x1312, x1313, x1314, x1315, x1316, x1317)_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(x1317, app(map_f(three, head(x1315)), x1316)), x1317))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x2042)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x1317, x2043)=cons(x2048, x2047)  ==>  U8^1(false, x1312, x1313, x1314, x1315, x1316, x1317)_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(x1317, app(map_f(three, head(x1315)), x1316)), x1317))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x1317, x2043)=cons(x2048, x2047)  ==>  U8^1(false, x1312, x1313, x1314, x1315, x1316, x1317)_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(x1317, app(map_f(three, head(x1315)), x1316)), x1317))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x1317, x2043)=cons(x2048, x2047) which results in the following new constraint:

(5)    (cons(x2052, fstsplit(x2053, x2051))=cons(x2048, x2047) & (\/x2054,x2055,x2056,x2057,x2058,x2059,x2060:fstsplit(x2053, x2051)=cons(x2054, x2055)  ==>  U8^1(false, x2056, x2057, x2058, x2059, x2060, x2053)_>=_RING(x2056, x2057, x2058, tail(x2059), sndsplit(x2053, app(map_f(three, head(x2059)), x2060)), x2053))  ==>  U8^1(false, x1312, x1313, x1314, x1315, x1316, s(x2053))_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(s(x2053), app(map_f(three, head(x1315)), x1316)), s(x2053)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U8^1(false, x1312, x1313, x1314, x1315, x1316, s(x2053))_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(s(x2053), app(map_f(three, head(x1315)), x1316)), s(x2053)))








For Pair U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x1368, x1369, x1370, x1371, x1372, x1373) -> U2^1(leq(x1373, length(x1370)), x1368, x1369, x1370, x1371, x1372, x1373), U2^1(true, x1374, x1375, x1376, x1377, x1378, x1379) -> U3^1(empty(fstsplit(x1379, x1376)), x1374, x1375, x1376, x1377, x1378, x1379) which results in the following constraint:

(1)    (U2^1(leq(x1373, length(x1370)), x1368, x1369, x1370, x1371, x1372, x1373)=U2^1(true, x1374, x1375, x1376, x1377, x1378, x1379)  ==>  U2^1(true, x1374, x1375, x1376, x1377, x1378, x1379)_>=_U3^1(empty(fstsplit(x1379, x1376)), x1374, x1375, x1376, x1377, x1378, x1379))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x1370)=x2061 & leq(x1373, x2061)=true  ==>  U2^1(true, x1368, x1369, x1370, x1371, x1372, x1373)_>=_U3^1(empty(fstsplit(x1373, x1370)), x1368, x1369, x1370, x1371, x1372, x1373))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x1373, x2061)=true which results in the following new constraints:

(3)    (true=true & length(x1370)=x2062  ==>  U2^1(true, x1368, x1369, x1370, x1371, x1372, 0)_>=_U3^1(empty(fstsplit(0, x1370)), x1368, x1369, x1370, x1371, x1372, 0))

(4)    (leq(x2065, x2064)=true & length(x1370)=s(x2064) & (\/x2066,x2067,x2068,x2069,x2070:leq(x2065, x2064)=true & length(x2066)=x2064  ==>  U2^1(true, x2067, x2068, x2066, x2069, x2070, x2065)_>=_U3^1(empty(fstsplit(x2065, x2066)), x2067, x2068, x2066, x2069, x2070, x2065))  ==>  U2^1(true, x1368, x1369, x1370, x1371, x1372, s(x2065))_>=_U3^1(empty(fstsplit(s(x2065), x1370)), x1368, x1369, x1370, x1371, x1372, s(x2065)))



We simplified constraint (3) using rules (I), (II), (IV) which results in the following new constraint:

(5)    (U2^1(true, x1368, x1369, x1370, x1371, x1372, 0)_>=_U3^1(empty(fstsplit(0, x1370)), x1368, x1369, x1370, x1371, x1372, 0))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x1370)=s(x2064) which results in the following new constraint:

(6)    (s(length(x2071))=s(x2064) & leq(x2065, x2064)=true & (\/x2066,x2067,x2068,x2069,x2070:leq(x2065, x2064)=true & length(x2066)=x2064  ==>  U2^1(true, x2067, x2068, x2066, x2069, x2070, x2065)_>=_U3^1(empty(fstsplit(x2065, x2066)), x2067, x2068, x2066, x2069, x2070, x2065)) & (\/x2073,x2074,x2075,x2076,x2077,x2078,x2079,x2080,x2081,x2082,x2083:length(x2071)=s(x2073) & leq(x2074, x2073)=true & (\/x2075,x2076,x2077,x2078,x2079:leq(x2074, x2073)=true & length(x2075)=x2073  ==>  U2^1(true, x2076, x2077, x2075, x2078, x2079, x2074)_>=_U3^1(empty(fstsplit(x2074, x2075)), x2076, x2077, x2075, x2078, x2079, x2074))  ==>  U2^1(true, x2080, x2081, x2071, x2082, x2083, s(x2074))_>=_U3^1(empty(fstsplit(s(x2074), x2071)), x2080, x2081, x2071, x2082, x2083, s(x2074)))  ==>  U2^1(true, x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065))_>=_U3^1(empty(fstsplit(s(x2065), cons(x2072, x2071))), x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(7)    (length(x2071)=x2064 & leq(x2065, x2064)=true & (\/x2066,x2067,x2068,x2069,x2070:leq(x2065, x2064)=true & length(x2066)=x2064  ==>  U2^1(true, x2067, x2068, x2066, x2069, x2070, x2065)_>=_U3^1(empty(fstsplit(x2065, x2066)), x2067, x2068, x2066, x2069, x2070, x2065)) & (\/x2073,x2074,x2075,x2076,x2077,x2078,x2079,x2080,x2081,x2082,x2083:length(x2071)=s(x2073) & leq(x2074, x2073)=true & (\/x2075,x2076,x2077,x2078,x2079:leq(x2074, x2073)=true & length(x2075)=x2073  ==>  U2^1(true, x2076, x2077, x2075, x2078, x2079, x2074)_>=_U3^1(empty(fstsplit(x2074, x2075)), x2076, x2077, x2075, x2078, x2079, x2074))  ==>  U2^1(true, x2080, x2081, x2071, x2082, x2083, s(x2074))_>=_U3^1(empty(fstsplit(s(x2074), x2071)), x2080, x2081, x2071, x2082, x2083, s(x2074)))  ==>  U2^1(true, x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065))_>=_U3^1(empty(fstsplit(s(x2065), cons(x2072, x2071))), x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065)))



We simplified constraint (7) using rule (VI) where we applied the induction hypothesis (\/x2066,x2067,x2068,x2069,x2070:leq(x2065, x2064)=true & length(x2066)=x2064  ==>  U2^1(true, x2067, x2068, x2066, x2069, x2070, x2065)_>=_U3^1(empty(fstsplit(x2065, x2066)), x2067, x2068, x2066, x2069, x2070, x2065)) with sigma = [x2066 / x2071, x2067 / x1368, x2068 / x1369, x2069 / x1371, x2070 / x1372] which results in the following new constraint:

(8)    (U2^1(true, x1368, x1369, x2071, x1371, x1372, x2065)_>=_U3^1(empty(fstsplit(x2065, x2071)), x1368, x1369, x2071, x1371, x1372, x2065) & (\/x2073,x2074,x2075,x2076,x2077,x2078,x2079,x2080,x2081,x2082,x2083:length(x2071)=s(x2073) & leq(x2074, x2073)=true & (\/x2075,x2076,x2077,x2078,x2079:leq(x2074, x2073)=true & length(x2075)=x2073  ==>  U2^1(true, x2076, x2077, x2075, x2078, x2079, x2074)_>=_U3^1(empty(fstsplit(x2074, x2075)), x2076, x2077, x2075, x2078, x2079, x2074))  ==>  U2^1(true, x2080, x2081, x2071, x2082, x2083, s(x2074))_>=_U3^1(empty(fstsplit(s(x2074), x2071)), x2080, x2081, x2071, x2082, x2083, s(x2074)))  ==>  U2^1(true, x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065))_>=_U3^1(empty(fstsplit(s(x2065), cons(x2072, x2071))), x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065)))



We simplified constraint (8) using rule (IV) which results in the following new constraint:

(9)    (U2^1(true, x1368, x1369, x2071, x1371, x1372, x2065)_>=_U3^1(empty(fstsplit(x2065, x2071)), x1368, x1369, x2071, x1371, x1372, x2065)  ==>  U2^1(true, x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065))_>=_U3^1(empty(fstsplit(s(x2065), cons(x2072, x2071))), x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065)))








For Pair U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m) the following chains were created:
*We consider the chain U2^1(true, x1532, x1533, x1534, x1535, x1536, x1537) -> U3^1(empty(fstsplit(x1537, x1534)), x1532, x1533, x1534, x1535, x1536, x1537), U3^1(false, x1538, x1539, x1540, x1541, x1542, x1543) -> RING(x1538, x1539, sndsplit(x1543, x1540), cons(fstsplit(x1543, x1540), x1541), x1542, x1543) which results in the following constraint:

(1)    (U3^1(empty(fstsplit(x1537, x1534)), x1532, x1533, x1534, x1535, x1536, x1537)=U3^1(false, x1538, x1539, x1540, x1541, x1542, x1543)  ==>  U3^1(false, x1538, x1539, x1540, x1541, x1542, x1543)_>=_RING(x1538, x1539, sndsplit(x1543, x1540), cons(fstsplit(x1543, x1540), x1541), x1542, x1543))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (fstsplit(x1537, x1534)=x2084 & empty(x2084)=false  ==>  U3^1(false, x1532, x1533, x1534, x1535, x1536, x1537)_>=_RING(x1532, x1533, sndsplit(x1537, x1534), cons(fstsplit(x1537, x1534), x1535), x1536, x1537))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x2084)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x1537, x1534)=cons(x2086, x2085)  ==>  U3^1(false, x1532, x1533, x1534, x1535, x1536, x1537)_>=_RING(x1532, x1533, sndsplit(x1537, x1534), cons(fstsplit(x1537, x1534), x1535), x1536, x1537))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x1537, x1534)=cons(x2086, x2085)  ==>  U3^1(false, x1532, x1533, x1534, x1535, x1536, x1537)_>=_RING(x1532, x1533, sndsplit(x1537, x1534), cons(fstsplit(x1537, x1534), x1535), x1536, x1537))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x1537, x1534)=cons(x2086, x2085) which results in the following new constraint:

(5)    (cons(x2090, fstsplit(x2091, x2089))=cons(x2086, x2085) & (\/x2092,x2093,x2094,x2095,x2096,x2097:fstsplit(x2091, x2089)=cons(x2092, x2093)  ==>  U3^1(false, x2094, x2095, x2089, x2096, x2097, x2091)_>=_RING(x2094, x2095, sndsplit(x2091, x2089), cons(fstsplit(x2091, x2089), x2096), x2097, x2091))  ==>  U3^1(false, x1532, x1533, cons(x2090, x2089), x1535, x1536, s(x2091))_>=_RING(x1532, x1533, sndsplit(s(x2091), cons(x2090, x2089)), cons(fstsplit(s(x2091), cons(x2090, x2089)), x1535), x1536, s(x2091)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U3^1(false, x1532, x1533, cons(x2090, x2089), x1535, x1536, s(x2091))_>=_RING(x1532, x1533, sndsplit(s(x2091), cons(x2090, x2089)), cons(fstsplit(s(x2091), cons(x2090, x2089)), x1535), x1536, s(x2091)))








For Pair RING(y0, cons(x0, x1), y2, y3, y4, y5) -> U5^1(empty(map_f(two, x0)), y0, cons(x0, x1), y2, y3, y4, y5) the following chains were created:
*We consider the chain U1^1(false, x1564, x1565, x1566, x1567, x1568, x1569) -> RING(sndsplit(x1569, x1564), cons(fstsplit(x1569, x1564), x1565), x1566, x1567, x1568, x1569), RING(x1570, cons(x1571, x1572), x1573, x1574, x1575, x1576) -> U5^1(empty(map_f(two, x1571)), x1570, cons(x1571, x1572), x1573, x1574, x1575, x1576) which results in the following constraint:

(1)    (RING(sndsplit(x1569, x1564), cons(fstsplit(x1569, x1564), x1565), x1566, x1567, x1568, x1569)=RING(x1570, cons(x1571, x1572), x1573, x1574, x1575, x1576)  ==>  RING(x1570, cons(x1571, x1572), x1573, x1574, x1575, x1576)_>=_U5^1(empty(map_f(two, x1571)), x1570, cons(x1571, x1572), x1573, x1574, x1575, x1576))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x1570, cons(x1571, x1565), x1566, x1567, x1568, x1569)_>=_U5^1(empty(map_f(two, x1571)), x1570, cons(x1571, x1565), x1566, x1567, x1568, x1569))




*We consider the chain U4^1(false, x1595, x1596, x1597, x1598, x1599, x1600) -> RING(x1595, tail(x1596), sndsplit(x1600, app(map_f(two, head(x1596)), x1597)), cons(fstsplit(x1600, app(map_f(two, head(x1596)), x1597)), x1598), x1599, x1600), RING(x1601, cons(x1602, x1603), x1604, x1605, x1606, x1607) -> U5^1(empty(map_f(two, x1602)), x1601, cons(x1602, x1603), x1604, x1605, x1606, x1607) which results in the following constraint:

(1)    (RING(x1595, tail(x1596), sndsplit(x1600, app(map_f(two, head(x1596)), x1597)), cons(fstsplit(x1600, app(map_f(two, head(x1596)), x1597)), x1598), x1599, x1600)=RING(x1601, cons(x1602, x1603), x1604, x1605, x1606, x1607)  ==>  RING(x1601, cons(x1602, x1603), x1604, x1605, x1606, x1607)_>=_U5^1(empty(map_f(two, x1602)), x1601, cons(x1602, x1603), x1604, x1605, x1606, x1607))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (tail(x1596)=cons(x1602, x1603) & app(x2099, x1597)=x2098 & sndsplit(x1600, x2098)=x1604 & cons(fstsplit(x1600, app(map_f(two, head(x1596)), x1597)), x1598)=x1605  ==>  RING(x1595, cons(x1602, x1603), x1604, x1605, x1599, x1600)_>=_U5^1(empty(map_f(two, x1602)), x1595, cons(x1602, x1603), x1604, x1605, x1599, x1600))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on tail(x1596)=cons(x1602, x1603) which results in the following new constraint:

(3)    (x2102=cons(x1602, x1603) & app(x2099, x1597)=x2098 & sndsplit(x1600, x2098)=x1604 & cons(fstsplit(x1600, app(map_f(two, head(cons(x2103, x2102))), x1597)), x1598)=x1605  ==>  RING(x1595, cons(x1602, x1603), x1604, x1605, x1599, x1600)_>=_U5^1(empty(map_f(two, x1602)), x1595, cons(x1602, x1603), x1604, x1605, x1599, x1600))



We simplified constraint (3) using rules (III), (IV) which results in the following new constraint:

(4)    (RING(x1595, cons(x1602, x1603), x1604, x1605, x1599, x1600)_>=_U5^1(empty(map_f(two, x1602)), x1595, cons(x1602, x1603), x1604, x1605, x1599, x1600))




*We consider the chain U5^1(true, x1608, x1609, x1610, x1611, x1612, x1613) -> RING(x1608, tail(x1609), x1610, x1611, x1612, x1613), RING(x1614, cons(x1615, x1616), x1617, x1618, x1619, x1620) -> U5^1(empty(map_f(two, x1615)), x1614, cons(x1615, x1616), x1617, x1618, x1619, x1620) which results in the following constraint:

(1)    (RING(x1608, tail(x1609), x1610, x1611, x1612, x1613)=RING(x1614, cons(x1615, x1616), x1617, x1618, x1619, x1620)  ==>  RING(x1614, cons(x1615, x1616), x1617, x1618, x1619, x1620)_>=_U5^1(empty(map_f(two, x1615)), x1614, cons(x1615, x1616), x1617, x1618, x1619, x1620))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (tail(x1609)=cons(x1615, x1616)  ==>  RING(x1608, cons(x1615, x1616), x1610, x1611, x1612, x1613)_>=_U5^1(empty(map_f(two, x1615)), x1608, cons(x1615, x1616), x1610, x1611, x1612, x1613))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on tail(x1609)=cons(x1615, x1616) which results in the following new constraint:

(3)    (x2104=cons(x1615, x1616)  ==>  RING(x1608, cons(x1615, x1616), x1610, x1611, x1612, x1613)_>=_U5^1(empty(map_f(two, x1615)), x1608, cons(x1615, x1616), x1610, x1611, x1612, x1613))



We simplified constraint (3) using rule (III) which results in the following new constraint:

(4)    (RING(x1608, cons(x1615, x1616), x1610, x1611, x1612, x1613)_>=_U5^1(empty(map_f(two, x1615)), x1608, cons(x1615, x1616), x1610, x1611, x1612, x1613))




*We consider the chain U7^1(false, x1633, x1634, x1635, x1636, x1637, x1638) -> RING(x1633, x1634, x1635, x1636, sndsplit(x1638, x1637), x1638), RING(x1639, cons(x1640, x1641), x1642, x1643, x1644, x1645) -> U5^1(empty(map_f(two, x1640)), x1639, cons(x1640, x1641), x1642, x1643, x1644, x1645) which results in the following constraint:

(1)    (RING(x1633, x1634, x1635, x1636, sndsplit(x1638, x1637), x1638)=RING(x1639, cons(x1640, x1641), x1642, x1643, x1644, x1645)  ==>  RING(x1639, cons(x1640, x1641), x1642, x1643, x1644, x1645)_>=_U5^1(empty(map_f(two, x1640)), x1639, cons(x1640, x1641), x1642, x1643, x1644, x1645))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x1633, cons(x1640, x1641), x1635, x1636, x1644, x1638)_>=_U5^1(empty(map_f(two, x1640)), x1633, cons(x1640, x1641), x1635, x1636, x1644, x1638))




*We consider the chain U9^1(true, x1646, x1647, x1648, x1649, x1650, x1651) -> RING(x1646, x1647, x1648, tail(x1649), x1650, x1651), RING(x1652, cons(x1653, x1654), x1655, x1656, x1657, x1658) -> U5^1(empty(map_f(two, x1653)), x1652, cons(x1653, x1654), x1655, x1656, x1657, x1658) which results in the following constraint:

(1)    (RING(x1646, x1647, x1648, tail(x1649), x1650, x1651)=RING(x1652, cons(x1653, x1654), x1655, x1656, x1657, x1658)  ==>  RING(x1652, cons(x1653, x1654), x1655, x1656, x1657, x1658)_>=_U5^1(empty(map_f(two, x1653)), x1652, cons(x1653, x1654), x1655, x1656, x1657, x1658))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x1646, cons(x1653, x1654), x1648, x1656, x1650, x1651)_>=_U5^1(empty(map_f(two, x1653)), x1646, cons(x1653, x1654), x1648, x1656, x1650, x1651))




*We consider the chain U8^1(false, x1665, x1666, x1667, x1668, x1669, x1670) -> RING(x1665, x1666, x1667, tail(x1668), sndsplit(x1670, app(map_f(three, head(x1668)), x1669)), x1670), RING(x1671, cons(x1672, x1673), x1674, x1675, x1676, x1677) -> U5^1(empty(map_f(two, x1672)), x1671, cons(x1672, x1673), x1674, x1675, x1676, x1677) which results in the following constraint:

(1)    (RING(x1665, x1666, x1667, tail(x1668), sndsplit(x1670, app(map_f(three, head(x1668)), x1669)), x1670)=RING(x1671, cons(x1672, x1673), x1674, x1675, x1676, x1677)  ==>  RING(x1671, cons(x1672, x1673), x1674, x1675, x1676, x1677)_>=_U5^1(empty(map_f(two, x1672)), x1671, cons(x1672, x1673), x1674, x1675, x1676, x1677))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x1665, cons(x1672, x1673), x1667, x1675, x1676, x1670)_>=_U5^1(empty(map_f(two, x1672)), x1665, cons(x1672, x1673), x1667, x1675, x1676, x1670))




*We consider the chain U3^1(false, x1684, x1685, x1686, x1687, x1688, x1689) -> RING(x1684, x1685, sndsplit(x1689, x1686), cons(fstsplit(x1689, x1686), x1687), x1688, x1689), RING(x1690, cons(x1691, x1692), x1693, x1694, x1695, x1696) -> U5^1(empty(map_f(two, x1691)), x1690, cons(x1691, x1692), x1693, x1694, x1695, x1696) which results in the following constraint:

(1)    (RING(x1684, x1685, sndsplit(x1689, x1686), cons(fstsplit(x1689, x1686), x1687), x1688, x1689)=RING(x1690, cons(x1691, x1692), x1693, x1694, x1695, x1696)  ==>  RING(x1690, cons(x1691, x1692), x1693, x1694, x1695, x1696)_>=_U5^1(empty(map_f(two, x1691)), x1690, cons(x1691, x1692), x1693, x1694, x1695, x1696))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x1684, cons(x1691, x1692), x1693, x1694, x1688, x1689)_>=_U5^1(empty(map_f(two, x1691)), x1684, cons(x1691, x1692), x1693, x1694, x1688, x1689))








For Pair RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5) the following chains were created:
*We consider the chain U1^1(false, x1711, x1712, x1713, x1714, x1715, x1716) -> RING(sndsplit(x1716, x1711), cons(fstsplit(x1716, x1711), x1712), x1713, x1714, x1715, x1716), RING(x1717, x1718, x1719, cons(x1720, x1721), x1722, x1723) -> U9^1(empty(map_f(three, x1720)), x1717, x1718, x1719, cons(x1720, x1721), x1722, x1723) which results in the following constraint:

(1)    (RING(sndsplit(x1716, x1711), cons(fstsplit(x1716, x1711), x1712), x1713, x1714, x1715, x1716)=RING(x1717, x1718, x1719, cons(x1720, x1721), x1722, x1723)  ==>  RING(x1717, x1718, x1719, cons(x1720, x1721), x1722, x1723)_>=_U9^1(empty(map_f(three, x1720)), x1717, x1718, x1719, cons(x1720, x1721), x1722, x1723))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x1717, x1718, x1713, cons(x1720, x1721), x1715, x1716)_>=_U9^1(empty(map_f(three, x1720)), x1717, x1718, x1713, cons(x1720, x1721), x1715, x1716))




*We consider the chain U4^1(false, x1742, x1743, x1744, x1745, x1746, x1747) -> RING(x1742, tail(x1743), sndsplit(x1747, app(map_f(two, head(x1743)), x1744)), cons(fstsplit(x1747, app(map_f(two, head(x1743)), x1744)), x1745), x1746, x1747), RING(x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754) -> U9^1(empty(map_f(three, x1751)), x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754) which results in the following constraint:

(1)    (RING(x1742, tail(x1743), sndsplit(x1747, app(map_f(two, head(x1743)), x1744)), cons(fstsplit(x1747, app(map_f(two, head(x1743)), x1744)), x1745), x1746, x1747)=RING(x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754)  ==>  RING(x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754)_>=_U9^1(empty(map_f(three, x1751)), x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x1742, x1749, x1750, cons(x1751, x1745), x1746, x1747)_>=_U9^1(empty(map_f(three, x1751)), x1742, x1749, x1750, cons(x1751, x1745), x1746, x1747))




*We consider the chain U5^1(true, x1755, x1756, x1757, x1758, x1759, x1760) -> RING(x1755, tail(x1756), x1757, x1758, x1759, x1760), RING(x1761, x1762, x1763, cons(x1764, x1765), x1766, x1767) -> U9^1(empty(map_f(three, x1764)), x1761, x1762, x1763, cons(x1764, x1765), x1766, x1767) which results in the following constraint:

(1)    (RING(x1755, tail(x1756), x1757, x1758, x1759, x1760)=RING(x1761, x1762, x1763, cons(x1764, x1765), x1766, x1767)  ==>  RING(x1761, x1762, x1763, cons(x1764, x1765), x1766, x1767)_>=_U9^1(empty(map_f(three, x1764)), x1761, x1762, x1763, cons(x1764, x1765), x1766, x1767))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x1755, x1762, x1757, cons(x1764, x1765), x1759, x1760)_>=_U9^1(empty(map_f(three, x1764)), x1755, x1762, x1757, cons(x1764, x1765), x1759, x1760))




*We consider the chain U7^1(false, x1780, x1781, x1782, x1783, x1784, x1785) -> RING(x1780, x1781, x1782, x1783, sndsplit(x1785, x1784), x1785), RING(x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792) -> U9^1(empty(map_f(three, x1789)), x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792) which results in the following constraint:

(1)    (RING(x1780, x1781, x1782, x1783, sndsplit(x1785, x1784), x1785)=RING(x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792)  ==>  RING(x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792)_>=_U9^1(empty(map_f(three, x1789)), x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x1780, x1781, x1782, cons(x1789, x1790), x1791, x1785)_>=_U9^1(empty(map_f(three, x1789)), x1780, x1781, x1782, cons(x1789, x1790), x1791, x1785))




*We consider the chain U9^1(true, x1793, x1794, x1795, x1796, x1797, x1798) -> RING(x1793, x1794, x1795, tail(x1796), x1797, x1798), RING(x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805) -> U9^1(empty(map_f(three, x1802)), x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805) which results in the following constraint:

(1)    (RING(x1793, x1794, x1795, tail(x1796), x1797, x1798)=RING(x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805)  ==>  RING(x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805)_>=_U9^1(empty(map_f(three, x1802)), x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (tail(x1796)=cons(x1802, x1803)  ==>  RING(x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798)_>=_U9^1(empty(map_f(three, x1802)), x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on tail(x1796)=cons(x1802, x1803) which results in the following new constraint:

(3)    (x2118=cons(x1802, x1803)  ==>  RING(x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798)_>=_U9^1(empty(map_f(three, x1802)), x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798))



We simplified constraint (3) using rule (III) which results in the following new constraint:

(4)    (RING(x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798)_>=_U9^1(empty(map_f(three, x1802)), x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798))




*We consider the chain U8^1(false, x1812, x1813, x1814, x1815, x1816, x1817) -> RING(x1812, x1813, x1814, tail(x1815), sndsplit(x1817, app(map_f(three, head(x1815)), x1816)), x1817), RING(x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824) -> U9^1(empty(map_f(three, x1821)), x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824) which results in the following constraint:

(1)    (RING(x1812, x1813, x1814, tail(x1815), sndsplit(x1817, app(map_f(three, head(x1815)), x1816)), x1817)=RING(x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824)  ==>  RING(x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824)_>=_U9^1(empty(map_f(three, x1821)), x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (tail(x1815)=cons(x1821, x1822) & app(x2121, x1816)=x2120 & sndsplit(x1817, x2120)=x1823  ==>  RING(x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817)_>=_U9^1(empty(map_f(three, x1821)), x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on tail(x1815)=cons(x1821, x1822) which results in the following new constraint:

(3)    (x2124=cons(x1821, x1822) & app(x2121, x1816)=x2120 & sndsplit(x1817, x2120)=x1823  ==>  RING(x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817)_>=_U9^1(empty(map_f(three, x1821)), x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817))



We simplified constraint (3) using rules (III), (IV) which results in the following new constraint:

(4)    (RING(x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817)_>=_U9^1(empty(map_f(three, x1821)), x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817))




*We consider the chain U3^1(false, x1831, x1832, x1833, x1834, x1835, x1836) -> RING(x1831, x1832, sndsplit(x1836, x1833), cons(fstsplit(x1836, x1833), x1834), x1835, x1836), RING(x1837, x1838, x1839, cons(x1840, x1841), x1842, x1843) -> U9^1(empty(map_f(three, x1840)), x1837, x1838, x1839, cons(x1840, x1841), x1842, x1843) which results in the following constraint:

(1)    (RING(x1831, x1832, sndsplit(x1836, x1833), cons(fstsplit(x1836, x1833), x1834), x1835, x1836)=RING(x1837, x1838, x1839, cons(x1840, x1841), x1842, x1843)  ==>  RING(x1837, x1838, x1839, cons(x1840, x1841), x1842, x1843)_>=_U9^1(empty(map_f(three, x1840)), x1837, x1838, x1839, cons(x1840, x1841), x1842, x1843))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x1831, x1832, x1839, cons(x1840, x1834), x1835, x1836)_>=_U9^1(empty(map_f(three, x1840)), x1831, x1832, x1839, cons(x1840, x1834), x1835, x1836))








To summarize, we get the following constraints P__>=_ for the following pairs.

*U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)

*(U1^1(false, cons(x1864, x1863), x7, x8, x9, x10, s(x1865))_>=_RING(sndsplit(s(x1865), cons(x1864, x1863)), cons(fstsplit(s(x1865), cons(x1864, x1863)), x7), x8, x9, x10, s(x1865)))




*RING(st_1, in_2, st_2, in_3, st_3, m) -> U1^1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)

*(RING(x110, x111, x106, x107, x108, x109)_>=_U1^1(empty(fstsplit(x109, x110)), x110, x111, x106, x107, x108, x109))


*(RING(x134, x141, x142, x143, x138, x139)_>=_U1^1(empty(fstsplit(x139, x134)), x134, x141, x142, x143, x138, x139))


*(RING(x146, x153, x148, x149, x150, x151)_>=_U1^1(empty(fstsplit(x151, x146)), x146, x153, x148, x149, x150, x151))


*(RING(x170, x171, x172, x173, x180, x175)_>=_U1^1(empty(fstsplit(x175, x170)), x170, x171, x172, x173, x180, x175))


*(RING(x182, x183, x184, x191, x186, x187)_>=_U1^1(empty(fstsplit(x187, x182)), x182, x183, x184, x191, x186, x187))


*(RING(x200, x201, x202, x209, x210, x205)_>=_U1^1(empty(fstsplit(x205, x200)), x200, x201, x202, x209, x210, x205))


*(RING(x218, x219, x226, x227, x222, x223)_>=_U1^1(empty(fstsplit(x223, x218)), x218, x219, x226, x227, x222, x223))




*RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)

*(RING(x250, x251, x246, x247, x248, x249)_>=_U2^1(leq(x249, length(x246)), x250, x251, x246, x247, x248, x249))


*(RING(x274, x281, x282, x283, x278, x279)_>=_U2^1(leq(x279, length(x282)), x274, x281, x282, x283, x278, x279))


*(RING(x286, x293, x288, x289, x290, x291)_>=_U2^1(leq(x291, length(x288)), x286, x293, x288, x289, x290, x291))


*(RING(x310, x311, x312, x313, x320, x315)_>=_U2^1(leq(x315, length(x312)), x310, x311, x312, x313, x320, x315))


*(RING(x322, x323, x324, x331, x326, x327)_>=_U2^1(leq(x327, length(x324)), x322, x323, x324, x331, x326, x327))


*(RING(x340, x341, x342, x349, x350, x345)_>=_U2^1(leq(x345, length(x342)), x340, x341, x342, x349, x350, x345))


*(RING(x358, x359, x366, x367, x362, x363)_>=_U2^1(leq(x363, length(x366)), x358, x359, x366, x367, x362, x363))




*U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)

*(U2^1(false, x396, x397, nil, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), nil))), x396, x397, nil, x399, x400, s(x1890)))


*(U2^1(false, x396, x397, x1900, x399, x400, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x397)), x1900))), x396, x397, x1900, x399, x400, x1892)  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))




*U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)

*(U4^1(false, x506, x507, x508, x509, x510, s(x1924))_>=_RING(x506, tail(x507), sndsplit(s(x1924), app(map_f(two, head(x507)), x508)), cons(fstsplit(s(x1924), app(map_f(two, head(x507)), x508)), x509), x510, s(x1924)))




*U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), st_2, in_3, st_3, m)

*(U5^1(true, x676, cons(nil, x678), x679, x680, x681, x682)_>=_RING(x676, tail(cons(nil, x678)), x679, x680, x681, x682))




*RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)

*(RING(x702, x703, x698, x699, x700, x701)_>=_U6^1(leq(x701, length(x700)), x702, x703, x698, x699, x700, x701))


*(RING(x726, x733, x734, x735, x730, x731)_>=_U6^1(leq(x731, length(x730)), x726, x733, x734, x735, x730, x731))


*(RING(x738, x745, x740, x741, x742, x743)_>=_U6^1(leq(x743, length(x742)), x738, x745, x740, x741, x742, x743))


*(RING(x762, x763, x764, x765, x772, x767)_>=_U6^1(leq(x767, length(x772)), x762, x763, x764, x765, x772, x767))


*(RING(x774, x775, x776, x783, x778, x779)_>=_U6^1(leq(x779, length(x778)), x774, x775, x776, x783, x778, x779))


*(RING(x792, x793, x794, x801, x802, x797)_>=_U6^1(leq(x797, length(x802)), x792, x793, x794, x801, x802, x797))


*(RING(x810, x811, x818, x819, x814, x815)_>=_U6^1(leq(x815, length(x814)), x810, x811, x818, x819, x814, x815))




*U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)

*(U6^1(true, x872, x873, x874, x875, x876, 0)_>=_U7^1(empty(fstsplit(0, x876)), x872, x873, x874, x875, x876, 0))


*(U6^1(true, x872, x873, x874, x875, x1970, x1964)_>=_U7^1(empty(fstsplit(x1964, x1970)), x872, x873, x874, x875, x1970, x1964)  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))




*U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)

*(U7^1(false, x982, x983, x984, x985, cons(x1989, x1988), s(x1990))_>=_RING(x982, x983, x984, x985, sndsplit(s(x1990), cons(x1989, x1988)), s(x1990)))




*U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)

*(U9^1(true, x1135, x1136, x1137, cons(nil, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(nil, x1139)), x1140, x1141))




*U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)

*(U6^1(false, x1184, x1185, x1186, x1187, nil, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), nil))), x1184, x1185, x1186, x1187, nil, s(x2019)))


*(U6^1(false, x1184, x1185, x1186, x1187, x2029, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x1187)), x2029))), x1184, x1185, x1186, x1187, x2029, x2021)  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))




*U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

*(U8^1(false, x1312, x1313, x1314, x1315, x1316, s(x2053))_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(s(x2053), app(map_f(three, head(x1315)), x1316)), s(x2053)))




*U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)

*(U2^1(true, x1368, x1369, x1370, x1371, x1372, 0)_>=_U3^1(empty(fstsplit(0, x1370)), x1368, x1369, x1370, x1371, x1372, 0))


*(U2^1(true, x1368, x1369, x2071, x1371, x1372, x2065)_>=_U3^1(empty(fstsplit(x2065, x2071)), x1368, x1369, x2071, x1371, x1372, x2065)  ==>  U2^1(true, x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065))_>=_U3^1(empty(fstsplit(s(x2065), cons(x2072, x2071))), x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065)))




*U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)

*(U3^1(false, x1532, x1533, cons(x2090, x2089), x1535, x1536, s(x2091))_>=_RING(x1532, x1533, sndsplit(s(x2091), cons(x2090, x2089)), cons(fstsplit(s(x2091), cons(x2090, x2089)), x1535), x1536, s(x2091)))




*RING(y0, cons(x0, x1), y2, y3, y4, y5) -> U5^1(empty(map_f(two, x0)), y0, cons(x0, x1), y2, y3, y4, y5)

*(RING(x1570, cons(x1571, x1565), x1566, x1567, x1568, x1569)_>=_U5^1(empty(map_f(two, x1571)), x1570, cons(x1571, x1565), x1566, x1567, x1568, x1569))


*(RING(x1595, cons(x1602, x1603), x1604, x1605, x1599, x1600)_>=_U5^1(empty(map_f(two, x1602)), x1595, cons(x1602, x1603), x1604, x1605, x1599, x1600))


*(RING(x1608, cons(x1615, x1616), x1610, x1611, x1612, x1613)_>=_U5^1(empty(map_f(two, x1615)), x1608, cons(x1615, x1616), x1610, x1611, x1612, x1613))


*(RING(x1633, cons(x1640, x1641), x1635, x1636, x1644, x1638)_>=_U5^1(empty(map_f(two, x1640)), x1633, cons(x1640, x1641), x1635, x1636, x1644, x1638))


*(RING(x1646, cons(x1653, x1654), x1648, x1656, x1650, x1651)_>=_U5^1(empty(map_f(two, x1653)), x1646, cons(x1653, x1654), x1648, x1656, x1650, x1651))


*(RING(x1665, cons(x1672, x1673), x1667, x1675, x1676, x1670)_>=_U5^1(empty(map_f(two, x1672)), x1665, cons(x1672, x1673), x1667, x1675, x1676, x1670))


*(RING(x1684, cons(x1691, x1692), x1693, x1694, x1688, x1689)_>=_U5^1(empty(map_f(two, x1691)), x1684, cons(x1691, x1692), x1693, x1694, x1688, x1689))




*RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)

*(RING(x1717, x1718, x1713, cons(x1720, x1721), x1715, x1716)_>=_U9^1(empty(map_f(three, x1720)), x1717, x1718, x1713, cons(x1720, x1721), x1715, x1716))


*(RING(x1742, x1749, x1750, cons(x1751, x1745), x1746, x1747)_>=_U9^1(empty(map_f(three, x1751)), x1742, x1749, x1750, cons(x1751, x1745), x1746, x1747))


*(RING(x1755, x1762, x1757, cons(x1764, x1765), x1759, x1760)_>=_U9^1(empty(map_f(three, x1764)), x1755, x1762, x1757, cons(x1764, x1765), x1759, x1760))


*(RING(x1780, x1781, x1782, cons(x1789, x1790), x1791, x1785)_>=_U9^1(empty(map_f(three, x1789)), x1780, x1781, x1782, cons(x1789, x1790), x1791, x1785))


*(RING(x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798)_>=_U9^1(empty(map_f(three, x1802)), x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798))


*(RING(x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817)_>=_U9^1(empty(map_f(three, x1821)), x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817))


*(RING(x1831, x1832, x1839, cons(x1840, x1834), x1835, x1836)_>=_U9^1(empty(map_f(three, x1840)), x1831, x1832, x1839, cons(x1840, x1834), x1835, x1836))








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation [NONINF]:

   POL(0) = 0
   POL(RING(x_1, x_2, x_3, x_4, x_5, x_6)) = -1 - x_1 - x_6
   POL(U1^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 - x_2 - x_7
   POL(U2^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 - x_1 - x_2 - x_7
   POL(U3^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 + x_1 - x_2 - x_7
   POL(U4^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 + x_1 - x_2 - x_7
   POL(U5^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 - x_2 - x_3 - x_7
   POL(U6^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 - x_1 - x_2 - x_7
   POL(U7^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 + x_1 - x_2 - x_7
   POL(U8^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 + x_1 - x_2 - x_7
   POL(U9^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 - x_2 - x_5 - x_7
   POL(app(x_1, x_2)) = 0
   POL(c) = -2
   POL(cons(x_1, x_2)) = 0
   POL(empty(x_1)) = 0
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(false) = 0
   POL(fstsplit(x_1, x_2)) = 0
   POL(head(x_1)) = 0
   POL(length(x_1)) = 0
   POL(leq(x_1, x_2)) = 0
   POL(map_f(x_1, x_2)) = 0
   POL(nil) = 1
   POL(s(x_1)) = 1
   POL(sndsplit(x_1, x_2)) = x_1
   POL(tail(x_1)) = 0
   POL(three) = 0
   POL(true) = 0
   POL(two) = 0


The following pairs  are in P_>:
   U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
The following pairs are in P_bound:
   U1^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(sndsplit(m, st_1), cons(fstsplit(m, st_1), in_2), st_2, in_3, st_3, m)
The following rules are usable:
   x -> sndsplit(0, x)
   nil -> sndsplit(s(n), nil)
   empty(nil) -> true
   empty(cons(h, t)) -> false
   true -> leq(0, m)
   false -> leq(s(n), 0)
   leq(n, m) -> leq(s(n), s(m))

----------------------------------------

(63)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U1^1(empty(fstsplit(m, st_1)), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   RING(y0, cons(x0, x1), y2, y3, y4, y5) -> U5^1(empty(map_f(two, x0)), y0, cons(x0, x1), y2, y3, y4, y5)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(64) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(65)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(y0, cons(x0, x1), y2, y3, y4, y5) -> U5^1(empty(map_f(two, x0)), y0, cons(x0, x1), y2, y3, y4, y5)
   U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), st_2, in_3, st_3, m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(66) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   RING(y0, cons(x0, x1), y2, y3, y4, y5) -> U5^1(empty(map_f(two, x0)), y0, cons(x0, x1), y2, y3, y4, y5)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial interpretation [POLO,RATPOLO]:

   POL(0) = 0
   POL(RING(x_1, x_2, x_3, x_4, x_5, x_6)) = [1/2]x_2
   POL(U2^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = [1/2]x_3
   POL(U3^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = [1/2]x_3
   POL(U4^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = [1/4]x_3
   POL(U5^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = [1/4]x_3
   POL(U6^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = [1/2]x_3
   POL(U7^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = [1/2]x_3
   POL(U8^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = [1/2]x_3
   POL(U9^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = [1/2]x_3
   POL(app(x_1, x_2)) = 0
   POL(cons(x_1, x_2)) = [1/4] + [4]x_2
   POL(empty(x_1)) = 0
   POL(f(x_1, x_2)) = 0
   POL(false) = 0
   POL(fstsplit(x_1, x_2)) = 0
   POL(head(x_1)) = 0
   POL(length(x_1)) = 0
   POL(leq(x_1, x_2)) = 0
   POL(map_f(x_1, x_2)) = 0
   POL(nil) = 0
   POL(s(x_1)) = 0
   POL(sndsplit(x_1, x_2)) = 0
   POL(tail(x_1)) = [1/2]x_1
   POL(three) = 0
   POL(true) = 0
   POL(two) = 0
The value of delta used in the strict ordering is 1/16.
The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   tail(cons(h, t)) -> t


----------------------------------------

(67)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U5^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), st_2, in_3, st_3, m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(68) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(69)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(70) NonInfProof (EQUIVALENT)
The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain U4^1(false, x274, x275, x276, x277, x278, x279) -> RING(x274, tail(x275), sndsplit(x279, app(map_f(two, head(x275)), x276)), cons(fstsplit(x279, app(map_f(two, head(x275)), x276)), x277), x278, x279), RING(x280, x281, x282, x283, x284, x285) -> U2^1(leq(x285, length(x282)), x280, x281, x282, x283, x284, x285) which results in the following constraint:

(1)    (RING(x274, tail(x275), sndsplit(x279, app(map_f(two, head(x275)), x276)), cons(fstsplit(x279, app(map_f(two, head(x275)), x276)), x277), x278, x279)=RING(x280, x281, x282, x283, x284, x285)  ==>  RING(x280, x281, x282, x283, x284, x285)_>=_U2^1(leq(x285, length(x282)), x280, x281, x282, x283, x284, x285))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x274, x281, x282, x283, x278, x279)_>=_U2^1(leq(x279, length(x282)), x274, x281, x282, x283, x278, x279))




*We consider the chain U7^1(false, x310, x311, x312, x313, x314, x315) -> RING(x310, x311, x312, x313, sndsplit(x315, x314), x315), RING(x316, x317, x318, x319, x320, x321) -> U2^1(leq(x321, length(x318)), x316, x317, x318, x319, x320, x321) which results in the following constraint:

(1)    (RING(x310, x311, x312, x313, sndsplit(x315, x314), x315)=RING(x316, x317, x318, x319, x320, x321)  ==>  RING(x316, x317, x318, x319, x320, x321)_>=_U2^1(leq(x321, length(x318)), x316, x317, x318, x319, x320, x321))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x310, x311, x312, x313, x320, x315)_>=_U2^1(leq(x315, length(x312)), x310, x311, x312, x313, x320, x315))




*We consider the chain U9^1(true, x322, x323, x324, x325, x326, x327) -> RING(x322, x323, x324, tail(x325), x326, x327), RING(x328, x329, x330, x331, x332, x333) -> U2^1(leq(x333, length(x330)), x328, x329, x330, x331, x332, x333) which results in the following constraint:

(1)    (RING(x322, x323, x324, tail(x325), x326, x327)=RING(x328, x329, x330, x331, x332, x333)  ==>  RING(x328, x329, x330, x331, x332, x333)_>=_U2^1(leq(x333, length(x330)), x328, x329, x330, x331, x332, x333))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x322, x323, x324, x331, x326, x327)_>=_U2^1(leq(x327, length(x324)), x322, x323, x324, x331, x326, x327))




*We consider the chain U8^1(false, x340, x341, x342, x343, x344, x345) -> RING(x340, x341, x342, tail(x343), sndsplit(x345, app(map_f(three, head(x343)), x344)), x345), RING(x346, x347, x348, x349, x350, x351) -> U2^1(leq(x351, length(x348)), x346, x347, x348, x349, x350, x351) which results in the following constraint:

(1)    (RING(x340, x341, x342, tail(x343), sndsplit(x345, app(map_f(three, head(x343)), x344)), x345)=RING(x346, x347, x348, x349, x350, x351)  ==>  RING(x346, x347, x348, x349, x350, x351)_>=_U2^1(leq(x351, length(x348)), x346, x347, x348, x349, x350, x351))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x340, x341, x342, x349, x350, x345)_>=_U2^1(leq(x345, length(x342)), x340, x341, x342, x349, x350, x345))




*We consider the chain U3^1(false, x358, x359, x360, x361, x362, x363) -> RING(x358, x359, sndsplit(x363, x360), cons(fstsplit(x363, x360), x361), x362, x363), RING(x364, x365, x366, x367, x368, x369) -> U2^1(leq(x369, length(x366)), x364, x365, x366, x367, x368, x369) which results in the following constraint:

(1)    (RING(x358, x359, sndsplit(x363, x360), cons(fstsplit(x363, x360), x361), x362, x363)=RING(x364, x365, x366, x367, x368, x369)  ==>  RING(x364, x365, x366, x367, x368, x369)_>=_U2^1(leq(x369, length(x366)), x364, x365, x366, x367, x368, x369))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x358, x359, x366, x367, x362, x363)_>=_U2^1(leq(x363, length(x366)), x358, x359, x366, x367, x362, x363))








For Pair U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x396, x397, x398, x399, x400, x401) -> U2^1(leq(x401, length(x398)), x396, x397, x398, x399, x400, x401), U2^1(false, x402, x403, x404, x405, x406, x407) -> U4^1(empty(fstsplit(x407, app(map_f(two, head(x403)), x404))), x402, x403, x404, x405, x406, x407) which results in the following constraint:

(1)    (U2^1(leq(x401, length(x398)), x396, x397, x398, x399, x400, x401)=U2^1(false, x402, x403, x404, x405, x406, x407)  ==>  U2^1(false, x402, x403, x404, x405, x406, x407)_>=_U4^1(empty(fstsplit(x407, app(map_f(two, head(x403)), x404))), x402, x403, x404, x405, x406, x407))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x398)=x1888 & leq(x401, x1888)=false  ==>  U2^1(false, x396, x397, x398, x399, x400, x401)_>=_U4^1(empty(fstsplit(x401, app(map_f(two, head(x397)), x398))), x396, x397, x398, x399, x400, x401))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x401, x1888)=false which results in the following new constraints:

(3)    (false=false & length(x398)=0  ==>  U2^1(false, x396, x397, x398, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), x398))), x396, x397, x398, x399, x400, s(x1890)))

(4)    (leq(x1892, x1891)=false & length(x398)=s(x1891) & (\/x1893,x1894,x1895,x1896,x1897:leq(x1892, x1891)=false & length(x1893)=x1891  ==>  U2^1(false, x1894, x1895, x1893, x1896, x1897, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x1895)), x1893))), x1894, x1895, x1893, x1896, x1897, x1892))  ==>  U2^1(false, x396, x397, x398, x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), x398))), x396, x397, x398, x399, x400, s(x1892)))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (length(x398)=0  ==>  U2^1(false, x396, x397, x398, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), x398))), x396, x397, x398, x399, x400, s(x1890)))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x398)=s(x1891) which results in the following new constraint:

(6)    (s(length(x1900))=s(x1891) & leq(x1892, x1891)=false & (\/x1893,x1894,x1895,x1896,x1897:leq(x1892, x1891)=false & length(x1893)=x1891  ==>  U2^1(false, x1894, x1895, x1893, x1896, x1897, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x1895)), x1893))), x1894, x1895, x1893, x1896, x1897, x1892)) & (\/x1902,x1903,x1904,x1905,x1906,x1907,x1908,x1909,x1910,x1911,x1912:length(x1900)=s(x1902) & leq(x1903, x1902)=false & (\/x1904,x1905,x1906,x1907,x1908:leq(x1903, x1902)=false & length(x1904)=x1902  ==>  U2^1(false, x1905, x1906, x1904, x1907, x1908, x1903)_>=_U4^1(empty(fstsplit(x1903, app(map_f(two, head(x1906)), x1904))), x1905, x1906, x1904, x1907, x1908, x1903))  ==>  U2^1(false, x1909, x1910, x1900, x1911, x1912, s(x1903))_>=_U4^1(empty(fstsplit(s(x1903), app(map_f(two, head(x1910)), x1900))), x1909, x1910, x1900, x1911, x1912, s(x1903)))  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))



We simplified constraint (5) using rule (V) (with possible (I) afterwards) using induction on length(x398)=0 which results in the following new constraint:

(7)    (0=0  ==>  U2^1(false, x396, x397, nil, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), nil))), x396, x397, nil, x399, x400, s(x1890)))



We simplified constraint (7) using rules (I), (II) which results in the following new constraint:

(8)    (U2^1(false, x396, x397, nil, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), nil))), x396, x397, nil, x399, x400, s(x1890)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(9)    (length(x1900)=x1891 & leq(x1892, x1891)=false & (\/x1893,x1894,x1895,x1896,x1897:leq(x1892, x1891)=false & length(x1893)=x1891  ==>  U2^1(false, x1894, x1895, x1893, x1896, x1897, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x1895)), x1893))), x1894, x1895, x1893, x1896, x1897, x1892)) & (\/x1902,x1903,x1904,x1905,x1906,x1907,x1908,x1909,x1910,x1911,x1912:length(x1900)=s(x1902) & leq(x1903, x1902)=false & (\/x1904,x1905,x1906,x1907,x1908:leq(x1903, x1902)=false & length(x1904)=x1902  ==>  U2^1(false, x1905, x1906, x1904, x1907, x1908, x1903)_>=_U4^1(empty(fstsplit(x1903, app(map_f(two, head(x1906)), x1904))), x1905, x1906, x1904, x1907, x1908, x1903))  ==>  U2^1(false, x1909, x1910, x1900, x1911, x1912, s(x1903))_>=_U4^1(empty(fstsplit(s(x1903), app(map_f(two, head(x1910)), x1900))), x1909, x1910, x1900, x1911, x1912, s(x1903)))  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))



We simplified constraint (9) using rule (VI) where we applied the induction hypothesis (\/x1893,x1894,x1895,x1896,x1897:leq(x1892, x1891)=false & length(x1893)=x1891  ==>  U2^1(false, x1894, x1895, x1893, x1896, x1897, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x1895)), x1893))), x1894, x1895, x1893, x1896, x1897, x1892)) with sigma = [x1893 / x1900, x1894 / x396, x1895 / x397, x1896 / x399, x1897 / x400] which results in the following new constraint:

(10)    (U2^1(false, x396, x397, x1900, x399, x400, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x397)), x1900))), x396, x397, x1900, x399, x400, x1892) & (\/x1902,x1903,x1904,x1905,x1906,x1907,x1908,x1909,x1910,x1911,x1912:length(x1900)=s(x1902) & leq(x1903, x1902)=false & (\/x1904,x1905,x1906,x1907,x1908:leq(x1903, x1902)=false & length(x1904)=x1902  ==>  U2^1(false, x1905, x1906, x1904, x1907, x1908, x1903)_>=_U4^1(empty(fstsplit(x1903, app(map_f(two, head(x1906)), x1904))), x1905, x1906, x1904, x1907, x1908, x1903))  ==>  U2^1(false, x1909, x1910, x1900, x1911, x1912, s(x1903))_>=_U4^1(empty(fstsplit(s(x1903), app(map_f(two, head(x1910)), x1900))), x1909, x1910, x1900, x1911, x1912, s(x1903)))  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))



We simplified constraint (10) using rule (IV) which results in the following new constraint:

(11)    (U2^1(false, x396, x397, x1900, x399, x400, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x397)), x1900))), x396, x397, x1900, x399, x400, x1892)  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))








For Pair U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m) the following chains were created:
*We consider the chain U2^1(false, x506, x507, x508, x509, x510, x511) -> U4^1(empty(fstsplit(x511, app(map_f(two, head(x507)), x508))), x506, x507, x508, x509, x510, x511), U4^1(false, x512, x513, x514, x515, x516, x517) -> RING(x512, tail(x513), sndsplit(x517, app(map_f(two, head(x513)), x514)), cons(fstsplit(x517, app(map_f(two, head(x513)), x514)), x515), x516, x517) which results in the following constraint:

(1)    (U4^1(empty(fstsplit(x511, app(map_f(two, head(x507)), x508))), x506, x507, x508, x509, x510, x511)=U4^1(false, x512, x513, x514, x515, x516, x517)  ==>  U4^1(false, x512, x513, x514, x515, x516, x517)_>=_RING(x512, tail(x513), sndsplit(x517, app(map_f(two, head(x513)), x514)), cons(fstsplit(x517, app(map_f(two, head(x513)), x514)), x515), x516, x517))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (fstsplit(x511, x1914)=x1913 & empty(x1913)=false  ==>  U4^1(false, x506, x507, x508, x509, x510, x511)_>=_RING(x506, tail(x507), sndsplit(x511, app(map_f(two, head(x507)), x508)), cons(fstsplit(x511, app(map_f(two, head(x507)), x508)), x509), x510, x511))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x1913)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x511, x1914)=cons(x1919, x1918)  ==>  U4^1(false, x506, x507, x508, x509, x510, x511)_>=_RING(x506, tail(x507), sndsplit(x511, app(map_f(two, head(x507)), x508)), cons(fstsplit(x511, app(map_f(two, head(x507)), x508)), x509), x510, x511))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x511, x1914)=cons(x1919, x1918)  ==>  U4^1(false, x506, x507, x508, x509, x510, x511)_>=_RING(x506, tail(x507), sndsplit(x511, app(map_f(two, head(x507)), x508)), cons(fstsplit(x511, app(map_f(two, head(x507)), x508)), x509), x510, x511))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x511, x1914)=cons(x1919, x1918) which results in the following new constraint:

(5)    (cons(x1923, fstsplit(x1924, x1922))=cons(x1919, x1918) & (\/x1925,x1926,x1927,x1928,x1929,x1930,x1931:fstsplit(x1924, x1922)=cons(x1925, x1926)  ==>  U4^1(false, x1927, x1928, x1929, x1930, x1931, x1924)_>=_RING(x1927, tail(x1928), sndsplit(x1924, app(map_f(two, head(x1928)), x1929)), cons(fstsplit(x1924, app(map_f(two, head(x1928)), x1929)), x1930), x1931, x1924))  ==>  U4^1(false, x506, x507, x508, x509, x510, s(x1924))_>=_RING(x506, tail(x507), sndsplit(s(x1924), app(map_f(two, head(x507)), x508)), cons(fstsplit(s(x1924), app(map_f(two, head(x507)), x508)), x509), x510, s(x1924)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U4^1(false, x506, x507, x508, x509, x510, s(x1924))_>=_RING(x506, tail(x507), sndsplit(s(x1924), app(map_f(two, head(x507)), x508)), cons(fstsplit(s(x1924), app(map_f(two, head(x507)), x508)), x509), x510, s(x1924)))








For Pair RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain U4^1(false, x726, x727, x728, x729, x730, x731) -> RING(x726, tail(x727), sndsplit(x731, app(map_f(two, head(x727)), x728)), cons(fstsplit(x731, app(map_f(two, head(x727)), x728)), x729), x730, x731), RING(x732, x733, x734, x735, x736, x737) -> U6^1(leq(x737, length(x736)), x732, x733, x734, x735, x736, x737) which results in the following constraint:

(1)    (RING(x726, tail(x727), sndsplit(x731, app(map_f(two, head(x727)), x728)), cons(fstsplit(x731, app(map_f(two, head(x727)), x728)), x729), x730, x731)=RING(x732, x733, x734, x735, x736, x737)  ==>  RING(x732, x733, x734, x735, x736, x737)_>=_U6^1(leq(x737, length(x736)), x732, x733, x734, x735, x736, x737))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x726, x733, x734, x735, x730, x731)_>=_U6^1(leq(x731, length(x730)), x726, x733, x734, x735, x730, x731))




*We consider the chain U7^1(false, x762, x763, x764, x765, x766, x767) -> RING(x762, x763, x764, x765, sndsplit(x767, x766), x767), RING(x768, x769, x770, x771, x772, x773) -> U6^1(leq(x773, length(x772)), x768, x769, x770, x771, x772, x773) which results in the following constraint:

(1)    (RING(x762, x763, x764, x765, sndsplit(x767, x766), x767)=RING(x768, x769, x770, x771, x772, x773)  ==>  RING(x768, x769, x770, x771, x772, x773)_>=_U6^1(leq(x773, length(x772)), x768, x769, x770, x771, x772, x773))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x762, x763, x764, x765, x772, x767)_>=_U6^1(leq(x767, length(x772)), x762, x763, x764, x765, x772, x767))




*We consider the chain U9^1(true, x774, x775, x776, x777, x778, x779) -> RING(x774, x775, x776, tail(x777), x778, x779), RING(x780, x781, x782, x783, x784, x785) -> U6^1(leq(x785, length(x784)), x780, x781, x782, x783, x784, x785) which results in the following constraint:

(1)    (RING(x774, x775, x776, tail(x777), x778, x779)=RING(x780, x781, x782, x783, x784, x785)  ==>  RING(x780, x781, x782, x783, x784, x785)_>=_U6^1(leq(x785, length(x784)), x780, x781, x782, x783, x784, x785))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x774, x775, x776, x783, x778, x779)_>=_U6^1(leq(x779, length(x778)), x774, x775, x776, x783, x778, x779))




*We consider the chain U8^1(false, x792, x793, x794, x795, x796, x797) -> RING(x792, x793, x794, tail(x795), sndsplit(x797, app(map_f(three, head(x795)), x796)), x797), RING(x798, x799, x800, x801, x802, x803) -> U6^1(leq(x803, length(x802)), x798, x799, x800, x801, x802, x803) which results in the following constraint:

(1)    (RING(x792, x793, x794, tail(x795), sndsplit(x797, app(map_f(three, head(x795)), x796)), x797)=RING(x798, x799, x800, x801, x802, x803)  ==>  RING(x798, x799, x800, x801, x802, x803)_>=_U6^1(leq(x803, length(x802)), x798, x799, x800, x801, x802, x803))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x792, x793, x794, x801, x802, x797)_>=_U6^1(leq(x797, length(x802)), x792, x793, x794, x801, x802, x797))




*We consider the chain U3^1(false, x810, x811, x812, x813, x814, x815) -> RING(x810, x811, sndsplit(x815, x812), cons(fstsplit(x815, x812), x813), x814, x815), RING(x816, x817, x818, x819, x820, x821) -> U6^1(leq(x821, length(x820)), x816, x817, x818, x819, x820, x821) which results in the following constraint:

(1)    (RING(x810, x811, sndsplit(x815, x812), cons(fstsplit(x815, x812), x813), x814, x815)=RING(x816, x817, x818, x819, x820, x821)  ==>  RING(x816, x817, x818, x819, x820, x821)_>=_U6^1(leq(x821, length(x820)), x816, x817, x818, x819, x820, x821))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x810, x811, x818, x819, x814, x815)_>=_U6^1(leq(x815, length(x814)), x810, x811, x818, x819, x814, x815))








For Pair U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x872, x873, x874, x875, x876, x877) -> U6^1(leq(x877, length(x876)), x872, x873, x874, x875, x876, x877), U6^1(true, x878, x879, x880, x881, x882, x883) -> U7^1(empty(fstsplit(x883, x882)), x878, x879, x880, x881, x882, x883) which results in the following constraint:

(1)    (U6^1(leq(x877, length(x876)), x872, x873, x874, x875, x876, x877)=U6^1(true, x878, x879, x880, x881, x882, x883)  ==>  U6^1(true, x878, x879, x880, x881, x882, x883)_>=_U7^1(empty(fstsplit(x883, x882)), x878, x879, x880, x881, x882, x883))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x876)=x1960 & leq(x877, x1960)=true  ==>  U6^1(true, x872, x873, x874, x875, x876, x877)_>=_U7^1(empty(fstsplit(x877, x876)), x872, x873, x874, x875, x876, x877))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x877, x1960)=true which results in the following new constraints:

(3)    (true=true & length(x876)=x1961  ==>  U6^1(true, x872, x873, x874, x875, x876, 0)_>=_U7^1(empty(fstsplit(0, x876)), x872, x873, x874, x875, x876, 0))

(4)    (leq(x1964, x1963)=true & length(x876)=s(x1963) & (\/x1965,x1966,x1967,x1968,x1969:leq(x1964, x1963)=true & length(x1965)=x1963  ==>  U6^1(true, x1966, x1967, x1968, x1969, x1965, x1964)_>=_U7^1(empty(fstsplit(x1964, x1965)), x1966, x1967, x1968, x1969, x1965, x1964))  ==>  U6^1(true, x872, x873, x874, x875, x876, s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), x876)), x872, x873, x874, x875, x876, s(x1964)))



We simplified constraint (3) using rules (I), (II), (IV) which results in the following new constraint:

(5)    (U6^1(true, x872, x873, x874, x875, x876, 0)_>=_U7^1(empty(fstsplit(0, x876)), x872, x873, x874, x875, x876, 0))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x876)=s(x1963) which results in the following new constraint:

(6)    (s(length(x1970))=s(x1963) & leq(x1964, x1963)=true & (\/x1965,x1966,x1967,x1968,x1969:leq(x1964, x1963)=true & length(x1965)=x1963  ==>  U6^1(true, x1966, x1967, x1968, x1969, x1965, x1964)_>=_U7^1(empty(fstsplit(x1964, x1965)), x1966, x1967, x1968, x1969, x1965, x1964)) & (\/x1972,x1973,x1974,x1975,x1976,x1977,x1978,x1979,x1980,x1981,x1982:length(x1970)=s(x1972) & leq(x1973, x1972)=true & (\/x1974,x1975,x1976,x1977,x1978:leq(x1973, x1972)=true & length(x1974)=x1972  ==>  U6^1(true, x1975, x1976, x1977, x1978, x1974, x1973)_>=_U7^1(empty(fstsplit(x1973, x1974)), x1975, x1976, x1977, x1978, x1974, x1973))  ==>  U6^1(true, x1979, x1980, x1981, x1982, x1970, s(x1973))_>=_U7^1(empty(fstsplit(s(x1973), x1970)), x1979, x1980, x1981, x1982, x1970, s(x1973)))  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(7)    (length(x1970)=x1963 & leq(x1964, x1963)=true & (\/x1965,x1966,x1967,x1968,x1969:leq(x1964, x1963)=true & length(x1965)=x1963  ==>  U6^1(true, x1966, x1967, x1968, x1969, x1965, x1964)_>=_U7^1(empty(fstsplit(x1964, x1965)), x1966, x1967, x1968, x1969, x1965, x1964)) & (\/x1972,x1973,x1974,x1975,x1976,x1977,x1978,x1979,x1980,x1981,x1982:length(x1970)=s(x1972) & leq(x1973, x1972)=true & (\/x1974,x1975,x1976,x1977,x1978:leq(x1973, x1972)=true & length(x1974)=x1972  ==>  U6^1(true, x1975, x1976, x1977, x1978, x1974, x1973)_>=_U7^1(empty(fstsplit(x1973, x1974)), x1975, x1976, x1977, x1978, x1974, x1973))  ==>  U6^1(true, x1979, x1980, x1981, x1982, x1970, s(x1973))_>=_U7^1(empty(fstsplit(s(x1973), x1970)), x1979, x1980, x1981, x1982, x1970, s(x1973)))  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))



We simplified constraint (7) using rule (VI) where we applied the induction hypothesis (\/x1965,x1966,x1967,x1968,x1969:leq(x1964, x1963)=true & length(x1965)=x1963  ==>  U6^1(true, x1966, x1967, x1968, x1969, x1965, x1964)_>=_U7^1(empty(fstsplit(x1964, x1965)), x1966, x1967, x1968, x1969, x1965, x1964)) with sigma = [x1965 / x1970, x1966 / x872, x1967 / x873, x1968 / x874, x1969 / x875] which results in the following new constraint:

(8)    (U6^1(true, x872, x873, x874, x875, x1970, x1964)_>=_U7^1(empty(fstsplit(x1964, x1970)), x872, x873, x874, x875, x1970, x1964) & (\/x1972,x1973,x1974,x1975,x1976,x1977,x1978,x1979,x1980,x1981,x1982:length(x1970)=s(x1972) & leq(x1973, x1972)=true & (\/x1974,x1975,x1976,x1977,x1978:leq(x1973, x1972)=true & length(x1974)=x1972  ==>  U6^1(true, x1975, x1976, x1977, x1978, x1974, x1973)_>=_U7^1(empty(fstsplit(x1973, x1974)), x1975, x1976, x1977, x1978, x1974, x1973))  ==>  U6^1(true, x1979, x1980, x1981, x1982, x1970, s(x1973))_>=_U7^1(empty(fstsplit(s(x1973), x1970)), x1979, x1980, x1981, x1982, x1970, s(x1973)))  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))



We simplified constraint (8) using rule (IV) which results in the following new constraint:

(9)    (U6^1(true, x872, x873, x874, x875, x1970, x1964)_>=_U7^1(empty(fstsplit(x1964, x1970)), x872, x873, x874, x875, x1970, x1964)  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))








For Pair U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m) the following chains were created:
*We consider the chain U6^1(true, x982, x983, x984, x985, x986, x987) -> U7^1(empty(fstsplit(x987, x986)), x982, x983, x984, x985, x986, x987), U7^1(false, x988, x989, x990, x991, x992, x993) -> RING(x988, x989, x990, x991, sndsplit(x993, x992), x993) which results in the following constraint:

(1)    (U7^1(empty(fstsplit(x987, x986)), x982, x983, x984, x985, x986, x987)=U7^1(false, x988, x989, x990, x991, x992, x993)  ==>  U7^1(false, x988, x989, x990, x991, x992, x993)_>=_RING(x988, x989, x990, x991, sndsplit(x993, x992), x993))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (fstsplit(x987, x986)=x1983 & empty(x1983)=false  ==>  U7^1(false, x982, x983, x984, x985, x986, x987)_>=_RING(x982, x983, x984, x985, sndsplit(x987, x986), x987))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x1983)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x987, x986)=cons(x1985, x1984)  ==>  U7^1(false, x982, x983, x984, x985, x986, x987)_>=_RING(x982, x983, x984, x985, sndsplit(x987, x986), x987))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x987, x986)=cons(x1985, x1984)  ==>  U7^1(false, x982, x983, x984, x985, x986, x987)_>=_RING(x982, x983, x984, x985, sndsplit(x987, x986), x987))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x987, x986)=cons(x1985, x1984) which results in the following new constraint:

(5)    (cons(x1989, fstsplit(x1990, x1988))=cons(x1985, x1984) & (\/x1991,x1992,x1993,x1994,x1995,x1996:fstsplit(x1990, x1988)=cons(x1991, x1992)  ==>  U7^1(false, x1993, x1994, x1995, x1996, x1988, x1990)_>=_RING(x1993, x1994, x1995, x1996, sndsplit(x1990, x1988), x1990))  ==>  U7^1(false, x982, x983, x984, x985, cons(x1989, x1988), s(x1990))_>=_RING(x982, x983, x984, x985, sndsplit(s(x1990), cons(x1989, x1988)), s(x1990)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U7^1(false, x982, x983, x984, x985, cons(x1989, x1988), s(x1990))_>=_RING(x982, x983, x984, x985, sndsplit(s(x1990), cons(x1989, x1988)), s(x1990)))








For Pair U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m) the following chains were created:
*We consider the chain RING(x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141) -> U9^1(empty(map_f(three, x1138)), x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141), U9^1(true, x1142, x1143, x1144, x1145, x1146, x1147) -> RING(x1142, x1143, x1144, tail(x1145), x1146, x1147) which results in the following constraint:

(1)    (U9^1(empty(map_f(three, x1138)), x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141)=U9^1(true, x1142, x1143, x1144, x1145, x1146, x1147)  ==>  U9^1(true, x1142, x1143, x1144, x1145, x1146, x1147)_>=_RING(x1142, x1143, x1144, tail(x1145), x1146, x1147))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (three=x1998 & map_f(x1998, x1138)=x1997 & empty(x1997)=true  ==>  U9^1(true, x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(x1138, x1139)), x1140, x1141))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x1997)=true which results in the following new constraint:

(3)    (true=true & three=x1998 & map_f(x1998, x1138)=nil  ==>  U9^1(true, x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(x1138, x1139)), x1140, x1141))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (three=x1998 & map_f(x1998, x1138)=nil  ==>  U9^1(true, x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(x1138, x1139)), x1140, x1141))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on map_f(x1998, x1138)=nil which results in the following new constraints:

(5)    (nil=nil & three=x2001  ==>  U9^1(true, x1135, x1136, x1137, cons(nil, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(nil, x1139)), x1140, x1141))

(6)    (app(f(x2004, x2003), map_f(x2004, x2002))=nil & three=x2004 & (\/x2005,x2006,x2007,x2008,x2009,x2010:map_f(x2004, x2002)=nil & three=x2004  ==>  U9^1(true, x2005, x2006, x2007, cons(x2002, x2008), x2009, x2010)_>=_RING(x2005, x2006, x2007, tail(cons(x2002, x2008)), x2009, x2010))  ==>  U9^1(true, x1135, x1136, x1137, cons(cons(x2003, x2002), x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(cons(x2003, x2002), x1139)), x1140, x1141))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(7)    (U9^1(true, x1135, x1136, x1137, cons(nil, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(nil, x1139)), x1140, x1141))



We simplified constraint (6) using rules (IV), (VII) which results in the following new constraint:

(8)    (f(x2004, x2003)=x2011 & map_f(x2004, x2002)=x2012 & app(x2011, x2012)=nil & three=x2004  ==>  U9^1(true, x1135, x1136, x1137, cons(cons(x2003, x2002), x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(cons(x2003, x2002), x1139)), x1140, x1141))



We simplified constraint (8) using rule (V) (with possible (I) afterwards) using induction on app(x2011, x2012)=nil which results in the following new constraint:

(9)    (x2013=nil & f(x2004, x2003)=nil & map_f(x2004, x2002)=x2013 & three=x2004  ==>  U9^1(true, x1135, x1136, x1137, cons(cons(x2003, x2002), x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(cons(x2003, x2002), x1139)), x1140, x1141))



We solved constraint (9) using rules (I), (II).




For Pair U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x1184, x1185, x1186, x1187, x1188, x1189) -> U6^1(leq(x1189, length(x1188)), x1184, x1185, x1186, x1187, x1188, x1189), U6^1(false, x1190, x1191, x1192, x1193, x1194, x1195) -> U8^1(empty(fstsplit(x1195, app(map_f(three, head(x1193)), x1194))), x1190, x1191, x1192, x1193, x1194, x1195) which results in the following constraint:

(1)    (U6^1(leq(x1189, length(x1188)), x1184, x1185, x1186, x1187, x1188, x1189)=U6^1(false, x1190, x1191, x1192, x1193, x1194, x1195)  ==>  U6^1(false, x1190, x1191, x1192, x1193, x1194, x1195)_>=_U8^1(empty(fstsplit(x1195, app(map_f(three, head(x1193)), x1194))), x1190, x1191, x1192, x1193, x1194, x1195))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x1188)=x2017 & leq(x1189, x2017)=false  ==>  U6^1(false, x1184, x1185, x1186, x1187, x1188, x1189)_>=_U8^1(empty(fstsplit(x1189, app(map_f(three, head(x1187)), x1188))), x1184, x1185, x1186, x1187, x1188, x1189))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x1189, x2017)=false which results in the following new constraints:

(3)    (false=false & length(x1188)=0  ==>  U6^1(false, x1184, x1185, x1186, x1187, x1188, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), x1188))), x1184, x1185, x1186, x1187, x1188, s(x2019)))

(4)    (leq(x2021, x2020)=false & length(x1188)=s(x2020) & (\/x2022,x2023,x2024,x2025,x2026:leq(x2021, x2020)=false & length(x2022)=x2020  ==>  U6^1(false, x2023, x2024, x2025, x2026, x2022, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x2026)), x2022))), x2023, x2024, x2025, x2026, x2022, x2021))  ==>  U6^1(false, x1184, x1185, x1186, x1187, x1188, s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), x1188))), x1184, x1185, x1186, x1187, x1188, s(x2021)))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (length(x1188)=0  ==>  U6^1(false, x1184, x1185, x1186, x1187, x1188, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), x1188))), x1184, x1185, x1186, x1187, x1188, s(x2019)))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x1188)=s(x2020) which results in the following new constraint:

(6)    (s(length(x2029))=s(x2020) & leq(x2021, x2020)=false & (\/x2022,x2023,x2024,x2025,x2026:leq(x2021, x2020)=false & length(x2022)=x2020  ==>  U6^1(false, x2023, x2024, x2025, x2026, x2022, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x2026)), x2022))), x2023, x2024, x2025, x2026, x2022, x2021)) & (\/x2031,x2032,x2033,x2034,x2035,x2036,x2037,x2038,x2039,x2040,x2041:length(x2029)=s(x2031) & leq(x2032, x2031)=false & (\/x2033,x2034,x2035,x2036,x2037:leq(x2032, x2031)=false & length(x2033)=x2031  ==>  U6^1(false, x2034, x2035, x2036, x2037, x2033, x2032)_>=_U8^1(empty(fstsplit(x2032, app(map_f(three, head(x2037)), x2033))), x2034, x2035, x2036, x2037, x2033, x2032))  ==>  U6^1(false, x2038, x2039, x2040, x2041, x2029, s(x2032))_>=_U8^1(empty(fstsplit(s(x2032), app(map_f(three, head(x2041)), x2029))), x2038, x2039, x2040, x2041, x2029, s(x2032)))  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))



We simplified constraint (5) using rule (V) (with possible (I) afterwards) using induction on length(x1188)=0 which results in the following new constraint:

(7)    (0=0  ==>  U6^1(false, x1184, x1185, x1186, x1187, nil, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), nil))), x1184, x1185, x1186, x1187, nil, s(x2019)))



We simplified constraint (7) using rules (I), (II) which results in the following new constraint:

(8)    (U6^1(false, x1184, x1185, x1186, x1187, nil, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), nil))), x1184, x1185, x1186, x1187, nil, s(x2019)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(9)    (length(x2029)=x2020 & leq(x2021, x2020)=false & (\/x2022,x2023,x2024,x2025,x2026:leq(x2021, x2020)=false & length(x2022)=x2020  ==>  U6^1(false, x2023, x2024, x2025, x2026, x2022, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x2026)), x2022))), x2023, x2024, x2025, x2026, x2022, x2021)) & (\/x2031,x2032,x2033,x2034,x2035,x2036,x2037,x2038,x2039,x2040,x2041:length(x2029)=s(x2031) & leq(x2032, x2031)=false & (\/x2033,x2034,x2035,x2036,x2037:leq(x2032, x2031)=false & length(x2033)=x2031  ==>  U6^1(false, x2034, x2035, x2036, x2037, x2033, x2032)_>=_U8^1(empty(fstsplit(x2032, app(map_f(three, head(x2037)), x2033))), x2034, x2035, x2036, x2037, x2033, x2032))  ==>  U6^1(false, x2038, x2039, x2040, x2041, x2029, s(x2032))_>=_U8^1(empty(fstsplit(s(x2032), app(map_f(three, head(x2041)), x2029))), x2038, x2039, x2040, x2041, x2029, s(x2032)))  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))



We simplified constraint (9) using rule (VI) where we applied the induction hypothesis (\/x2022,x2023,x2024,x2025,x2026:leq(x2021, x2020)=false & length(x2022)=x2020  ==>  U6^1(false, x2023, x2024, x2025, x2026, x2022, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x2026)), x2022))), x2023, x2024, x2025, x2026, x2022, x2021)) with sigma = [x2022 / x2029, x2023 / x1184, x2024 / x1185, x2025 / x1186, x2026 / x1187] which results in the following new constraint:

(10)    (U6^1(false, x1184, x1185, x1186, x1187, x2029, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x1187)), x2029))), x1184, x1185, x1186, x1187, x2029, x2021) & (\/x2031,x2032,x2033,x2034,x2035,x2036,x2037,x2038,x2039,x2040,x2041:length(x2029)=s(x2031) & leq(x2032, x2031)=false & (\/x2033,x2034,x2035,x2036,x2037:leq(x2032, x2031)=false & length(x2033)=x2031  ==>  U6^1(false, x2034, x2035, x2036, x2037, x2033, x2032)_>=_U8^1(empty(fstsplit(x2032, app(map_f(three, head(x2037)), x2033))), x2034, x2035, x2036, x2037, x2033, x2032))  ==>  U6^1(false, x2038, x2039, x2040, x2041, x2029, s(x2032))_>=_U8^1(empty(fstsplit(s(x2032), app(map_f(three, head(x2041)), x2029))), x2038, x2039, x2040, x2041, x2029, s(x2032)))  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))



We simplified constraint (10) using rule (IV) which results in the following new constraint:

(11)    (U6^1(false, x1184, x1185, x1186, x1187, x2029, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x1187)), x2029))), x1184, x1185, x1186, x1187, x2029, x2021)  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))








For Pair U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m) the following chains were created:
*We consider the chain U6^1(false, x1312, x1313, x1314, x1315, x1316, x1317) -> U8^1(empty(fstsplit(x1317, app(map_f(three, head(x1315)), x1316))), x1312, x1313, x1314, x1315, x1316, x1317), U8^1(false, x1318, x1319, x1320, x1321, x1322, x1323) -> RING(x1318, x1319, x1320, tail(x1321), sndsplit(x1323, app(map_f(three, head(x1321)), x1322)), x1323) which results in the following constraint:

(1)    (U8^1(empty(fstsplit(x1317, app(map_f(three, head(x1315)), x1316))), x1312, x1313, x1314, x1315, x1316, x1317)=U8^1(false, x1318, x1319, x1320, x1321, x1322, x1323)  ==>  U8^1(false, x1318, x1319, x1320, x1321, x1322, x1323)_>=_RING(x1318, x1319, x1320, tail(x1321), sndsplit(x1323, app(map_f(three, head(x1321)), x1322)), x1323))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (fstsplit(x1317, x2043)=x2042 & empty(x2042)=false  ==>  U8^1(false, x1312, x1313, x1314, x1315, x1316, x1317)_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(x1317, app(map_f(three, head(x1315)), x1316)), x1317))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x2042)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x1317, x2043)=cons(x2048, x2047)  ==>  U8^1(false, x1312, x1313, x1314, x1315, x1316, x1317)_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(x1317, app(map_f(three, head(x1315)), x1316)), x1317))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x1317, x2043)=cons(x2048, x2047)  ==>  U8^1(false, x1312, x1313, x1314, x1315, x1316, x1317)_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(x1317, app(map_f(three, head(x1315)), x1316)), x1317))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x1317, x2043)=cons(x2048, x2047) which results in the following new constraint:

(5)    (cons(x2052, fstsplit(x2053, x2051))=cons(x2048, x2047) & (\/x2054,x2055,x2056,x2057,x2058,x2059,x2060:fstsplit(x2053, x2051)=cons(x2054, x2055)  ==>  U8^1(false, x2056, x2057, x2058, x2059, x2060, x2053)_>=_RING(x2056, x2057, x2058, tail(x2059), sndsplit(x2053, app(map_f(three, head(x2059)), x2060)), x2053))  ==>  U8^1(false, x1312, x1313, x1314, x1315, x1316, s(x2053))_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(s(x2053), app(map_f(three, head(x1315)), x1316)), s(x2053)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U8^1(false, x1312, x1313, x1314, x1315, x1316, s(x2053))_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(s(x2053), app(map_f(three, head(x1315)), x1316)), s(x2053)))








For Pair U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x1368, x1369, x1370, x1371, x1372, x1373) -> U2^1(leq(x1373, length(x1370)), x1368, x1369, x1370, x1371, x1372, x1373), U2^1(true, x1374, x1375, x1376, x1377, x1378, x1379) -> U3^1(empty(fstsplit(x1379, x1376)), x1374, x1375, x1376, x1377, x1378, x1379) which results in the following constraint:

(1)    (U2^1(leq(x1373, length(x1370)), x1368, x1369, x1370, x1371, x1372, x1373)=U2^1(true, x1374, x1375, x1376, x1377, x1378, x1379)  ==>  U2^1(true, x1374, x1375, x1376, x1377, x1378, x1379)_>=_U3^1(empty(fstsplit(x1379, x1376)), x1374, x1375, x1376, x1377, x1378, x1379))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x1370)=x2061 & leq(x1373, x2061)=true  ==>  U2^1(true, x1368, x1369, x1370, x1371, x1372, x1373)_>=_U3^1(empty(fstsplit(x1373, x1370)), x1368, x1369, x1370, x1371, x1372, x1373))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x1373, x2061)=true which results in the following new constraints:

(3)    (true=true & length(x1370)=x2062  ==>  U2^1(true, x1368, x1369, x1370, x1371, x1372, 0)_>=_U3^1(empty(fstsplit(0, x1370)), x1368, x1369, x1370, x1371, x1372, 0))

(4)    (leq(x2065, x2064)=true & length(x1370)=s(x2064) & (\/x2066,x2067,x2068,x2069,x2070:leq(x2065, x2064)=true & length(x2066)=x2064  ==>  U2^1(true, x2067, x2068, x2066, x2069, x2070, x2065)_>=_U3^1(empty(fstsplit(x2065, x2066)), x2067, x2068, x2066, x2069, x2070, x2065))  ==>  U2^1(true, x1368, x1369, x1370, x1371, x1372, s(x2065))_>=_U3^1(empty(fstsplit(s(x2065), x1370)), x1368, x1369, x1370, x1371, x1372, s(x2065)))



We simplified constraint (3) using rules (I), (II), (IV) which results in the following new constraint:

(5)    (U2^1(true, x1368, x1369, x1370, x1371, x1372, 0)_>=_U3^1(empty(fstsplit(0, x1370)), x1368, x1369, x1370, x1371, x1372, 0))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x1370)=s(x2064) which results in the following new constraint:

(6)    (s(length(x2071))=s(x2064) & leq(x2065, x2064)=true & (\/x2066,x2067,x2068,x2069,x2070:leq(x2065, x2064)=true & length(x2066)=x2064  ==>  U2^1(true, x2067, x2068, x2066, x2069, x2070, x2065)_>=_U3^1(empty(fstsplit(x2065, x2066)), x2067, x2068, x2066, x2069, x2070, x2065)) & (\/x2073,x2074,x2075,x2076,x2077,x2078,x2079,x2080,x2081,x2082,x2083:length(x2071)=s(x2073) & leq(x2074, x2073)=true & (\/x2075,x2076,x2077,x2078,x2079:leq(x2074, x2073)=true & length(x2075)=x2073  ==>  U2^1(true, x2076, x2077, x2075, x2078, x2079, x2074)_>=_U3^1(empty(fstsplit(x2074, x2075)), x2076, x2077, x2075, x2078, x2079, x2074))  ==>  U2^1(true, x2080, x2081, x2071, x2082, x2083, s(x2074))_>=_U3^1(empty(fstsplit(s(x2074), x2071)), x2080, x2081, x2071, x2082, x2083, s(x2074)))  ==>  U2^1(true, x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065))_>=_U3^1(empty(fstsplit(s(x2065), cons(x2072, x2071))), x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(7)    (length(x2071)=x2064 & leq(x2065, x2064)=true & (\/x2066,x2067,x2068,x2069,x2070:leq(x2065, x2064)=true & length(x2066)=x2064  ==>  U2^1(true, x2067, x2068, x2066, x2069, x2070, x2065)_>=_U3^1(empty(fstsplit(x2065, x2066)), x2067, x2068, x2066, x2069, x2070, x2065)) & (\/x2073,x2074,x2075,x2076,x2077,x2078,x2079,x2080,x2081,x2082,x2083:length(x2071)=s(x2073) & leq(x2074, x2073)=true & (\/x2075,x2076,x2077,x2078,x2079:leq(x2074, x2073)=true & length(x2075)=x2073  ==>  U2^1(true, x2076, x2077, x2075, x2078, x2079, x2074)_>=_U3^1(empty(fstsplit(x2074, x2075)), x2076, x2077, x2075, x2078, x2079, x2074))  ==>  U2^1(true, x2080, x2081, x2071, x2082, x2083, s(x2074))_>=_U3^1(empty(fstsplit(s(x2074), x2071)), x2080, x2081, x2071, x2082, x2083, s(x2074)))  ==>  U2^1(true, x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065))_>=_U3^1(empty(fstsplit(s(x2065), cons(x2072, x2071))), x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065)))



We simplified constraint (7) using rule (VI) where we applied the induction hypothesis (\/x2066,x2067,x2068,x2069,x2070:leq(x2065, x2064)=true & length(x2066)=x2064  ==>  U2^1(true, x2067, x2068, x2066, x2069, x2070, x2065)_>=_U3^1(empty(fstsplit(x2065, x2066)), x2067, x2068, x2066, x2069, x2070, x2065)) with sigma = [x2066 / x2071, x2067 / x1368, x2068 / x1369, x2069 / x1371, x2070 / x1372] which results in the following new constraint:

(8)    (U2^1(true, x1368, x1369, x2071, x1371, x1372, x2065)_>=_U3^1(empty(fstsplit(x2065, x2071)), x1368, x1369, x2071, x1371, x1372, x2065) & (\/x2073,x2074,x2075,x2076,x2077,x2078,x2079,x2080,x2081,x2082,x2083:length(x2071)=s(x2073) & leq(x2074, x2073)=true & (\/x2075,x2076,x2077,x2078,x2079:leq(x2074, x2073)=true & length(x2075)=x2073  ==>  U2^1(true, x2076, x2077, x2075, x2078, x2079, x2074)_>=_U3^1(empty(fstsplit(x2074, x2075)), x2076, x2077, x2075, x2078, x2079, x2074))  ==>  U2^1(true, x2080, x2081, x2071, x2082, x2083, s(x2074))_>=_U3^1(empty(fstsplit(s(x2074), x2071)), x2080, x2081, x2071, x2082, x2083, s(x2074)))  ==>  U2^1(true, x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065))_>=_U3^1(empty(fstsplit(s(x2065), cons(x2072, x2071))), x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065)))



We simplified constraint (8) using rule (IV) which results in the following new constraint:

(9)    (U2^1(true, x1368, x1369, x2071, x1371, x1372, x2065)_>=_U3^1(empty(fstsplit(x2065, x2071)), x1368, x1369, x2071, x1371, x1372, x2065)  ==>  U2^1(true, x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065))_>=_U3^1(empty(fstsplit(s(x2065), cons(x2072, x2071))), x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065)))








For Pair U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m) the following chains were created:
*We consider the chain U2^1(true, x1532, x1533, x1534, x1535, x1536, x1537) -> U3^1(empty(fstsplit(x1537, x1534)), x1532, x1533, x1534, x1535, x1536, x1537), U3^1(false, x1538, x1539, x1540, x1541, x1542, x1543) -> RING(x1538, x1539, sndsplit(x1543, x1540), cons(fstsplit(x1543, x1540), x1541), x1542, x1543) which results in the following constraint:

(1)    (U3^1(empty(fstsplit(x1537, x1534)), x1532, x1533, x1534, x1535, x1536, x1537)=U3^1(false, x1538, x1539, x1540, x1541, x1542, x1543)  ==>  U3^1(false, x1538, x1539, x1540, x1541, x1542, x1543)_>=_RING(x1538, x1539, sndsplit(x1543, x1540), cons(fstsplit(x1543, x1540), x1541), x1542, x1543))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (fstsplit(x1537, x1534)=x2084 & empty(x2084)=false  ==>  U3^1(false, x1532, x1533, x1534, x1535, x1536, x1537)_>=_RING(x1532, x1533, sndsplit(x1537, x1534), cons(fstsplit(x1537, x1534), x1535), x1536, x1537))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x2084)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x1537, x1534)=cons(x2086, x2085)  ==>  U3^1(false, x1532, x1533, x1534, x1535, x1536, x1537)_>=_RING(x1532, x1533, sndsplit(x1537, x1534), cons(fstsplit(x1537, x1534), x1535), x1536, x1537))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x1537, x1534)=cons(x2086, x2085)  ==>  U3^1(false, x1532, x1533, x1534, x1535, x1536, x1537)_>=_RING(x1532, x1533, sndsplit(x1537, x1534), cons(fstsplit(x1537, x1534), x1535), x1536, x1537))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x1537, x1534)=cons(x2086, x2085) which results in the following new constraint:

(5)    (cons(x2090, fstsplit(x2091, x2089))=cons(x2086, x2085) & (\/x2092,x2093,x2094,x2095,x2096,x2097:fstsplit(x2091, x2089)=cons(x2092, x2093)  ==>  U3^1(false, x2094, x2095, x2089, x2096, x2097, x2091)_>=_RING(x2094, x2095, sndsplit(x2091, x2089), cons(fstsplit(x2091, x2089), x2096), x2097, x2091))  ==>  U3^1(false, x1532, x1533, cons(x2090, x2089), x1535, x1536, s(x2091))_>=_RING(x1532, x1533, sndsplit(s(x2091), cons(x2090, x2089)), cons(fstsplit(s(x2091), cons(x2090, x2089)), x1535), x1536, s(x2091)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U3^1(false, x1532, x1533, cons(x2090, x2089), x1535, x1536, s(x2091))_>=_RING(x1532, x1533, sndsplit(s(x2091), cons(x2090, x2089)), cons(fstsplit(s(x2091), cons(x2090, x2089)), x1535), x1536, s(x2091)))








For Pair RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5) the following chains were created:
*We consider the chain U4^1(false, x1742, x1743, x1744, x1745, x1746, x1747) -> RING(x1742, tail(x1743), sndsplit(x1747, app(map_f(two, head(x1743)), x1744)), cons(fstsplit(x1747, app(map_f(two, head(x1743)), x1744)), x1745), x1746, x1747), RING(x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754) -> U9^1(empty(map_f(three, x1751)), x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754) which results in the following constraint:

(1)    (RING(x1742, tail(x1743), sndsplit(x1747, app(map_f(two, head(x1743)), x1744)), cons(fstsplit(x1747, app(map_f(two, head(x1743)), x1744)), x1745), x1746, x1747)=RING(x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754)  ==>  RING(x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754)_>=_U9^1(empty(map_f(three, x1751)), x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x1742, x1749, x1750, cons(x1751, x1745), x1746, x1747)_>=_U9^1(empty(map_f(three, x1751)), x1742, x1749, x1750, cons(x1751, x1745), x1746, x1747))




*We consider the chain U7^1(false, x1780, x1781, x1782, x1783, x1784, x1785) -> RING(x1780, x1781, x1782, x1783, sndsplit(x1785, x1784), x1785), RING(x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792) -> U9^1(empty(map_f(three, x1789)), x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792) which results in the following constraint:

(1)    (RING(x1780, x1781, x1782, x1783, sndsplit(x1785, x1784), x1785)=RING(x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792)  ==>  RING(x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792)_>=_U9^1(empty(map_f(three, x1789)), x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x1780, x1781, x1782, cons(x1789, x1790), x1791, x1785)_>=_U9^1(empty(map_f(three, x1789)), x1780, x1781, x1782, cons(x1789, x1790), x1791, x1785))




*We consider the chain U9^1(true, x1793, x1794, x1795, x1796, x1797, x1798) -> RING(x1793, x1794, x1795, tail(x1796), x1797, x1798), RING(x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805) -> U9^1(empty(map_f(three, x1802)), x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805) which results in the following constraint:

(1)    (RING(x1793, x1794, x1795, tail(x1796), x1797, x1798)=RING(x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805)  ==>  RING(x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805)_>=_U9^1(empty(map_f(three, x1802)), x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (tail(x1796)=cons(x1802, x1803)  ==>  RING(x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798)_>=_U9^1(empty(map_f(three, x1802)), x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on tail(x1796)=cons(x1802, x1803) which results in the following new constraint:

(3)    (x2118=cons(x1802, x1803)  ==>  RING(x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798)_>=_U9^1(empty(map_f(three, x1802)), x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798))



We simplified constraint (3) using rule (III) which results in the following new constraint:

(4)    (RING(x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798)_>=_U9^1(empty(map_f(three, x1802)), x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798))




*We consider the chain U8^1(false, x1812, x1813, x1814, x1815, x1816, x1817) -> RING(x1812, x1813, x1814, tail(x1815), sndsplit(x1817, app(map_f(three, head(x1815)), x1816)), x1817), RING(x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824) -> U9^1(empty(map_f(three, x1821)), x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824) which results in the following constraint:

(1)    (RING(x1812, x1813, x1814, tail(x1815), sndsplit(x1817, app(map_f(three, head(x1815)), x1816)), x1817)=RING(x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824)  ==>  RING(x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824)_>=_U9^1(empty(map_f(three, x1821)), x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (tail(x1815)=cons(x1821, x1822) & app(x2121, x1816)=x2120 & sndsplit(x1817, x2120)=x1823  ==>  RING(x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817)_>=_U9^1(empty(map_f(three, x1821)), x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on tail(x1815)=cons(x1821, x1822) which results in the following new constraint:

(3)    (x2124=cons(x1821, x1822) & app(x2121, x1816)=x2120 & sndsplit(x1817, x2120)=x1823  ==>  RING(x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817)_>=_U9^1(empty(map_f(three, x1821)), x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817))



We simplified constraint (3) using rules (III), (IV) which results in the following new constraint:

(4)    (RING(x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817)_>=_U9^1(empty(map_f(three, x1821)), x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817))




*We consider the chain U3^1(false, x1831, x1832, x1833, x1834, x1835, x1836) -> RING(x1831, x1832, sndsplit(x1836, x1833), cons(fstsplit(x1836, x1833), x1834), x1835, x1836), RING(x1837, x1838, x1839, cons(x1840, x1841), x1842, x1843) -> U9^1(empty(map_f(three, x1840)), x1837, x1838, x1839, cons(x1840, x1841), x1842, x1843) which results in the following constraint:

(1)    (RING(x1831, x1832, sndsplit(x1836, x1833), cons(fstsplit(x1836, x1833), x1834), x1835, x1836)=RING(x1837, x1838, x1839, cons(x1840, x1841), x1842, x1843)  ==>  RING(x1837, x1838, x1839, cons(x1840, x1841), x1842, x1843)_>=_U9^1(empty(map_f(three, x1840)), x1837, x1838, x1839, cons(x1840, x1841), x1842, x1843))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x1831, x1832, x1839, cons(x1840, x1834), x1835, x1836)_>=_U9^1(empty(map_f(three, x1840)), x1831, x1832, x1839, cons(x1840, x1834), x1835, x1836))








To summarize, we get the following constraints P__>=_ for the following pairs.

*RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)

*(RING(x274, x281, x282, x283, x278, x279)_>=_U2^1(leq(x279, length(x282)), x274, x281, x282, x283, x278, x279))


*(RING(x310, x311, x312, x313, x320, x315)_>=_U2^1(leq(x315, length(x312)), x310, x311, x312, x313, x320, x315))


*(RING(x322, x323, x324, x331, x326, x327)_>=_U2^1(leq(x327, length(x324)), x322, x323, x324, x331, x326, x327))


*(RING(x340, x341, x342, x349, x350, x345)_>=_U2^1(leq(x345, length(x342)), x340, x341, x342, x349, x350, x345))


*(RING(x358, x359, x366, x367, x362, x363)_>=_U2^1(leq(x363, length(x366)), x358, x359, x366, x367, x362, x363))




*U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)

*(U2^1(false, x396, x397, nil, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), nil))), x396, x397, nil, x399, x400, s(x1890)))


*(U2^1(false, x396, x397, x1900, x399, x400, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x397)), x1900))), x396, x397, x1900, x399, x400, x1892)  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))




*U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)

*(U4^1(false, x506, x507, x508, x509, x510, s(x1924))_>=_RING(x506, tail(x507), sndsplit(s(x1924), app(map_f(two, head(x507)), x508)), cons(fstsplit(s(x1924), app(map_f(two, head(x507)), x508)), x509), x510, s(x1924)))




*RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)

*(RING(x726, x733, x734, x735, x730, x731)_>=_U6^1(leq(x731, length(x730)), x726, x733, x734, x735, x730, x731))


*(RING(x762, x763, x764, x765, x772, x767)_>=_U6^1(leq(x767, length(x772)), x762, x763, x764, x765, x772, x767))


*(RING(x774, x775, x776, x783, x778, x779)_>=_U6^1(leq(x779, length(x778)), x774, x775, x776, x783, x778, x779))


*(RING(x792, x793, x794, x801, x802, x797)_>=_U6^1(leq(x797, length(x802)), x792, x793, x794, x801, x802, x797))


*(RING(x810, x811, x818, x819, x814, x815)_>=_U6^1(leq(x815, length(x814)), x810, x811, x818, x819, x814, x815))




*U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)

*(U6^1(true, x872, x873, x874, x875, x876, 0)_>=_U7^1(empty(fstsplit(0, x876)), x872, x873, x874, x875, x876, 0))


*(U6^1(true, x872, x873, x874, x875, x1970, x1964)_>=_U7^1(empty(fstsplit(x1964, x1970)), x872, x873, x874, x875, x1970, x1964)  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))




*U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)

*(U7^1(false, x982, x983, x984, x985, cons(x1989, x1988), s(x1990))_>=_RING(x982, x983, x984, x985, sndsplit(s(x1990), cons(x1989, x1988)), s(x1990)))




*U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)

*(U9^1(true, x1135, x1136, x1137, cons(nil, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(nil, x1139)), x1140, x1141))




*U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)

*(U6^1(false, x1184, x1185, x1186, x1187, nil, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), nil))), x1184, x1185, x1186, x1187, nil, s(x2019)))


*(U6^1(false, x1184, x1185, x1186, x1187, x2029, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x1187)), x2029))), x1184, x1185, x1186, x1187, x2029, x2021)  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))




*U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

*(U8^1(false, x1312, x1313, x1314, x1315, x1316, s(x2053))_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(s(x2053), app(map_f(three, head(x1315)), x1316)), s(x2053)))




*U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)

*(U2^1(true, x1368, x1369, x1370, x1371, x1372, 0)_>=_U3^1(empty(fstsplit(0, x1370)), x1368, x1369, x1370, x1371, x1372, 0))


*(U2^1(true, x1368, x1369, x2071, x1371, x1372, x2065)_>=_U3^1(empty(fstsplit(x2065, x2071)), x1368, x1369, x2071, x1371, x1372, x2065)  ==>  U2^1(true, x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065))_>=_U3^1(empty(fstsplit(s(x2065), cons(x2072, x2071))), x1368, x1369, cons(x2072, x2071), x1371, x1372, s(x2065)))




*U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)

*(U3^1(false, x1532, x1533, cons(x2090, x2089), x1535, x1536, s(x2091))_>=_RING(x1532, x1533, sndsplit(s(x2091), cons(x2090, x2089)), cons(fstsplit(s(x2091), cons(x2090, x2089)), x1535), x1536, s(x2091)))




*RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)

*(RING(x1742, x1749, x1750, cons(x1751, x1745), x1746, x1747)_>=_U9^1(empty(map_f(three, x1751)), x1742, x1749, x1750, cons(x1751, x1745), x1746, x1747))


*(RING(x1780, x1781, x1782, cons(x1789, x1790), x1791, x1785)_>=_U9^1(empty(map_f(three, x1789)), x1780, x1781, x1782, cons(x1789, x1790), x1791, x1785))


*(RING(x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798)_>=_U9^1(empty(map_f(three, x1802)), x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798))


*(RING(x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817)_>=_U9^1(empty(map_f(three, x1821)), x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817))


*(RING(x1831, x1832, x1839, cons(x1840, x1834), x1835, x1836)_>=_U9^1(empty(map_f(three, x1840)), x1831, x1832, x1839, cons(x1840, x1834), x1835, x1836))








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation [NONINF]:

   POL(0) = 0
   POL(RING(x_1, x_2, x_3, x_4, x_5, x_6)) = x_1 - x_3 - x_6
   POL(U2^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 - x_4 - x_7
   POL(U3^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 + x_1 + x_2 - x_4 - x_7
   POL(U4^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 + x_1 + x_2 - x_7
   POL(U6^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 - x_4 - x_7
   POL(U7^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_1 + x_2 - x_4 - x_7
   POL(U8^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_1 + x_2 - x_4 - x_7
   POL(U9^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_1 + x_2 - x_4 - x_5 - x_7
   POL(app(x_1, x_2)) = 0
   POL(c) = -2
   POL(cons(x_1, x_2)) = 0
   POL(empty(x_1)) = 0
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(false) = 0
   POL(fstsplit(x_1, x_2)) = 0
   POL(head(x_1)) = 0
   POL(length(x_1)) = 0
   POL(leq(x_1, x_2)) = 0
   POL(map_f(x_1, x_2)) = 0
   POL(nil) = 1
   POL(s(x_1)) = 1
   POL(sndsplit(x_1, x_2)) = x_1
   POL(tail(x_1)) = 0
   POL(three) = 0
   POL(true) = 0
   POL(two) = 0


The following pairs  are in P_>:
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
The following pairs are in P_bound:
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
The following rules are usable:
   empty(nil) -> true
   empty(cons(h, t)) -> false
   x -> sndsplit(0, x)
   nil -> sndsplit(s(n), nil)

----------------------------------------

(71)
Complex Obligation (AND)

----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U3^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, sndsplit(m, st_2), cons(fstsplit(m, st_2), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(73) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(74)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(75) NonInfProof (EQUIVALENT)
The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain U4^1(false, x274, x275, x276, x277, x278, x279) -> RING(x274, tail(x275), sndsplit(x279, app(map_f(two, head(x275)), x276)), cons(fstsplit(x279, app(map_f(two, head(x275)), x276)), x277), x278, x279), RING(x280, x281, x282, x283, x284, x285) -> U2^1(leq(x285, length(x282)), x280, x281, x282, x283, x284, x285) which results in the following constraint:

(1)    (RING(x274, tail(x275), sndsplit(x279, app(map_f(two, head(x275)), x276)), cons(fstsplit(x279, app(map_f(two, head(x275)), x276)), x277), x278, x279)=RING(x280, x281, x282, x283, x284, x285)  ==>  RING(x280, x281, x282, x283, x284, x285)_>=_U2^1(leq(x285, length(x282)), x280, x281, x282, x283, x284, x285))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x274, x281, x282, x283, x278, x279)_>=_U2^1(leq(x279, length(x282)), x274, x281, x282, x283, x278, x279))




*We consider the chain U7^1(false, x310, x311, x312, x313, x314, x315) -> RING(x310, x311, x312, x313, sndsplit(x315, x314), x315), RING(x316, x317, x318, x319, x320, x321) -> U2^1(leq(x321, length(x318)), x316, x317, x318, x319, x320, x321) which results in the following constraint:

(1)    (RING(x310, x311, x312, x313, sndsplit(x315, x314), x315)=RING(x316, x317, x318, x319, x320, x321)  ==>  RING(x316, x317, x318, x319, x320, x321)_>=_U2^1(leq(x321, length(x318)), x316, x317, x318, x319, x320, x321))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x310, x311, x312, x313, x320, x315)_>=_U2^1(leq(x315, length(x312)), x310, x311, x312, x313, x320, x315))




*We consider the chain U9^1(true, x322, x323, x324, x325, x326, x327) -> RING(x322, x323, x324, tail(x325), x326, x327), RING(x328, x329, x330, x331, x332, x333) -> U2^1(leq(x333, length(x330)), x328, x329, x330, x331, x332, x333) which results in the following constraint:

(1)    (RING(x322, x323, x324, tail(x325), x326, x327)=RING(x328, x329, x330, x331, x332, x333)  ==>  RING(x328, x329, x330, x331, x332, x333)_>=_U2^1(leq(x333, length(x330)), x328, x329, x330, x331, x332, x333))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x322, x323, x324, x331, x326, x327)_>=_U2^1(leq(x327, length(x324)), x322, x323, x324, x331, x326, x327))




*We consider the chain U8^1(false, x340, x341, x342, x343, x344, x345) -> RING(x340, x341, x342, tail(x343), sndsplit(x345, app(map_f(three, head(x343)), x344)), x345), RING(x346, x347, x348, x349, x350, x351) -> U2^1(leq(x351, length(x348)), x346, x347, x348, x349, x350, x351) which results in the following constraint:

(1)    (RING(x340, x341, x342, tail(x343), sndsplit(x345, app(map_f(three, head(x343)), x344)), x345)=RING(x346, x347, x348, x349, x350, x351)  ==>  RING(x346, x347, x348, x349, x350, x351)_>=_U2^1(leq(x351, length(x348)), x346, x347, x348, x349, x350, x351))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x340, x341, x342, x349, x350, x345)_>=_U2^1(leq(x345, length(x342)), x340, x341, x342, x349, x350, x345))








For Pair U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x396, x397, x398, x399, x400, x401) -> U2^1(leq(x401, length(x398)), x396, x397, x398, x399, x400, x401), U2^1(false, x402, x403, x404, x405, x406, x407) -> U4^1(empty(fstsplit(x407, app(map_f(two, head(x403)), x404))), x402, x403, x404, x405, x406, x407) which results in the following constraint:

(1)    (U2^1(leq(x401, length(x398)), x396, x397, x398, x399, x400, x401)=U2^1(false, x402, x403, x404, x405, x406, x407)  ==>  U2^1(false, x402, x403, x404, x405, x406, x407)_>=_U4^1(empty(fstsplit(x407, app(map_f(two, head(x403)), x404))), x402, x403, x404, x405, x406, x407))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x398)=x1888 & leq(x401, x1888)=false  ==>  U2^1(false, x396, x397, x398, x399, x400, x401)_>=_U4^1(empty(fstsplit(x401, app(map_f(two, head(x397)), x398))), x396, x397, x398, x399, x400, x401))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x401, x1888)=false which results in the following new constraints:

(3)    (false=false & length(x398)=0  ==>  U2^1(false, x396, x397, x398, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), x398))), x396, x397, x398, x399, x400, s(x1890)))

(4)    (leq(x1892, x1891)=false & length(x398)=s(x1891) & (\/x1893,x1894,x1895,x1896,x1897:leq(x1892, x1891)=false & length(x1893)=x1891  ==>  U2^1(false, x1894, x1895, x1893, x1896, x1897, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x1895)), x1893))), x1894, x1895, x1893, x1896, x1897, x1892))  ==>  U2^1(false, x396, x397, x398, x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), x398))), x396, x397, x398, x399, x400, s(x1892)))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (length(x398)=0  ==>  U2^1(false, x396, x397, x398, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), x398))), x396, x397, x398, x399, x400, s(x1890)))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x398)=s(x1891) which results in the following new constraint:

(6)    (s(length(x1900))=s(x1891) & leq(x1892, x1891)=false & (\/x1893,x1894,x1895,x1896,x1897:leq(x1892, x1891)=false & length(x1893)=x1891  ==>  U2^1(false, x1894, x1895, x1893, x1896, x1897, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x1895)), x1893))), x1894, x1895, x1893, x1896, x1897, x1892)) & (\/x1902,x1903,x1904,x1905,x1906,x1907,x1908,x1909,x1910,x1911,x1912:length(x1900)=s(x1902) & leq(x1903, x1902)=false & (\/x1904,x1905,x1906,x1907,x1908:leq(x1903, x1902)=false & length(x1904)=x1902  ==>  U2^1(false, x1905, x1906, x1904, x1907, x1908, x1903)_>=_U4^1(empty(fstsplit(x1903, app(map_f(two, head(x1906)), x1904))), x1905, x1906, x1904, x1907, x1908, x1903))  ==>  U2^1(false, x1909, x1910, x1900, x1911, x1912, s(x1903))_>=_U4^1(empty(fstsplit(s(x1903), app(map_f(two, head(x1910)), x1900))), x1909, x1910, x1900, x1911, x1912, s(x1903)))  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))



We simplified constraint (5) using rule (V) (with possible (I) afterwards) using induction on length(x398)=0 which results in the following new constraint:

(7)    (0=0  ==>  U2^1(false, x396, x397, nil, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), nil))), x396, x397, nil, x399, x400, s(x1890)))



We simplified constraint (7) using rules (I), (II) which results in the following new constraint:

(8)    (U2^1(false, x396, x397, nil, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), nil))), x396, x397, nil, x399, x400, s(x1890)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(9)    (length(x1900)=x1891 & leq(x1892, x1891)=false & (\/x1893,x1894,x1895,x1896,x1897:leq(x1892, x1891)=false & length(x1893)=x1891  ==>  U2^1(false, x1894, x1895, x1893, x1896, x1897, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x1895)), x1893))), x1894, x1895, x1893, x1896, x1897, x1892)) & (\/x1902,x1903,x1904,x1905,x1906,x1907,x1908,x1909,x1910,x1911,x1912:length(x1900)=s(x1902) & leq(x1903, x1902)=false & (\/x1904,x1905,x1906,x1907,x1908:leq(x1903, x1902)=false & length(x1904)=x1902  ==>  U2^1(false, x1905, x1906, x1904, x1907, x1908, x1903)_>=_U4^1(empty(fstsplit(x1903, app(map_f(two, head(x1906)), x1904))), x1905, x1906, x1904, x1907, x1908, x1903))  ==>  U2^1(false, x1909, x1910, x1900, x1911, x1912, s(x1903))_>=_U4^1(empty(fstsplit(s(x1903), app(map_f(two, head(x1910)), x1900))), x1909, x1910, x1900, x1911, x1912, s(x1903)))  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))



We simplified constraint (9) using rule (VI) where we applied the induction hypothesis (\/x1893,x1894,x1895,x1896,x1897:leq(x1892, x1891)=false & length(x1893)=x1891  ==>  U2^1(false, x1894, x1895, x1893, x1896, x1897, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x1895)), x1893))), x1894, x1895, x1893, x1896, x1897, x1892)) with sigma = [x1893 / x1900, x1894 / x396, x1895 / x397, x1896 / x399, x1897 / x400] which results in the following new constraint:

(10)    (U2^1(false, x396, x397, x1900, x399, x400, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x397)), x1900))), x396, x397, x1900, x399, x400, x1892) & (\/x1902,x1903,x1904,x1905,x1906,x1907,x1908,x1909,x1910,x1911,x1912:length(x1900)=s(x1902) & leq(x1903, x1902)=false & (\/x1904,x1905,x1906,x1907,x1908:leq(x1903, x1902)=false & length(x1904)=x1902  ==>  U2^1(false, x1905, x1906, x1904, x1907, x1908, x1903)_>=_U4^1(empty(fstsplit(x1903, app(map_f(two, head(x1906)), x1904))), x1905, x1906, x1904, x1907, x1908, x1903))  ==>  U2^1(false, x1909, x1910, x1900, x1911, x1912, s(x1903))_>=_U4^1(empty(fstsplit(s(x1903), app(map_f(two, head(x1910)), x1900))), x1909, x1910, x1900, x1911, x1912, s(x1903)))  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))



We simplified constraint (10) using rule (IV) which results in the following new constraint:

(11)    (U2^1(false, x396, x397, x1900, x399, x400, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x397)), x1900))), x396, x397, x1900, x399, x400, x1892)  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))








For Pair U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m) the following chains were created:
*We consider the chain U2^1(false, x506, x507, x508, x509, x510, x511) -> U4^1(empty(fstsplit(x511, app(map_f(two, head(x507)), x508))), x506, x507, x508, x509, x510, x511), U4^1(false, x512, x513, x514, x515, x516, x517) -> RING(x512, tail(x513), sndsplit(x517, app(map_f(two, head(x513)), x514)), cons(fstsplit(x517, app(map_f(two, head(x513)), x514)), x515), x516, x517) which results in the following constraint:

(1)    (U4^1(empty(fstsplit(x511, app(map_f(two, head(x507)), x508))), x506, x507, x508, x509, x510, x511)=U4^1(false, x512, x513, x514, x515, x516, x517)  ==>  U4^1(false, x512, x513, x514, x515, x516, x517)_>=_RING(x512, tail(x513), sndsplit(x517, app(map_f(two, head(x513)), x514)), cons(fstsplit(x517, app(map_f(two, head(x513)), x514)), x515), x516, x517))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (fstsplit(x511, x1914)=x1913 & empty(x1913)=false  ==>  U4^1(false, x506, x507, x508, x509, x510, x511)_>=_RING(x506, tail(x507), sndsplit(x511, app(map_f(two, head(x507)), x508)), cons(fstsplit(x511, app(map_f(two, head(x507)), x508)), x509), x510, x511))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x1913)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x511, x1914)=cons(x1919, x1918)  ==>  U4^1(false, x506, x507, x508, x509, x510, x511)_>=_RING(x506, tail(x507), sndsplit(x511, app(map_f(two, head(x507)), x508)), cons(fstsplit(x511, app(map_f(two, head(x507)), x508)), x509), x510, x511))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x511, x1914)=cons(x1919, x1918)  ==>  U4^1(false, x506, x507, x508, x509, x510, x511)_>=_RING(x506, tail(x507), sndsplit(x511, app(map_f(two, head(x507)), x508)), cons(fstsplit(x511, app(map_f(two, head(x507)), x508)), x509), x510, x511))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x511, x1914)=cons(x1919, x1918) which results in the following new constraint:

(5)    (cons(x1923, fstsplit(x1924, x1922))=cons(x1919, x1918) & (\/x1925,x1926,x1927,x1928,x1929,x1930,x1931:fstsplit(x1924, x1922)=cons(x1925, x1926)  ==>  U4^1(false, x1927, x1928, x1929, x1930, x1931, x1924)_>=_RING(x1927, tail(x1928), sndsplit(x1924, app(map_f(two, head(x1928)), x1929)), cons(fstsplit(x1924, app(map_f(two, head(x1928)), x1929)), x1930), x1931, x1924))  ==>  U4^1(false, x506, x507, x508, x509, x510, s(x1924))_>=_RING(x506, tail(x507), sndsplit(s(x1924), app(map_f(two, head(x507)), x508)), cons(fstsplit(s(x1924), app(map_f(two, head(x507)), x508)), x509), x510, s(x1924)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U4^1(false, x506, x507, x508, x509, x510, s(x1924))_>=_RING(x506, tail(x507), sndsplit(s(x1924), app(map_f(two, head(x507)), x508)), cons(fstsplit(s(x1924), app(map_f(two, head(x507)), x508)), x509), x510, s(x1924)))








For Pair RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain U4^1(false, x726, x727, x728, x729, x730, x731) -> RING(x726, tail(x727), sndsplit(x731, app(map_f(two, head(x727)), x728)), cons(fstsplit(x731, app(map_f(two, head(x727)), x728)), x729), x730, x731), RING(x732, x733, x734, x735, x736, x737) -> U6^1(leq(x737, length(x736)), x732, x733, x734, x735, x736, x737) which results in the following constraint:

(1)    (RING(x726, tail(x727), sndsplit(x731, app(map_f(two, head(x727)), x728)), cons(fstsplit(x731, app(map_f(two, head(x727)), x728)), x729), x730, x731)=RING(x732, x733, x734, x735, x736, x737)  ==>  RING(x732, x733, x734, x735, x736, x737)_>=_U6^1(leq(x737, length(x736)), x732, x733, x734, x735, x736, x737))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x726, x733, x734, x735, x730, x731)_>=_U6^1(leq(x731, length(x730)), x726, x733, x734, x735, x730, x731))




*We consider the chain U7^1(false, x762, x763, x764, x765, x766, x767) -> RING(x762, x763, x764, x765, sndsplit(x767, x766), x767), RING(x768, x769, x770, x771, x772, x773) -> U6^1(leq(x773, length(x772)), x768, x769, x770, x771, x772, x773) which results in the following constraint:

(1)    (RING(x762, x763, x764, x765, sndsplit(x767, x766), x767)=RING(x768, x769, x770, x771, x772, x773)  ==>  RING(x768, x769, x770, x771, x772, x773)_>=_U6^1(leq(x773, length(x772)), x768, x769, x770, x771, x772, x773))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x762, x763, x764, x765, x772, x767)_>=_U6^1(leq(x767, length(x772)), x762, x763, x764, x765, x772, x767))




*We consider the chain U9^1(true, x774, x775, x776, x777, x778, x779) -> RING(x774, x775, x776, tail(x777), x778, x779), RING(x780, x781, x782, x783, x784, x785) -> U6^1(leq(x785, length(x784)), x780, x781, x782, x783, x784, x785) which results in the following constraint:

(1)    (RING(x774, x775, x776, tail(x777), x778, x779)=RING(x780, x781, x782, x783, x784, x785)  ==>  RING(x780, x781, x782, x783, x784, x785)_>=_U6^1(leq(x785, length(x784)), x780, x781, x782, x783, x784, x785))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x774, x775, x776, x783, x778, x779)_>=_U6^1(leq(x779, length(x778)), x774, x775, x776, x783, x778, x779))




*We consider the chain U8^1(false, x792, x793, x794, x795, x796, x797) -> RING(x792, x793, x794, tail(x795), sndsplit(x797, app(map_f(three, head(x795)), x796)), x797), RING(x798, x799, x800, x801, x802, x803) -> U6^1(leq(x803, length(x802)), x798, x799, x800, x801, x802, x803) which results in the following constraint:

(1)    (RING(x792, x793, x794, tail(x795), sndsplit(x797, app(map_f(three, head(x795)), x796)), x797)=RING(x798, x799, x800, x801, x802, x803)  ==>  RING(x798, x799, x800, x801, x802, x803)_>=_U6^1(leq(x803, length(x802)), x798, x799, x800, x801, x802, x803))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x792, x793, x794, x801, x802, x797)_>=_U6^1(leq(x797, length(x802)), x792, x793, x794, x801, x802, x797))








For Pair U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x872, x873, x874, x875, x876, x877) -> U6^1(leq(x877, length(x876)), x872, x873, x874, x875, x876, x877), U6^1(true, x878, x879, x880, x881, x882, x883) -> U7^1(empty(fstsplit(x883, x882)), x878, x879, x880, x881, x882, x883) which results in the following constraint:

(1)    (U6^1(leq(x877, length(x876)), x872, x873, x874, x875, x876, x877)=U6^1(true, x878, x879, x880, x881, x882, x883)  ==>  U6^1(true, x878, x879, x880, x881, x882, x883)_>=_U7^1(empty(fstsplit(x883, x882)), x878, x879, x880, x881, x882, x883))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x876)=x1960 & leq(x877, x1960)=true  ==>  U6^1(true, x872, x873, x874, x875, x876, x877)_>=_U7^1(empty(fstsplit(x877, x876)), x872, x873, x874, x875, x876, x877))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x877, x1960)=true which results in the following new constraints:

(3)    (true=true & length(x876)=x1961  ==>  U6^1(true, x872, x873, x874, x875, x876, 0)_>=_U7^1(empty(fstsplit(0, x876)), x872, x873, x874, x875, x876, 0))

(4)    (leq(x1964, x1963)=true & length(x876)=s(x1963) & (\/x1965,x1966,x1967,x1968,x1969:leq(x1964, x1963)=true & length(x1965)=x1963  ==>  U6^1(true, x1966, x1967, x1968, x1969, x1965, x1964)_>=_U7^1(empty(fstsplit(x1964, x1965)), x1966, x1967, x1968, x1969, x1965, x1964))  ==>  U6^1(true, x872, x873, x874, x875, x876, s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), x876)), x872, x873, x874, x875, x876, s(x1964)))



We simplified constraint (3) using rules (I), (II), (IV) which results in the following new constraint:

(5)    (U6^1(true, x872, x873, x874, x875, x876, 0)_>=_U7^1(empty(fstsplit(0, x876)), x872, x873, x874, x875, x876, 0))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x876)=s(x1963) which results in the following new constraint:

(6)    (s(length(x1970))=s(x1963) & leq(x1964, x1963)=true & (\/x1965,x1966,x1967,x1968,x1969:leq(x1964, x1963)=true & length(x1965)=x1963  ==>  U6^1(true, x1966, x1967, x1968, x1969, x1965, x1964)_>=_U7^1(empty(fstsplit(x1964, x1965)), x1966, x1967, x1968, x1969, x1965, x1964)) & (\/x1972,x1973,x1974,x1975,x1976,x1977,x1978,x1979,x1980,x1981,x1982:length(x1970)=s(x1972) & leq(x1973, x1972)=true & (\/x1974,x1975,x1976,x1977,x1978:leq(x1973, x1972)=true & length(x1974)=x1972  ==>  U6^1(true, x1975, x1976, x1977, x1978, x1974, x1973)_>=_U7^1(empty(fstsplit(x1973, x1974)), x1975, x1976, x1977, x1978, x1974, x1973))  ==>  U6^1(true, x1979, x1980, x1981, x1982, x1970, s(x1973))_>=_U7^1(empty(fstsplit(s(x1973), x1970)), x1979, x1980, x1981, x1982, x1970, s(x1973)))  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(7)    (length(x1970)=x1963 & leq(x1964, x1963)=true & (\/x1965,x1966,x1967,x1968,x1969:leq(x1964, x1963)=true & length(x1965)=x1963  ==>  U6^1(true, x1966, x1967, x1968, x1969, x1965, x1964)_>=_U7^1(empty(fstsplit(x1964, x1965)), x1966, x1967, x1968, x1969, x1965, x1964)) & (\/x1972,x1973,x1974,x1975,x1976,x1977,x1978,x1979,x1980,x1981,x1982:length(x1970)=s(x1972) & leq(x1973, x1972)=true & (\/x1974,x1975,x1976,x1977,x1978:leq(x1973, x1972)=true & length(x1974)=x1972  ==>  U6^1(true, x1975, x1976, x1977, x1978, x1974, x1973)_>=_U7^1(empty(fstsplit(x1973, x1974)), x1975, x1976, x1977, x1978, x1974, x1973))  ==>  U6^1(true, x1979, x1980, x1981, x1982, x1970, s(x1973))_>=_U7^1(empty(fstsplit(s(x1973), x1970)), x1979, x1980, x1981, x1982, x1970, s(x1973)))  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))



We simplified constraint (7) using rule (VI) where we applied the induction hypothesis (\/x1965,x1966,x1967,x1968,x1969:leq(x1964, x1963)=true & length(x1965)=x1963  ==>  U6^1(true, x1966, x1967, x1968, x1969, x1965, x1964)_>=_U7^1(empty(fstsplit(x1964, x1965)), x1966, x1967, x1968, x1969, x1965, x1964)) with sigma = [x1965 / x1970, x1966 / x872, x1967 / x873, x1968 / x874, x1969 / x875] which results in the following new constraint:

(8)    (U6^1(true, x872, x873, x874, x875, x1970, x1964)_>=_U7^1(empty(fstsplit(x1964, x1970)), x872, x873, x874, x875, x1970, x1964) & (\/x1972,x1973,x1974,x1975,x1976,x1977,x1978,x1979,x1980,x1981,x1982:length(x1970)=s(x1972) & leq(x1973, x1972)=true & (\/x1974,x1975,x1976,x1977,x1978:leq(x1973, x1972)=true & length(x1974)=x1972  ==>  U6^1(true, x1975, x1976, x1977, x1978, x1974, x1973)_>=_U7^1(empty(fstsplit(x1973, x1974)), x1975, x1976, x1977, x1978, x1974, x1973))  ==>  U6^1(true, x1979, x1980, x1981, x1982, x1970, s(x1973))_>=_U7^1(empty(fstsplit(s(x1973), x1970)), x1979, x1980, x1981, x1982, x1970, s(x1973)))  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))



We simplified constraint (8) using rule (IV) which results in the following new constraint:

(9)    (U6^1(true, x872, x873, x874, x875, x1970, x1964)_>=_U7^1(empty(fstsplit(x1964, x1970)), x872, x873, x874, x875, x1970, x1964)  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))








For Pair U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m) the following chains were created:
*We consider the chain U6^1(true, x982, x983, x984, x985, x986, x987) -> U7^1(empty(fstsplit(x987, x986)), x982, x983, x984, x985, x986, x987), U7^1(false, x988, x989, x990, x991, x992, x993) -> RING(x988, x989, x990, x991, sndsplit(x993, x992), x993) which results in the following constraint:

(1)    (U7^1(empty(fstsplit(x987, x986)), x982, x983, x984, x985, x986, x987)=U7^1(false, x988, x989, x990, x991, x992, x993)  ==>  U7^1(false, x988, x989, x990, x991, x992, x993)_>=_RING(x988, x989, x990, x991, sndsplit(x993, x992), x993))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (fstsplit(x987, x986)=x1983 & empty(x1983)=false  ==>  U7^1(false, x982, x983, x984, x985, x986, x987)_>=_RING(x982, x983, x984, x985, sndsplit(x987, x986), x987))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x1983)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x987, x986)=cons(x1985, x1984)  ==>  U7^1(false, x982, x983, x984, x985, x986, x987)_>=_RING(x982, x983, x984, x985, sndsplit(x987, x986), x987))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x987, x986)=cons(x1985, x1984)  ==>  U7^1(false, x982, x983, x984, x985, x986, x987)_>=_RING(x982, x983, x984, x985, sndsplit(x987, x986), x987))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x987, x986)=cons(x1985, x1984) which results in the following new constraint:

(5)    (cons(x1989, fstsplit(x1990, x1988))=cons(x1985, x1984) & (\/x1991,x1992,x1993,x1994,x1995,x1996:fstsplit(x1990, x1988)=cons(x1991, x1992)  ==>  U7^1(false, x1993, x1994, x1995, x1996, x1988, x1990)_>=_RING(x1993, x1994, x1995, x1996, sndsplit(x1990, x1988), x1990))  ==>  U7^1(false, x982, x983, x984, x985, cons(x1989, x1988), s(x1990))_>=_RING(x982, x983, x984, x985, sndsplit(s(x1990), cons(x1989, x1988)), s(x1990)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U7^1(false, x982, x983, x984, x985, cons(x1989, x1988), s(x1990))_>=_RING(x982, x983, x984, x985, sndsplit(s(x1990), cons(x1989, x1988)), s(x1990)))








For Pair U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m) the following chains were created:
*We consider the chain RING(x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141) -> U9^1(empty(map_f(three, x1138)), x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141), U9^1(true, x1142, x1143, x1144, x1145, x1146, x1147) -> RING(x1142, x1143, x1144, tail(x1145), x1146, x1147) which results in the following constraint:

(1)    (U9^1(empty(map_f(three, x1138)), x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141)=U9^1(true, x1142, x1143, x1144, x1145, x1146, x1147)  ==>  U9^1(true, x1142, x1143, x1144, x1145, x1146, x1147)_>=_RING(x1142, x1143, x1144, tail(x1145), x1146, x1147))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (three=x1998 & map_f(x1998, x1138)=x1997 & empty(x1997)=true  ==>  U9^1(true, x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(x1138, x1139)), x1140, x1141))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x1997)=true which results in the following new constraint:

(3)    (true=true & three=x1998 & map_f(x1998, x1138)=nil  ==>  U9^1(true, x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(x1138, x1139)), x1140, x1141))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (three=x1998 & map_f(x1998, x1138)=nil  ==>  U9^1(true, x1135, x1136, x1137, cons(x1138, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(x1138, x1139)), x1140, x1141))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on map_f(x1998, x1138)=nil which results in the following new constraints:

(5)    (nil=nil & three=x2001  ==>  U9^1(true, x1135, x1136, x1137, cons(nil, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(nil, x1139)), x1140, x1141))

(6)    (app(f(x2004, x2003), map_f(x2004, x2002))=nil & three=x2004 & (\/x2005,x2006,x2007,x2008,x2009,x2010:map_f(x2004, x2002)=nil & three=x2004  ==>  U9^1(true, x2005, x2006, x2007, cons(x2002, x2008), x2009, x2010)_>=_RING(x2005, x2006, x2007, tail(cons(x2002, x2008)), x2009, x2010))  ==>  U9^1(true, x1135, x1136, x1137, cons(cons(x2003, x2002), x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(cons(x2003, x2002), x1139)), x1140, x1141))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(7)    (U9^1(true, x1135, x1136, x1137, cons(nil, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(nil, x1139)), x1140, x1141))



We simplified constraint (6) using rules (IV), (VII) which results in the following new constraint:

(8)    (f(x2004, x2003)=x2011 & map_f(x2004, x2002)=x2012 & app(x2011, x2012)=nil & three=x2004  ==>  U9^1(true, x1135, x1136, x1137, cons(cons(x2003, x2002), x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(cons(x2003, x2002), x1139)), x1140, x1141))



We simplified constraint (8) using rule (V) (with possible (I) afterwards) using induction on app(x2011, x2012)=nil which results in the following new constraint:

(9)    (x2013=nil & f(x2004, x2003)=nil & map_f(x2004, x2002)=x2013 & three=x2004  ==>  U9^1(true, x1135, x1136, x1137, cons(cons(x2003, x2002), x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(cons(x2003, x2002), x1139)), x1140, x1141))



We solved constraint (9) using rules (I), (II).




For Pair U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x1184, x1185, x1186, x1187, x1188, x1189) -> U6^1(leq(x1189, length(x1188)), x1184, x1185, x1186, x1187, x1188, x1189), U6^1(false, x1190, x1191, x1192, x1193, x1194, x1195) -> U8^1(empty(fstsplit(x1195, app(map_f(three, head(x1193)), x1194))), x1190, x1191, x1192, x1193, x1194, x1195) which results in the following constraint:

(1)    (U6^1(leq(x1189, length(x1188)), x1184, x1185, x1186, x1187, x1188, x1189)=U6^1(false, x1190, x1191, x1192, x1193, x1194, x1195)  ==>  U6^1(false, x1190, x1191, x1192, x1193, x1194, x1195)_>=_U8^1(empty(fstsplit(x1195, app(map_f(three, head(x1193)), x1194))), x1190, x1191, x1192, x1193, x1194, x1195))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x1188)=x2017 & leq(x1189, x2017)=false  ==>  U6^1(false, x1184, x1185, x1186, x1187, x1188, x1189)_>=_U8^1(empty(fstsplit(x1189, app(map_f(three, head(x1187)), x1188))), x1184, x1185, x1186, x1187, x1188, x1189))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x1189, x2017)=false which results in the following new constraints:

(3)    (false=false & length(x1188)=0  ==>  U6^1(false, x1184, x1185, x1186, x1187, x1188, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), x1188))), x1184, x1185, x1186, x1187, x1188, s(x2019)))

(4)    (leq(x2021, x2020)=false & length(x1188)=s(x2020) & (\/x2022,x2023,x2024,x2025,x2026:leq(x2021, x2020)=false & length(x2022)=x2020  ==>  U6^1(false, x2023, x2024, x2025, x2026, x2022, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x2026)), x2022))), x2023, x2024, x2025, x2026, x2022, x2021))  ==>  U6^1(false, x1184, x1185, x1186, x1187, x1188, s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), x1188))), x1184, x1185, x1186, x1187, x1188, s(x2021)))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (length(x1188)=0  ==>  U6^1(false, x1184, x1185, x1186, x1187, x1188, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), x1188))), x1184, x1185, x1186, x1187, x1188, s(x2019)))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x1188)=s(x2020) which results in the following new constraint:

(6)    (s(length(x2029))=s(x2020) & leq(x2021, x2020)=false & (\/x2022,x2023,x2024,x2025,x2026:leq(x2021, x2020)=false & length(x2022)=x2020  ==>  U6^1(false, x2023, x2024, x2025, x2026, x2022, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x2026)), x2022))), x2023, x2024, x2025, x2026, x2022, x2021)) & (\/x2031,x2032,x2033,x2034,x2035,x2036,x2037,x2038,x2039,x2040,x2041:length(x2029)=s(x2031) & leq(x2032, x2031)=false & (\/x2033,x2034,x2035,x2036,x2037:leq(x2032, x2031)=false & length(x2033)=x2031  ==>  U6^1(false, x2034, x2035, x2036, x2037, x2033, x2032)_>=_U8^1(empty(fstsplit(x2032, app(map_f(three, head(x2037)), x2033))), x2034, x2035, x2036, x2037, x2033, x2032))  ==>  U6^1(false, x2038, x2039, x2040, x2041, x2029, s(x2032))_>=_U8^1(empty(fstsplit(s(x2032), app(map_f(three, head(x2041)), x2029))), x2038, x2039, x2040, x2041, x2029, s(x2032)))  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))



We simplified constraint (5) using rule (V) (with possible (I) afterwards) using induction on length(x1188)=0 which results in the following new constraint:

(7)    (0=0  ==>  U6^1(false, x1184, x1185, x1186, x1187, nil, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), nil))), x1184, x1185, x1186, x1187, nil, s(x2019)))



We simplified constraint (7) using rules (I), (II) which results in the following new constraint:

(8)    (U6^1(false, x1184, x1185, x1186, x1187, nil, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), nil))), x1184, x1185, x1186, x1187, nil, s(x2019)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(9)    (length(x2029)=x2020 & leq(x2021, x2020)=false & (\/x2022,x2023,x2024,x2025,x2026:leq(x2021, x2020)=false & length(x2022)=x2020  ==>  U6^1(false, x2023, x2024, x2025, x2026, x2022, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x2026)), x2022))), x2023, x2024, x2025, x2026, x2022, x2021)) & (\/x2031,x2032,x2033,x2034,x2035,x2036,x2037,x2038,x2039,x2040,x2041:length(x2029)=s(x2031) & leq(x2032, x2031)=false & (\/x2033,x2034,x2035,x2036,x2037:leq(x2032, x2031)=false & length(x2033)=x2031  ==>  U6^1(false, x2034, x2035, x2036, x2037, x2033, x2032)_>=_U8^1(empty(fstsplit(x2032, app(map_f(three, head(x2037)), x2033))), x2034, x2035, x2036, x2037, x2033, x2032))  ==>  U6^1(false, x2038, x2039, x2040, x2041, x2029, s(x2032))_>=_U8^1(empty(fstsplit(s(x2032), app(map_f(three, head(x2041)), x2029))), x2038, x2039, x2040, x2041, x2029, s(x2032)))  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))



We simplified constraint (9) using rule (VI) where we applied the induction hypothesis (\/x2022,x2023,x2024,x2025,x2026:leq(x2021, x2020)=false & length(x2022)=x2020  ==>  U6^1(false, x2023, x2024, x2025, x2026, x2022, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x2026)), x2022))), x2023, x2024, x2025, x2026, x2022, x2021)) with sigma = [x2022 / x2029, x2023 / x1184, x2024 / x1185, x2025 / x1186, x2026 / x1187] which results in the following new constraint:

(10)    (U6^1(false, x1184, x1185, x1186, x1187, x2029, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x1187)), x2029))), x1184, x1185, x1186, x1187, x2029, x2021) & (\/x2031,x2032,x2033,x2034,x2035,x2036,x2037,x2038,x2039,x2040,x2041:length(x2029)=s(x2031) & leq(x2032, x2031)=false & (\/x2033,x2034,x2035,x2036,x2037:leq(x2032, x2031)=false & length(x2033)=x2031  ==>  U6^1(false, x2034, x2035, x2036, x2037, x2033, x2032)_>=_U8^1(empty(fstsplit(x2032, app(map_f(three, head(x2037)), x2033))), x2034, x2035, x2036, x2037, x2033, x2032))  ==>  U6^1(false, x2038, x2039, x2040, x2041, x2029, s(x2032))_>=_U8^1(empty(fstsplit(s(x2032), app(map_f(three, head(x2041)), x2029))), x2038, x2039, x2040, x2041, x2029, s(x2032)))  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))



We simplified constraint (10) using rule (IV) which results in the following new constraint:

(11)    (U6^1(false, x1184, x1185, x1186, x1187, x2029, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x1187)), x2029))), x1184, x1185, x1186, x1187, x2029, x2021)  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))








For Pair U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m) the following chains were created:
*We consider the chain U6^1(false, x1312, x1313, x1314, x1315, x1316, x1317) -> U8^1(empty(fstsplit(x1317, app(map_f(three, head(x1315)), x1316))), x1312, x1313, x1314, x1315, x1316, x1317), U8^1(false, x1318, x1319, x1320, x1321, x1322, x1323) -> RING(x1318, x1319, x1320, tail(x1321), sndsplit(x1323, app(map_f(three, head(x1321)), x1322)), x1323) which results in the following constraint:

(1)    (U8^1(empty(fstsplit(x1317, app(map_f(three, head(x1315)), x1316))), x1312, x1313, x1314, x1315, x1316, x1317)=U8^1(false, x1318, x1319, x1320, x1321, x1322, x1323)  ==>  U8^1(false, x1318, x1319, x1320, x1321, x1322, x1323)_>=_RING(x1318, x1319, x1320, tail(x1321), sndsplit(x1323, app(map_f(three, head(x1321)), x1322)), x1323))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (fstsplit(x1317, x2043)=x2042 & empty(x2042)=false  ==>  U8^1(false, x1312, x1313, x1314, x1315, x1316, x1317)_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(x1317, app(map_f(three, head(x1315)), x1316)), x1317))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x2042)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x1317, x2043)=cons(x2048, x2047)  ==>  U8^1(false, x1312, x1313, x1314, x1315, x1316, x1317)_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(x1317, app(map_f(three, head(x1315)), x1316)), x1317))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x1317, x2043)=cons(x2048, x2047)  ==>  U8^1(false, x1312, x1313, x1314, x1315, x1316, x1317)_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(x1317, app(map_f(three, head(x1315)), x1316)), x1317))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x1317, x2043)=cons(x2048, x2047) which results in the following new constraint:

(5)    (cons(x2052, fstsplit(x2053, x2051))=cons(x2048, x2047) & (\/x2054,x2055,x2056,x2057,x2058,x2059,x2060:fstsplit(x2053, x2051)=cons(x2054, x2055)  ==>  U8^1(false, x2056, x2057, x2058, x2059, x2060, x2053)_>=_RING(x2056, x2057, x2058, tail(x2059), sndsplit(x2053, app(map_f(three, head(x2059)), x2060)), x2053))  ==>  U8^1(false, x1312, x1313, x1314, x1315, x1316, s(x2053))_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(s(x2053), app(map_f(three, head(x1315)), x1316)), s(x2053)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U8^1(false, x1312, x1313, x1314, x1315, x1316, s(x2053))_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(s(x2053), app(map_f(three, head(x1315)), x1316)), s(x2053)))








For Pair RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5) the following chains were created:
*We consider the chain U4^1(false, x1742, x1743, x1744, x1745, x1746, x1747) -> RING(x1742, tail(x1743), sndsplit(x1747, app(map_f(two, head(x1743)), x1744)), cons(fstsplit(x1747, app(map_f(two, head(x1743)), x1744)), x1745), x1746, x1747), RING(x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754) -> U9^1(empty(map_f(three, x1751)), x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754) which results in the following constraint:

(1)    (RING(x1742, tail(x1743), sndsplit(x1747, app(map_f(two, head(x1743)), x1744)), cons(fstsplit(x1747, app(map_f(two, head(x1743)), x1744)), x1745), x1746, x1747)=RING(x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754)  ==>  RING(x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754)_>=_U9^1(empty(map_f(three, x1751)), x1748, x1749, x1750, cons(x1751, x1752), x1753, x1754))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x1742, x1749, x1750, cons(x1751, x1745), x1746, x1747)_>=_U9^1(empty(map_f(three, x1751)), x1742, x1749, x1750, cons(x1751, x1745), x1746, x1747))




*We consider the chain U7^1(false, x1780, x1781, x1782, x1783, x1784, x1785) -> RING(x1780, x1781, x1782, x1783, sndsplit(x1785, x1784), x1785), RING(x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792) -> U9^1(empty(map_f(three, x1789)), x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792) which results in the following constraint:

(1)    (RING(x1780, x1781, x1782, x1783, sndsplit(x1785, x1784), x1785)=RING(x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792)  ==>  RING(x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792)_>=_U9^1(empty(map_f(three, x1789)), x1786, x1787, x1788, cons(x1789, x1790), x1791, x1792))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x1780, x1781, x1782, cons(x1789, x1790), x1791, x1785)_>=_U9^1(empty(map_f(three, x1789)), x1780, x1781, x1782, cons(x1789, x1790), x1791, x1785))




*We consider the chain U9^1(true, x1793, x1794, x1795, x1796, x1797, x1798) -> RING(x1793, x1794, x1795, tail(x1796), x1797, x1798), RING(x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805) -> U9^1(empty(map_f(three, x1802)), x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805) which results in the following constraint:

(1)    (RING(x1793, x1794, x1795, tail(x1796), x1797, x1798)=RING(x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805)  ==>  RING(x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805)_>=_U9^1(empty(map_f(three, x1802)), x1799, x1800, x1801, cons(x1802, x1803), x1804, x1805))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (tail(x1796)=cons(x1802, x1803)  ==>  RING(x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798)_>=_U9^1(empty(map_f(three, x1802)), x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on tail(x1796)=cons(x1802, x1803) which results in the following new constraint:

(3)    (x2118=cons(x1802, x1803)  ==>  RING(x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798)_>=_U9^1(empty(map_f(three, x1802)), x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798))



We simplified constraint (3) using rule (III) which results in the following new constraint:

(4)    (RING(x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798)_>=_U9^1(empty(map_f(three, x1802)), x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798))




*We consider the chain U8^1(false, x1812, x1813, x1814, x1815, x1816, x1817) -> RING(x1812, x1813, x1814, tail(x1815), sndsplit(x1817, app(map_f(three, head(x1815)), x1816)), x1817), RING(x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824) -> U9^1(empty(map_f(three, x1821)), x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824) which results in the following constraint:

(1)    (RING(x1812, x1813, x1814, tail(x1815), sndsplit(x1817, app(map_f(three, head(x1815)), x1816)), x1817)=RING(x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824)  ==>  RING(x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824)_>=_U9^1(empty(map_f(three, x1821)), x1818, x1819, x1820, cons(x1821, x1822), x1823, x1824))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (tail(x1815)=cons(x1821, x1822) & app(x2121, x1816)=x2120 & sndsplit(x1817, x2120)=x1823  ==>  RING(x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817)_>=_U9^1(empty(map_f(three, x1821)), x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on tail(x1815)=cons(x1821, x1822) which results in the following new constraint:

(3)    (x2124=cons(x1821, x1822) & app(x2121, x1816)=x2120 & sndsplit(x1817, x2120)=x1823  ==>  RING(x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817)_>=_U9^1(empty(map_f(three, x1821)), x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817))



We simplified constraint (3) using rules (III), (IV) which results in the following new constraint:

(4)    (RING(x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817)_>=_U9^1(empty(map_f(three, x1821)), x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817))








To summarize, we get the following constraints P__>=_ for the following pairs.

*RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)

*(RING(x274, x281, x282, x283, x278, x279)_>=_U2^1(leq(x279, length(x282)), x274, x281, x282, x283, x278, x279))


*(RING(x310, x311, x312, x313, x320, x315)_>=_U2^1(leq(x315, length(x312)), x310, x311, x312, x313, x320, x315))


*(RING(x322, x323, x324, x331, x326, x327)_>=_U2^1(leq(x327, length(x324)), x322, x323, x324, x331, x326, x327))


*(RING(x340, x341, x342, x349, x350, x345)_>=_U2^1(leq(x345, length(x342)), x340, x341, x342, x349, x350, x345))




*U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)

*(U2^1(false, x396, x397, nil, x399, x400, s(x1890))_>=_U4^1(empty(fstsplit(s(x1890), app(map_f(two, head(x397)), nil))), x396, x397, nil, x399, x400, s(x1890)))


*(U2^1(false, x396, x397, x1900, x399, x400, x1892)_>=_U4^1(empty(fstsplit(x1892, app(map_f(two, head(x397)), x1900))), x396, x397, x1900, x399, x400, x1892)  ==>  U2^1(false, x396, x397, cons(x1901, x1900), x399, x400, s(x1892))_>=_U4^1(empty(fstsplit(s(x1892), app(map_f(two, head(x397)), cons(x1901, x1900)))), x396, x397, cons(x1901, x1900), x399, x400, s(x1892)))




*U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)

*(U4^1(false, x506, x507, x508, x509, x510, s(x1924))_>=_RING(x506, tail(x507), sndsplit(s(x1924), app(map_f(two, head(x507)), x508)), cons(fstsplit(s(x1924), app(map_f(two, head(x507)), x508)), x509), x510, s(x1924)))




*RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)

*(RING(x726, x733, x734, x735, x730, x731)_>=_U6^1(leq(x731, length(x730)), x726, x733, x734, x735, x730, x731))


*(RING(x762, x763, x764, x765, x772, x767)_>=_U6^1(leq(x767, length(x772)), x762, x763, x764, x765, x772, x767))


*(RING(x774, x775, x776, x783, x778, x779)_>=_U6^1(leq(x779, length(x778)), x774, x775, x776, x783, x778, x779))


*(RING(x792, x793, x794, x801, x802, x797)_>=_U6^1(leq(x797, length(x802)), x792, x793, x794, x801, x802, x797))




*U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)

*(U6^1(true, x872, x873, x874, x875, x876, 0)_>=_U7^1(empty(fstsplit(0, x876)), x872, x873, x874, x875, x876, 0))


*(U6^1(true, x872, x873, x874, x875, x1970, x1964)_>=_U7^1(empty(fstsplit(x1964, x1970)), x872, x873, x874, x875, x1970, x1964)  ==>  U6^1(true, x872, x873, x874, x875, cons(x1971, x1970), s(x1964))_>=_U7^1(empty(fstsplit(s(x1964), cons(x1971, x1970))), x872, x873, x874, x875, cons(x1971, x1970), s(x1964)))




*U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)

*(U7^1(false, x982, x983, x984, x985, cons(x1989, x1988), s(x1990))_>=_RING(x982, x983, x984, x985, sndsplit(s(x1990), cons(x1989, x1988)), s(x1990)))




*U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)

*(U9^1(true, x1135, x1136, x1137, cons(nil, x1139), x1140, x1141)_>=_RING(x1135, x1136, x1137, tail(cons(nil, x1139)), x1140, x1141))




*U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)

*(U6^1(false, x1184, x1185, x1186, x1187, nil, s(x2019))_>=_U8^1(empty(fstsplit(s(x2019), app(map_f(three, head(x1187)), nil))), x1184, x1185, x1186, x1187, nil, s(x2019)))


*(U6^1(false, x1184, x1185, x1186, x1187, x2029, x2021)_>=_U8^1(empty(fstsplit(x2021, app(map_f(three, head(x1187)), x2029))), x1184, x1185, x1186, x1187, x2029, x2021)  ==>  U6^1(false, x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021))_>=_U8^1(empty(fstsplit(s(x2021), app(map_f(three, head(x1187)), cons(x2030, x2029)))), x1184, x1185, x1186, x1187, cons(x2030, x2029), s(x2021)))




*U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

*(U8^1(false, x1312, x1313, x1314, x1315, x1316, s(x2053))_>=_RING(x1312, x1313, x1314, tail(x1315), sndsplit(s(x2053), app(map_f(three, head(x1315)), x1316)), s(x2053)))




*RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)

*(RING(x1742, x1749, x1750, cons(x1751, x1745), x1746, x1747)_>=_U9^1(empty(map_f(three, x1751)), x1742, x1749, x1750, cons(x1751, x1745), x1746, x1747))


*(RING(x1780, x1781, x1782, cons(x1789, x1790), x1791, x1785)_>=_U9^1(empty(map_f(three, x1789)), x1780, x1781, x1782, cons(x1789, x1790), x1791, x1785))


*(RING(x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798)_>=_U9^1(empty(map_f(three, x1802)), x1793, x1794, x1795, cons(x1802, x1803), x1797, x1798))


*(RING(x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817)_>=_U9^1(empty(map_f(three, x1821)), x1812, x1813, x1814, cons(x1821, x1822), x1823, x1817))








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation [NONINF]:

   POL(0) = 0
   POL(RING(x_1, x_2, x_3, x_4, x_5, x_6)) = -x_5 - x_6
   POL(U2^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -x_1 - x_6 - x_7
   POL(U4^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_1 - x_6 - x_7
   POL(U6^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -x_1 - x_6 - x_7
   POL(U7^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 + x_1 - x_6 - x_7
   POL(U8^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -1 + x_1 - x_7
   POL(U9^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_1 - x_5 - x_6 - x_7
   POL(app(x_1, x_2)) = 0
   POL(c) = -2
   POL(cons(x_1, x_2)) = 0
   POL(empty(x_1)) = 0
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(false) = 0
   POL(fstsplit(x_1, x_2)) = 0
   POL(head(x_1)) = 0
   POL(length(x_1)) = 0
   POL(leq(x_1, x_2)) = 0
   POL(map_f(x_1, x_2)) = 0
   POL(nil) = 1
   POL(s(x_1)) = 1
   POL(sndsplit(x_1, x_2)) = x_1
   POL(tail(x_1)) = 0
   POL(three) = 0
   POL(true) = 0
   POL(two) = 0


The following pairs  are in P_>:
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
The following pairs are in P_bound:
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
The following rules are usable:
   x -> sndsplit(0, x)
   nil -> sndsplit(s(n), nil)
   true -> leq(0, m)
   false -> leq(s(n), 0)
   leq(n, m) -> leq(s(n), s(m))
   empty(nil) -> true
   empty(cons(h, t)) -> false

----------------------------------------

(76)
Complex Obligation (AND)

----------------------------------------

(77)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(78) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(79)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(80) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.


Strictly oriented rules of the TRS R:

   leq(0, m) -> true

Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(RING(x_1, x_2, x_3, x_4, x_5, x_6)) = 2 + x_1
   POL(U2^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_1 + x_2
   POL(U4^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = 2 + x_2
   POL(U6^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_1 + x_2
   POL(U8^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = 2 + x_2
   POL(U9^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = 2 + x_2
   POL(app(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(cons(x_1, x_2)) = 2 + x_1 + x_2
   POL(empty(x_1)) = 2*x_1
   POL(f(x_1, x_2)) = 0
   POL(false) = 2
   POL(fstsplit(x_1, x_2)) = 2*x_2
   POL(head(x_1)) = 2*x_1
   POL(length(x_1)) = 2*x_1
   POL(leq(x_1, x_2)) = 2
   POL(map_f(x_1, x_2)) = 0
   POL(nil) = 0
   POL(s(x_1)) = 0
   POL(sndsplit(x_1, x_2)) = 2*x_2
   POL(tail(x_1)) = 2*x_1
   POL(three) = 0
   POL(true) = 0
   POL(two) = 0


----------------------------------------

(81)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(82) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m) at position [0] we obtained the following new rules [LPAR04]:

   (RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5),RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5))
   (RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5),RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5))


----------------------------------------

(83)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(84) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m) at position [0] we obtained the following new rules [LPAR04]:

   (U2^1(false, y0, y1, y2, y3, y4, 0) -> U4^1(empty(nil), y0, y1, y2, y3, y4, 0),U2^1(false, y0, y1, y2, y3, y4, 0) -> U4^1(empty(nil), y0, y1, y2, y3, y4, 0))
   (U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5),U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5))


----------------------------------------

(85)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U2^1(false, y0, y1, y2, y3, y4, 0) -> U4^1(empty(nil), y0, y1, y2, y3, y4, 0)
   U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(86) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(87)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(88) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m) at position [0] we obtained the following new rules [LPAR04]:

   (RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5),RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5))
   (RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5),RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5))


----------------------------------------

(89)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(90) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m) at position [0] we obtained the following new rules [LPAR04]:

   (U6^1(false, y0, y1, y2, y3, y4, 0) -> U8^1(empty(nil), y0, y1, y2, y3, y4, 0),U6^1(false, y0, y1, y2, y3, y4, 0) -> U8^1(empty(nil), y0, y1, y2, y3, y4, 0))
   (U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5),U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5))


----------------------------------------

(91)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U6^1(false, y0, y1, y2, y3, y4, 0) -> U8^1(empty(nil), y0, y1, y2, y3, y4, 0)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(92) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(93)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(94) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m) we obtained the following new rules [LPAR04]:

   (U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, tail(cons(z3, z4)), z5, z6),U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, tail(cons(z3, z4)), z5, z6))


----------------------------------------

(95)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, tail(cons(z3, z4)), z5, z6)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(96) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, tail(cons(z3, z4)), z5, z6) at position [3] we obtained the following new rules [LPAR04]:

   (U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6),U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6))


----------------------------------------

(97)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(98) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5) we obtained the following new rules [LPAR04]:

   (U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4),U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4))
   (U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6),U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6))


----------------------------------------

(99)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(100) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m) we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, tail(cons(z1, z2)), sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5),U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, tail(cons(z1, z2)), sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5))
   (U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, tail(cons(z1, z2)), sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7),U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, tail(cons(z1, z2)), sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7))


----------------------------------------

(101)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, tail(cons(z1, z2)), sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, tail(cons(z1, z2)), sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(102) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, tail(cons(z1, z2)), sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5) at position [1] we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5),U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5))


----------------------------------------

(103)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, tail(cons(z1, z2)), sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(104) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, tail(cons(z1, z2)), sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7) at position [1] we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7),U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7))


----------------------------------------

(105)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(106) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5) at position [2,1,0,1] we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5),U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5))


----------------------------------------

(107)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(108) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7) at position [2,1,0,1] we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7),U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7))


----------------------------------------

(109)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(110) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5) at position [3,0,1,0,1] we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5),U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5))


----------------------------------------

(111)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(112) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7) at position [3,0,1,0,1] we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7),U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7))


----------------------------------------

(113)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(114) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5) we obtained the following new rules [LPAR04]:

   (U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4),U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4))
   (U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6),U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6))


----------------------------------------

(115)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(116) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m) we obtained the following new rules [LPAR04]:

   (U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, tail(cons(z3, z4)), sndsplit(z5, app(map_f(three, head(cons(z3, z4))), nil)), z5),U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, tail(cons(z3, z4)), sndsplit(z5, app(map_f(three, head(cons(z3, z4))), nil)), z5))
   (U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, tail(cons(z3, z4)), sndsplit(z7, app(map_f(three, head(cons(z3, z4))), cons(z5, z6))), z7),U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, tail(cons(z3, z4)), sndsplit(z7, app(map_f(three, head(cons(z3, z4))), cons(z5, z6))), z7))


----------------------------------------

(117)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, tail(cons(z3, z4)), sndsplit(z5, app(map_f(three, head(cons(z3, z4))), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, tail(cons(z3, z4)), sndsplit(z7, app(map_f(three, head(cons(z3, z4))), cons(z5, z6))), z7)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(118) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, tail(cons(z3, z4)), sndsplit(z5, app(map_f(three, head(cons(z3, z4))), nil)), z5) at position [3] we obtained the following new rules [LPAR04]:

   (U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, head(cons(z3, z4))), nil)), z5),U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, head(cons(z3, z4))), nil)), z5))


----------------------------------------

(119)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, tail(cons(z3, z4)), sndsplit(z7, app(map_f(three, head(cons(z3, z4))), cons(z5, z6))), z7)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, head(cons(z3, z4))), nil)), z5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(120) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, tail(cons(z3, z4)), sndsplit(z7, app(map_f(three, head(cons(z3, z4))), cons(z5, z6))), z7) at position [3] we obtained the following new rules [LPAR04]:

   (U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, head(cons(z3, z4))), cons(z5, z6))), z7),U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, head(cons(z3, z4))), cons(z5, z6))), z7))


----------------------------------------

(121)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, head(cons(z3, z4))), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, head(cons(z3, z4))), cons(z5, z6))), z7)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(122) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(123)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, head(cons(z3, z4))), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, head(cons(z3, z4))), cons(z5, z6))), z7)

The TRS R consists of the following rules:

   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(124) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   tail(cons(x0, x1))


----------------------------------------

(125)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, head(cons(z3, z4))), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, head(cons(z3, z4))), cons(z5, z6))), z7)

The TRS R consists of the following rules:

   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(126) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, head(cons(z3, z4))), nil)), z5) at position [4,1,0,1] we obtained the following new rules [LPAR04]:

   (U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5),U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5))


----------------------------------------

(127)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, head(cons(z3, z4))), cons(z5, z6))), z7)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5)

The TRS R consists of the following rules:

   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(128) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, head(cons(z3, z4))), cons(z5, z6))), z7) at position [4,1,0,1] we obtained the following new rules [LPAR04]:

   (U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, z3), cons(z5, z6))), z7),U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, z3), cons(z5, z6))), z7))


----------------------------------------

(129)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, z3), cons(z5, z6))), z7)

The TRS R consists of the following rules:

   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(130) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(131)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, z3), cons(z5, z6))), z7)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(132) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   head(cons(x0, x1))


----------------------------------------

(133)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, z3), cons(z5, z6))), z7)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(134) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5) we obtained the following new rules [LPAR04]:

   (RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4),RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4))


----------------------------------------

(135)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, z3), cons(z5, z6))), z7)
   RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(136) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5) we obtained the following new rules [LPAR04]:

   (RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6),RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6))


----------------------------------------

(137)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, z3), cons(z5, z6))), z7)
   RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4)
   RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(138) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5) we obtained the following new rules [LPAR04]:

   (RING(x0, x1, x2, cons(y_4, y_5), nil, x4) -> U6^1(leq(x4, 0), x0, x1, x2, cons(y_4, y_5), nil, x4),RING(x0, x1, x2, cons(y_4, y_5), nil, x4) -> U6^1(leq(x4, 0), x0, x1, x2, cons(y_4, y_5), nil, x4))


----------------------------------------

(139)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, z3), cons(z5, z6))), z7)
   RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4)
   RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6)
   RING(x0, x1, x2, cons(y_4, y_5), nil, x4) -> U6^1(leq(x4, 0), x0, x1, x2, cons(y_4, y_5), nil, x4)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(140) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5) we obtained the following new rules [LPAR04]:

   (RING(x0, x1, x2, cons(y_4, y_5), cons(x4, x5), x6) -> U6^1(leq(x6, s(length(x5))), x0, x1, x2, cons(y_4, y_5), cons(x4, x5), x6),RING(x0, x1, x2, cons(y_4, y_5), cons(x4, x5), x6) -> U6^1(leq(x6, s(length(x5))), x0, x1, x2, cons(y_4, y_5), cons(x4, x5), x6))


----------------------------------------

(141)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, z3), cons(z5, z6))), z7)
   RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4)
   RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6)
   RING(x0, x1, x2, cons(y_4, y_5), nil, x4) -> U6^1(leq(x4, 0), x0, x1, x2, cons(y_4, y_5), nil, x4)
   RING(x0, x1, x2, cons(y_4, y_5), cons(x4, x5), x6) -> U6^1(leq(x6, s(length(x5))), x0, x1, x2, cons(y_4, y_5), cons(x4, x5), x6)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(142) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6) we obtained the following new rules [LPAR04]:

   (U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), x5, x6) -> RING(x0, x1, x2, cons(y_3, y_4), x5, x6),U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), x5, x6) -> RING(x0, x1, x2, cons(y_3, y_4), x5, x6))
   (U9^1(true, x0, cons(y_1, y_2), nil, cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), nil, x4, x5, x6),U9^1(true, x0, cons(y_1, y_2), nil, cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), nil, x4, x5, x6))
   (U9^1(true, x0, cons(y_1, y_2), cons(y_3, y_4), cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), cons(y_3, y_4), x4, x5, x6),U9^1(true, x0, cons(y_1, y_2), cons(y_3, y_4), cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), cons(y_3, y_4), x4, x5, x6))
   (U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), nil, x6) -> RING(x0, x1, x2, cons(y_3, y_4), nil, x6),U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), nil, x6) -> RING(x0, x1, x2, cons(y_3, y_4), nil, x6))
   (U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), cons(y_5, y_6), x6) -> RING(x0, x1, x2, cons(y_3, y_4), cons(y_5, y_6), x6),U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), cons(y_5, y_6), x6) -> RING(x0, x1, x2, cons(y_3, y_4), cons(y_5, y_6), x6))


----------------------------------------

(143)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, z3), cons(z5, z6))), z7)
   RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4)
   RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6)
   RING(x0, x1, x2, cons(y_4, y_5), nil, x4) -> U6^1(leq(x4, 0), x0, x1, x2, cons(y_4, y_5), nil, x4)
   RING(x0, x1, x2, cons(y_4, y_5), cons(x4, x5), x6) -> U6^1(leq(x6, s(length(x5))), x0, x1, x2, cons(y_4, y_5), cons(x4, x5), x6)
   U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), x5, x6) -> RING(x0, x1, x2, cons(y_3, y_4), x5, x6)
   U9^1(true, x0, cons(y_1, y_2), nil, cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), nil, x4, x5, x6)
   U9^1(true, x0, cons(y_1, y_2), cons(y_3, y_4), cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), cons(y_3, y_4), x4, x5, x6)
   U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), nil, x6) -> RING(x0, x1, x2, cons(y_3, y_4), nil, x6)
   U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), cons(y_5, y_6), x6) -> RING(x0, x1, x2, cons(y_3, y_4), cons(y_5, y_6), x6)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(144) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5) we obtained the following new rules [LPAR04]:

   (RING(x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6),RING(x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6))
   (RING(x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6),RING(x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6))
   (RING(x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6),RING(x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6))
   (RING(x0, x1, x2, cons(x3, cons(y_5, y_6)), cons(y_7, y_8), x6) -> U9^1(empty(map_f(three, x3)), x0, x1, x2, cons(x3, cons(y_5, y_6)), cons(y_7, y_8), x6),RING(x0, x1, x2, cons(x3, cons(y_5, y_6)), cons(y_7, y_8), x6) -> U9^1(empty(map_f(three, x3)), x0, x1, x2, cons(x3, cons(y_5, y_6)), cons(y_7, y_8), x6))


----------------------------------------

(145)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
   U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
   U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5)
   U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, z3), cons(z5, z6))), z7)
   RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4)
   RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6)
   RING(x0, x1, x2, cons(y_4, y_5), nil, x4) -> U6^1(leq(x4, 0), x0, x1, x2, cons(y_4, y_5), nil, x4)
   RING(x0, x1, x2, cons(y_4, y_5), cons(x4, x5), x6) -> U6^1(leq(x6, s(length(x5))), x0, x1, x2, cons(y_4, y_5), cons(x4, x5), x6)
   U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), x5, x6) -> RING(x0, x1, x2, cons(y_3, y_4), x5, x6)
   U9^1(true, x0, cons(y_1, y_2), nil, cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), nil, x4, x5, x6)
   U9^1(true, x0, cons(y_1, y_2), cons(y_3, y_4), cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), cons(y_3, y_4), x4, x5, x6)
   U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), nil, x6) -> RING(x0, x1, x2, cons(y_3, y_4), nil, x6)
   U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), cons(y_5, y_6), x6) -> RING(x0, x1, x2, cons(y_3, y_4), cons(y_5, y_6), x6)
   RING(x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6)
   RING(x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6)
   RING(x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6)
   RING(x0, x1, x2, cons(x3, cons(y_5, y_6)), cons(y_7, y_8), x6) -> U9^1(empty(map_f(three, x3)), x0, x1, x2, cons(x3, cons(y_5, y_6)), cons(y_7, y_8), x6)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(146) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
The graph contains the following edges 2 >= 1, 3 > 2, 6 >= 5, 7 >= 6


*RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


*U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
The graph contains the following edges 2 >= 1, 3 > 2, 6 >= 5, 7 >= 6


*RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


*U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
The graph contains the following edges 2 >= 2, 3 >= 3, 4 >= 4, 5 >= 5, 6 >= 6, 7 >= 7


*U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
The graph contains the following edges 2 >= 2, 3 >= 3, 4 >= 4, 5 >= 5, 6 >= 6, 7 >= 7


*RING(x0, x1, x2, cons(y_4, y_5), nil, x4) -> U6^1(leq(x4, 0), x0, x1, x2, cons(y_4, y_5), nil, x4)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


*U8^1(false, z0, z1, z2, cons(z3, z4), nil, z5) -> RING(z0, z1, z2, z4, sndsplit(z5, app(map_f(three, z3), nil)), z5)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 >= 3, 5 > 4, 7 >= 6


*RING(x0, x1, x2, cons(y_4, y_5), cons(x4, x5), x6) -> U6^1(leq(x6, s(length(x5))), x0, x1, x2, cons(y_4, y_5), cons(x4, x5), x6)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


*U8^1(false, z0, z1, z2, cons(z3, z4), cons(z5, z6), z7) -> RING(z0, z1, z2, z4, sndsplit(z7, app(map_f(three, z3), cons(z5, z6))), z7)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 >= 3, 5 > 4, 7 >= 6


*U6^1(false, z0, z1, z2, cons(x3, x4), nil, z4) -> U8^1(empty(fstsplit(z4, app(map_f(three, x3), nil))), z0, z1, z2, cons(x3, x4), nil, z4)
The graph contains the following edges 2 >= 2, 3 >= 3, 4 >= 4, 5 >= 5, 6 >= 6, 7 >= 7


*U6^1(false, z0, z1, z2, cons(x3, x4), cons(z4, z5), z6) -> U8^1(empty(fstsplit(z6, app(map_f(three, x3), cons(z4, z5)))), z0, z1, z2, cons(x3, x4), cons(z4, z5), z6)
The graph contains the following edges 2 >= 2, 3 >= 3, 4 >= 4, 5 >= 5, 6 >= 6, 7 >= 7


*U9^1(true, x0, cons(y_1, y_2), cons(y_3, y_4), cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), cons(y_3, y_4), x4, x5, x6)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 >= 3, 5 > 4, 6 >= 5, 7 >= 6


*U9^1(true, x0, cons(y_1, y_2), nil, cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), nil, x4, x5, x6)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 >= 3, 5 > 4, 6 >= 5, 7 >= 6


*U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), cons(y_5, y_6), x6) -> RING(x0, x1, x2, cons(y_3, y_4), cons(y_5, y_6), x6)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 >= 3, 5 > 4, 6 >= 5, 7 >= 6


*U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), x5, x6) -> RING(x0, x1, x2, cons(y_3, y_4), x5, x6)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 >= 3, 5 > 4, 6 >= 5, 7 >= 6


*U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), nil, x6) -> RING(x0, x1, x2, cons(y_3, y_4), nil, x6)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 >= 3, 5 > 4, 6 >= 5, 7 >= 6


*RING(x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


*RING(x0, x1, x2, cons(x3, cons(y_5, y_6)), cons(y_7, y_8), x6) -> U9^1(empty(map_f(three, x3)), x0, x1, x2, cons(x3, cons(y_5, y_6)), cons(y_7, y_8), x6)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


*RING(x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


*RING(x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


----------------------------------------

(147)
YES

----------------------------------------

(148)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(149) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(150)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(151) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m) at position [0] we obtained the following new rules [LPAR04]:

   (RING(y0, y1, y2, y3, y4, 0) -> U2^1(true, y0, y1, y2, y3, y4, 0),RING(y0, y1, y2, y3, y4, 0) -> U2^1(true, y0, y1, y2, y3, y4, 0))
   (RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5),RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5))
   (RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5),RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5))


----------------------------------------

(152)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   RING(y0, y1, y2, y3, y4, 0) -> U2^1(true, y0, y1, y2, y3, y4, 0)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(153) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(154)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(155) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule U2^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U4^1(empty(fstsplit(m, app(map_f(two, head(in_2)), st_2))), st_1, in_2, st_2, in_3, st_3, m) at position [0] we obtained the following new rules [LPAR04]:

   (U2^1(false, y0, y1, y2, y3, y4, 0) -> U4^1(empty(nil), y0, y1, y2, y3, y4, 0),U2^1(false, y0, y1, y2, y3, y4, 0) -> U4^1(empty(nil), y0, y1, y2, y3, y4, 0))
   (U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5),U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5))


----------------------------------------

(156)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U2^1(false, y0, y1, y2, y3, y4, 0) -> U4^1(empty(nil), y0, y1, y2, y3, y4, 0)
   U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(157) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(158)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(159) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m) we obtained the following new rules [LPAR04]:

   (U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, tail(cons(z3, z4)), z5, z6),U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, tail(cons(z3, z4)), z5, z6))


----------------------------------------

(160)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, tail(cons(z3, z4)), z5, z6)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(161) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, tail(cons(z3, z4)), z5, z6) at position [3] we obtained the following new rules [LPAR04]:

   (U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6),U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6))


----------------------------------------

(162)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(163) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U2^1(false, y0, cons(x0, x1), y2, y3, y4, y5) -> U4^1(empty(fstsplit(y5, app(map_f(two, x0), y2))), y0, cons(x0, x1), y2, y3, y4, y5) we obtained the following new rules [LPAR04]:

   (U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4),U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4))
   (U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6),U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6))


----------------------------------------

(164)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(165) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U4^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, tail(in_2), sndsplit(m, app(map_f(two, head(in_2)), st_2)), cons(fstsplit(m, app(map_f(two, head(in_2)), st_2)), in_3), st_3, m) we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, tail(cons(z1, z2)), sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5),U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, tail(cons(z1, z2)), sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5))
   (U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, tail(cons(z1, z2)), sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7),U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, tail(cons(z1, z2)), sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7))


----------------------------------------

(166)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, tail(cons(z1, z2)), sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, tail(cons(z1, z2)), sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(167) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, tail(cons(z1, z2)), sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5) at position [1] we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5),U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5))


----------------------------------------

(168)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, tail(cons(z1, z2)), sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(169) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, tail(cons(z1, z2)), sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7) at position [1] we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7),U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7))


----------------------------------------

(170)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(171) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(172)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)

The TRS R consists of the following rules:

   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(173) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   tail(cons(x0, x1))


----------------------------------------

(174)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)

The TRS R consists of the following rules:

   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(175) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5) at position [2,1,0,1] we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5),U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5))


----------------------------------------

(176)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5)

The TRS R consists of the following rules:

   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(177) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7) at position [2,1,0,1] we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7),U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7))


----------------------------------------

(178)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)

The TRS R consists of the following rules:

   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(179) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, head(cons(z1, z2))), nil)), z3), z4, z5) at position [3,0,1,0,1] we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5),U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5))


----------------------------------------

(180)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)

The TRS R consists of the following rules:

   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(181) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, head(cons(z1, z2))), cons(z3, z4))), z5), z6, z7) at position [3,0,1,0,1] we obtained the following new rules [LPAR04]:

   (U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7),U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7))


----------------------------------------

(182)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)

The TRS R consists of the following rules:

   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(183) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(184)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(185) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   head(cons(x0, x1))


----------------------------------------

(186)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(187) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule RING(y0, y1, nil, y3, y4, y5) -> U2^1(leq(y5, 0), y0, y1, nil, y3, y4, y5) we obtained the following new rules [LPAR04]:

   (RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4),RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4))


----------------------------------------

(188)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(189) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule RING(y0, y1, cons(x0, x1), y3, y4, y5) -> U2^1(leq(y5, s(length(x1))), y0, y1, cons(x0, x1), y3, y4, y5) we obtained the following new rules [LPAR04]:

   (RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6),RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6))


----------------------------------------

(190)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4)
   RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(191) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, z4, z5, z6) we obtained the following new rules [LPAR04]:

   (U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), x5, x6) -> RING(x0, x1, x2, cons(y_3, y_4), x5, x6),U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), x5, x6) -> RING(x0, x1, x2, cons(y_3, y_4), x5, x6))
   (U9^1(true, x0, cons(y_1, y_2), nil, cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), nil, x4, x5, x6),U9^1(true, x0, cons(y_1, y_2), nil, cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), nil, x4, x5, x6))
   (U9^1(true, x0, cons(y_1, y_2), cons(y_3, y_4), cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), cons(y_3, y_4), x4, x5, x6),U9^1(true, x0, cons(y_1, y_2), cons(y_3, y_4), cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), cons(y_3, y_4), x4, x5, x6))


----------------------------------------

(192)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4)
   RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6)
   U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), x5, x6) -> RING(x0, x1, x2, cons(y_3, y_4), x5, x6)
   U9^1(true, x0, cons(y_1, y_2), nil, cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), nil, x4, x5, x6)
   U9^1(true, x0, cons(y_1, y_2), cons(y_3, y_4), cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), cons(y_3, y_4), x4, x5, x6)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(193) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5) we obtained the following new rules [LPAR04]:

   (RING(x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6),RING(x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6))
   (RING(x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6),RING(x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6))
   (RING(x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6),RING(x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6))


----------------------------------------

(194)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
   U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
   U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
   U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
   RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4)
   RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6)
   U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), x5, x6) -> RING(x0, x1, x2, cons(y_3, y_4), x5, x6)
   U9^1(true, x0, cons(y_1, y_2), nil, cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), nil, x4, x5, x6)
   U9^1(true, x0, cons(y_1, y_2), cons(y_3, y_4), cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), cons(y_3, y_4), x4, x5, x6)
   RING(x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6)
   RING(x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6)
   RING(x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6)

The TRS R consists of the following rules:

   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(195) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*U4^1(false, z0, cons(z1, z2), nil, z3, z4, z5) -> RING(z0, z2, sndsplit(z5, app(map_f(two, z1), nil)), cons(fstsplit(z5, app(map_f(two, z1), nil)), z3), z4, z5)
The graph contains the following edges 2 >= 1, 3 > 2, 6 >= 5, 7 >= 6


*RING(x0, cons(y_2, y_3), nil, x2, x3, x4) -> U2^1(leq(x4, 0), x0, cons(y_2, y_3), nil, x2, x3, x4)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


*U4^1(false, z0, cons(z1, z2), cons(z3, z4), z5, z6, z7) -> RING(z0, z2, sndsplit(z7, app(map_f(two, z1), cons(z3, z4))), cons(fstsplit(z7, app(map_f(two, z1), cons(z3, z4))), z5), z6, z7)
The graph contains the following edges 2 >= 1, 3 > 2, 6 >= 5, 7 >= 6


*RING(x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6) -> U2^1(leq(x6, s(length(x3))), x0, cons(y_2, y_3), cons(x2, x3), x4, x5, x6)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


*U2^1(false, z0, cons(x1, x2), nil, z2, z3, z4) -> U4^1(empty(fstsplit(z4, app(map_f(two, x1), nil))), z0, cons(x1, x2), nil, z2, z3, z4)
The graph contains the following edges 2 >= 2, 3 >= 3, 4 >= 4, 5 >= 5, 6 >= 6, 7 >= 7


*U2^1(false, z0, cons(x1, x2), cons(z2, z3), z4, z5, z6) -> U4^1(empty(fstsplit(z6, app(map_f(two, x1), cons(z2, z3)))), z0, cons(x1, x2), cons(z2, z3), z4, z5, z6)
The graph contains the following edges 2 >= 2, 3 >= 3, 4 >= 4, 5 >= 5, 6 >= 6, 7 >= 7


*U9^1(true, x0, cons(y_1, y_2), cons(y_3, y_4), cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), cons(y_3, y_4), x4, x5, x6)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 >= 3, 5 > 4, 6 >= 5, 7 >= 6


*U9^1(true, x0, x1, x2, cons(x3, cons(y_3, y_4)), x5, x6) -> RING(x0, x1, x2, cons(y_3, y_4), x5, x6)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 >= 3, 5 > 4, 6 >= 5, 7 >= 6


*U9^1(true, x0, cons(y_1, y_2), nil, cons(x3, x4), x5, x6) -> RING(x0, cons(y_1, y_2), nil, x4, x5, x6)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 >= 3, 5 > 4, 6 >= 5, 7 >= 6


*RING(x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), cons(y_4, y_5), cons(x3, x4), x5, x6)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


*RING(x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, x1, x2, cons(x3, cons(y_5, y_6)), x5, x6)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


*RING(x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6) -> U9^1(empty(map_f(three, x3)), x0, cons(y_2, y_3), x2, cons(x3, x4), x5, x6)
The graph contains the following edges 1 >= 2, 2 >= 3, 3 >= 4, 4 >= 5, 5 >= 6, 6 >= 7


----------------------------------------

(196)
YES

----------------------------------------

(197)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U2^1(leq(m, length(st_2)), st_1, in_2, st_2, in_3, st_3, m)
   U2^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U3^1(empty(fstsplit(m, st_2)), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(198) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(199)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   tail(cons(h, t)) -> t
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(200) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.


Strictly oriented rules of the TRS R:

   tail(cons(h, t)) -> t

Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(RING(x_1, x_2, x_3, x_4, x_5, x_6)) = x_1 + 2*x_2 + x_3 + 2*x_4
   POL(U6^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_3 + x_4 + 2*x_5
   POL(U7^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_3 + x_4 + 2*x_5
   POL(U8^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_3 + x_4 + 2*x_5
   POL(U9^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = x_2 + 2*x_3 + x_4 + 2*x_5
   POL(app(x_1, x_2)) = x_1 + 2*x_2
   POL(cons(x_1, x_2)) = 1 + x_1 + x_2
   POL(empty(x_1)) = 0
   POL(f(x_1, x_2)) = 0
   POL(false) = 0
   POL(fstsplit(x_1, x_2)) = 2*x_2
   POL(head(x_1)) = 1 + x_1
   POL(length(x_1)) = 0
   POL(leq(x_1, x_2)) = 0
   POL(map_f(x_1, x_2)) = 0
   POL(nil) = 0
   POL(s(x_1)) = 0
   POL(sndsplit(x_1, x_2)) = 2 + x_2
   POL(tail(x_1)) = x_1
   POL(three) = 0
   POL(true) = 0


----------------------------------------

(201)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(202) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U9^1(true, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), st_3, m) we obtained the following new rules [LPAR04]:

   (U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, tail(cons(z3, z4)), z5, z6),U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, tail(cons(z3, z4)), z5, z6))


----------------------------------------

(203)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(y0, y1, y2, cons(x0, x1), y4, y5) -> U9^1(empty(map_f(three, x0)), y0, y1, y2, cons(x0, x1), y4, y5)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   U9^1(true, z0, z1, z2, cons(z3, z4), z5, z6) -> RING(z0, z1, z2, tail(cons(z3, z4)), z5, z6)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(204) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(205)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(206) NonInfProof (EQUIVALENT)
The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x12, x13, x14, x15, x16, x17) -> U6^1(leq(x17, length(x16)), x12, x13, x14, x15, x16, x17), U6^1(true, x18, x19, x20, x21, x22, x23) -> U7^1(empty(fstsplit(x23, x22)), x18, x19, x20, x21, x22, x23) which results in the following constraint:

(1)    (U6^1(leq(x17, length(x16)), x12, x13, x14, x15, x16, x17)=U6^1(true, x18, x19, x20, x21, x22, x23)  ==>  U6^1(true, x18, x19, x20, x21, x22, x23)_>=_U7^1(empty(fstsplit(x23, x22)), x18, x19, x20, x21, x22, x23))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x16)=x186 & leq(x17, x186)=true  ==>  U6^1(true, x12, x13, x14, x15, x16, x17)_>=_U7^1(empty(fstsplit(x17, x16)), x12, x13, x14, x15, x16, x17))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x17, x186)=true which results in the following new constraints:

(3)    (true=true & length(x16)=x187  ==>  U6^1(true, x12, x13, x14, x15, x16, 0)_>=_U7^1(empty(fstsplit(0, x16)), x12, x13, x14, x15, x16, 0))

(4)    (leq(x190, x189)=true & length(x16)=s(x189) & (\/x191,x192,x193,x194,x195:leq(x190, x189)=true & length(x191)=x189  ==>  U6^1(true, x192, x193, x194, x195, x191, x190)_>=_U7^1(empty(fstsplit(x190, x191)), x192, x193, x194, x195, x191, x190))  ==>  U6^1(true, x12, x13, x14, x15, x16, s(x190))_>=_U7^1(empty(fstsplit(s(x190), x16)), x12, x13, x14, x15, x16, s(x190)))



We simplified constraint (3) using rules (I), (II), (IV) which results in the following new constraint:

(5)    (U6^1(true, x12, x13, x14, x15, x16, 0)_>=_U7^1(empty(fstsplit(0, x16)), x12, x13, x14, x15, x16, 0))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x16)=s(x189) which results in the following new constraint:

(6)    (s(length(x196))=s(x189) & leq(x190, x189)=true & (\/x191,x192,x193,x194,x195:leq(x190, x189)=true & length(x191)=x189  ==>  U6^1(true, x192, x193, x194, x195, x191, x190)_>=_U7^1(empty(fstsplit(x190, x191)), x192, x193, x194, x195, x191, x190)) & (\/x198,x199,x200,x201,x202,x203,x204,x205,x206,x207,x208:length(x196)=s(x198) & leq(x199, x198)=true & (\/x200,x201,x202,x203,x204:leq(x199, x198)=true & length(x200)=x198  ==>  U6^1(true, x201, x202, x203, x204, x200, x199)_>=_U7^1(empty(fstsplit(x199, x200)), x201, x202, x203, x204, x200, x199))  ==>  U6^1(true, x205, x206, x207, x208, x196, s(x199))_>=_U7^1(empty(fstsplit(s(x199), x196)), x205, x206, x207, x208, x196, s(x199)))  ==>  U6^1(true, x12, x13, x14, x15, cons(x197, x196), s(x190))_>=_U7^1(empty(fstsplit(s(x190), cons(x197, x196))), x12, x13, x14, x15, cons(x197, x196), s(x190)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(7)    (length(x196)=x189 & leq(x190, x189)=true & (\/x191,x192,x193,x194,x195:leq(x190, x189)=true & length(x191)=x189  ==>  U6^1(true, x192, x193, x194, x195, x191, x190)_>=_U7^1(empty(fstsplit(x190, x191)), x192, x193, x194, x195, x191, x190)) & (\/x198,x199,x200,x201,x202,x203,x204,x205,x206,x207,x208:length(x196)=s(x198) & leq(x199, x198)=true & (\/x200,x201,x202,x203,x204:leq(x199, x198)=true & length(x200)=x198  ==>  U6^1(true, x201, x202, x203, x204, x200, x199)_>=_U7^1(empty(fstsplit(x199, x200)), x201, x202, x203, x204, x200, x199))  ==>  U6^1(true, x205, x206, x207, x208, x196, s(x199))_>=_U7^1(empty(fstsplit(s(x199), x196)), x205, x206, x207, x208, x196, s(x199)))  ==>  U6^1(true, x12, x13, x14, x15, cons(x197, x196), s(x190))_>=_U7^1(empty(fstsplit(s(x190), cons(x197, x196))), x12, x13, x14, x15, cons(x197, x196), s(x190)))



We simplified constraint (7) using rule (VI) where we applied the induction hypothesis (\/x191,x192,x193,x194,x195:leq(x190, x189)=true & length(x191)=x189  ==>  U6^1(true, x192, x193, x194, x195, x191, x190)_>=_U7^1(empty(fstsplit(x190, x191)), x192, x193, x194, x195, x191, x190)) with sigma = [x191 / x196, x192 / x12, x193 / x13, x194 / x14, x195 / x15] which results in the following new constraint:

(8)    (U6^1(true, x12, x13, x14, x15, x196, x190)_>=_U7^1(empty(fstsplit(x190, x196)), x12, x13, x14, x15, x196, x190) & (\/x198,x199,x200,x201,x202,x203,x204,x205,x206,x207,x208:length(x196)=s(x198) & leq(x199, x198)=true & (\/x200,x201,x202,x203,x204:leq(x199, x198)=true & length(x200)=x198  ==>  U6^1(true, x201, x202, x203, x204, x200, x199)_>=_U7^1(empty(fstsplit(x199, x200)), x201, x202, x203, x204, x200, x199))  ==>  U6^1(true, x205, x206, x207, x208, x196, s(x199))_>=_U7^1(empty(fstsplit(s(x199), x196)), x205, x206, x207, x208, x196, s(x199)))  ==>  U6^1(true, x12, x13, x14, x15, cons(x197, x196), s(x190))_>=_U7^1(empty(fstsplit(s(x190), cons(x197, x196))), x12, x13, x14, x15, cons(x197, x196), s(x190)))



We simplified constraint (8) using rule (IV) which results in the following new constraint:

(9)    (U6^1(true, x12, x13, x14, x15, x196, x190)_>=_U7^1(empty(fstsplit(x190, x196)), x12, x13, x14, x15, x196, x190)  ==>  U6^1(true, x12, x13, x14, x15, cons(x197, x196), s(x190))_>=_U7^1(empty(fstsplit(s(x190), cons(x197, x196))), x12, x13, x14, x15, cons(x197, x196), s(x190)))








For Pair U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m) the following chains were created:
*We consider the chain U6^1(true, x36, x37, x38, x39, x40, x41) -> U7^1(empty(fstsplit(x41, x40)), x36, x37, x38, x39, x40, x41), U7^1(false, x42, x43, x44, x45, x46, x47) -> RING(x42, x43, x44, x45, sndsplit(x47, x46), x47) which results in the following constraint:

(1)    (U7^1(empty(fstsplit(x41, x40)), x36, x37, x38, x39, x40, x41)=U7^1(false, x42, x43, x44, x45, x46, x47)  ==>  U7^1(false, x42, x43, x44, x45, x46, x47)_>=_RING(x42, x43, x44, x45, sndsplit(x47, x46), x47))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (fstsplit(x41, x40)=x209 & empty(x209)=false  ==>  U7^1(false, x36, x37, x38, x39, x40, x41)_>=_RING(x36, x37, x38, x39, sndsplit(x41, x40), x41))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x209)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x41, x40)=cons(x211, x210)  ==>  U7^1(false, x36, x37, x38, x39, x40, x41)_>=_RING(x36, x37, x38, x39, sndsplit(x41, x40), x41))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x41, x40)=cons(x211, x210)  ==>  U7^1(false, x36, x37, x38, x39, x40, x41)_>=_RING(x36, x37, x38, x39, sndsplit(x41, x40), x41))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x41, x40)=cons(x211, x210) which results in the following new constraint:

(5)    (cons(x215, fstsplit(x216, x214))=cons(x211, x210) & (\/x217,x218,x219,x220,x221,x222:fstsplit(x216, x214)=cons(x217, x218)  ==>  U7^1(false, x219, x220, x221, x222, x214, x216)_>=_RING(x219, x220, x221, x222, sndsplit(x216, x214), x216))  ==>  U7^1(false, x36, x37, x38, x39, cons(x215, x214), s(x216))_>=_RING(x36, x37, x38, x39, sndsplit(s(x216), cons(x215, x214)), s(x216)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U7^1(false, x36, x37, x38, x39, cons(x215, x214), s(x216))_>=_RING(x36, x37, x38, x39, sndsplit(s(x216), cons(x215, x214)), s(x216)))








For Pair RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain U7^1(false, x78, x79, x80, x81, x82, x83) -> RING(x78, x79, x80, x81, sndsplit(x83, x82), x83), RING(x84, x85, x86, x87, x88, x89) -> U6^1(leq(x89, length(x88)), x84, x85, x86, x87, x88, x89) which results in the following constraint:

(1)    (RING(x78, x79, x80, x81, sndsplit(x83, x82), x83)=RING(x84, x85, x86, x87, x88, x89)  ==>  RING(x84, x85, x86, x87, x88, x89)_>=_U6^1(leq(x89, length(x88)), x84, x85, x86, x87, x88, x89))



We simplified constraint (1) using rules (I), (II), (III), (IV) which results in the following new constraint:

(2)    (RING(x78, x79, x80, x81, x88, x83)_>=_U6^1(leq(x83, length(x88)), x78, x79, x80, x81, x88, x83))




*We consider the chain U8^1(false, x102, x103, x104, x105, x106, x107) -> RING(x102, x103, x104, tail(x105), sndsplit(x107, app(map_f(three, head(x105)), x106)), x107), RING(x108, x109, x110, x111, x112, x113) -> U6^1(leq(x113, length(x112)), x108, x109, x110, x111, x112, x113) which results in the following constraint:

(1)    (RING(x102, x103, x104, tail(x105), sndsplit(x107, app(map_f(three, head(x105)), x106)), x107)=RING(x108, x109, x110, x111, x112, x113)  ==>  RING(x108, x109, x110, x111, x112, x113)_>=_U6^1(leq(x113, length(x112)), x108, x109, x110, x111, x112, x113))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (RING(x102, x103, x104, tail(x105), x112, x107)_>=_U6^1(leq(x107, length(x112)), x102, x103, x104, tail(x105), x112, x107))








For Pair U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m) the following chains were created:
*We consider the chain RING(x126, x127, x128, x129, x130, x131) -> U6^1(leq(x131, length(x130)), x126, x127, x128, x129, x130, x131), U6^1(false, x132, x133, x134, x135, x136, x137) -> U8^1(empty(fstsplit(x137, app(map_f(three, head(x135)), x136))), x132, x133, x134, x135, x136, x137) which results in the following constraint:

(1)    (U6^1(leq(x131, length(x130)), x126, x127, x128, x129, x130, x131)=U6^1(false, x132, x133, x134, x135, x136, x137)  ==>  U6^1(false, x132, x133, x134, x135, x136, x137)_>=_U8^1(empty(fstsplit(x137, app(map_f(three, head(x135)), x136))), x132, x133, x134, x135, x136, x137))



We simplified constraint (1) using rules (I), (II), (III), (VII) which results in the following new constraint:

(2)    (length(x130)=x227 & leq(x131, x227)=false  ==>  U6^1(false, x126, x127, x128, x129, x130, x131)_>=_U8^1(empty(fstsplit(x131, app(map_f(three, head(x129)), x130))), x126, x127, x128, x129, x130, x131))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on leq(x131, x227)=false which results in the following new constraints:

(3)    (false=false & length(x130)=0  ==>  U6^1(false, x126, x127, x128, x129, x130, s(x229))_>=_U8^1(empty(fstsplit(s(x229), app(map_f(three, head(x129)), x130))), x126, x127, x128, x129, x130, s(x229)))

(4)    (leq(x231, x230)=false & length(x130)=s(x230) & (\/x232,x233,x234,x235,x236:leq(x231, x230)=false & length(x232)=x230  ==>  U6^1(false, x233, x234, x235, x236, x232, x231)_>=_U8^1(empty(fstsplit(x231, app(map_f(three, head(x236)), x232))), x233, x234, x235, x236, x232, x231))  ==>  U6^1(false, x126, x127, x128, x129, x130, s(x231))_>=_U8^1(empty(fstsplit(s(x231), app(map_f(three, head(x129)), x130))), x126, x127, x128, x129, x130, s(x231)))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (length(x130)=0  ==>  U6^1(false, x126, x127, x128, x129, x130, s(x229))_>=_U8^1(empty(fstsplit(s(x229), app(map_f(three, head(x129)), x130))), x126, x127, x128, x129, x130, s(x229)))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on length(x130)=s(x230) which results in the following new constraint:

(6)    (s(length(x239))=s(x230) & leq(x231, x230)=false & (\/x232,x233,x234,x235,x236:leq(x231, x230)=false & length(x232)=x230  ==>  U6^1(false, x233, x234, x235, x236, x232, x231)_>=_U8^1(empty(fstsplit(x231, app(map_f(three, head(x236)), x232))), x233, x234, x235, x236, x232, x231)) & (\/x241,x242,x243,x244,x245,x246,x247,x248,x249,x250,x251:length(x239)=s(x241) & leq(x242, x241)=false & (\/x243,x244,x245,x246,x247:leq(x242, x241)=false & length(x243)=x241  ==>  U6^1(false, x244, x245, x246, x247, x243, x242)_>=_U8^1(empty(fstsplit(x242, app(map_f(three, head(x247)), x243))), x244, x245, x246, x247, x243, x242))  ==>  U6^1(false, x248, x249, x250, x251, x239, s(x242))_>=_U8^1(empty(fstsplit(s(x242), app(map_f(three, head(x251)), x239))), x248, x249, x250, x251, x239, s(x242)))  ==>  U6^1(false, x126, x127, x128, x129, cons(x240, x239), s(x231))_>=_U8^1(empty(fstsplit(s(x231), app(map_f(three, head(x129)), cons(x240, x239)))), x126, x127, x128, x129, cons(x240, x239), s(x231)))



We simplified constraint (5) using rule (V) (with possible (I) afterwards) using induction on length(x130)=0 which results in the following new constraint:

(7)    (0=0  ==>  U6^1(false, x126, x127, x128, x129, nil, s(x229))_>=_U8^1(empty(fstsplit(s(x229), app(map_f(three, head(x129)), nil))), x126, x127, x128, x129, nil, s(x229)))



We simplified constraint (7) using rules (I), (II) which results in the following new constraint:

(8)    (U6^1(false, x126, x127, x128, x129, nil, s(x229))_>=_U8^1(empty(fstsplit(s(x229), app(map_f(three, head(x129)), nil))), x126, x127, x128, x129, nil, s(x229)))



We simplified constraint (6) using rules (I), (II) which results in the following new constraint:

(9)    (length(x239)=x230 & leq(x231, x230)=false & (\/x232,x233,x234,x235,x236:leq(x231, x230)=false & length(x232)=x230  ==>  U6^1(false, x233, x234, x235, x236, x232, x231)_>=_U8^1(empty(fstsplit(x231, app(map_f(three, head(x236)), x232))), x233, x234, x235, x236, x232, x231)) & (\/x241,x242,x243,x244,x245,x246,x247,x248,x249,x250,x251:length(x239)=s(x241) & leq(x242, x241)=false & (\/x243,x244,x245,x246,x247:leq(x242, x241)=false & length(x243)=x241  ==>  U6^1(false, x244, x245, x246, x247, x243, x242)_>=_U8^1(empty(fstsplit(x242, app(map_f(three, head(x247)), x243))), x244, x245, x246, x247, x243, x242))  ==>  U6^1(false, x248, x249, x250, x251, x239, s(x242))_>=_U8^1(empty(fstsplit(s(x242), app(map_f(three, head(x251)), x239))), x248, x249, x250, x251, x239, s(x242)))  ==>  U6^1(false, x126, x127, x128, x129, cons(x240, x239), s(x231))_>=_U8^1(empty(fstsplit(s(x231), app(map_f(three, head(x129)), cons(x240, x239)))), x126, x127, x128, x129, cons(x240, x239), s(x231)))



We simplified constraint (9) using rule (VI) where we applied the induction hypothesis (\/x232,x233,x234,x235,x236:leq(x231, x230)=false & length(x232)=x230  ==>  U6^1(false, x233, x234, x235, x236, x232, x231)_>=_U8^1(empty(fstsplit(x231, app(map_f(three, head(x236)), x232))), x233, x234, x235, x236, x232, x231)) with sigma = [x232 / x239, x233 / x126, x234 / x127, x235 / x128, x236 / x129] which results in the following new constraint:

(10)    (U6^1(false, x126, x127, x128, x129, x239, x231)_>=_U8^1(empty(fstsplit(x231, app(map_f(three, head(x129)), x239))), x126, x127, x128, x129, x239, x231) & (\/x241,x242,x243,x244,x245,x246,x247,x248,x249,x250,x251:length(x239)=s(x241) & leq(x242, x241)=false & (\/x243,x244,x245,x246,x247:leq(x242, x241)=false & length(x243)=x241  ==>  U6^1(false, x244, x245, x246, x247, x243, x242)_>=_U8^1(empty(fstsplit(x242, app(map_f(three, head(x247)), x243))), x244, x245, x246, x247, x243, x242))  ==>  U6^1(false, x248, x249, x250, x251, x239, s(x242))_>=_U8^1(empty(fstsplit(s(x242), app(map_f(three, head(x251)), x239))), x248, x249, x250, x251, x239, s(x242)))  ==>  U6^1(false, x126, x127, x128, x129, cons(x240, x239), s(x231))_>=_U8^1(empty(fstsplit(s(x231), app(map_f(three, head(x129)), cons(x240, x239)))), x126, x127, x128, x129, cons(x240, x239), s(x231)))



We simplified constraint (10) using rule (IV) which results in the following new constraint:

(11)    (U6^1(false, x126, x127, x128, x129, x239, x231)_>=_U8^1(empty(fstsplit(x231, app(map_f(three, head(x129)), x239))), x126, x127, x128, x129, x239, x231)  ==>  U6^1(false, x126, x127, x128, x129, cons(x240, x239), s(x231))_>=_U8^1(empty(fstsplit(s(x231), app(map_f(three, head(x129)), cons(x240, x239)))), x126, x127, x128, x129, cons(x240, x239), s(x231)))








For Pair U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m) the following chains were created:
*We consider the chain U6^1(false, x168, x169, x170, x171, x172, x173) -> U8^1(empty(fstsplit(x173, app(map_f(three, head(x171)), x172))), x168, x169, x170, x171, x172, x173), U8^1(false, x174, x175, x176, x177, x178, x179) -> RING(x174, x175, x176, tail(x177), sndsplit(x179, app(map_f(three, head(x177)), x178)), x179) which results in the following constraint:

(1)    (U8^1(empty(fstsplit(x173, app(map_f(three, head(x171)), x172))), x168, x169, x170, x171, x172, x173)=U8^1(false, x174, x175, x176, x177, x178, x179)  ==>  U8^1(false, x174, x175, x176, x177, x178, x179)_>=_RING(x174, x175, x176, tail(x177), sndsplit(x179, app(map_f(three, head(x177)), x178)), x179))



We simplified constraint (1) using rules (I), (II), (III), (IV), (VII) which results in the following new constraint:

(2)    (fstsplit(x173, x253)=x252 & empty(x252)=false  ==>  U8^1(false, x168, x169, x170, x171, x172, x173)_>=_RING(x168, x169, x170, tail(x171), sndsplit(x173, app(map_f(three, head(x171)), x172)), x173))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on empty(x252)=false which results in the following new constraint:

(3)    (false=false & fstsplit(x173, x253)=cons(x258, x257)  ==>  U8^1(false, x168, x169, x170, x171, x172, x173)_>=_RING(x168, x169, x170, tail(x171), sndsplit(x173, app(map_f(three, head(x171)), x172)), x173))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(4)    (fstsplit(x173, x253)=cons(x258, x257)  ==>  U8^1(false, x168, x169, x170, x171, x172, x173)_>=_RING(x168, x169, x170, tail(x171), sndsplit(x173, app(map_f(three, head(x171)), x172)), x173))



We simplified constraint (4) using rule (V) (with possible (I) afterwards) using induction on fstsplit(x173, x253)=cons(x258, x257) which results in the following new constraint:

(5)    (cons(x262, fstsplit(x263, x261))=cons(x258, x257) & (\/x264,x265,x266,x267,x268,x269,x270:fstsplit(x263, x261)=cons(x264, x265)  ==>  U8^1(false, x266, x267, x268, x269, x270, x263)_>=_RING(x266, x267, x268, tail(x269), sndsplit(x263, app(map_f(three, head(x269)), x270)), x263))  ==>  U8^1(false, x168, x169, x170, x171, x172, s(x263))_>=_RING(x168, x169, x170, tail(x171), sndsplit(s(x263), app(map_f(three, head(x171)), x172)), s(x263)))



We simplified constraint (5) using rules (I), (II), (IV) which results in the following new constraint:

(6)    (U8^1(false, x168, x169, x170, x171, x172, s(x263))_>=_RING(x168, x169, x170, tail(x171), sndsplit(s(x263), app(map_f(three, head(x171)), x172)), s(x263)))








To summarize, we get the following constraints P__>=_ for the following pairs.

*U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)

*(U6^1(true, x12, x13, x14, x15, x16, 0)_>=_U7^1(empty(fstsplit(0, x16)), x12, x13, x14, x15, x16, 0))


*(U6^1(true, x12, x13, x14, x15, x196, x190)_>=_U7^1(empty(fstsplit(x190, x196)), x12, x13, x14, x15, x196, x190)  ==>  U6^1(true, x12, x13, x14, x15, cons(x197, x196), s(x190))_>=_U7^1(empty(fstsplit(s(x190), cons(x197, x196))), x12, x13, x14, x15, cons(x197, x196), s(x190)))




*U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)

*(U7^1(false, x36, x37, x38, x39, cons(x215, x214), s(x216))_>=_RING(x36, x37, x38, x39, sndsplit(s(x216), cons(x215, x214)), s(x216)))




*RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)

*(RING(x78, x79, x80, x81, x88, x83)_>=_U6^1(leq(x83, length(x88)), x78, x79, x80, x81, x88, x83))


*(RING(x102, x103, x104, tail(x105), x112, x107)_>=_U6^1(leq(x107, length(x112)), x102, x103, x104, tail(x105), x112, x107))




*U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)

*(U6^1(false, x126, x127, x128, x129, nil, s(x229))_>=_U8^1(empty(fstsplit(s(x229), app(map_f(three, head(x129)), nil))), x126, x127, x128, x129, nil, s(x229)))


*(U6^1(false, x126, x127, x128, x129, x239, x231)_>=_U8^1(empty(fstsplit(x231, app(map_f(three, head(x129)), x239))), x126, x127, x128, x129, x239, x231)  ==>  U6^1(false, x126, x127, x128, x129, cons(x240, x239), s(x231))_>=_U8^1(empty(fstsplit(s(x231), app(map_f(three, head(x129)), cons(x240, x239)))), x126, x127, x128, x129, cons(x240, x239), s(x231)))




*U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

*(U8^1(false, x168, x169, x170, x171, x172, s(x263))_>=_RING(x168, x169, x170, tail(x171), sndsplit(s(x263), app(map_f(three, head(x171)), x172)), s(x263)))








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation [NONINF]:

   POL(0) = 0
   POL(RING(x_1, x_2, x_3, x_4, x_5, x_6)) = 1 + x_4 - x_5 - x_6
   POL(U6^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = 1 - x_1 + x_5 - x_6 - x_7
   POL(U7^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -x_1 + x_5 - x_6 - x_7
   POL(U8^1(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = -x_1 + x_5 - x_7
   POL(app(x_1, x_2)) = 0
   POL(c) = -1
   POL(cons(x_1, x_2)) = 0
   POL(empty(x_1)) = 0
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(false) = 0
   POL(fstsplit(x_1, x_2)) = 0
   POL(head(x_1)) = 0
   POL(length(x_1)) = 0
   POL(leq(x_1, x_2)) = 0
   POL(map_f(x_1, x_2)) = 0
   POL(nil) = 1
   POL(s(x_1)) = 1
   POL(sndsplit(x_1, x_2)) = x_1
   POL(tail(x_1)) = 0
   POL(three) = 0
   POL(true) = 0


The following pairs  are in P_>:
   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
The following pairs are in P_bound:
   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
The following rules are usable:
   true -> empty(nil)
   false -> empty(cons(h, t))
   x -> sndsplit(0, x)
   nil -> sndsplit(s(n), nil)
   true -> leq(0, m)
   false -> leq(s(n), 0)
   leq(n, m) -> leq(s(n), s(m))

----------------------------------------

(207)
Complex Obligation (AND)

----------------------------------------

(208)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U7^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, in_3, sndsplit(m, st_3), m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(209) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(210)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(211) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule U6^1(false, st_1, in_2, st_2, in_3, st_3, m) -> U8^1(empty(fstsplit(m, app(map_f(three, head(in_3)), st_3))), st_1, in_2, st_2, in_3, st_3, m) at position [0] we obtained the following new rules [LPAR04]:

   (U6^1(false, y0, y1, y2, y3, y4, 0) -> U8^1(empty(nil), y0, y1, y2, y3, y4, 0),U6^1(false, y0, y1, y2, y3, y4, 0) -> U8^1(empty(nil), y0, y1, y2, y3, y4, 0))
   (U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5),U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5))


----------------------------------------

(212)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(false, y0, y1, y2, y3, y4, 0) -> U8^1(empty(nil), y0, y1, y2, y3, y4, 0)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(213) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(214)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(215) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m) at position [0] we obtained the following new rules [LPAR04]:

   (RING(y0, y1, y2, y3, y4, 0) -> U6^1(true, y0, y1, y2, y3, y4, 0),RING(y0, y1, y2, y3, y4, 0) -> U6^1(true, y0, y1, y2, y3, y4, 0))
   (RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5),RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5))
   (RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5),RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5))


----------------------------------------

(216)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, y4, 0) -> U6^1(true, y0, y1, y2, y3, y4, 0)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(217) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(218)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(219) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule U8^1(false, st_1, in_2, st_2, in_3, st_3, m) -> RING(st_1, in_2, st_2, tail(in_3), sndsplit(m, app(map_f(three, head(in_3)), st_3)), m) at position [4] we obtained the following new rules [LPAR04]:

   (U8^1(false, y0, y1, y2, y3, y4, 0) -> RING(y0, y1, y2, tail(y3), app(map_f(three, head(y3)), y4), 0),U8^1(false, y0, y1, y2, y3, y4, 0) -> RING(y0, y1, y2, tail(y3), app(map_f(three, head(y3)), y4), 0))
   (U8^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> RING(y0, y1, y2, tail(cons(x0, x1)), sndsplit(y5, app(map_f(three, x0), y4)), y5),U8^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> RING(y0, y1, y2, tail(cons(x0, x1)), sndsplit(y5, app(map_f(three, x0), y4)), y5))


----------------------------------------

(220)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U8^1(false, y0, y1, y2, y3, y4, 0) -> RING(y0, y1, y2, tail(y3), app(map_f(three, head(y3)), y4), 0)
   U8^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> RING(y0, y1, y2, tail(cons(x0, x1)), sndsplit(y5, app(map_f(three, x0), y4)), y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(221) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(222)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, y0, y1, y2, y3, y4, 0) -> RING(y0, y1, y2, tail(y3), app(map_f(three, head(y3)), y4), 0)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(223) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(224)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, y0, y1, y2, y3, y4, 0) -> RING(y0, y1, y2, tail(y3), app(map_f(three, head(y3)), y4), 0)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)

The TRS R consists of the following rules:

   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(225) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))


----------------------------------------

(226)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   U8^1(false, y0, y1, y2, y3, y4, 0) -> RING(y0, y1, y2, tail(y3), app(map_f(three, head(y3)), y4), 0)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)

The TRS R consists of the following rules:

   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(227) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule U8^1(false, y0, y1, y2, y3, y4, 0) -> RING(y0, y1, y2, tail(y3), app(map_f(three, head(y3)), y4), 0) at position [4] we obtained the following new rules [LPAR04]:

   (U8^1(false, y0, y1, y2, cons(x0, x1), y4, 0) -> RING(y0, y1, y2, tail(cons(x0, x1)), app(map_f(three, x0), y4), 0),U8^1(false, y0, y1, y2, cons(x0, x1), y4, 0) -> RING(y0, y1, y2, tail(cons(x0, x1)), app(map_f(three, x0), y4), 0))


----------------------------------------

(228)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6^1(false, y0, y1, y2, cons(x0, x1), y4, y5) -> U8^1(empty(fstsplit(y5, app(map_f(three, x0), y4))), y0, y1, y2, cons(x0, x1), y4, y5)
   RING(y0, y1, y2, y3, nil, y5) -> U6^1(leq(y5, 0), y0, y1, y2, y3, nil, y5)
   RING(y0, y1, y2, y3, cons(x0, x1), y5) -> U6^1(leq(y5, s(length(x1))), y0, y1, y2, y3, cons(x0, x1), y5)
   U8^1(false, y0, y1, y2, cons(x0, x1), y4, 0) -> RING(y0, y1, y2, tail(cons(x0, x1)), app(map_f(three, x0), y4), 0)

The TRS R consists of the following rules:

   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), s(m)) -> leq(n, m)
   leq(s(n), 0) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(229) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 4 less nodes.
----------------------------------------

(230)
TRUE

----------------------------------------

(231)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6^1(true, st_1, in_2, st_2, in_3, st_3, m) -> U7^1(empty(fstsplit(m, st_3)), st_1, in_2, st_2, in_3, st_3, m)
   RING(st_1, in_2, st_2, in_3, st_3, m) -> U6^1(leq(m, length(st_3)), st_1, in_2, st_2, in_3, st_3, m)

The TRS R consists of the following rules:

   sndsplit(0, x) -> x
   sndsplit(s(n), nil) -> nil
   fstsplit(0, x) -> nil
   fstsplit(s(n), nil) -> nil
   fstsplit(s(n), cons(h, t)) -> cons(h, fstsplit(n, t))
   empty(nil) -> true
   empty(cons(h, t)) -> false
   head(cons(h, t)) -> h
   map_f(pid, nil) -> nil
   map_f(pid, cons(h, t)) -> app(f(pid, h), map_f(pid, t))
   app(nil, x) -> x
   app(cons(h, t), x) -> cons(h, app(t, x))
   length(nil) -> 0
   length(cons(h, t)) -> s(length(t))
   leq(0, m) -> true
   leq(s(n), 0) -> false
   leq(s(n), s(m)) -> leq(n, m)

The set Q consists of the following terms:

   fstsplit(0, x0)
   fstsplit(s(x0), nil)
   fstsplit(s(x0), cons(x1, x2))
   sndsplit(0, x0)
   sndsplit(s(x0), nil)
   sndsplit(s(x0), cons(x1, x2))
   empty(nil)
   empty(cons(x0, x1))
   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))
   length(nil)
   length(cons(x0, x1))
   app(nil, x0)
   app(cons(x0, x1), x2)
   map_f(x0, nil)
   map_f(x0, cons(x1, x2))
   head(cons(x0, x1))
   tail(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(232) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 2 less nodes.
----------------------------------------

(233)
TRUE
