YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/4Co6t.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) DependencyPairsProof [EQUIVALENT, 0 ms]
(2) QDP
(3) DependencyGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) QDP
        (6) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (7) YES
    (8) QDP
        (9) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (10) YES
    (11) QDP
        (12) QDPOrderProof [EQUIVALENT, 13 ms]
        (13) QDP
        (14) DependencyGraphProof [EQUIVALENT, 0 ms]
        (15) TRUE


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   test(x_0, y) -> True
   test(x_0, y) -> False
   append(l1_2, l2_1) -> match_0(l1_2, l2_1, l1_2)
   match_0(l1_2, l2_1, Nil) -> l2_1
   match_0(l1_2, l2_1, Cons(x, l)) -> Cons(x, append(l, l2_1))
   part(a_4, l_3) -> match_1(a_4, l_3, l_3)
   match_1(a_4, l_3, Nil) -> Pair(Nil, Nil)
   match_1(a_4, l_3, Cons(x, l')) -> match_2(x, l', a_4, l_3, part(a_4, l'))
   match_2(x, l', a_4, l_3, Pair(l1, l2)) -> match_3(l1, l2, x, l', a_4, l_3, test(a_4, x))
   match_3(l1, l2, x, l', a_4, l_3, False) -> Pair(Cons(x, l1), l2)
   match_3(l1, l2, x, l', a_4, l_3, True) -> Pair(l1, Cons(x, l2))
   quick(l_5) -> match_4(l_5, l_5)
   match_4(l_5, Nil) -> Nil
   match_4(l_5, Cons(a, l')) -> match_5(a, l', l_5, part(a, l'))
   match_5(a, l', l_5, Pair(l1, l2)) -> append(quick(l1), Cons(a, quick(l2)))

Q is empty.

----------------------------------------

(1) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(2)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APPEND(l1_2, l2_1) -> MATCH_0(l1_2, l2_1, l1_2)
   MATCH_0(l1_2, l2_1, Cons(x, l)) -> APPEND(l, l2_1)
   PART(a_4, l_3) -> MATCH_1(a_4, l_3, l_3)
   MATCH_1(a_4, l_3, Cons(x, l')) -> MATCH_2(x, l', a_4, l_3, part(a_4, l'))
   MATCH_1(a_4, l_3, Cons(x, l')) -> PART(a_4, l')
   MATCH_2(x, l', a_4, l_3, Pair(l1, l2)) -> MATCH_3(l1, l2, x, l', a_4, l_3, test(a_4, x))
   MATCH_2(x, l', a_4, l_3, Pair(l1, l2)) -> TEST(a_4, x)
   QUICK(l_5) -> MATCH_4(l_5, l_5)
   MATCH_4(l_5, Cons(a, l')) -> MATCH_5(a, l', l_5, part(a, l'))
   MATCH_4(l_5, Cons(a, l')) -> PART(a, l')
   MATCH_5(a, l', l_5, Pair(l1, l2)) -> APPEND(quick(l1), Cons(a, quick(l2)))
   MATCH_5(a, l', l_5, Pair(l1, l2)) -> QUICK(l1)
   MATCH_5(a, l', l_5, Pair(l1, l2)) -> QUICK(l2)

The TRS R consists of the following rules:

   test(x_0, y) -> True
   test(x_0, y) -> False
   append(l1_2, l2_1) -> match_0(l1_2, l2_1, l1_2)
   match_0(l1_2, l2_1, Nil) -> l2_1
   match_0(l1_2, l2_1, Cons(x, l)) -> Cons(x, append(l, l2_1))
   part(a_4, l_3) -> match_1(a_4, l_3, l_3)
   match_1(a_4, l_3, Nil) -> Pair(Nil, Nil)
   match_1(a_4, l_3, Cons(x, l')) -> match_2(x, l', a_4, l_3, part(a_4, l'))
   match_2(x, l', a_4, l_3, Pair(l1, l2)) -> match_3(l1, l2, x, l', a_4, l_3, test(a_4, x))
   match_3(l1, l2, x, l', a_4, l_3, False) -> Pair(Cons(x, l1), l2)
   match_3(l1, l2, x, l', a_4, l_3, True) -> Pair(l1, Cons(x, l2))
   quick(l_5) -> match_4(l_5, l_5)
   match_4(l_5, Nil) -> Nil
   match_4(l_5, Cons(a, l')) -> match_5(a, l', l_5, part(a, l'))
   match_5(a, l', l_5, Pair(l1, l2)) -> append(quick(l1), Cons(a, quick(l2)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(3) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 3 SCCs with 5 less nodes.
----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MATCH_1(a_4, l_3, Cons(x, l')) -> PART(a_4, l')
   PART(a_4, l_3) -> MATCH_1(a_4, l_3, l_3)

The TRS R consists of the following rules:

   test(x_0, y) -> True
   test(x_0, y) -> False
   append(l1_2, l2_1) -> match_0(l1_2, l2_1, l1_2)
   match_0(l1_2, l2_1, Nil) -> l2_1
   match_0(l1_2, l2_1, Cons(x, l)) -> Cons(x, append(l, l2_1))
   part(a_4, l_3) -> match_1(a_4, l_3, l_3)
   match_1(a_4, l_3, Nil) -> Pair(Nil, Nil)
   match_1(a_4, l_3, Cons(x, l')) -> match_2(x, l', a_4, l_3, part(a_4, l'))
   match_2(x, l', a_4, l_3, Pair(l1, l2)) -> match_3(l1, l2, x, l', a_4, l_3, test(a_4, x))
   match_3(l1, l2, x, l', a_4, l_3, False) -> Pair(Cons(x, l1), l2)
   match_3(l1, l2, x, l', a_4, l_3, True) -> Pair(l1, Cons(x, l2))
   quick(l_5) -> match_4(l_5, l_5)
   match_4(l_5, Nil) -> Nil
   match_4(l_5, Cons(a, l')) -> match_5(a, l', l_5, part(a, l'))
   match_5(a, l', l_5, Pair(l1, l2)) -> append(quick(l1), Cons(a, quick(l2)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(6) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*PART(a_4, l_3) -> MATCH_1(a_4, l_3, l_3)
The graph contains the following edges 1 >= 1, 2 >= 2, 2 >= 3


*MATCH_1(a_4, l_3, Cons(x, l')) -> PART(a_4, l')
The graph contains the following edges 1 >= 1, 3 > 2


----------------------------------------

(7)
YES

----------------------------------------

(8)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MATCH_0(l1_2, l2_1, Cons(x, l)) -> APPEND(l, l2_1)
   APPEND(l1_2, l2_1) -> MATCH_0(l1_2, l2_1, l1_2)

The TRS R consists of the following rules:

   test(x_0, y) -> True
   test(x_0, y) -> False
   append(l1_2, l2_1) -> match_0(l1_2, l2_1, l1_2)
   match_0(l1_2, l2_1, Nil) -> l2_1
   match_0(l1_2, l2_1, Cons(x, l)) -> Cons(x, append(l, l2_1))
   part(a_4, l_3) -> match_1(a_4, l_3, l_3)
   match_1(a_4, l_3, Nil) -> Pair(Nil, Nil)
   match_1(a_4, l_3, Cons(x, l')) -> match_2(x, l', a_4, l_3, part(a_4, l'))
   match_2(x, l', a_4, l_3, Pair(l1, l2)) -> match_3(l1, l2, x, l', a_4, l_3, test(a_4, x))
   match_3(l1, l2, x, l', a_4, l_3, False) -> Pair(Cons(x, l1), l2)
   match_3(l1, l2, x, l', a_4, l_3, True) -> Pair(l1, Cons(x, l2))
   quick(l_5) -> match_4(l_5, l_5)
   match_4(l_5, Nil) -> Nil
   match_4(l_5, Cons(a, l')) -> match_5(a, l', l_5, part(a, l'))
   match_5(a, l', l_5, Pair(l1, l2)) -> append(quick(l1), Cons(a, quick(l2)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(9) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*APPEND(l1_2, l2_1) -> MATCH_0(l1_2, l2_1, l1_2)
The graph contains the following edges 1 >= 1, 2 >= 2, 1 >= 3


*MATCH_0(l1_2, l2_1, Cons(x, l)) -> APPEND(l, l2_1)
The graph contains the following edges 3 > 1, 2 >= 2


----------------------------------------

(10)
YES

----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MATCH_5(a, l', l_5, Pair(l1, l2)) -> QUICK(l1)
   QUICK(l_5) -> MATCH_4(l_5, l_5)
   MATCH_4(l_5, Cons(a, l')) -> MATCH_5(a, l', l_5, part(a, l'))
   MATCH_5(a, l', l_5, Pair(l1, l2)) -> QUICK(l2)

The TRS R consists of the following rules:

   test(x_0, y) -> True
   test(x_0, y) -> False
   append(l1_2, l2_1) -> match_0(l1_2, l2_1, l1_2)
   match_0(l1_2, l2_1, Nil) -> l2_1
   match_0(l1_2, l2_1, Cons(x, l)) -> Cons(x, append(l, l2_1))
   part(a_4, l_3) -> match_1(a_4, l_3, l_3)
   match_1(a_4, l_3, Nil) -> Pair(Nil, Nil)
   match_1(a_4, l_3, Cons(x, l')) -> match_2(x, l', a_4, l_3, part(a_4, l'))
   match_2(x, l', a_4, l_3, Pair(l1, l2)) -> match_3(l1, l2, x, l', a_4, l_3, test(a_4, x))
   match_3(l1, l2, x, l', a_4, l_3, False) -> Pair(Cons(x, l1), l2)
   match_3(l1, l2, x, l', a_4, l_3, True) -> Pair(l1, Cons(x, l2))
   quick(l_5) -> match_4(l_5, l_5)
   match_4(l_5, Nil) -> Nil
   match_4(l_5, Cons(a, l')) -> match_5(a, l', l_5, part(a, l'))
   match_5(a, l', l_5, Pair(l1, l2)) -> append(quick(l1), Cons(a, quick(l2)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(12) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MATCH_4(l_5, Cons(a, l')) -> MATCH_5(a, l', l_5, part(a, l'))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( MATCH_5_4(x_1, ..., x_4) ) = x_4 + 1
POL( part_2(x_1, x_2) ) = 2x_2
POL( match_1_3(x_1, ..., x_3) ) = 2x_3
POL( Nil ) = 0
POL( Pair_2(x_1, x_2) ) = max{0, 2x_1 + 2x_2 - 1}
POL( Cons_2(x_1, x_2) ) = x_2 + 1
POL( match_2_5(x_1, ..., x_5) ) = x_5 + 2
POL( match_3_7(x_1, ..., x_7) ) = max{0, 2x_1 + 2x_2 + 2x_7 - 1}
POL( test_2(x_1, x_2) ) = 1
POL( True ) = 1
POL( False ) = 1
POL( QUICK_1(x_1) ) = 2x_1
POL( MATCH_4_2(x_1, x_2) ) = 2x_2

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   part(a_4, l_3) -> match_1(a_4, l_3, l_3)
   match_1(a_4, l_3, Nil) -> Pair(Nil, Nil)
   match_1(a_4, l_3, Cons(x, l')) -> match_2(x, l', a_4, l_3, part(a_4, l'))
   match_2(x, l', a_4, l_3, Pair(l1, l2)) -> match_3(l1, l2, x, l', a_4, l_3, test(a_4, x))
   test(x_0, y) -> True
   test(x_0, y) -> False
   match_3(l1, l2, x, l', a_4, l_3, False) -> Pair(Cons(x, l1), l2)
   match_3(l1, l2, x, l', a_4, l_3, True) -> Pair(l1, Cons(x, l2))


----------------------------------------

(13)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MATCH_5(a, l', l_5, Pair(l1, l2)) -> QUICK(l1)
   QUICK(l_5) -> MATCH_4(l_5, l_5)
   MATCH_5(a, l', l_5, Pair(l1, l2)) -> QUICK(l2)

The TRS R consists of the following rules:

   test(x_0, y) -> True
   test(x_0, y) -> False
   append(l1_2, l2_1) -> match_0(l1_2, l2_1, l1_2)
   match_0(l1_2, l2_1, Nil) -> l2_1
   match_0(l1_2, l2_1, Cons(x, l)) -> Cons(x, append(l, l2_1))
   part(a_4, l_3) -> match_1(a_4, l_3, l_3)
   match_1(a_4, l_3, Nil) -> Pair(Nil, Nil)
   match_1(a_4, l_3, Cons(x, l')) -> match_2(x, l', a_4, l_3, part(a_4, l'))
   match_2(x, l', a_4, l_3, Pair(l1, l2)) -> match_3(l1, l2, x, l', a_4, l_3, test(a_4, x))
   match_3(l1, l2, x, l', a_4, l_3, False) -> Pair(Cons(x, l1), l2)
   match_3(l1, l2, x, l', a_4, l_3, True) -> Pair(l1, Cons(x, l2))
   quick(l_5) -> match_4(l_5, l_5)
   match_4(l_5, Nil) -> Nil
   match_4(l_5, Cons(a, l')) -> match_5(a, l', l_5, part(a, l'))
   match_5(a, l', l_5, Pair(l1, l2)) -> append(quick(l1), Cons(a, quick(l2)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(14) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 3 less nodes.
----------------------------------------

(15)
TRUE
