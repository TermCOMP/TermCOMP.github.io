YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/BaWGj.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Quasi decreasingness of the given CTRS could be proven:

(0) CTRS
(1) CTRSToQTRSProof [SOUND, 0 ms]
(2) QTRS
(3) QTRSRRRProof [EQUIVALENT, 12 ms]
(4) QTRS
(5) RisEmptyProof [EQUIVALENT, 0 ms]
(6) YES


----------------------------------------

(0)
Obligation:
Conditional term rewrite system:
The TRS R consists of the following rules:

   split(x, nil) -> tp2(nil, nil)
   le(0, y) -> true
   le(s(x), 0) -> false
   le(s(x), s(y)) -> le(x, y)

The conditional TRS C consists of the following conditional rules:

   split(x, cons(y, ys)) -> tp2(zs1, cons(y, zs2)) <= split(x, ys) -> tp2(zs1, zs2), le(x, y) -> true
   split(x, cons(y, ys)) -> tp2(cons(y, zs1), zs2) <= split(x, ys) -> tp2(zs1, zs2), le(x, y) -> false


----------------------------------------

(1) CTRSToQTRSProof (SOUND)
The conditional rules have been transormed into unconditional rules according to [CTRS,AAECCNOC].
----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   split(x, cons(y, ys)) -> U1(split(x, ys), x, y)
   U1(tp2(zs1, zs2), x, y) -> U2(le(x, y), y, zs1, zs2)
   U2(false, y, zs1, zs2) -> tp2(cons(y, zs1), zs2)
   U2(true, y, zs1, zs2) -> tp2(zs1, cons(y, zs2))
   split(x, nil) -> tp2(nil, nil)
   le(0, y) -> true
   le(s(x), 0) -> false
   le(s(x), s(y)) -> le(x, y)

Q is empty.

----------------------------------------

(3) QTRSRRRProof (EQUIVALENT)
Used ordering:
Quasi precedence:
split_2 > U1_3 > U2_4 > [cons_2, tp2_2, le_2]
split_2 > nil > [cons_2, tp2_2, le_2]
0 > [false, s_1] > [cons_2, tp2_2, le_2]
0 > true > [cons_2, tp2_2, le_2]


Status:
split_2: multiset status
cons_2: [1,2]
U1_3: multiset status
tp2_2: multiset status
U2_4: multiset status
le_2: multiset status
false: multiset status
true: multiset status
nil: multiset status
0: multiset status
s_1: [1]

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   split(x, cons(y, ys)) -> U1(split(x, ys), x, y)
   U1(tp2(zs1, zs2), x, y) -> U2(le(x, y), y, zs1, zs2)
   U2(false, y, zs1, zs2) -> tp2(cons(y, zs1), zs2)
   U2(true, y, zs1, zs2) -> tp2(zs1, cons(y, zs2))
   split(x, nil) -> tp2(nil, nil)
   le(0, y) -> true
   le(s(x), 0) -> false
   le(s(x), s(y)) -> le(x, y)




----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
R is empty.
Q is empty.

----------------------------------------

(5) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(6)
YES
