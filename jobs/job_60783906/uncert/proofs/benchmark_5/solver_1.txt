YES

Problem 1: 

(VAR vu95NonEmpty x y)
(RULES
le(num0,s(x)) -> ftrue
le(s(x),s(y)) -> le(x,y)
le(x,num0) -> ffalse
m -> s(s(s(s(num0))))
pop(empty) -> empty
pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
size(empty) -> num0
size(push(x,y)) -> s(size(x))
top(empty) -> eentry
top(push(x,y)) -> y | le(size(x),m) ->* ftrue
)


Problem 1: 
Valid CTRS Processor:
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue
-> The system is a 2-CTRS.

Problem 1: 

2D Dependency Pair Processor:

Conditional Termination Problem 1:
-> Pairs:
 LE(s(x),s(y)) -> LE(x,y)
 SIZE(push(x,y)) -> SIZE(x)
-> QPairs:
 Empty
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue

Conditional Termination Problem 2:
-> Pairs:
 POP(push(x,y)) -> LE(size(x),m)
 POP(push(x,y)) -> M
 POP(push(x,y)) -> SIZE(x)
 TOP(push(x,y)) -> LE(size(x),m)
 TOP(push(x,y)) -> M
 TOP(push(x,y)) -> SIZE(x)
-> QPairs:
 LE(s(x),s(y)) -> LE(x,y)
 SIZE(push(x,y)) -> SIZE(x)
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue


The problem is decomposed in 2 subproblems.

Problem 1.1: 

SCC Processor:
-> Pairs:
 LE(s(x),s(y)) -> LE(x,y)
 SIZE(push(x,y)) -> SIZE(x)
-> QPairs:
 Empty
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 SIZE(push(x,y)) -> SIZE(x)
-> QPairs:
 Empty
->->-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue
->->Cycle:
->->-> Pairs:
 LE(s(x),s(y)) -> LE(x,y)
-> QPairs:
 Empty
->->-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue


The problem is decomposed in 2 subproblems.

Problem 1.1.1: 

Subterm Processor:
-> Pairs:
 SIZE(push(x,y)) -> SIZE(x)
-> QPairs:
 Empty
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue
->Projection:
 pi(SIZE) = 1

Problem 1.1.1: 

SCC Processor:
-> Pairs:
 Empty
-> QPairs:
 Empty
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.1.2: 

Subterm Processor:
-> Pairs:
 LE(s(x),s(y)) -> LE(x,y)
-> QPairs:
 Empty
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue
->Projection:
 pi(LE) = 1

Problem 1.1.2: 

SCC Processor:
-> Pairs:
 Empty
-> QPairs:
 Empty
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

SCC Processor:
-> Pairs:
 POP(push(x,y)) -> LE(size(x),m)
 POP(push(x,y)) -> M
 POP(push(x,y)) -> SIZE(x)
 TOP(push(x,y)) -> LE(size(x),m)
 TOP(push(x,y)) -> M
 TOP(push(x,y)) -> SIZE(x)
-> QPairs:
 LE(s(x),s(y)) -> LE(x,y)
 SIZE(push(x,y)) -> SIZE(x)
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
