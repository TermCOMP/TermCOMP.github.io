YES

Problem 1: 

(VAR vu95NonEmpty v w ws xu39 xs xsu39 y yu39 ys ysu39 z zs)
(RULES
get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
get(cons(y,ys)) -> tp2(y,ys)
sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
sspu39(xs,num0) -> nil
sub(s(v),s(w)) -> z | sub(v,w) ->* z
sub(z,num0) -> z
)


Problem 1: 
Valid CTRS Processor:
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
-> The system is a deterministic 3-CTRS.

Problem 1: 

2D Dependency Pair Processor:

Conditional Termination Problem 1:
-> Pairs:
 Empty
-> QPairs:
 Empty
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z

Conditional Termination Problem 2:
-> Pairs:
 GET(cons(xu39,xsu39)) -> GET(xsu39)
 SSPU39(cons(xu39,xsu39),v) -> GET(xsu39)
 SSPU39(cons(xu39,xsu39),v) -> SSPU39(cons(xu39,zs),w) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w
 SSPU39(cons(xu39,xsu39),v) -> SUB(v,yu39) | get(xsu39) ->* tp2(yu39,zs)
 SSPU39(cons(yu39,ws),v) -> SSPU39(ws,w) | sub(v,yu39) ->* w
 SSPU39(cons(yu39,ws),v) -> SUB(v,yu39)
 SUB(s(v),s(w)) -> SUB(v,w)
-> QPairs:
 Empty
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z


The problem is decomposed in 2 subproblems.

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> QPairs:
 Empty
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

SCC Processor:
-> Pairs:
 GET(cons(xu39,xsu39)) -> GET(xsu39)
 SSPU39(cons(xu39,xsu39),v) -> GET(xsu39)
 SSPU39(cons(xu39,xsu39),v) -> SSPU39(cons(xu39,zs),w) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w
 SSPU39(cons(xu39,xsu39),v) -> SUB(v,yu39) | get(xsu39) ->* tp2(yu39,zs)
 SSPU39(cons(yu39,ws),v) -> SSPU39(ws,w) | sub(v,yu39) ->* w
 SSPU39(cons(yu39,ws),v) -> SUB(v,yu39)
 SUB(s(v),s(w)) -> SUB(v,w)
-> QPairs:
 Empty
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 SUB(s(v),s(w)) -> SUB(v,w)
-> QPairs:
 Empty
->->-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
->->Cycle:
->->-> Pairs:
 GET(cons(xu39,xsu39)) -> GET(xsu39)
-> QPairs:
 Empty
->->-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
->->Cycle:
->->-> Pairs:
 SSPU39(cons(xu39,xsu39),v) -> SSPU39(cons(xu39,zs),w) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w
 SSPU39(cons(yu39,ws),v) -> SSPU39(ws,w) | sub(v,yu39) ->* w
-> QPairs:
 Empty
->->-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z


The problem is decomposed in 3 subproblems.

Problem 1.2.1: 

Subterm Processor:
-> Pairs:
 SUB(s(v),s(w)) -> SUB(v,w)
-> QPairs:
 Empty
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
->Projection:
 pi(SUB) = 1

Problem 1.2.1: 

SCC Processor:
-> Pairs:
 Empty
-> QPairs:
 Empty
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2.2: 

Subterm Processor:
-> Pairs:
 GET(cons(xu39,xsu39)) -> GET(xsu39)
-> QPairs:
 Empty
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
->Projection:
 pi(GET) = 1

Problem 1.2.2: 

SCC Processor:
-> Pairs:
 Empty
-> QPairs:
 Empty
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2.3: 

Semantic Removal Triple Processor:
-> Pairs:
 SSPU39(cons(xu39,xsu39),v) -> SSPU39(cons(xu39,zs),w) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w
 SSPU39(cons(yu39,ws),v) -> SSPU39(ws,w) | sub(v,yu39) ->* w
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
-> Usable rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
-> Needed rules:
 Empty
->AGES Output:
 
Model Results

System:
mod InTheory is
sort S .
sort Bool .
sort PSharp .


op _->*_ : S S -> Bool [m = 2] .
op _->_ : S S -> Bool [m = 2] .
op get : S -> S .
op sspu39 : S S -> S .
op sub : S S -> S .
op num0 :  -> S .
op cons : S S -> S .
op fSNonEmpty :  -> S .
op nil :  -> S .
op s : S -> S .
op tp2 : S S -> S .
op _->P_ : PSharp PSharp -> Bool .
op _->Q_ : PSharp PSharp -> Bool .
op GET : S -> PSharp .
op SSPU39 : S S -> PSharp .
op SUB : S S -> PSharp .
op pi : S S -> S .
op gtrsim : PSharp PSharp -> Bool .
op succeq : PSharp PSharp -> Bool .
op sqsupset : PSharp PSharp -> Bool [wellfounded m = 1] .
op _->N_ : S S -> Bool .
op _->N_ : PSharp PSharp -> Bool .

endm


Property:
x ->R* x
x ->R y /\ y ->R* z => x ->R* z
gtrsim(x,y) /\ sqsupset(y,z) => sqsupset(x,z)
succeq(x,y) /\ sqsupset(y,z) => sqsupset(x,z)
gtrsim(x,y) /\ succeq(y,z) => gtrsim(x,z)
_->N_(x,y) => gtrsim(x,y)
_->P_(x,y) => gtrsim(x,y) \/ succeq(x,y) \/ sqsupset(x,y)
_->Q_(x,y) => gtrsim(x,y) \/ succeq(x,y) \/ sqsupset(x,y)
x1 ->R y1 => get(x1) ->R get(y1)
x1 ->R y1 => sub(x1,x2) ->R sub(y1,x2)
x2 ->R y2 => sub(x1,x2) ->R sub(x1,y2)
x1 ->R y1 => cons(x1,x2) ->R cons(y1,x2)
x2 ->R y2 => cons(x1,x2) ->R cons(x1,y2)
x1 ->R y1 => s(x1) ->R s(y1)
x1 ->R y1 => tp2(x1,x2) ->R tp2(y1,x2)
x2 ->R y2 => tp2(x1,x2) ->R tp2(x1,y2)
_->N_(x1,y1) => _->N_(get(x1),get(y1))
_->N_(x1,y1) => _->N_(sub(x1,x2),sub(y1,x2))
_->N_(x2,y2) => _->N_(sub(x1,x2),sub(x1,y2))
_->N_(x1,y1) => _->N_(cons(x1,x2),cons(y1,x2))
_->N_(x2,y2) => _->N_(cons(x1,x2),cons(x1,y2))
_->N_(x1,y1) => _->N_(s(x1),s(y1))
_->N_(x1,y1) => _->N_(tp2(x1,x2),tp2(y1,x2))
_->N_(x2,y2) => _->N_(tp2(x1,x2),tp2(x1,y2))
_->N_(x1,y1) => _->N_(SSPU39(x1,x2),SSPU39(y1,x2))
_->N_(x2,y2) => _->N_(SSPU39(x1,x2),SSPU39(x1,y2))
get(xsu39) ->R* tp2(y,zs) => get(cons(xu39,xsu39)) ->R tp2(y,cons(xu39,zs))
get(cons(y,ys)) ->R tp2(y,ys)
sub(v,w) ->R* z => sub(s(v),s(w)) ->R z
sub(z,num0) ->R z
pi(x13,x14) ->R x13
pi(x13,x14) ->R x14
_->N_(pi(x13,x14),x13)
_->N_(pi(x13,x14),x14)
sub(v,yu39) ->R* w => _->P_(SSPU39(cons(yu39,ws),v),SSPU39(ws,w))
get(xsu39) ->R* tp2(yu39,zs) /\ sub(v,yu39) ->R* w => sqsupset(SSPU39(cons(xu39,xsu39),v),SSPU39(cons(xu39,zs),w))

Results:


Domains:
S: |N \ {0}
PSharp: |N

Function Interpretations:
|[GET(x_1_1:S)]| = - 1 + x_1_1:S
|[SSPU39(x_1_1:S,x_2_1:S)]| = 1 + x_1_1:S
|[SUB(x_1_1:S,x_2_1:S)]| = 0
|[cons(x_1_1:S,x_2_1:S)]| = 2.x_1_1:S + x_2_1:S
|[fSNonEmpty]| = 1
|[get(x_1_1:S)]| = x_1_1:S
|[nil]| = 1
|[num0]| = 1
|[pi(x_1_1:S,x_2_1:S)]| = x_1_1:S + x_2_1:S
|[s(x_1_1:S)]| = x_1_1:S
|[sspu39(x_1_1:S,x_2_1:S)]| = 1
|[sub(x_1_1:S,x_2_1:S)]| = x_1_1:S + x_2_1:S
|[tp2(x_1_1:S,x_2_1:S)]| = - 1 + 2.x_1_1:S + x_2_1:S

Predicate Interpretations:
 x_1_1:S ->* x_2_1:S <=> (x_1_1:S >= x_2_1:S)
 x_1_1:S ->N x_2_1:S <=> (x_1_1:S >= x_2_1:S)
 x_1_1:PSharp ->N x_2_1:PSharp <=> (x_1_1:PSharp >= x_2_1:PSharp)
 x_1_1:PSharp ->P x_2_1:PSharp <=> (x_1_1:PSharp >= 2 + x_2_1:PSharp)
 x_1_1:PSharp ->Q x_2_1:PSharp <=> (0 >= 1 + x_1_1:PSharp + 2.x_2_1:PSharp)
 x_1_1:S -> x_2_1:S <=> (x_1_1:S >= x_2_1:S)
gtrsim(x_1_1:PSharp,x_2_1:PSharp) <=> (x_1_1:PSharp >= x_2_1:PSharp)
sqsupset(x_1_1:PSharp,x_2_1:PSharp) <=> (x_1_1:PSharp >= 1 + x_2_1:PSharp)
succeq(x_1_1:PSharp,x_2_1:PSharp) <=> (0 >= 1 + x_1_1:PSharp + x_2_1:PSharp)

Problem 1.2.3: 

SCC Processor:
-> Pairs:
 SSPU39(cons(yu39,ws),v) -> SSPU39(ws,w) | sub(v,yu39) ->* w
-> QPairs:
 Empty
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 SSPU39(cons(yu39,ws),v) -> SSPU39(ws,w) | sub(v,yu39) ->* w
-> QPairs:
 Empty
->->-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z

Problem 1.2.3: 

Subterm Processor:
-> Pairs:
 SSPU39(cons(yu39,ws),v) -> SSPU39(ws,w) | sub(v,yu39) ->* w
-> QPairs:
 Empty
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
->Projection:
 pi(SSPU39) = 1

Problem 1.2.3: 

SCC Processor:
-> Pairs:
 Empty
-> QPairs:
 Empty
-> Rules:
 get(cons(xu39,xsu39)) -> tp2(y,cons(xu39,zs)) | get(xsu39) ->* tp2(y,zs)
 get(cons(y,ys)) -> tp2(y,ys)
 sspu39(cons(xu39,xsu39),v) -> cons(yu39,ysu39) | get(xsu39) ->* tp2(yu39,zs), sub(v,yu39) ->* w, sspu39(cons(xu39,zs),w) ->* ysu39
 sspu39(cons(yu39,ws),v) -> cons(yu39,ysu39) | sub(v,yu39) ->* w, sspu39(ws,w) ->* ysu39
 sspu39(xs,num0) -> nil
 sub(s(v),s(w)) -> z | sub(v,w) ->* z
 sub(z,num0) -> z
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
