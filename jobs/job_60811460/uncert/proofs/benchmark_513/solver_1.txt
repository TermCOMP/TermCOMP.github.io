WORST_CASE(Omega(n^1),O(n^1))

# LoAT Proof:
WORST_CASE(Omega(n^1),?)

WORST_CASE(Omega(n^1),?)
Initial ITS

Start location: f2

Location map:
LoAT_sink -> 0
f2 -> 1
f1 -> 2
f300 -> 3

Rules:
   0: (1-i4 >= 0 /\ -1+i1 == 0) /\ i1'=2, i3'=1+i3, i5'=it2
   1: (-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0) /\ i1'=3, i3'=1+i3
   2: (-3+i1 == 0 /\ 1+i7 >= 0) /\ i1'=2, i3'=1+i3, i5'=it3
   3: (-3+i1 == 0 /\ -2-i7 >= 0 /\ i8 >= 0) /\ i1'=3, i3'=1+i3, i7'=1+i7, i8'=1+i8
   4: (-3+i1 == 0 /\ -2-i7 >= 0 /\ -2-i8 >= 0) /\ i1'=3, i3'=1+i3, i7'=1+i7, i8'=1+i8

Dependency graph:
1 -> 2, 1 -> 3, 1 -> 4
3 -> 2, 3 -> 3, 3 -> 4
4 -> 2, 4 -> 3, 4 -> 4

Refined Dependency Graph

	Removed the following edges: 3 -> 4, 4 -> 3

Start location: f2

Location map:
LoAT_sink -> 0
f2 -> 1
f1 -> 2
f300 -> 3

Rules:
   0: (1-i4 >= 0 /\ -1+i1 == 0) /\ i1'=2, i3'=1+i3, i5'=it2
   1: (-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0) /\ i1'=3, i3'=1+i3
   2: (-3+i1 == 0 /\ 1+i7 >= 0) /\ i1'=2, i3'=1+i3, i5'=it3
   3: (-3+i1 == 0 /\ -2-i7 >= 0 /\ i8 >= 0) /\ i1'=3, i3'=1+i3, i7'=1+i7, i8'=1+i8
   4: (-3+i1 == 0 /\ -2-i7 >= 0 /\ -2-i8 >= 0) /\ i1'=3, i3'=1+i3, i7'=1+i7, i8'=1+i8

Dependency graph:
1 -> 2, 1 -> 3, 1 -> 4
3 -> 2, 3 -> 3
4 -> 2, 4 -> 4

Step with 1

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	
	Blocked

	{}
	{}
	
Step with 4

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	4[(-3+i1 == 0 /\ -2-i7 >= 0 /\ -2-i8 >= 0)]
	
	Blocked

	{}
	{}
	{}
	
Poly(n^1)

Accelerate

	Loop Acceleration

	Original rule:
	(-3+i1 == 0 /\ -2-i7 >= 0 /\ -2-i8 >= 0) /\ i1'=3, i3'=1+i3, i7'=1+i7, i8'=1+i8
	New rule:
	(-3+i1 >= 0 /\ -1-it18-i7 >= 0 /\ -1+it18 >= 0 /\ 3-i1 >= 0 /\ -1-it18-i8 >= 0) /\ i1'=i1, i3'=i3+it18, i7'=it18+i7, i8'=it18+i8

		-3+i1 >= 0 [0]: unchanged
		
		-2-i7 >= 0 [0]: montonic decrease yields -1-it18-i7 >= 0
		
		-2-i8 >= 0 [0]: montonic decrease yields -1-it18-i8 >= 0
		
		3-i1 >= 0 [0]: unchanged
		
		Replacement map: {-3+i1 >= 0 -> -3+i1 >= 0, -2-i7 >= 0 -> -1-it18-i7 >= 0, -2-i8 >= 0 -> -1-it18-i8 >= 0, 3-i1 >= 0 -> 3-i1 >= 0}

	Removed Trivial Updates

	Original rule:
	(-3+i1 >= 0 /\ -1-it18-i7 >= 0 /\ -1+it18 >= 0 /\ 3-i1 >= 0 /\ -1-it18-i8 >= 0) /\ i1'=i1, i3'=i3+it18, i7'=it18+i7, i8'=it18+i8
	New rule:
	(-3+i1 >= 0 /\ -1-it18-i7 >= 0 /\ -1+it18 >= 0 /\ 3-i1 >= 0 /\ -1-it18-i8 >= 0) /\ i3'=i3+it18, i7'=it18+i7, i8'=it18+i8

Start location: f2

Location map:
LoAT_sink -> 0
f2 -> 1
f1 -> 2
f300 -> 3

Rules:
   0: (1-i4 >= 0 /\ -1+i1 == 0) /\ i1'=2, i3'=1+i3, i5'=it2
   1: (-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0) /\ i1'=3, i3'=1+i3
   2: (-3+i1 == 0 /\ 1+i7 >= 0) /\ i1'=2, i3'=1+i3, i5'=it3
   3: (-3+i1 == 0 /\ -2-i7 >= 0 /\ i8 >= 0) /\ i1'=3, i3'=1+i3, i7'=1+i7, i8'=1+i8
   4: (-3+i1 == 0 /\ -2-i7 >= 0 /\ -2-i8 >= 0) /\ i1'=3, i3'=1+i3, i7'=1+i7, i8'=1+i8
   5: (-3+i1 >= 0 /\ -1-it18-i7 >= 0 /\ -1+it18 >= 0 /\ 3-i1 >= 0 /\ -1-it18-i8 >= 0) /\ i3'=i3+it18, i7'=it18+i7, i8'=it18+i8

Dependency graph:
1 -> 2, 1 -> 3, 1 -> 4, 1 -> 5
3 -> 2, 3 -> 3
4 -> 2, 4 -> 4, 4 -> 5
5 -> 2, 5 -> 4

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	5[(-3+i1 >= 0 /\ -1-it18-i7 >= 0 /\ -1+it18 >= 0 /\ 3-i1 >= 0 /\ -1-it18-i8 >= 0)]
	
	Blocked

	{}
	{}
	{4[T], 5[T]}
	
Step with 2

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	5[(-3+i1 >= 0 /\ -1-it18-i7 >= 0 /\ -1+it18 >= 0 /\ 3-i1 >= 0 /\ -1-it18-i8 >= 0)]
	2[(-3+i1 == 0 /\ 1+i7 >= 0)]
	
	Blocked

	{}
	{}
	{4[T], 5[T]}
	{}
	
Backtrack

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	5[(-3+i1 >= 0 /\ -1-it18-i7 >= 0 /\ -1+it18 >= 0 /\ 3-i1 >= 0 /\ -1-it18-i8 >= 0)]
	
	Blocked

	{}
	{}
	{2[T], 4[T], 5[T]}
	
Backtrack

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	
	Blocked

	{}
	{5[T]}
	
Step with 4

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	4[(-3+i1 == 0 /\ -2-i7 >= 0 /\ -2-i8 >= 0)]
	
	Blocked

	{}
	{5[T]}
	{}
	
Covered

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	
	Blocked

	{}
	{4[T], 5[T]}
	
Step with 2

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	2[(-3+i1 == 0 /\ 1+i7 >= 0)]
	
	Blocked

	{}
	{4[T], 5[T]}
	{}
	
Backtrack

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	
	Blocked

	{}
	{2[T], 4[T], 5[T]}
	
Step with 3

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	3[(-3+i1 == 0 /\ -2-i7 >= 0 /\ i8 >= 0)]
	
	Blocked

	{}
	{2[T], 4[T], 5[T]}
	{}
	
Accelerate

	Loop Acceleration

	Original rule:
	(-3+i1 == 0 /\ -2-i7 >= 0 /\ i8 >= 0) /\ i1'=3, i3'=1+i3, i7'=1+i7, i8'=1+i8
	New rule:
	(-3+i1 >= 0 /\ -1+it71 >= 0 /\ -1-i7-it71 >= 0 /\ 3-i1 >= 0 /\ i8 >= 0) /\ i1'=i1, i3'=i3+it71, i7'=i7+it71, i8'=i8+it71

		-3+i1 >= 0 [0]: unchanged
		
		-2-i7 >= 0 [0]: montonic decrease yields -1-i7-it71 >= 0
		
		3-i1 >= 0 [0]: unchanged
		
		i8 >= 0 [0]: monotonic increase yields i8 >= 0
		
		Replacement map: {-3+i1 >= 0 -> -3+i1 >= 0, -2-i7 >= 0 -> -1-i7-it71 >= 0, 3-i1 >= 0 -> 3-i1 >= 0, i8 >= 0 -> i8 >= 0}

	Removed Trivial Updates

	Original rule:
	(-3+i1 >= 0 /\ -1+it71 >= 0 /\ -1-i7-it71 >= 0 /\ 3-i1 >= 0 /\ i8 >= 0) /\ i1'=i1, i3'=i3+it71, i7'=i7+it71, i8'=i8+it71
	New rule:
	(-3+i1 >= 0 /\ -1+it71 >= 0 /\ -1-i7-it71 >= 0 /\ 3-i1 >= 0 /\ i8 >= 0) /\ i3'=i3+it71, i7'=i7+it71, i8'=i8+it71
	
	Instantiation

	Original rule:
	(-3+i1 >= 0 /\ -1+it71 >= 0 /\ -1-i7-it71 >= 0 /\ 3-i1 >= 0 /\ i8 >= 0) /\ i3'=i3+it71, i7'=i7+it71, i8'=i8+it71
	New rule:
	(0 >= 0 /\ -3+i1 >= 0 /\ -2-i7 >= 0 /\ 3-i1 >= 0 /\ i8 >= 0) /\ i3'=-1+i3-i7, i7'=-1, i8'=-1-i7+i8

Start location: f2

Location map:
LoAT_sink -> 0
f2 -> 1
f1 -> 2
f300 -> 3

Rules:
   0: (1-i4 >= 0 /\ -1+i1 == 0) /\ i1'=2, i3'=1+i3, i5'=it2
   1: (-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0) /\ i1'=3, i3'=1+i3
   2: (-3+i1 == 0 /\ 1+i7 >= 0) /\ i1'=2, i3'=1+i3, i5'=it3
   3: (-3+i1 == 0 /\ -2-i7 >= 0 /\ i8 >= 0) /\ i1'=3, i3'=1+i3, i7'=1+i7, i8'=1+i8
   4: (-3+i1 == 0 /\ -2-i7 >= 0 /\ -2-i8 >= 0) /\ i1'=3, i3'=1+i3, i7'=1+i7, i8'=1+i8
   5: (-3+i1 >= 0 /\ -1-it18-i7 >= 0 /\ -1+it18 >= 0 /\ 3-i1 >= 0 /\ -1-it18-i8 >= 0) /\ i3'=i3+it18, i7'=it18+i7, i8'=it18+i8
   6: (0 >= 0 /\ -3+i1 >= 0 /\ -2-i7 >= 0 /\ 3-i1 >= 0 /\ i8 >= 0) /\ i3'=-1+i3-i7, i7'=-1, i8'=-1-i7+i8

Dependency graph:
1 -> 2, 1 -> 3, 1 -> 4, 1 -> 5, 1 -> 6
3 -> 2, 3 -> 3, 3 -> 6
4 -> 2, 4 -> 4, 4 -> 5
5 -> 2, 5 -> 4
6 -> 2, 6 -> 3

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	6[(0 >= 0 /\ -3+i1 >= 0 /\ -2-i7 >= 0 /\ 3-i1 >= 0 /\ i8 >= 0)]
	
	Blocked

	{}
	{2[T], 4[T], 5[T]}
	{3[T], 6[T]}
	
Step with 2

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	6[(0 >= 0 /\ -3+i1 >= 0 /\ -2-i7 >= 0 /\ 3-i1 >= 0 /\ i8 >= 0)]
	2[(-3+i1 == 0 /\ 1+i7 >= 0)]
	
	Blocked

	{}
	{2[T], 4[T], 5[T]}
	{3[T], 6[T]}
	{}
	
Backtrack

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	6[(0 >= 0 /\ -3+i1 >= 0 /\ -2-i7 >= 0 /\ 3-i1 >= 0 /\ i8 >= 0)]
	
	Blocked

	{}
	{2[T], 4[T], 5[T]}
	{2[T], 3[T], 6[T]}
	
Backtrack

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	
	Blocked

	{}
	{2[T], 4[T], 5[T], 6[T]}
	
Step with 3

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	3[(-3+i1 == 0 /\ -2-i7 >= 0 /\ i8 >= 0)]
	
	Blocked

	{}
	{2[T], 4[T], 5[T], 6[T]}
	{}
	
Covered

	Trace

	1[(-2+i6 >= 0 /\ -2+i4 >= 0 /\ -1+i1 == 0)]
	
	Blocked

	{}
	{2[T], 3[T], 4[T], 5[T], 6[T]}
	
Backtrack

	Trace

	Blocked

	{1[T]}
	
Step with 0

	Trace

	0[(1-i4 >= 0 /\ -1+i1 == 0)]
	
	Blocked

	{1[T]}
	{}
	
Backtrack

	Trace

	Blocked

	{0[T], 1[T]}
	
Accept

Poly(n^1)


Build SHA: 6b55ffa0f2e04038cf304ba1a3fdb6d4d62c77f7

# KoAT Proof:
WORST_CASE(?, O(n^1))


Initial Problem
  Start:  l0
  Program_Vars:  X₀, X₁, X₂, X₃, X₄
  Temp_Vars:  F
  Locations:  l0, l1, l2
  Return Locations:  
  Transitions:
  t₁: l0(X₀, X₁, X₂, X₃, X₄) → l1(X₀, X₁, X₂, X₃, X₄) :|: 2 ≤ X₀ ∧ 2 ≤ X₂
  t₀: l0(X₀, X₁, X₂, X₃, X₄) → l2(X₀, F, X₂, X₃, X₄) :|: X₀ ≤ 1
  t₃: l1(X₀, X₁, X₂, X₃, X₄) → l1(X₀, X₁, X₂, 1+X₃, 1+X₄) :|: 2+X₃ ≤ 0 ∧ 0 ≤ X₄
  t₄: l1(X₀, X₁, X₂, X₃, X₄) → l1(X₀, X₁, X₂, 1+X₃, 1+X₄) :|: 2+X₃ ≤ 0 ∧ 2+X₄ ≤ 0
  t₂: l1(X₀, X₁, X₂, X₃, X₄) → l2(X₀, F, X₂, X₃, X₄) :|: 0 ≤ 1+X₃


Preprocessing
  Eliminate variables [F; X₁] that do not contribute to the problem


  Found invariant 2 ≤ X₁ ∧ 4 ≤ X₀+X₁ ∧ 2 ≤ X₀ for location l1


Problem after Preprocessing
  Start:  l0
  Program_Vars:  X₀, X₁, X₂, X₃
  Temp_Vars:  
  Locations:  l0, l1, l2
  Return Locations:  
  Transitions:
  t₅: l0(X₀, X₁, X₂, X₃) → l1(X₀, X₁, X₂, X₃) :|: 2 ≤ X₀ ∧ 2 ≤ X₁
  t₆: l0(X₀, X₁, X₂, X₃) → l2(X₀, X₁, X₂, X₃) :|: X₀ ≤ 1
  t₇: l1(X₀, X₁, X₂, X₃) → l1(X₀, X₁, 1+X₂, 1+X₃) :|: 2+X₂ ≤ 0 ∧ 0 ≤ X₃ ∧ 2 ≤ X₀ ∧ 2 ≤ X₁ ∧ 4 ≤ X₀+X₁
  t₈: l1(X₀, X₁, X₂, X₃) → l1(X₀, X₁, 1+X₂, 1+X₃) :|: 2+X₂ ≤ 0 ∧ 2+X₃ ≤ 0 ∧ 2 ≤ X₀ ∧ 2 ≤ X₁ ∧ 4 ≤ X₀+X₁
  t₉: l1(X₀, X₁, X₂, X₃) → l2(X₀, X₁, X₂, X₃) :|: 0 ≤ 1+X₂ ∧ 2 ≤ X₀ ∧ 2 ≤ X₁ ∧ 4 ≤ X₀+X₁


MPRF for transition t₇: l1(X₀, X₁, X₂, X₃) → l1(X₀, X₁, 1+X₂, 1+X₃) :|: 2+X₂ ≤ 0 ∧ 0 ≤ X₃ ∧ 2 ≤ X₀ ∧ 2 ≤ X₁ ∧ 4 ≤ X₀+X₁ of depth 1:
  new bound:
    X₂ {O(n)}

  MPRF:
    • l1: [-X₂]




MPRF for transition t₈: l1(X₀, X₁, X₂, X₃) → l1(X₀, X₁, 1+X₂, 1+X₃) :|: 2+X₂ ≤ 0 ∧ 2+X₃ ≤ 0 ∧ 2 ≤ X₀ ∧ 2 ≤ X₁ ∧ 4 ≤ X₀+X₁ of depth 1:
  new bound:
    X₂ {O(n)}

  MPRF:
    • l1: [-X₂]




All Bounds
Timebounds
  Overall timebound:2⋅X₂+3 {O(n)}
    t₅: 1 {O(1)}
    t₆: 1 {O(1)}
    t₇: X₂ {O(n)}
    t₈: X₂ {O(n)}
    t₉: 1 {O(1)}


Costbounds
  Overall costbound: 2⋅X₂+3 {O(n)}
    t₅: 1 {O(1)}
    t₆: 1 {O(1)}
    t₇: X₂ {O(n)}
    t₈: X₂ {O(n)}
    t₉: 1 {O(1)}


Sizebounds
    t₅, X₀: X₀ {O(n)}
    t₅, X₁: X₁ {O(n)}
    t₅, X₂: X₂ {O(n)}
    t₅, X₃: X₃ {O(n)}
    t₆, X₀: X₀ {O(n)}
    t₆, X₁: X₁ {O(n)}
    t₆, X₂: X₂ {O(n)}
    t₆, X₃: X₃ {O(n)}
    t₇, X₀: X₀ {O(n)}
    t₇, X₁: X₁ {O(n)}
    t₇, X₂: X₂ {O(n)}
    t₇, X₃: X₂+X₃ {O(n)}
    t₈, X₀: X₀ {O(n)}
    t₈, X₁: X₁ {O(n)}
    t₈, X₂: X₂ {O(n)}
    t₈, X₃: X₃ {O(n)}
    t₉, X₀: 3⋅X₀ {O(n)}
    t₉, X₁: 3⋅X₁ {O(n)}
    t₉, X₂: 3⋅X₂ {O(n)}
    t₉, X₃: 3⋅X₃+X₂ {O(n)}

