YES
proof of /home/ff862203/input_HxX1O1Lcb1.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) QTRSToCSRProof [SOUND, 0 ms]
(2) CSR
(3) CSRInnermostProof [EQUIVALENT, 0 ms]
(4) CSR
(5) CSDependencyPairsProof [EQUIVALENT, 0 ms]
(6) QCSDP
(7) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
(8) AND
    (9) QCSDP
        (10) QCSDPSubtermProof [EQUIVALENT, 1 ms]
        (11) QCSDP
        (12) PIsEmptyProof [EQUIVALENT, 0 ms]
        (13) YES
    (14) QCSDP
        (15) QCSDPSubtermProof [EQUIVALENT, 1 ms]
        (16) QCSDP
        (17) PIsEmptyProof [EQUIVALENT, 0 ms]
        (18) YES
    (19) QCSDP
        (20) QCSDPSubtermProof [EQUIVALENT, 6 ms]
        (21) QCSDP
        (22) PIsEmptyProof [EQUIVALENT, 0 ms]
        (23) YES
    (24) QCSDP
        (25) QCSDPSubtermProof [EQUIVALENT, 0 ms]
        (26) QCSDP
        (27) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
        (28) TRUE


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   active(s(X)) -> s(active(X))
   active(posrecip(X)) -> posrecip(active(X))
   active(negrecip(X)) -> negrecip(active(X))
   active(cons(X1, X2)) -> cons(active(X1), X2)
   active(cons2(X1, X2)) -> cons2(X1, active(X2))
   active(rcons(X1, X2)) -> rcons(active(X1), X2)
   active(rcons(X1, X2)) -> rcons(X1, active(X2))
   active(from(X)) -> from(active(X))
   active(2ndspos(X1, X2)) -> 2ndspos(active(X1), X2)
   active(2ndspos(X1, X2)) -> 2ndspos(X1, active(X2))
   active(2ndsneg(X1, X2)) -> 2ndsneg(active(X1), X2)
   active(2ndsneg(X1, X2)) -> 2ndsneg(X1, active(X2))
   active(pi(X)) -> pi(active(X))
   active(plus(X1, X2)) -> plus(active(X1), X2)
   active(plus(X1, X2)) -> plus(X1, active(X2))
   active(times(X1, X2)) -> times(active(X1), X2)
   active(times(X1, X2)) -> times(X1, active(X2))
   active(square(X)) -> square(active(X))
   s(mark(X)) -> mark(s(X))
   posrecip(mark(X)) -> mark(posrecip(X))
   negrecip(mark(X)) -> mark(negrecip(X))
   cons(mark(X1), X2) -> mark(cons(X1, X2))
   cons2(X1, mark(X2)) -> mark(cons2(X1, X2))
   rcons(mark(X1), X2) -> mark(rcons(X1, X2))
   rcons(X1, mark(X2)) -> mark(rcons(X1, X2))
   from(mark(X)) -> mark(from(X))
   2ndspos(mark(X1), X2) -> mark(2ndspos(X1, X2))
   2ndspos(X1, mark(X2)) -> mark(2ndspos(X1, X2))
   2ndsneg(mark(X1), X2) -> mark(2ndsneg(X1, X2))
   2ndsneg(X1, mark(X2)) -> mark(2ndsneg(X1, X2))
   pi(mark(X)) -> mark(pi(X))
   plus(mark(X1), X2) -> mark(plus(X1, X2))
   plus(X1, mark(X2)) -> mark(plus(X1, X2))
   times(mark(X1), X2) -> mark(times(X1, X2))
   times(X1, mark(X2)) -> mark(times(X1, X2))
   square(mark(X)) -> mark(square(X))
   proper(0) -> ok(0)
   proper(s(X)) -> s(proper(X))
   proper(posrecip(X)) -> posrecip(proper(X))
   proper(negrecip(X)) -> negrecip(proper(X))
   proper(nil) -> ok(nil)
   proper(cons(X1, X2)) -> cons(proper(X1), proper(X2))
   proper(cons2(X1, X2)) -> cons2(proper(X1), proper(X2))
   proper(rnil) -> ok(rnil)
   proper(rcons(X1, X2)) -> rcons(proper(X1), proper(X2))
   proper(from(X)) -> from(proper(X))
   proper(2ndspos(X1, X2)) -> 2ndspos(proper(X1), proper(X2))
   proper(2ndsneg(X1, X2)) -> 2ndsneg(proper(X1), proper(X2))
   proper(pi(X)) -> pi(proper(X))
   proper(plus(X1, X2)) -> plus(proper(X1), proper(X2))
   proper(times(X1, X2)) -> times(proper(X1), proper(X2))
   proper(square(X)) -> square(proper(X))
   s(ok(X)) -> ok(s(X))
   posrecip(ok(X)) -> ok(posrecip(X))
   negrecip(ok(X)) -> ok(negrecip(X))
   cons(ok(X1), ok(X2)) -> ok(cons(X1, X2))
   cons2(ok(X1), ok(X2)) -> ok(cons2(X1, X2))
   rcons(ok(X1), ok(X2)) -> ok(rcons(X1, X2))
   from(ok(X)) -> ok(from(X))
   2ndspos(ok(X1), ok(X2)) -> ok(2ndspos(X1, X2))
   2ndsneg(ok(X1), ok(X2)) -> ok(2ndsneg(X1, X2))
   pi(ok(X)) -> ok(pi(X))
   plus(ok(X1), ok(X2)) -> ok(plus(X1, X2))
   times(ok(X1), ok(X2)) -> ok(times(X1, X2))
   square(ok(X)) -> ok(square(X))
   top(mark(X)) -> top(proper(X))
   top(ok(X)) -> top(active(X))

The set Q consists of the following terms:

   active(rcons(x0, x1))
   active(plus(x0, x1))
   cons2(x0, mark(x1))
   proper(square(x0))
   proper(cons2(x0, x1))
   proper(2ndsneg(x0, x1))
   proper(2ndspos(x0, x1))
   proper(negrecip(x0))
   active(posrecip(x0))
   square(ok(x0))
   plus(ok(x0), ok(x1))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   proper(cons(x0, x1))
   proper(rcons(x0, x1))
   active(pi(x0))
   active(2ndsneg(x0, x1))
   proper(0)
   proper(from(x0))
   s(ok(x0))
   active(from(x0))
   negrecip(mark(x0))
   2ndspos(mark(x0), x1)
   pi(ok(x0))
   active(cons(x0, x1))
   proper(pi(x0))
   proper(plus(x0, x1))
   active(s(x0))
   cons(ok(x0), ok(x1))
   active(negrecip(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   proper(s(x0))
   active(2ndspos(x0, x1))
   2ndsneg(ok(x0), ok(x1))
   proper(rnil)
   rcons(mark(x0), x1)
   from(ok(x0))
   top(mark(x0))
   cons(mark(x0), x1)
   rcons(ok(x0), ok(x1))
   proper(nil)
   2ndspos(ok(x0), ok(x1))
   proper(times(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   posrecip(ok(x0))
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   negrecip(ok(x0))
   cons2(ok(x0), ok(x1))
   plus(x0, mark(x1))
   active(times(x0, x1))
   posrecip(mark(x0))
   s(mark(x0))
   active(cons2(x0, x1))
   top(ok(x0))
   proper(posrecip(x0))
   times(ok(x0), ok(x1))
   2ndspos(x0, mark(x1))


----------------------------------------

(1) QTRSToCSRProof (SOUND)
The following Q TRS is given: Q restricted rewrite system:
The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   active(s(X)) -> s(active(X))
   active(posrecip(X)) -> posrecip(active(X))
   active(negrecip(X)) -> negrecip(active(X))
   active(cons(X1, X2)) -> cons(active(X1), X2)
   active(cons2(X1, X2)) -> cons2(X1, active(X2))
   active(rcons(X1, X2)) -> rcons(active(X1), X2)
   active(rcons(X1, X2)) -> rcons(X1, active(X2))
   active(from(X)) -> from(active(X))
   active(2ndspos(X1, X2)) -> 2ndspos(active(X1), X2)
   active(2ndspos(X1, X2)) -> 2ndspos(X1, active(X2))
   active(2ndsneg(X1, X2)) -> 2ndsneg(active(X1), X2)
   active(2ndsneg(X1, X2)) -> 2ndsneg(X1, active(X2))
   active(pi(X)) -> pi(active(X))
   active(plus(X1, X2)) -> plus(active(X1), X2)
   active(plus(X1, X2)) -> plus(X1, active(X2))
   active(times(X1, X2)) -> times(active(X1), X2)
   active(times(X1, X2)) -> times(X1, active(X2))
   active(square(X)) -> square(active(X))
   s(mark(X)) -> mark(s(X))
   posrecip(mark(X)) -> mark(posrecip(X))
   negrecip(mark(X)) -> mark(negrecip(X))
   cons(mark(X1), X2) -> mark(cons(X1, X2))
   cons2(X1, mark(X2)) -> mark(cons2(X1, X2))
   rcons(mark(X1), X2) -> mark(rcons(X1, X2))
   rcons(X1, mark(X2)) -> mark(rcons(X1, X2))
   from(mark(X)) -> mark(from(X))
   2ndspos(mark(X1), X2) -> mark(2ndspos(X1, X2))
   2ndspos(X1, mark(X2)) -> mark(2ndspos(X1, X2))
   2ndsneg(mark(X1), X2) -> mark(2ndsneg(X1, X2))
   2ndsneg(X1, mark(X2)) -> mark(2ndsneg(X1, X2))
   pi(mark(X)) -> mark(pi(X))
   plus(mark(X1), X2) -> mark(plus(X1, X2))
   plus(X1, mark(X2)) -> mark(plus(X1, X2))
   times(mark(X1), X2) -> mark(times(X1, X2))
   times(X1, mark(X2)) -> mark(times(X1, X2))
   square(mark(X)) -> mark(square(X))
   proper(0) -> ok(0)
   proper(s(X)) -> s(proper(X))
   proper(posrecip(X)) -> posrecip(proper(X))
   proper(negrecip(X)) -> negrecip(proper(X))
   proper(nil) -> ok(nil)
   proper(cons(X1, X2)) -> cons(proper(X1), proper(X2))
   proper(cons2(X1, X2)) -> cons2(proper(X1), proper(X2))
   proper(rnil) -> ok(rnil)
   proper(rcons(X1, X2)) -> rcons(proper(X1), proper(X2))
   proper(from(X)) -> from(proper(X))
   proper(2ndspos(X1, X2)) -> 2ndspos(proper(X1), proper(X2))
   proper(2ndsneg(X1, X2)) -> 2ndsneg(proper(X1), proper(X2))
   proper(pi(X)) -> pi(proper(X))
   proper(plus(X1, X2)) -> plus(proper(X1), proper(X2))
   proper(times(X1, X2)) -> times(proper(X1), proper(X2))
   proper(square(X)) -> square(proper(X))
   s(ok(X)) -> ok(s(X))
   posrecip(ok(X)) -> ok(posrecip(X))
   negrecip(ok(X)) -> ok(negrecip(X))
   cons(ok(X1), ok(X2)) -> ok(cons(X1, X2))
   cons2(ok(X1), ok(X2)) -> ok(cons2(X1, X2))
   rcons(ok(X1), ok(X2)) -> ok(rcons(X1, X2))
   from(ok(X)) -> ok(from(X))
   2ndspos(ok(X1), ok(X2)) -> ok(2ndspos(X1, X2))
   2ndsneg(ok(X1), ok(X2)) -> ok(2ndsneg(X1, X2))
   pi(ok(X)) -> ok(pi(X))
   plus(ok(X1), ok(X2)) -> ok(plus(X1, X2))
   times(ok(X1), ok(X2)) -> ok(times(X1, X2))
   square(ok(X)) -> ok(square(X))
   top(mark(X)) -> top(proper(X))
   top(ok(X)) -> top(active(X))

The set Q consists of the following terms:

   active(rcons(x0, x1))
   active(plus(x0, x1))
   cons2(x0, mark(x1))
   proper(square(x0))
   proper(cons2(x0, x1))
   proper(2ndsneg(x0, x1))
   proper(2ndspos(x0, x1))
   proper(negrecip(x0))
   active(posrecip(x0))
   square(ok(x0))
   plus(ok(x0), ok(x1))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   proper(cons(x0, x1))
   proper(rcons(x0, x1))
   active(pi(x0))
   active(2ndsneg(x0, x1))
   proper(0)
   proper(from(x0))
   s(ok(x0))
   active(from(x0))
   negrecip(mark(x0))
   2ndspos(mark(x0), x1)
   pi(ok(x0))
   active(cons(x0, x1))
   proper(pi(x0))
   proper(plus(x0, x1))
   active(s(x0))
   cons(ok(x0), ok(x1))
   active(negrecip(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   proper(s(x0))
   active(2ndspos(x0, x1))
   2ndsneg(ok(x0), ok(x1))
   proper(rnil)
   rcons(mark(x0), x1)
   from(ok(x0))
   top(mark(x0))
   cons(mark(x0), x1)
   rcons(ok(x0), ok(x1))
   proper(nil)
   2ndspos(ok(x0), ok(x1))
   proper(times(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   posrecip(ok(x0))
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   negrecip(ok(x0))
   cons2(ok(x0), ok(x1))
   plus(x0, mark(x1))
   active(times(x0, x1))
   posrecip(mark(x0))
   s(mark(x0))
   active(cons2(x0, x1))
   top(ok(x0))
   proper(posrecip(x0))
   times(ok(x0), ok(x1))
   2ndspos(x0, mark(x1))

Special symbols used for the transformation (see [GM04]):
top: top_1, active: active_1, mark: mark_1, ok: ok_1, proper: proper_1
The replacement map contains the following entries:

from: {1}
cons: {1}
s: {1}
2ndspos: {1, 2}
0: empty set
rnil: empty set
cons2: {2}
rcons: {1, 2}
posrecip: {1}
2ndsneg: {1, 2}
negrecip: {1}
pi: {1}
plus: {1, 2}
times: {1, 2}
square: {1}
The QTRS contained just a subset of rules created by the complete Giesl-Middeldorp transformation. Therefore, the inverse transformation is sound, but not necessarily complete.
----------------------------------------

(2)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   from(X) -> cons(X, from(s(X)))
   2ndspos(0, Z) -> rnil
   2ndspos(s(N), cons(X, Z)) -> 2ndspos(s(N), cons2(X, Z))
   2ndspos(s(N), cons2(X, cons(Y, Z))) -> rcons(posrecip(Y), 2ndsneg(N, Z))
   2ndsneg(0, Z) -> rnil
   2ndsneg(s(N), cons(X, Z)) -> 2ndsneg(s(N), cons2(X, Z))
   2ndsneg(s(N), cons2(X, cons(Y, Z))) -> rcons(negrecip(Y), 2ndspos(N, Z))
   pi(X) -> 2ndspos(X, from(0))
   plus(0, Y) -> Y
   plus(s(X), Y) -> s(plus(X, Y))
   times(0, Y) -> 0
   times(s(X), Y) -> plus(Y, times(X, Y))
   square(X) -> times(X, X)

The replacement map contains the following entries:

from: {1}
cons: {1}
s: {1}
2ndspos: {1, 2}
0: empty set
rnil: empty set
cons2: {2}
rcons: {1, 2}
posrecip: {1}
2ndsneg: {1, 2}
negrecip: {1}
pi: {1}
plus: {1, 2}
times: {1, 2}
square: {1}

----------------------------------------

(3) CSRInnermostProof (EQUIVALENT)
The CSR is orthogonal. By [CS_Inn] we can switch to innermost.
----------------------------------------

(4)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   from(X) -> cons(X, from(s(X)))
   2ndspos(0, Z) -> rnil
   2ndspos(s(N), cons(X, Z)) -> 2ndspos(s(N), cons2(X, Z))
   2ndspos(s(N), cons2(X, cons(Y, Z))) -> rcons(posrecip(Y), 2ndsneg(N, Z))
   2ndsneg(0, Z) -> rnil
   2ndsneg(s(N), cons(X, Z)) -> 2ndsneg(s(N), cons2(X, Z))
   2ndsneg(s(N), cons2(X, cons(Y, Z))) -> rcons(negrecip(Y), 2ndspos(N, Z))
   pi(X) -> 2ndspos(X, from(0))
   plus(0, Y) -> Y
   plus(s(X), Y) -> s(plus(X, Y))
   times(0, Y) -> 0
   times(s(X), Y) -> plus(Y, times(X, Y))
   square(X) -> times(X, X)

The replacement map contains the following entries:

from: {1}
cons: {1}
s: {1}
2ndspos: {1, 2}
0: empty set
rnil: empty set
cons2: {2}
rcons: {1, 2}
posrecip: {1}
2ndsneg: {1, 2}
negrecip: {1}
pi: {1}
plus: {1, 2}
times: {1, 2}
square: {1}


Innermost Strategy.

----------------------------------------

(5) CSDependencyPairsProof (EQUIVALENT)
Using Improved CS-DPs [LPAR08] we result in the following initial Q-CSDP problem.
----------------------------------------

(6)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {from_1, s_1, 2ndspos_2, rcons_2, posrecip_1, 2ndsneg_2, negrecip_1, pi_1, plus_2, times_2, square_1, 2NDSPOS_2, 2NDSNEG_2, PI_1, FROM_1, PLUS_2, TIMES_2, SQUARE_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.
For all symbols f in {cons2_2} we have mu(f) = {2}.
The symbols in {U_1} are not replacing on any position.

The ordinary context-sensitive dependency pairs DP_o are:
   2NDSPOS(s(N), cons(X, Z)) -> 2NDSPOS(s(N), cons2(X, Z))
   2NDSPOS(s(N), cons2(X, cons(Y, Z))) -> 2NDSNEG(N, Z)
   2NDSNEG(s(N), cons(X, Z)) -> 2NDSNEG(s(N), cons2(X, Z))
   2NDSNEG(s(N), cons2(X, cons(Y, Z))) -> 2NDSPOS(N, Z)
   PI(X) -> 2NDSPOS(X, from(0))
   PI(X) -> FROM(0)
   PLUS(s(X), Y) -> PLUS(X, Y)
   TIMES(s(X), Y) -> PLUS(Y, times(X, Y))
   TIMES(s(X), Y) -> TIMES(X, Y)
   SQUARE(X) -> TIMES(X, X)

The collapsing dependency pairs are DP_c:
   2NDSPOS(s(N), cons(X, Z)) -> Z
   2NDSPOS(s(N), cons2(X, cons(Y, Z))) -> Z
   2NDSNEG(s(N), cons(X, Z)) -> Z
   2NDSNEG(s(N), cons2(X, cons(Y, Z))) -> Z


The hidden terms of R are:

   from(s(x0))

Every hiding context is built from:
   aprove.DPFramework.CSDPProblem.QCSDPProblem$1@22dbc2f3
   aprove.DPFramework.CSDPProblem.QCSDPProblem$1@142f7791

Hence, the new unhiding pairs DP_u are :
   2NDSPOS(s(N), cons(X, Z)) -> U(Z)
   2NDSPOS(s(N), cons2(X, cons(Y, Z))) -> U(Z)
   2NDSNEG(s(N), cons(X, Z)) -> U(Z)
   2NDSNEG(s(N), cons2(X, cons(Y, Z))) -> U(Z)
   U(s(x_0)) -> U(x_0)
   U(from(x_0)) -> U(x_0)
   U(from(s(x0))) -> FROM(s(x0))

The TRS R consists of the following rules:

   from(X) -> cons(X, from(s(X)))
   2ndspos(0, Z) -> rnil
   2ndspos(s(N), cons(X, Z)) -> 2ndspos(s(N), cons2(X, Z))
   2ndspos(s(N), cons2(X, cons(Y, Z))) -> rcons(posrecip(Y), 2ndsneg(N, Z))
   2ndsneg(0, Z) -> rnil
   2ndsneg(s(N), cons(X, Z)) -> 2ndsneg(s(N), cons2(X, Z))
   2ndsneg(s(N), cons2(X, cons(Y, Z))) -> rcons(negrecip(Y), 2ndspos(N, Z))
   pi(X) -> 2ndspos(X, from(0))
   plus(0, Y) -> Y
   plus(s(X), Y) -> s(plus(X, Y))
   times(0, Y) -> 0
   times(s(X), Y) -> plus(Y, times(X, Y))
   square(X) -> times(X, X)

The set Q consists of the following terms:

   from(x0)
   2ndspos(0, x0)
   2ndspos(s(x0), cons(x1, x2))
   2ndspos(s(x0), cons2(x1, cons(x2, x3)))
   2ndsneg(0, x0)
   2ndsneg(s(x0), cons(x1, x2))
   2ndsneg(s(x0), cons2(x1, cons(x2, x3)))
   pi(x0)
   plus(0, x0)
   plus(s(x0), x1)
   times(0, x0)
   times(s(x0), x1)
   square(x0)


----------------------------------------

(7) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 4 SCCs with 8 less nodes.
The rules 2NDSPOS(s(z0), cons(z1, z2)) -> 2NDSPOS(s(z0), cons2(z1, z2)) and 2NDSPOS(s(x0), cons(x1, x2)) -> 2NDSPOS(s(x0), cons2(x1, x2)) form no chain, because ECap^mu(2NDSPOS(s(z0), cons2(z1, z2))) = 2NDSPOS(s(z0), cons2(z1, x_1)) does not unify with 2NDSPOS(s(x0), cons(x1, x2)). The rules 2NDSPOS(s(z0), cons(z1, z2)) -> 2NDSPOS(s(z0), cons2(z1, z2)) and 2NDSPOS(s(x0), cons(x1, x2)) -> U(x2) form no chain, because ECap^mu(2NDSPOS(s(z0), cons2(z1, z2))) = 2NDSPOS(s(z0), cons2(z1, x_1)) does not unify with 2NDSPOS(s(x0), cons(x1, x2)). The rules 2NDSNEG(s(z0), cons(z1, z2)) -> 2NDSNEG(s(z0), cons2(z1, z2)) and 2NDSNEG(s(x0), cons(x1, x2)) -> 2NDSNEG(s(x0), cons2(x1, x2)) form no chain, because ECap^mu(2NDSNEG(s(z0), cons2(z1, z2))) = 2NDSNEG(s(z0), cons2(z1, x_1)) does not unify with 2NDSNEG(s(x0), cons(x1, x2)). The rules 2NDSNEG(s(z0), cons(z1, z2)) -> 2NDSNEG(s(z0), cons2(z1, z2)) and 2NDSNEG(s(x0), cons(x1, x2)) -> U(x2) form no chain, because ECap^mu(2NDSNEG(s(z0), cons2(z1, z2))) = 2NDSNEG(s(z0), cons2(z1, x_1)) does not unify with 2NDSNEG(s(x0), cons(x1, x2)). The rules PI(x0) -> 2NDSPOS(x0, from(0)) and 2NDSPOS(s(z0), cons2(z1, cons(z2, z3))) -> 2NDSNEG(z0, z3) form no chain, because ECap^mu_R'(2NDSPOS(s(z0), cons2(z1, cons(z2, z3)))) = 2NDSPOS(s(x_1), cons2(z1, x_3)) does not unify with 2NDSPOS(x0, from(0)). 
R' = 
   ( cons(X, from(s(X))), from(X))


The rules PI(x0) -> 2NDSPOS(x0, from(0)) and 2NDSPOS(s(z0), cons2(z1, cons(z2, z3))) -> U(z3) form no chain, because ECap^mu_R'(2NDSPOS(s(z0), cons2(z1, cons(z2, z3)))) = 2NDSPOS(s(x_1), cons2(z1, x_3)) does not unify with 2NDSPOS(x0, from(0)). 
R' = 
   ( cons(X, from(s(X))), from(X))



----------------------------------------

(8)
Complex Obligation (AND)

----------------------------------------

(9)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {from_1, s_1, 2ndspos_2, rcons_2, posrecip_1, 2ndsneg_2, negrecip_1, pi_1, plus_2, times_2, square_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.
For all symbols f in {cons2_2} we have mu(f) = {2}.
The symbols in {U_1} are not replacing on any position.

The TRS P consists of the following rules:

   U(s(x_0)) -> U(x_0)
   U(from(x_0)) -> U(x_0)

The TRS R consists of the following rules:

   from(X) -> cons(X, from(s(X)))
   2ndspos(0, Z) -> rnil
   2ndspos(s(N), cons(X, Z)) -> 2ndspos(s(N), cons2(X, Z))
   2ndspos(s(N), cons2(X, cons(Y, Z))) -> rcons(posrecip(Y), 2ndsneg(N, Z))
   2ndsneg(0, Z) -> rnil
   2ndsneg(s(N), cons(X, Z)) -> 2ndsneg(s(N), cons2(X, Z))
   2ndsneg(s(N), cons2(X, cons(Y, Z))) -> rcons(negrecip(Y), 2ndspos(N, Z))
   pi(X) -> 2ndspos(X, from(0))
   plus(0, Y) -> Y
   plus(s(X), Y) -> s(plus(X, Y))
   times(0, Y) -> 0
   times(s(X), Y) -> plus(Y, times(X, Y))
   square(X) -> times(X, X)

The set Q consists of the following terms:

   from(x0)
   2ndspos(0, x0)
   2ndspos(s(x0), cons(x1, x2))
   2ndspos(s(x0), cons2(x1, cons(x2, x3)))
   2ndsneg(0, x0)
   2ndsneg(s(x0), cons(x1, x2))
   2ndsneg(s(x0), cons2(x1, cons(x2, x3)))
   pi(x0)
   plus(0, x0)
   plus(s(x0), x1)
   times(0, x0)
   times(s(x0), x1)
   square(x0)


----------------------------------------

(10) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   U(s(x_0)) -> U(x_0)
   U(from(x_0)) -> U(x_0)
The remaining pairs can at least be oriented weakly.
none
Used ordering:  Combined order from the following AFS and order.
U(x1)  =  x1


Subterm Order

----------------------------------------

(11)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {from_1, s_1, 2ndspos_2, rcons_2, posrecip_1, 2ndsneg_2, negrecip_1, pi_1, plus_2, times_2, square_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.
For all symbols f in {cons2_2} we have mu(f) = {2}.

The TRS P consists of the following rules:
none

The TRS R consists of the following rules:

   from(X) -> cons(X, from(s(X)))
   2ndspos(0, Z) -> rnil
   2ndspos(s(N), cons(X, Z)) -> 2ndspos(s(N), cons2(X, Z))
   2ndspos(s(N), cons2(X, cons(Y, Z))) -> rcons(posrecip(Y), 2ndsneg(N, Z))
   2ndsneg(0, Z) -> rnil
   2ndsneg(s(N), cons(X, Z)) -> 2ndsneg(s(N), cons2(X, Z))
   2ndsneg(s(N), cons2(X, cons(Y, Z))) -> rcons(negrecip(Y), 2ndspos(N, Z))
   pi(X) -> 2ndspos(X, from(0))
   plus(0, Y) -> Y
   plus(s(X), Y) -> s(plus(X, Y))
   times(0, Y) -> 0
   times(s(X), Y) -> plus(Y, times(X, Y))
   square(X) -> times(X, X)

The set Q consists of the following terms:

   from(x0)
   2ndspos(0, x0)
   2ndspos(s(x0), cons(x1, x2))
   2ndspos(s(x0), cons2(x1, cons(x2, x3)))
   2ndsneg(0, x0)
   2ndsneg(s(x0), cons(x1, x2))
   2ndsneg(s(x0), cons2(x1, cons(x2, x3)))
   pi(x0)
   plus(0, x0)
   plus(s(x0), x1)
   times(0, x0)
   times(s(x0), x1)
   square(x0)


----------------------------------------

(12) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {from_1, s_1, 2ndspos_2, rcons_2, posrecip_1, 2ndsneg_2, negrecip_1, pi_1, plus_2, times_2, square_1, PLUS_2} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.
For all symbols f in {cons2_2} we have mu(f) = {2}.

The TRS P consists of the following rules:

   PLUS(s(X), Y) -> PLUS(X, Y)

The TRS R consists of the following rules:

   from(X) -> cons(X, from(s(X)))
   2ndspos(0, Z) -> rnil
   2ndspos(s(N), cons(X, Z)) -> 2ndspos(s(N), cons2(X, Z))
   2ndspos(s(N), cons2(X, cons(Y, Z))) -> rcons(posrecip(Y), 2ndsneg(N, Z))
   2ndsneg(0, Z) -> rnil
   2ndsneg(s(N), cons(X, Z)) -> 2ndsneg(s(N), cons2(X, Z))
   2ndsneg(s(N), cons2(X, cons(Y, Z))) -> rcons(negrecip(Y), 2ndspos(N, Z))
   pi(X) -> 2ndspos(X, from(0))
   plus(0, Y) -> Y
   plus(s(X), Y) -> s(plus(X, Y))
   times(0, Y) -> 0
   times(s(X), Y) -> plus(Y, times(X, Y))
   square(X) -> times(X, X)

The set Q consists of the following terms:

   from(x0)
   2ndspos(0, x0)
   2ndspos(s(x0), cons(x1, x2))
   2ndspos(s(x0), cons2(x1, cons(x2, x3)))
   2ndsneg(0, x0)
   2ndsneg(s(x0), cons(x1, x2))
   2ndsneg(s(x0), cons2(x1, cons(x2, x3)))
   pi(x0)
   plus(0, x0)
   plus(s(x0), x1)
   times(0, x0)
   times(s(x0), x1)
   square(x0)


----------------------------------------

(15) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   PLUS(s(X), Y) -> PLUS(X, Y)
The remaining pairs can at least be oriented weakly.
none
Used ordering:  Combined order from the following AFS and order.
PLUS(x1, x2)  =  x1


Subterm Order

----------------------------------------

(16)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {from_1, s_1, 2ndspos_2, rcons_2, posrecip_1, 2ndsneg_2, negrecip_1, pi_1, plus_2, times_2, square_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.
For all symbols f in {cons2_2} we have mu(f) = {2}.

The TRS P consists of the following rules:
none

The TRS R consists of the following rules:

   from(X) -> cons(X, from(s(X)))
   2ndspos(0, Z) -> rnil
   2ndspos(s(N), cons(X, Z)) -> 2ndspos(s(N), cons2(X, Z))
   2ndspos(s(N), cons2(X, cons(Y, Z))) -> rcons(posrecip(Y), 2ndsneg(N, Z))
   2ndsneg(0, Z) -> rnil
   2ndsneg(s(N), cons(X, Z)) -> 2ndsneg(s(N), cons2(X, Z))
   2ndsneg(s(N), cons2(X, cons(Y, Z))) -> rcons(negrecip(Y), 2ndspos(N, Z))
   pi(X) -> 2ndspos(X, from(0))
   plus(0, Y) -> Y
   plus(s(X), Y) -> s(plus(X, Y))
   times(0, Y) -> 0
   times(s(X), Y) -> plus(Y, times(X, Y))
   square(X) -> times(X, X)

The set Q consists of the following terms:

   from(x0)
   2ndspos(0, x0)
   2ndspos(s(x0), cons(x1, x2))
   2ndspos(s(x0), cons2(x1, cons(x2, x3)))
   2ndsneg(0, x0)
   2ndsneg(s(x0), cons(x1, x2))
   2ndsneg(s(x0), cons2(x1, cons(x2, x3)))
   pi(x0)
   plus(0, x0)
   plus(s(x0), x1)
   times(0, x0)
   times(s(x0), x1)
   square(x0)


----------------------------------------

(17) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(18)
YES

----------------------------------------

(19)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {from_1, s_1, 2ndspos_2, rcons_2, posrecip_1, 2ndsneg_2, negrecip_1, pi_1, plus_2, times_2, square_1, TIMES_2} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.
For all symbols f in {cons2_2} we have mu(f) = {2}.

The TRS P consists of the following rules:

   TIMES(s(X), Y) -> TIMES(X, Y)

The TRS R consists of the following rules:

   from(X) -> cons(X, from(s(X)))
   2ndspos(0, Z) -> rnil
   2ndspos(s(N), cons(X, Z)) -> 2ndspos(s(N), cons2(X, Z))
   2ndspos(s(N), cons2(X, cons(Y, Z))) -> rcons(posrecip(Y), 2ndsneg(N, Z))
   2ndsneg(0, Z) -> rnil
   2ndsneg(s(N), cons(X, Z)) -> 2ndsneg(s(N), cons2(X, Z))
   2ndsneg(s(N), cons2(X, cons(Y, Z))) -> rcons(negrecip(Y), 2ndspos(N, Z))
   pi(X) -> 2ndspos(X, from(0))
   plus(0, Y) -> Y
   plus(s(X), Y) -> s(plus(X, Y))
   times(0, Y) -> 0
   times(s(X), Y) -> plus(Y, times(X, Y))
   square(X) -> times(X, X)

The set Q consists of the following terms:

   from(x0)
   2ndspos(0, x0)
   2ndspos(s(x0), cons(x1, x2))
   2ndspos(s(x0), cons2(x1, cons(x2, x3)))
   2ndsneg(0, x0)
   2ndsneg(s(x0), cons(x1, x2))
   2ndsneg(s(x0), cons2(x1, cons(x2, x3)))
   pi(x0)
   plus(0, x0)
   plus(s(x0), x1)
   times(0, x0)
   times(s(x0), x1)
   square(x0)


----------------------------------------

(20) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   TIMES(s(X), Y) -> TIMES(X, Y)
The remaining pairs can at least be oriented weakly.
none
Used ordering:  Combined order from the following AFS and order.
TIMES(x1, x2)  =  x1


Subterm Order

----------------------------------------

(21)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {from_1, s_1, 2ndspos_2, rcons_2, posrecip_1, 2ndsneg_2, negrecip_1, pi_1, plus_2, times_2, square_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.
For all symbols f in {cons2_2} we have mu(f) = {2}.

The TRS P consists of the following rules:
none

The TRS R consists of the following rules:

   from(X) -> cons(X, from(s(X)))
   2ndspos(0, Z) -> rnil
   2ndspos(s(N), cons(X, Z)) -> 2ndspos(s(N), cons2(X, Z))
   2ndspos(s(N), cons2(X, cons(Y, Z))) -> rcons(posrecip(Y), 2ndsneg(N, Z))
   2ndsneg(0, Z) -> rnil
   2ndsneg(s(N), cons(X, Z)) -> 2ndsneg(s(N), cons2(X, Z))
   2ndsneg(s(N), cons2(X, cons(Y, Z))) -> rcons(negrecip(Y), 2ndspos(N, Z))
   pi(X) -> 2ndspos(X, from(0))
   plus(0, Y) -> Y
   plus(s(X), Y) -> s(plus(X, Y))
   times(0, Y) -> 0
   times(s(X), Y) -> plus(Y, times(X, Y))
   square(X) -> times(X, X)

The set Q consists of the following terms:

   from(x0)
   2ndspos(0, x0)
   2ndspos(s(x0), cons(x1, x2))
   2ndspos(s(x0), cons2(x1, cons(x2, x3)))
   2ndsneg(0, x0)
   2ndsneg(s(x0), cons(x1, x2))
   2ndsneg(s(x0), cons2(x1, cons(x2, x3)))
   pi(x0)
   plus(0, x0)
   plus(s(x0), x1)
   times(0, x0)
   times(s(x0), x1)
   square(x0)


----------------------------------------

(22) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(23)
YES

----------------------------------------

(24)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {from_1, s_1, 2ndspos_2, rcons_2, posrecip_1, 2ndsneg_2, negrecip_1, pi_1, plus_2, times_2, square_1, 2NDSNEG_2, 2NDSPOS_2} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.
For all symbols f in {cons2_2} we have mu(f) = {2}.

The TRS P consists of the following rules:

   2NDSPOS(s(N), cons2(X, cons(Y, Z))) -> 2NDSNEG(N, Z)
   2NDSNEG(s(N), cons(X, Z)) -> 2NDSNEG(s(N), cons2(X, Z))
   2NDSNEG(s(N), cons2(X, cons(Y, Z))) -> 2NDSPOS(N, Z)
   2NDSPOS(s(N), cons(X, Z)) -> 2NDSPOS(s(N), cons2(X, Z))

The TRS R consists of the following rules:

   from(X) -> cons(X, from(s(X)))
   2ndspos(0, Z) -> rnil
   2ndspos(s(N), cons(X, Z)) -> 2ndspos(s(N), cons2(X, Z))
   2ndspos(s(N), cons2(X, cons(Y, Z))) -> rcons(posrecip(Y), 2ndsneg(N, Z))
   2ndsneg(0, Z) -> rnil
   2ndsneg(s(N), cons(X, Z)) -> 2ndsneg(s(N), cons2(X, Z))
   2ndsneg(s(N), cons2(X, cons(Y, Z))) -> rcons(negrecip(Y), 2ndspos(N, Z))
   pi(X) -> 2ndspos(X, from(0))
   plus(0, Y) -> Y
   plus(s(X), Y) -> s(plus(X, Y))
   times(0, Y) -> 0
   times(s(X), Y) -> plus(Y, times(X, Y))
   square(X) -> times(X, X)

The set Q consists of the following terms:

   from(x0)
   2ndspos(0, x0)
   2ndspos(s(x0), cons(x1, x2))
   2ndspos(s(x0), cons2(x1, cons(x2, x3)))
   2ndsneg(0, x0)
   2ndsneg(s(x0), cons(x1, x2))
   2ndsneg(s(x0), cons2(x1, cons(x2, x3)))
   pi(x0)
   plus(0, x0)
   plus(s(x0), x1)
   times(0, x0)
   times(s(x0), x1)
   square(x0)


----------------------------------------

(25) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   2NDSPOS(s(N), cons2(X, cons(Y, Z))) -> 2NDSNEG(N, Z)
   2NDSNEG(s(N), cons2(X, cons(Y, Z))) -> 2NDSPOS(N, Z)
The remaining pairs can at least be oriented weakly.

   2NDSNEG(s(N), cons(X, Z)) -> 2NDSNEG(s(N), cons2(X, Z))
   2NDSPOS(s(N), cons(X, Z)) -> 2NDSPOS(s(N), cons2(X, Z))
Used ordering:  Combined order from the following AFS and order.
2NDSNEG(x1, x2)  =  x1

2NDSPOS(x1, x2)  =  x1


Subterm Order

----------------------------------------

(26)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {from_1, s_1, 2ndspos_2, rcons_2, posrecip_1, 2ndsneg_2, negrecip_1, pi_1, plus_2, times_2, square_1, 2NDSNEG_2, 2NDSPOS_2} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.
For all symbols f in {cons2_2} we have mu(f) = {2}.

The TRS P consists of the following rules:

   2NDSNEG(s(N), cons(X, Z)) -> 2NDSNEG(s(N), cons2(X, Z))
   2NDSPOS(s(N), cons(X, Z)) -> 2NDSPOS(s(N), cons2(X, Z))

The TRS R consists of the following rules:

   from(X) -> cons(X, from(s(X)))
   2ndspos(0, Z) -> rnil
   2ndspos(s(N), cons(X, Z)) -> 2ndspos(s(N), cons2(X, Z))
   2ndspos(s(N), cons2(X, cons(Y, Z))) -> rcons(posrecip(Y), 2ndsneg(N, Z))
   2ndsneg(0, Z) -> rnil
   2ndsneg(s(N), cons(X, Z)) -> 2ndsneg(s(N), cons2(X, Z))
   2ndsneg(s(N), cons2(X, cons(Y, Z))) -> rcons(negrecip(Y), 2ndspos(N, Z))
   pi(X) -> 2ndspos(X, from(0))
   plus(0, Y) -> Y
   plus(s(X), Y) -> s(plus(X, Y))
   times(0, Y) -> 0
   times(s(X), Y) -> plus(Y, times(X, Y))
   square(X) -> times(X, X)

The set Q consists of the following terms:

   from(x0)
   2ndspos(0, x0)
   2ndspos(s(x0), cons(x1, x2))
   2ndspos(s(x0), cons2(x1, cons(x2, x3)))
   2ndsneg(0, x0)
   2ndsneg(s(x0), cons(x1, x2))
   2ndsneg(s(x0), cons2(x1, cons(x2, x3)))
   pi(x0)
   plus(0, x0)
   plus(s(x0), x1)
   times(0, x0)
   times(s(x0), x1)
   square(x0)


----------------------------------------

(27) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 0 SCCs with 2 less nodes.

----------------------------------------

(28)
TRUE
