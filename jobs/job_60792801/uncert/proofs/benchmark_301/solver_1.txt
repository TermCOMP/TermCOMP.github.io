YES
proof of /home/ff862203/input_LdXuYxH3kV.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) QTRSToCSRProof [SOUND, 0 ms]
(2) CSR
(3) CSDependencyPairsProof [EQUIVALENT, 0 ms]
(4) QCSDP
(5) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) QCSDP
        (8) QCSDPReductionPairProof [EQUIVALENT, 31 ms]
        (9) QCSDP
        (10) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
        (11) TRUE
    (12) QCSDP
        (13) QCSDPSubtermProof [EQUIVALENT, 0 ms]
        (14) QCSDP
        (15) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
        (16) TRUE
    (17) QCSDP
        (18) QCSDPSubtermProof [EQUIVALENT, 1 ms]
        (19) QCSDP
        (20) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
        (21) TRUE


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(U11(tt, N)) -> mark(N)
   active(U21(tt, M, N)) -> mark(s(plus(N, M)))
   active(U31(tt)) -> mark(0)
   active(U41(tt, M, N)) -> mark(plus(x(N, M), N))
   active(and(tt, X)) -> mark(X)
   active(isNat(0)) -> mark(tt)
   active(isNat(plus(V1, V2))) -> mark(and(isNat(V1), isNat(V2)))
   active(isNat(s(V1))) -> mark(isNat(V1))
   active(isNat(x(V1, V2))) -> mark(and(isNat(V1), isNat(V2)))
   active(plus(N, 0)) -> mark(U11(isNat(N), N))
   active(plus(N, s(M))) -> mark(U21(and(isNat(M), isNat(N)), M, N))
   active(x(N, 0)) -> mark(U31(isNat(N)))
   active(x(N, s(M))) -> mark(U41(and(isNat(M), isNat(N)), M, N))
   active(U11(X1, X2)) -> U11(active(X1), X2)
   active(U21(X1, X2, X3)) -> U21(active(X1), X2, X3)
   active(s(X)) -> s(active(X))
   active(plus(X1, X2)) -> plus(active(X1), X2)
   active(plus(X1, X2)) -> plus(X1, active(X2))
   active(U31(X)) -> U31(active(X))
   active(U41(X1, X2, X3)) -> U41(active(X1), X2, X3)
   active(x(X1, X2)) -> x(active(X1), X2)
   active(x(X1, X2)) -> x(X1, active(X2))
   active(and(X1, X2)) -> and(active(X1), X2)
   U11(mark(X1), X2) -> mark(U11(X1, X2))
   U21(mark(X1), X2, X3) -> mark(U21(X1, X2, X3))
   s(mark(X)) -> mark(s(X))
   plus(mark(X1), X2) -> mark(plus(X1, X2))
   plus(X1, mark(X2)) -> mark(plus(X1, X2))
   U31(mark(X)) -> mark(U31(X))
   U41(mark(X1), X2, X3) -> mark(U41(X1, X2, X3))
   x(mark(X1), X2) -> mark(x(X1, X2))
   x(X1, mark(X2)) -> mark(x(X1, X2))
   and(mark(X1), X2) -> mark(and(X1, X2))
   proper(U11(X1, X2)) -> U11(proper(X1), proper(X2))
   proper(tt) -> ok(tt)
   proper(U21(X1, X2, X3)) -> U21(proper(X1), proper(X2), proper(X3))
   proper(s(X)) -> s(proper(X))
   proper(plus(X1, X2)) -> plus(proper(X1), proper(X2))
   proper(U31(X)) -> U31(proper(X))
   proper(0) -> ok(0)
   proper(U41(X1, X2, X3)) -> U41(proper(X1), proper(X2), proper(X3))
   proper(x(X1, X2)) -> x(proper(X1), proper(X2))
   proper(and(X1, X2)) -> and(proper(X1), proper(X2))
   proper(isNat(X)) -> isNat(proper(X))
   U11(ok(X1), ok(X2)) -> ok(U11(X1, X2))
   U21(ok(X1), ok(X2), ok(X3)) -> ok(U21(X1, X2, X3))
   s(ok(X)) -> ok(s(X))
   plus(ok(X1), ok(X2)) -> ok(plus(X1, X2))
   U31(ok(X)) -> ok(U31(X))
   U41(ok(X1), ok(X2), ok(X3)) -> ok(U41(X1, X2, X3))
   x(ok(X1), ok(X2)) -> ok(x(X1, X2))
   and(ok(X1), ok(X2)) -> ok(and(X1, X2))
   isNat(ok(X)) -> ok(isNat(X))
   top(mark(X)) -> top(proper(X))
   top(ok(X)) -> top(active(X))

The set Q consists of the following terms:

   active(x(x0, x1))
   active(and(x0, x1))
   proper(isNat(x0))
   active(plus(x0, x1))
   U11(mark(x0), x1)
   proper(U41(x0, x1, x2))
   proper(U11(x0, x1))
   plus(ok(x0), ok(x1))
   U21(ok(x0), ok(x1), ok(x2))
   x(ok(x0), ok(x1))
   and(ok(x0), ok(x1))
   active(U41(x0, x1, x2))
   proper(0)
   active(isNat(plus(x0, x1)))
   s(ok(x0))
   x(mark(x0), x1)
   proper(plus(x0, x1))
   proper(U21(x0, x1, x2))
   active(s(x0))
   U31(mark(x0))
   active(U11(x0, x1))
   active(U21(x0, x1, x2))
   plus(mark(x0), x1)
   and(mark(x0), x1)
   proper(s(x0))
   active(isNat(0))
   U21(mark(x0), x1, x2)
   active(U31(x0))
   top(mark(x0))
   active(isNat(s(x0)))
   proper(U31(x0))
   U31(ok(x0))
   x(x0, mark(x1))
   proper(tt)
   plus(x0, mark(x1))
   U41(mark(x0), x1, x2)
   s(mark(x0))
   proper(x(x0, x1))
   active(isNat(x(x0, x1)))
   proper(and(x0, x1))
   U41(ok(x0), ok(x1), ok(x2))
   isNat(ok(x0))
   U11(ok(x0), ok(x1))
   top(ok(x0))


----------------------------------------

(1) QTRSToCSRProof (SOUND)
The following Q TRS is given: Q restricted rewrite system:
The TRS R consists of the following rules:

   active(U11(tt, N)) -> mark(N)
   active(U21(tt, M, N)) -> mark(s(plus(N, M)))
   active(U31(tt)) -> mark(0)
   active(U41(tt, M, N)) -> mark(plus(x(N, M), N))
   active(and(tt, X)) -> mark(X)
   active(isNat(0)) -> mark(tt)
   active(isNat(plus(V1, V2))) -> mark(and(isNat(V1), isNat(V2)))
   active(isNat(s(V1))) -> mark(isNat(V1))
   active(isNat(x(V1, V2))) -> mark(and(isNat(V1), isNat(V2)))
   active(plus(N, 0)) -> mark(U11(isNat(N), N))
   active(plus(N, s(M))) -> mark(U21(and(isNat(M), isNat(N)), M, N))
   active(x(N, 0)) -> mark(U31(isNat(N)))
   active(x(N, s(M))) -> mark(U41(and(isNat(M), isNat(N)), M, N))
   active(U11(X1, X2)) -> U11(active(X1), X2)
   active(U21(X1, X2, X3)) -> U21(active(X1), X2, X3)
   active(s(X)) -> s(active(X))
   active(plus(X1, X2)) -> plus(active(X1), X2)
   active(plus(X1, X2)) -> plus(X1, active(X2))
   active(U31(X)) -> U31(active(X))
   active(U41(X1, X2, X3)) -> U41(active(X1), X2, X3)
   active(x(X1, X2)) -> x(active(X1), X2)
   active(x(X1, X2)) -> x(X1, active(X2))
   active(and(X1, X2)) -> and(active(X1), X2)
   U11(mark(X1), X2) -> mark(U11(X1, X2))
   U21(mark(X1), X2, X3) -> mark(U21(X1, X2, X3))
   s(mark(X)) -> mark(s(X))
   plus(mark(X1), X2) -> mark(plus(X1, X2))
   plus(X1, mark(X2)) -> mark(plus(X1, X2))
   U31(mark(X)) -> mark(U31(X))
   U41(mark(X1), X2, X3) -> mark(U41(X1, X2, X3))
   x(mark(X1), X2) -> mark(x(X1, X2))
   x(X1, mark(X2)) -> mark(x(X1, X2))
   and(mark(X1), X2) -> mark(and(X1, X2))
   proper(U11(X1, X2)) -> U11(proper(X1), proper(X2))
   proper(tt) -> ok(tt)
   proper(U21(X1, X2, X3)) -> U21(proper(X1), proper(X2), proper(X3))
   proper(s(X)) -> s(proper(X))
   proper(plus(X1, X2)) -> plus(proper(X1), proper(X2))
   proper(U31(X)) -> U31(proper(X))
   proper(0) -> ok(0)
   proper(U41(X1, X2, X3)) -> U41(proper(X1), proper(X2), proper(X3))
   proper(x(X1, X2)) -> x(proper(X1), proper(X2))
   proper(and(X1, X2)) -> and(proper(X1), proper(X2))
   proper(isNat(X)) -> isNat(proper(X))
   U11(ok(X1), ok(X2)) -> ok(U11(X1, X2))
   U21(ok(X1), ok(X2), ok(X3)) -> ok(U21(X1, X2, X3))
   s(ok(X)) -> ok(s(X))
   plus(ok(X1), ok(X2)) -> ok(plus(X1, X2))
   U31(ok(X)) -> ok(U31(X))
   U41(ok(X1), ok(X2), ok(X3)) -> ok(U41(X1, X2, X3))
   x(ok(X1), ok(X2)) -> ok(x(X1, X2))
   and(ok(X1), ok(X2)) -> ok(and(X1, X2))
   isNat(ok(X)) -> ok(isNat(X))
   top(mark(X)) -> top(proper(X))
   top(ok(X)) -> top(active(X))

The set Q consists of the following terms:

   active(x(x0, x1))
   active(and(x0, x1))
   proper(isNat(x0))
   active(plus(x0, x1))
   U11(mark(x0), x1)
   proper(U41(x0, x1, x2))
   proper(U11(x0, x1))
   plus(ok(x0), ok(x1))
   U21(ok(x0), ok(x1), ok(x2))
   x(ok(x0), ok(x1))
   and(ok(x0), ok(x1))
   active(U41(x0, x1, x2))
   proper(0)
   active(isNat(plus(x0, x1)))
   s(ok(x0))
   x(mark(x0), x1)
   proper(plus(x0, x1))
   proper(U21(x0, x1, x2))
   active(s(x0))
   U31(mark(x0))
   active(U11(x0, x1))
   active(U21(x0, x1, x2))
   plus(mark(x0), x1)
   and(mark(x0), x1)
   proper(s(x0))
   active(isNat(0))
   U21(mark(x0), x1, x2)
   active(U31(x0))
   top(mark(x0))
   active(isNat(s(x0)))
   proper(U31(x0))
   U31(ok(x0))
   x(x0, mark(x1))
   proper(tt)
   plus(x0, mark(x1))
   U41(mark(x0), x1, x2)
   s(mark(x0))
   proper(x(x0, x1))
   active(isNat(x(x0, x1)))
   proper(and(x0, x1))
   U41(ok(x0), ok(x1), ok(x2))
   isNat(ok(x0))
   U11(ok(x0), ok(x1))
   top(ok(x0))

Special symbols used for the transformation (see [GM04]):
top: top_1, active: active_1, mark: mark_1, ok: ok_1, proper: proper_1
The replacement map contains the following entries:

U11: {1}
tt: empty set
U21: {1}
s: {1}
plus: {1, 2}
U31: {1}
0: empty set
U41: {1}
x: {1, 2}
and: {1}
isNat: empty set
The QTRS contained just a subset of rules created by the complete Giesl-Middeldorp transformation. Therefore, the inverse transformation is sound, but not necessarily complete.
----------------------------------------

(2)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   U11(tt, N) -> N
   U21(tt, M, N) -> s(plus(N, M))
   U31(tt) -> 0
   U41(tt, M, N) -> plus(x(N, M), N)
   and(tt, X) -> X
   isNat(0) -> tt
   isNat(plus(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(s(V1)) -> isNat(V1)
   isNat(x(V1, V2)) -> and(isNat(V1), isNat(V2))
   plus(N, 0) -> U11(isNat(N), N)
   plus(N, s(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   x(N, 0) -> U31(isNat(N))
   x(N, s(M)) -> U41(and(isNat(M), isNat(N)), M, N)

The replacement map contains the following entries:

U11: {1}
tt: empty set
U21: {1}
s: {1}
plus: {1, 2}
U31: {1}
0: empty set
U41: {1}
x: {1, 2}
and: {1}
isNat: empty set

----------------------------------------

(3) CSDependencyPairsProof (EQUIVALENT)
Using Improved CS-DPs [LPAR08] we result in the following initial Q-CSDP problem.
----------------------------------------

(4)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {s_1, plus_2, U31_1, x_2, PLUS_2, X_2, U31'_1} are replacing on all positions.
For all symbols f in {U11_2, U21_3, U41_3, and_2, U21'_3, U41'_3, AND_2, U11'_2} we have mu(f) = {1}.
The symbols in {isNat_1, ISNAT_1, U_1} are not replacing on any position.

The ordinary context-sensitive dependency pairs DP_o are:
   U21'(tt, M, N) -> PLUS(N, M)
   U41'(tt, M, N) -> PLUS(x(N, M), N)
   U41'(tt, M, N) -> X(N, M)
   ISNAT(plus(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(plus(V1, V2)) -> ISNAT(V1)
   ISNAT(s(V1)) -> ISNAT(V1)
   ISNAT(x(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(x(V1, V2)) -> ISNAT(V1)
   PLUS(N, 0) -> U11'(isNat(N), N)
   PLUS(N, 0) -> ISNAT(N)
   PLUS(N, s(M)) -> U21'(and(isNat(M), isNat(N)), M, N)
   PLUS(N, s(M)) -> AND(isNat(M), isNat(N))
   PLUS(N, s(M)) -> ISNAT(M)
   X(N, 0) -> U31'(isNat(N))
   X(N, 0) -> ISNAT(N)
   X(N, s(M)) -> U41'(and(isNat(M), isNat(N)), M, N)
   X(N, s(M)) -> AND(isNat(M), isNat(N))
   X(N, s(M)) -> ISNAT(M)

The collapsing dependency pairs are DP_c:
   U11'(tt, N) -> N
   U21'(tt, M, N) -> N
   U21'(tt, M, N) -> M
   U41'(tt, M, N) -> N
   U41'(tt, M, N) -> M
   AND(tt, X) -> X


The hidden terms of R are:

   isNat(x0)

Every hiding context is built from:none

Hence, the new unhiding pairs DP_u are :
   U11'(tt, N) -> U(N)
   U21'(tt, M, N) -> U(N)
   U21'(tt, M, N) -> U(M)
   U41'(tt, M, N) -> U(N)
   U41'(tt, M, N) -> U(M)
   AND(tt, X) -> U(X)
   U(isNat(x0)) -> ISNAT(x0)

The TRS R consists of the following rules:

   U11(tt, N) -> N
   U21(tt, M, N) -> s(plus(N, M))
   U31(tt) -> 0
   U41(tt, M, N) -> plus(x(N, M), N)
   and(tt, X) -> X
   isNat(0) -> tt
   isNat(plus(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(s(V1)) -> isNat(V1)
   isNat(x(V1, V2)) -> and(isNat(V1), isNat(V2))
   plus(N, 0) -> U11(isNat(N), N)
   plus(N, s(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   x(N, 0) -> U31(isNat(N))
   x(N, s(M)) -> U41(and(isNat(M), isNat(N)), M, N)

Q is empty.

----------------------------------------

(5) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 3 SCCs with 14 less nodes.

----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {s_1, plus_2, U31_1, x_2} are replacing on all positions.
For all symbols f in {U11_2, U21_3, U41_3, and_2, AND_2} we have mu(f) = {1}.
The symbols in {isNat_1, U_1, ISNAT_1} are not replacing on any position.

The TRS P consists of the following rules:

   AND(tt, X) -> U(X)
   U(isNat(x0)) -> ISNAT(x0)
   ISNAT(plus(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(plus(V1, V2)) -> ISNAT(V1)
   ISNAT(s(V1)) -> ISNAT(V1)
   ISNAT(x(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(x(V1, V2)) -> ISNAT(V1)

The TRS R consists of the following rules:

   U11(tt, N) -> N
   U21(tt, M, N) -> s(plus(N, M))
   U31(tt) -> 0
   U41(tt, M, N) -> plus(x(N, M), N)
   and(tt, X) -> X
   isNat(0) -> tt
   isNat(plus(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(s(V1)) -> isNat(V1)
   isNat(x(V1, V2)) -> and(isNat(V1), isNat(V2))
   plus(N, 0) -> U11(isNat(N), N)
   plus(N, s(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   x(N, 0) -> U31(isNat(N))
   x(N, s(M)) -> U41(and(isNat(M), isNat(N)), M, N)

Q is empty.

----------------------------------------

(8) QCSDPReductionPairProof (EQUIVALENT)
Using the order

AND/2)NO,YES(
tt/0)
U/1)YES(
isNat/1(YES)
ISNAT/1(YES)
plus/2(YES,YES)
s/1(YES)
x/2(YES,YES)
0/0)
and/2)NO,YES(
U11/2(YES,YES)
U21/3(YES,YES,YES)
U31/1(NO)
U41/3(YES,YES,YES)

Quasi precedence:
[x_2, 0, U31, U41_3] > tt > [plus_2, U21_3] > s_1 > [isNat_1, ISNAT_1] > U11_2


Status:
tt: multiset status
isNat_1: multiset status
ISNAT_1: multiset status
plus_2: [1,2]
s_1: [1]
x_2: [2,1]
0: multiset status
U11_2: [1,2]
U21_3: [3,2,1]
U31: []
U41_3: [2,3,1]



the following usable rules


   isNat(0) -> tt
   isNat(plus(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(s(V1)) -> isNat(V1)
   isNat(x(V1, V2)) -> and(isNat(V1), isNat(V2))
   plus(N, 0) -> U11(isNat(N), N)
   plus(N, s(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   U11(tt, N) -> N
   U21(tt, M, N) -> s(plus(N, M))
   and(tt, X) -> X
   x(N, 0) -> U31(isNat(N))
   x(N, s(M)) -> U41(and(isNat(M), isNat(N)), M, N)
   U31(tt) -> 0
   U41(tt, M, N) -> plus(x(N, M), N)


could all be oriented weakly.

Furthermore, the pairs


   ISNAT(plus(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(plus(V1, V2)) -> ISNAT(V1)
   ISNAT(s(V1)) -> ISNAT(V1)
   ISNAT(x(V1, V2)) -> AND(isNat(V1), isNat(V2))
   ISNAT(x(V1, V2)) -> ISNAT(V1)


could be oriented strictly and thus removed by the CS-Reduction Pair Processor [LPAR08,DA_EMMES].


----------------------------------------

(9)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {s_1, plus_2, U31_1, x_2} are replacing on all positions.
For all symbols f in {U11_2, U21_3, U41_3, and_2, AND_2} we have mu(f) = {1}.
The symbols in {isNat_1, U_1, ISNAT_1} are not replacing on any position.

The TRS P consists of the following rules:

   AND(tt, X) -> U(X)
   U(isNat(x0)) -> ISNAT(x0)

The TRS R consists of the following rules:

   U11(tt, N) -> N
   U21(tt, M, N) -> s(plus(N, M))
   U31(tt) -> 0
   U41(tt, M, N) -> plus(x(N, M), N)
   and(tt, X) -> X
   isNat(0) -> tt
   isNat(plus(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(s(V1)) -> isNat(V1)
   isNat(x(V1, V2)) -> and(isNat(V1), isNat(V2))
   plus(N, 0) -> U11(isNat(N), N)
   plus(N, s(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   x(N, 0) -> U31(isNat(N))
   x(N, s(M)) -> U41(and(isNat(M), isNat(N)), M, N)

Q is empty.

----------------------------------------

(10) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 0 SCCs with 2 less nodes.

----------------------------------------

(11)
TRUE

----------------------------------------

(12)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {s_1, plus_2, U31_1, x_2, PLUS_2} are replacing on all positions.
For all symbols f in {U11_2, U21_3, U41_3, and_2, U21'_3} we have mu(f) = {1}.
The symbols in {isNat_1} are not replacing on any position.

The TRS P consists of the following rules:

   PLUS(N, s(M)) -> U21'(and(isNat(M), isNat(N)), M, N)
   U21'(tt, M, N) -> PLUS(N, M)

The TRS R consists of the following rules:

   U11(tt, N) -> N
   U21(tt, M, N) -> s(plus(N, M))
   U31(tt) -> 0
   U41(tt, M, N) -> plus(x(N, M), N)
   and(tt, X) -> X
   isNat(0) -> tt
   isNat(plus(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(s(V1)) -> isNat(V1)
   isNat(x(V1, V2)) -> and(isNat(V1), isNat(V2))
   plus(N, 0) -> U11(isNat(N), N)
   plus(N, s(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   x(N, 0) -> U31(isNat(N))
   x(N, s(M)) -> U41(and(isNat(M), isNat(N)), M, N)

Q is empty.

----------------------------------------

(13) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   PLUS(N, s(M)) -> U21'(and(isNat(M), isNat(N)), M, N)
The remaining pairs can at least be oriented weakly.

   U21'(tt, M, N) -> PLUS(N, M)
Used ordering:  Combined order from the following AFS and order.
U21'(x1, x2, x3)  =  x2

PLUS(x1, x2)  =  x2


Subterm Order

----------------------------------------

(14)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {s_1, plus_2, U31_1, x_2, PLUS_2} are replacing on all positions.
For all symbols f in {U11_2, U21_3, U41_3, and_2, U21'_3} we have mu(f) = {1}.
The symbols in {isNat_1} are not replacing on any position.

The TRS P consists of the following rules:

   U21'(tt, M, N) -> PLUS(N, M)

The TRS R consists of the following rules:

   U11(tt, N) -> N
   U21(tt, M, N) -> s(plus(N, M))
   U31(tt) -> 0
   U41(tt, M, N) -> plus(x(N, M), N)
   and(tt, X) -> X
   isNat(0) -> tt
   isNat(plus(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(s(V1)) -> isNat(V1)
   isNat(x(V1, V2)) -> and(isNat(V1), isNat(V2))
   plus(N, 0) -> U11(isNat(N), N)
   plus(N, s(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   x(N, 0) -> U31(isNat(N))
   x(N, s(M)) -> U41(and(isNat(M), isNat(N)), M, N)

Q is empty.

----------------------------------------

(15) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 0 SCCs with 1 less node.

----------------------------------------

(16)
TRUE

----------------------------------------

(17)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {s_1, plus_2, U31_1, x_2, X_2} are replacing on all positions.
For all symbols f in {U11_2, U21_3, U41_3, and_2, U41'_3} we have mu(f) = {1}.
The symbols in {isNat_1} are not replacing on any position.

The TRS P consists of the following rules:

   U41'(tt, M, N) -> X(N, M)
   X(N, s(M)) -> U41'(and(isNat(M), isNat(N)), M, N)

The TRS R consists of the following rules:

   U11(tt, N) -> N
   U21(tt, M, N) -> s(plus(N, M))
   U31(tt) -> 0
   U41(tt, M, N) -> plus(x(N, M), N)
   and(tt, X) -> X
   isNat(0) -> tt
   isNat(plus(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(s(V1)) -> isNat(V1)
   isNat(x(V1, V2)) -> and(isNat(V1), isNat(V2))
   plus(N, 0) -> U11(isNat(N), N)
   plus(N, s(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   x(N, 0) -> U31(isNat(N))
   x(N, s(M)) -> U41(and(isNat(M), isNat(N)), M, N)

Q is empty.

----------------------------------------

(18) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   X(N, s(M)) -> U41'(and(isNat(M), isNat(N)), M, N)
The remaining pairs can at least be oriented weakly.

   U41'(tt, M, N) -> X(N, M)
Used ordering:  Combined order from the following AFS and order.
X(x1, x2)  =  x2

U41'(x1, x2, x3)  =  x2


Subterm Order

----------------------------------------

(19)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {s_1, plus_2, U31_1, x_2, X_2} are replacing on all positions.
For all symbols f in {U11_2, U21_3, U41_3, and_2, U41'_3} we have mu(f) = {1}.
The symbols in {isNat_1} are not replacing on any position.

The TRS P consists of the following rules:

   U41'(tt, M, N) -> X(N, M)

The TRS R consists of the following rules:

   U11(tt, N) -> N
   U21(tt, M, N) -> s(plus(N, M))
   U31(tt) -> 0
   U41(tt, M, N) -> plus(x(N, M), N)
   and(tt, X) -> X
   isNat(0) -> tt
   isNat(plus(V1, V2)) -> and(isNat(V1), isNat(V2))
   isNat(s(V1)) -> isNat(V1)
   isNat(x(V1, V2)) -> and(isNat(V1), isNat(V2))
   plus(N, 0) -> U11(isNat(N), N)
   plus(N, s(M)) -> U21(and(isNat(M), isNat(N)), M, N)
   x(N, 0) -> U31(isNat(N))
   x(N, s(M)) -> U41(and(isNat(M), isNat(N)), M, N)

Q is empty.

----------------------------------------

(20) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 0 SCCs with 1 less node.

----------------------------------------

(21)
TRUE
