NO
proof of /home/ff862203/input_wQSs49dsnT.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be disproven:

(0) QTRS
(1) QTRSRRRProof [EQUIVALENT, 36 ms]
(2) QTRS
(3) QTRSRRRProof [EQUIVALENT, 0 ms]
(4) QTRS
(5) DependencyPairsProof [EQUIVALENT, 0 ms]
(6) QDP
(7) DependencyGraphProof [EQUIVALENT, 0 ms]
(8) QDP
(9) MRRProof [EQUIVALENT, 0 ms]
(10) QDP
(11) MRRProof [EQUIVALENT, 7 ms]
(12) QDP
(13) DependencyGraphProof [EQUIVALENT, 0 ms]
(14) AND
    (15) QDP
        (16) UsableRulesProof [EQUIVALENT, 0 ms]
        (17) QDP
        (18) QReductionProof [EQUIVALENT, 0 ms]
        (19) QDP
        (20) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (21) YES
    (22) QDP
        (23) TransformationProof [EQUIVALENT, 0 ms]
        (24) QDP
        (25) DependencyGraphProof [EQUIVALENT, 0 ms]
        (26) QDP
        (27) TransformationProof [EQUIVALENT, 0 ms]
        (28) QDP
        (29) DependencyGraphProof [EQUIVALENT, 0 ms]
        (30) AND
            (31) QDP
                (32) UsableRulesProof [EQUIVALENT, 0 ms]
                (33) QDP
                (34) QReductionProof [EQUIVALENT, 0 ms]
                (35) QDP
                (36) TransformationProof [EQUIVALENT, 0 ms]
                (37) QDP
                (38) NonTerminationLoopProof [COMPLETE, 0 ms]
                (39) NO
            (40) QDP
                (41) MRRProof [EQUIVALENT, 3 ms]
                (42) QDP
                (43) QDPQMonotonicMRRProof [EQUIVALENT, 3 ms]
                (44) QDP


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__and(tt, X) -> mark(X)
   a__length(nil) -> 0
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(0, IL) -> nil
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))


----------------------------------------

(1) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(a__and(x_1, x_2)) = x_1 + 2*x_2
   POL(a__length(x_1)) = x_1
   POL(a__take(x_1, x_2)) = x_1 + 2*x_2
   POL(a__zeros) = 0
   POL(and(x_1, x_2)) = x_1 + 2*x_2
   POL(cons(x_1, x_2)) = x_1 + x_2
   POL(length(x_1)) = x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(s(x_1)) = x_1
   POL(take(x_1, x_2)) = x_1 + 2*x_2
   POL(tt) = 1
   POL(zeros) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   a__and(tt, X) -> mark(X)




----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(nil) -> 0
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(0, IL) -> nil
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))


----------------------------------------

(3) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(a__and(x_1, x_2)) = x_1 + 2*x_2
   POL(a__length(x_1)) = 2*x_1
   POL(a__take(x_1, x_2)) = 2 + x_1 + x_2
   POL(a__zeros) = 0
   POL(and(x_1, x_2)) = x_1 + 2*x_2
   POL(cons(x_1, x_2)) = x_1 + x_2
   POL(length(x_1)) = 2*x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 1
   POL(s(x_1)) = x_1
   POL(take(x_1, x_2)) = 2 + x_1 + x_2
   POL(tt) = 0
   POL(zeros) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   a__length(nil) -> 0
   a__take(0, IL) -> nil




----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))


----------------------------------------

(5) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(6)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(N, L)) -> A__LENGTH(mark(L))
   A__LENGTH(cons(N, L)) -> MARK(L)
   A__TAKE(s(M), cons(N, IL)) -> MARK(N)
   MARK(zeros) -> A__ZEROS
   MARK(and(X1, X2)) -> A__AND(mark(X1), X2)
   MARK(and(X1, X2)) -> MARK(X1)
   MARK(length(X)) -> A__LENGTH(mark(X))
   MARK(length(X)) -> MARK(X)
   MARK(take(X1, X2)) -> A__TAKE(mark(X1), mark(X2))
   MARK(take(X1, X2)) -> MARK(X1)
   MARK(take(X1, X2)) -> MARK(X2)
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(7) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(8)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(N, L)) -> MARK(L)
   MARK(and(X1, X2)) -> MARK(X1)
   MARK(length(X)) -> A__LENGTH(mark(X))
   A__LENGTH(cons(N, L)) -> A__LENGTH(mark(L))
   MARK(length(X)) -> MARK(X)
   MARK(take(X1, X2)) -> A__TAKE(mark(X1), mark(X2))
   A__TAKE(s(M), cons(N, IL)) -> MARK(N)
   MARK(take(X1, X2)) -> MARK(X1)
   MARK(take(X1, X2)) -> MARK(X2)
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(9) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   MARK(and(X1, X2)) -> MARK(X1)


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(A__LENGTH(x_1)) = x_1
   POL(A__TAKE(x_1, x_2)) = x_1 + 2*x_2
   POL(MARK(x_1)) = x_1
   POL(a__and(x_1, x_2)) = 1 + x_1 + 2*x_2
   POL(a__length(x_1)) = x_1
   POL(a__take(x_1, x_2)) = x_1 + 2*x_2
   POL(a__zeros) = 0
   POL(and(x_1, x_2)) = 1 + x_1 + 2*x_2
   POL(cons(x_1, x_2)) = x_1 + 2*x_2
   POL(length(x_1)) = x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(s(x_1)) = 2*x_1
   POL(take(x_1, x_2)) = x_1 + 2*x_2
   POL(tt) = 0
   POL(zeros) = 0


----------------------------------------

(10)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(N, L)) -> MARK(L)
   MARK(length(X)) -> A__LENGTH(mark(X))
   A__LENGTH(cons(N, L)) -> A__LENGTH(mark(L))
   MARK(length(X)) -> MARK(X)
   MARK(take(X1, X2)) -> A__TAKE(mark(X1), mark(X2))
   A__TAKE(s(M), cons(N, IL)) -> MARK(N)
   MARK(take(X1, X2)) -> MARK(X1)
   MARK(take(X1, X2)) -> MARK(X2)
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(11) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A__LENGTH(cons(N, L)) -> MARK(L)
   MARK(length(X)) -> A__LENGTH(mark(X))
   MARK(length(X)) -> MARK(X)
   MARK(take(X1, X2)) -> A__TAKE(mark(X1), mark(X2))
   A__TAKE(s(M), cons(N, IL)) -> MARK(N)
   MARK(take(X1, X2)) -> MARK(X1)
   MARK(take(X1, X2)) -> MARK(X2)


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(A__LENGTH(x_1)) = 2 + 2*x_1
   POL(A__TAKE(x_1, x_2)) = 1 + x_1 + 2*x_2
   POL(MARK(x_1)) = 2*x_1
   POL(a__and(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(a__length(x_1)) = 2 + x_1
   POL(a__take(x_1, x_2)) = 1 + x_1 + 2*x_2
   POL(a__zeros) = 0
   POL(and(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(cons(x_1, x_2)) = x_1 + x_2
   POL(length(x_1)) = 2 + x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(s(x_1)) = x_1
   POL(take(x_1, x_2)) = 1 + x_1 + 2*x_2
   POL(tt) = 0
   POL(zeros) = 0


----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(N, L)) -> A__LENGTH(mark(L))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(13) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs.
----------------------------------------

(14)
Complex Obligation (AND)

----------------------------------------

(15)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MARK(s(X)) -> MARK(X)
   MARK(cons(X1, X2)) -> MARK(X1)

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(16) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(17)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MARK(s(X)) -> MARK(X)
   MARK(cons(X1, X2)) -> MARK(X1)

R is empty.
The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(18) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))


----------------------------------------

(19)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MARK(s(X)) -> MARK(X)
   MARK(cons(X1, X2)) -> MARK(X1)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(20) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MARK(s(X)) -> MARK(X)
The graph contains the following edges 1 > 1


*MARK(cons(X1, X2)) -> MARK(X1)
The graph contains the following edges 1 > 1


----------------------------------------

(21)
YES

----------------------------------------

(22)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(N, L)) -> A__LENGTH(mark(L))

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(23) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A__LENGTH(cons(N, L)) -> A__LENGTH(mark(L)) at position [0] we obtained the following new rules [LPAR04]:

   (A__LENGTH(cons(y0, zeros)) -> A__LENGTH(a__zeros),A__LENGTH(cons(y0, zeros)) -> A__LENGTH(a__zeros))
   (A__LENGTH(cons(y0, and(x0, x1))) -> A__LENGTH(a__and(mark(x0), x1)),A__LENGTH(cons(y0, and(x0, x1))) -> A__LENGTH(a__and(mark(x0), x1)))
   (A__LENGTH(cons(y0, length(x0))) -> A__LENGTH(a__length(mark(x0))),A__LENGTH(cons(y0, length(x0))) -> A__LENGTH(a__length(mark(x0))))
   (A__LENGTH(cons(y0, take(x0, x1))) -> A__LENGTH(a__take(mark(x0), mark(x1))),A__LENGTH(cons(y0, take(x0, x1))) -> A__LENGTH(a__take(mark(x0), mark(x1))))
   (A__LENGTH(cons(y0, cons(x0, x1))) -> A__LENGTH(cons(mark(x0), x1)),A__LENGTH(cons(y0, cons(x0, x1))) -> A__LENGTH(cons(mark(x0), x1)))
   (A__LENGTH(cons(y0, 0)) -> A__LENGTH(0),A__LENGTH(cons(y0, 0)) -> A__LENGTH(0))
   (A__LENGTH(cons(y0, tt)) -> A__LENGTH(tt),A__LENGTH(cons(y0, tt)) -> A__LENGTH(tt))
   (A__LENGTH(cons(y0, nil)) -> A__LENGTH(nil),A__LENGTH(cons(y0, nil)) -> A__LENGTH(nil))
   (A__LENGTH(cons(y0, s(x0))) -> A__LENGTH(s(mark(x0))),A__LENGTH(cons(y0, s(x0))) -> A__LENGTH(s(mark(x0))))


----------------------------------------

(24)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(y0, zeros)) -> A__LENGTH(a__zeros)
   A__LENGTH(cons(y0, and(x0, x1))) -> A__LENGTH(a__and(mark(x0), x1))
   A__LENGTH(cons(y0, length(x0))) -> A__LENGTH(a__length(mark(x0)))
   A__LENGTH(cons(y0, take(x0, x1))) -> A__LENGTH(a__take(mark(x0), mark(x1)))
   A__LENGTH(cons(y0, cons(x0, x1))) -> A__LENGTH(cons(mark(x0), x1))
   A__LENGTH(cons(y0, 0)) -> A__LENGTH(0)
   A__LENGTH(cons(y0, tt)) -> A__LENGTH(tt)
   A__LENGTH(cons(y0, nil)) -> A__LENGTH(nil)
   A__LENGTH(cons(y0, s(x0))) -> A__LENGTH(s(mark(x0)))

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(25) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 4 less nodes.
----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(y0, zeros)) -> A__LENGTH(a__zeros)
   A__LENGTH(cons(y0, cons(x0, x1))) -> A__LENGTH(cons(mark(x0), x1))
   A__LENGTH(cons(y0, and(x0, x1))) -> A__LENGTH(a__and(mark(x0), x1))
   A__LENGTH(cons(y0, length(x0))) -> A__LENGTH(a__length(mark(x0)))
   A__LENGTH(cons(y0, take(x0, x1))) -> A__LENGTH(a__take(mark(x0), mark(x1)))

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(27) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A__LENGTH(cons(y0, zeros)) -> A__LENGTH(a__zeros) at position [0] we obtained the following new rules [LPAR04]:

   (A__LENGTH(cons(y0, zeros)) -> A__LENGTH(cons(0, zeros)),A__LENGTH(cons(y0, zeros)) -> A__LENGTH(cons(0, zeros)))
   (A__LENGTH(cons(y0, zeros)) -> A__LENGTH(zeros),A__LENGTH(cons(y0, zeros)) -> A__LENGTH(zeros))


----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(y0, cons(x0, x1))) -> A__LENGTH(cons(mark(x0), x1))
   A__LENGTH(cons(y0, and(x0, x1))) -> A__LENGTH(a__and(mark(x0), x1))
   A__LENGTH(cons(y0, length(x0))) -> A__LENGTH(a__length(mark(x0)))
   A__LENGTH(cons(y0, take(x0, x1))) -> A__LENGTH(a__take(mark(x0), mark(x1)))
   A__LENGTH(cons(y0, zeros)) -> A__LENGTH(cons(0, zeros))
   A__LENGTH(cons(y0, zeros)) -> A__LENGTH(zeros)

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(29) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(30)
Complex Obligation (AND)

----------------------------------------

(31)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(y0, zeros)) -> A__LENGTH(cons(0, zeros))

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(32) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(33)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(y0, zeros)) -> A__LENGTH(cons(0, zeros))

R is empty.
The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(34) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))


----------------------------------------

(35)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(y0, zeros)) -> A__LENGTH(cons(0, zeros))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(36) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule A__LENGTH(cons(y0, zeros)) -> A__LENGTH(cons(0, zeros)) we obtained the following new rules [LPAR04]:

   (A__LENGTH(cons(0, zeros)) -> A__LENGTH(cons(0, zeros)),A__LENGTH(cons(0, zeros)) -> A__LENGTH(cons(0, zeros)))


----------------------------------------

(37)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(0, zeros)) -> A__LENGTH(cons(0, zeros))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(38) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = A__LENGTH(cons(0, zeros)) evaluates to  t =A__LENGTH(cons(0, zeros))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from A__LENGTH(cons(0, zeros)) to A__LENGTH(cons(0, zeros)).




----------------------------------------

(39)
NO

----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(y0, and(x0, x1))) -> A__LENGTH(a__and(mark(x0), x1))
   A__LENGTH(cons(y0, length(x0))) -> A__LENGTH(a__length(mark(x0)))
   A__LENGTH(cons(y0, take(x0, x1))) -> A__LENGTH(a__take(mark(x0), mark(x1)))
   A__LENGTH(cons(y0, cons(x0, x1))) -> A__LENGTH(cons(mark(x0), x1))

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(41) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A__LENGTH(cons(y0, and(x0, x1))) -> A__LENGTH(a__and(mark(x0), x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(A__LENGTH(x_1)) = x_1
   POL(a__and(x_1, x_2)) = 2 + 2*x_1 + x_2
   POL(a__length(x_1)) = x_1
   POL(a__take(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(a__zeros) = 0
   POL(and(x_1, x_2)) = 2 + 2*x_1 + x_2
   POL(cons(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(length(x_1)) = x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(s(x_1)) = 2*x_1
   POL(take(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(tt) = 0
   POL(zeros) = 0


----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(y0, length(x0))) -> A__LENGTH(a__length(mark(x0)))
   A__LENGTH(cons(y0, take(x0, x1))) -> A__LENGTH(a__take(mark(x0), mark(x1)))
   A__LENGTH(cons(y0, cons(x0, x1))) -> A__LENGTH(cons(mark(x0), x1))

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(43) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   A__LENGTH(cons(y0, length(x0))) -> A__LENGTH(a__length(mark(x0)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(A__LENGTH(x_1)) = 2*x_1
   POL(a__and(x_1, x_2)) = 2*x_2
   POL(a__length(x_1)) = 2
   POL(a__take(x_1, x_2)) = 0
   POL(a__zeros) = 0
   POL(and(x_1, x_2)) = 2*x_2
   POL(cons(x_1, x_2)) = 2*x_2
   POL(length(x_1)) = 2
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(s(x_1)) = 0
   POL(take(x_1, x_2)) = 0
   POL(tt) = 0
   POL(zeros) = 0


----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A__LENGTH(cons(y0, take(x0, x1))) -> A__LENGTH(a__take(mark(x0), mark(x1)))
   A__LENGTH(cons(y0, cons(x0, x1))) -> A__LENGTH(cons(mark(x0), x1))

The TRS R consists of the following rules:

   a__zeros -> cons(0, zeros)
   a__length(cons(N, L)) -> s(a__length(mark(L)))
   a__take(s(M), cons(N, IL)) -> cons(mark(N), take(M, IL))
   mark(zeros) -> a__zeros
   mark(and(X1, X2)) -> a__and(mark(X1), X2)
   mark(length(X)) -> a__length(mark(X))
   mark(take(X1, X2)) -> a__take(mark(X1), mark(X2))
   mark(cons(X1, X2)) -> cons(mark(X1), X2)
   mark(0) -> 0
   mark(tt) -> tt
   mark(nil) -> nil
   mark(s(X)) -> s(mark(X))
   a__zeros -> zeros
   a__and(X1, X2) -> and(X1, X2)
   a__length(X) -> length(X)
   a__take(X1, X2) -> take(X1, X2)

The set Q consists of the following terms:

   mark(take(x0, x1))
   a__and(x0, x1)
   a__length(x0)
   a__take(x0, x1)
   a__zeros
   mark(tt)
   mark(zeros)
   mark(0)
   mark(length(x0))
   mark(s(x0))
   mark(cons(x0, x1))
   mark(nil)
   mark(and(x0, x1))

We have to consider all minimal (P,Q,R)-chains.