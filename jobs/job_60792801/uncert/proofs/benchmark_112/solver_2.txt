YES

Problem 1: 

(VAR vu95NonEmpty L X X1 X2 Y)
(RULES
au95u95eq(num0,num0) -> ftrue
au95u95eq(s(X),s(Y)) -> au95u95eq(X,Y)
au95u95eq(X,Y) -> ffalse
au95u95eq(X1,X2) -> eq(X1,X2)
au95u95inf(X) -> cons(X,inf(s(X)))
au95u95inf(X) -> inf(X)
au95u95length(cons(X,L)) -> s(length(L))
au95u95length(nil) -> num0
au95u95length(X) -> length(X)
au95u95take(num0,X) -> nil
au95u95take(s(X),cons(Y,L)) -> cons(Y,take(X,L))
au95u95take(X1,X2) -> take(X1,X2)
mark(num0) -> num0
mark(cons(X1,X2)) -> cons(X1,X2)
mark(eq(X1,X2)) -> au95u95eq(X1,X2)
mark(ffalse) -> ffalse
mark(inf(X)) -> au95u95inf(mark(X))
mark(length(X)) -> au95u95length(mark(X))
mark(nil) -> nil
mark(s(X)) -> s(X)
mark(take(X1,X2)) -> au95u95take(mark(X1),mark(X2))
mark(ftrue) -> ftrue
)
 
(STRATEGY INNERMOST)

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 AU95U95EQ(s(X),s(Y)) -> AU95U95EQ(X,Y)
 MARK(eq(X1,X2)) -> AU95U95EQ(X1,X2)
 MARK(inf(X)) -> AU95U95INF(mark(X))
 MARK(inf(X)) -> MARK(X)
 MARK(length(X)) -> AU95U95LENGTH(mark(X))
 MARK(length(X)) -> MARK(X)
 MARK(take(X1,X2)) -> AU95U95TAKE(mark(X1),mark(X2))
 MARK(take(X1,X2)) -> MARK(X1)
 MARK(take(X1,X2)) -> MARK(X2)
-> Rules:
 au95u95eq(num0,num0) -> ftrue
 au95u95eq(s(X),s(Y)) -> au95u95eq(X,Y)
 au95u95eq(X,Y) -> ffalse
 au95u95eq(X1,X2) -> eq(X1,X2)
 au95u95inf(X) -> cons(X,inf(s(X)))
 au95u95inf(X) -> inf(X)
 au95u95length(cons(X,L)) -> s(length(L))
 au95u95length(nil) -> num0
 au95u95length(X) -> length(X)
 au95u95take(num0,X) -> nil
 au95u95take(s(X),cons(Y,L)) -> cons(Y,take(X,L))
 au95u95take(X1,X2) -> take(X1,X2)
 mark(num0) -> num0
 mark(cons(X1,X2)) -> cons(X1,X2)
 mark(eq(X1,X2)) -> au95u95eq(X1,X2)
 mark(ffalse) -> ffalse
 mark(inf(X)) -> au95u95inf(mark(X))
 mark(length(X)) -> au95u95length(mark(X))
 mark(nil) -> nil
 mark(s(X)) -> s(X)
 mark(take(X1,X2)) -> au95u95take(mark(X1),mark(X2))
 mark(ftrue) -> ftrue

Problem 1: 

SCC Processor:
-> Pairs:
 AU95U95EQ(s(X),s(Y)) -> AU95U95EQ(X,Y)
 MARK(eq(X1,X2)) -> AU95U95EQ(X1,X2)
 MARK(inf(X)) -> AU95U95INF(mark(X))
 MARK(inf(X)) -> MARK(X)
 MARK(length(X)) -> AU95U95LENGTH(mark(X))
 MARK(length(X)) -> MARK(X)
 MARK(take(X1,X2)) -> AU95U95TAKE(mark(X1),mark(X2))
 MARK(take(X1,X2)) -> MARK(X1)
 MARK(take(X1,X2)) -> MARK(X2)
-> Rules:
 au95u95eq(num0,num0) -> ftrue
 au95u95eq(s(X),s(Y)) -> au95u95eq(X,Y)
 au95u95eq(X,Y) -> ffalse
 au95u95eq(X1,X2) -> eq(X1,X2)
 au95u95inf(X) -> cons(X,inf(s(X)))
 au95u95inf(X) -> inf(X)
 au95u95length(cons(X,L)) -> s(length(L))
 au95u95length(nil) -> num0
 au95u95length(X) -> length(X)
 au95u95take(num0,X) -> nil
 au95u95take(s(X),cons(Y,L)) -> cons(Y,take(X,L))
 au95u95take(X1,X2) -> take(X1,X2)
 mark(num0) -> num0
 mark(cons(X1,X2)) -> cons(X1,X2)
 mark(eq(X1,X2)) -> au95u95eq(X1,X2)
 mark(ffalse) -> ffalse
 mark(inf(X)) -> au95u95inf(mark(X))
 mark(length(X)) -> au95u95length(mark(X))
 mark(nil) -> nil
 mark(s(X)) -> s(X)
 mark(take(X1,X2)) -> au95u95take(mark(X1),mark(X2))
 mark(ftrue) -> ftrue
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AU95U95EQ(s(X),s(Y)) -> AU95U95EQ(X,Y)
->->-> Rules:
 au95u95eq(num0,num0) -> ftrue
 au95u95eq(s(X),s(Y)) -> au95u95eq(X,Y)
 au95u95eq(X,Y) -> ffalse
 au95u95eq(X1,X2) -> eq(X1,X2)
 au95u95inf(X) -> cons(X,inf(s(X)))
 au95u95inf(X) -> inf(X)
 au95u95length(cons(X,L)) -> s(length(L))
 au95u95length(nil) -> num0
 au95u95length(X) -> length(X)
 au95u95take(num0,X) -> nil
 au95u95take(s(X),cons(Y,L)) -> cons(Y,take(X,L))
 au95u95take(X1,X2) -> take(X1,X2)
 mark(num0) -> num0
 mark(cons(X1,X2)) -> cons(X1,X2)
 mark(eq(X1,X2)) -> au95u95eq(X1,X2)
 mark(ffalse) -> ffalse
 mark(inf(X)) -> au95u95inf(mark(X))
 mark(length(X)) -> au95u95length(mark(X))
 mark(nil) -> nil
 mark(s(X)) -> s(X)
 mark(take(X1,X2)) -> au95u95take(mark(X1),mark(X2))
 mark(ftrue) -> ftrue
->->Cycle:
->->-> Pairs:
 MARK(inf(X)) -> MARK(X)
 MARK(length(X)) -> MARK(X)
 MARK(take(X1,X2)) -> MARK(X1)
 MARK(take(X1,X2)) -> MARK(X2)
->->-> Rules:
 au95u95eq(num0,num0) -> ftrue
 au95u95eq(s(X),s(Y)) -> au95u95eq(X,Y)
 au95u95eq(X,Y) -> ffalse
 au95u95eq(X1,X2) -> eq(X1,X2)
 au95u95inf(X) -> cons(X,inf(s(X)))
 au95u95inf(X) -> inf(X)
 au95u95length(cons(X,L)) -> s(length(L))
 au95u95length(nil) -> num0
 au95u95length(X) -> length(X)
 au95u95take(num0,X) -> nil
 au95u95take(s(X),cons(Y,L)) -> cons(Y,take(X,L))
 au95u95take(X1,X2) -> take(X1,X2)
 mark(num0) -> num0
 mark(cons(X1,X2)) -> cons(X1,X2)
 mark(eq(X1,X2)) -> au95u95eq(X1,X2)
 mark(ffalse) -> ffalse
 mark(inf(X)) -> au95u95inf(mark(X))
 mark(length(X)) -> au95u95length(mark(X))
 mark(nil) -> nil
 mark(s(X)) -> s(X)
 mark(take(X1,X2)) -> au95u95take(mark(X1),mark(X2))
 mark(ftrue) -> ftrue


The problem is decomposed in 2 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 AU95U95EQ(s(X),s(Y)) -> AU95U95EQ(X,Y)
-> Rules:
 au95u95eq(num0,num0) -> ftrue
 au95u95eq(s(X),s(Y)) -> au95u95eq(X,Y)
 au95u95eq(X,Y) -> ffalse
 au95u95eq(X1,X2) -> eq(X1,X2)
 au95u95inf(X) -> cons(X,inf(s(X)))
 au95u95inf(X) -> inf(X)
 au95u95length(cons(X,L)) -> s(length(L))
 au95u95length(nil) -> num0
 au95u95length(X) -> length(X)
 au95u95take(num0,X) -> nil
 au95u95take(s(X),cons(Y,L)) -> cons(Y,take(X,L))
 au95u95take(X1,X2) -> take(X1,X2)
 mark(num0) -> num0
 mark(cons(X1,X2)) -> cons(X1,X2)
 mark(eq(X1,X2)) -> au95u95eq(X1,X2)
 mark(ffalse) -> ffalse
 mark(inf(X)) -> au95u95inf(mark(X))
 mark(length(X)) -> au95u95length(mark(X))
 mark(nil) -> nil
 mark(s(X)) -> s(X)
 mark(take(X1,X2)) -> au95u95take(mark(X1),mark(X2))
 mark(ftrue) -> ftrue
->Projection:
 pi(AU95U95EQ) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 au95u95eq(num0,num0) -> ftrue
 au95u95eq(s(X),s(Y)) -> au95u95eq(X,Y)
 au95u95eq(X,Y) -> ffalse
 au95u95eq(X1,X2) -> eq(X1,X2)
 au95u95inf(X) -> cons(X,inf(s(X)))
 au95u95inf(X) -> inf(X)
 au95u95length(cons(X,L)) -> s(length(L))
 au95u95length(nil) -> num0
 au95u95length(X) -> length(X)
 au95u95take(num0,X) -> nil
 au95u95take(s(X),cons(Y,L)) -> cons(Y,take(X,L))
 au95u95take(X1,X2) -> take(X1,X2)
 mark(num0) -> num0
 mark(cons(X1,X2)) -> cons(X1,X2)
 mark(eq(X1,X2)) -> au95u95eq(X1,X2)
 mark(ffalse) -> ffalse
 mark(inf(X)) -> au95u95inf(mark(X))
 mark(length(X)) -> au95u95length(mark(X))
 mark(nil) -> nil
 mark(s(X)) -> s(X)
 mark(take(X1,X2)) -> au95u95take(mark(X1),mark(X2))
 mark(ftrue) -> ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Subterm Processor:
-> Pairs:
 MARK(inf(X)) -> MARK(X)
 MARK(length(X)) -> MARK(X)
 MARK(take(X1,X2)) -> MARK(X1)
 MARK(take(X1,X2)) -> MARK(X2)
-> Rules:
 au95u95eq(num0,num0) -> ftrue
 au95u95eq(s(X),s(Y)) -> au95u95eq(X,Y)
 au95u95eq(X,Y) -> ffalse
 au95u95eq(X1,X2) -> eq(X1,X2)
 au95u95inf(X) -> cons(X,inf(s(X)))
 au95u95inf(X) -> inf(X)
 au95u95length(cons(X,L)) -> s(length(L))
 au95u95length(nil) -> num0
 au95u95length(X) -> length(X)
 au95u95take(num0,X) -> nil
 au95u95take(s(X),cons(Y,L)) -> cons(Y,take(X,L))
 au95u95take(X1,X2) -> take(X1,X2)
 mark(num0) -> num0
 mark(cons(X1,X2)) -> cons(X1,X2)
 mark(eq(X1,X2)) -> au95u95eq(X1,X2)
 mark(ffalse) -> ffalse
 mark(inf(X)) -> au95u95inf(mark(X))
 mark(length(X)) -> au95u95length(mark(X))
 mark(nil) -> nil
 mark(s(X)) -> s(X)
 mark(take(X1,X2)) -> au95u95take(mark(X1),mark(X2))
 mark(ftrue) -> ftrue
->Projection:
 pi(MARK) = 1

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 au95u95eq(num0,num0) -> ftrue
 au95u95eq(s(X),s(Y)) -> au95u95eq(X,Y)
 au95u95eq(X,Y) -> ffalse
 au95u95eq(X1,X2) -> eq(X1,X2)
 au95u95inf(X) -> cons(X,inf(s(X)))
 au95u95inf(X) -> inf(X)
 au95u95length(cons(X,L)) -> s(length(L))
 au95u95length(nil) -> num0
 au95u95length(X) -> length(X)
 au95u95take(num0,X) -> nil
 au95u95take(s(X),cons(Y,L)) -> cons(Y,take(X,L))
 au95u95take(X1,X2) -> take(X1,X2)
 mark(num0) -> num0
 mark(cons(X1,X2)) -> cons(X1,X2)
 mark(eq(X1,X2)) -> au95u95eq(X1,X2)
 mark(ffalse) -> ffalse
 mark(inf(X)) -> au95u95inf(mark(X))
 mark(length(X)) -> au95u95length(mark(X))
 mark(nil) -> nil
 mark(s(X)) -> s(X)
 mark(take(X1,X2)) -> au95u95take(mark(X1),mark(X2))
 mark(ftrue) -> ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
