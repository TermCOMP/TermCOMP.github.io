NO
proof of /home/ff862203/input_GgEP6UQb46.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be disproven:

(0) QTRS
(1) DependencyPairsProof [EQUIVALENT, 0 ms]
(2) QDP
(3) DependencyGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) QDP
        (6) UsableRulesProof [EQUIVALENT, 0 ms]
        (7) QDP
        (8) QReductionProof [EQUIVALENT, 0 ms]
        (9) QDP
        (10) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (11) YES
    (12) QDP
        (13) UsableRulesProof [EQUIVALENT, 0 ms]
        (14) QDP
        (15) QReductionProof [EQUIVALENT, 0 ms]
        (16) QDP
        (17) TransformationProof [EQUIVALENT, 0 ms]
        (18) QDP
        (19) UsableRulesProof [EQUIVALENT, 0 ms]
        (20) QDP
        (21) QReductionProof [EQUIVALENT, 0 ms]
        (22) QDP
        (23) TransformationProof [EQUIVALENT, 0 ms]
        (24) QDP
        (25) TransformationProof [EQUIVALENT, 0 ms]
        (26) QDP
        (27) TransformationProof [EQUIVALENT, 0 ms]
        (28) QDP
        (29) TransformationProof [EQUIVALENT, 0 ms]
        (30) QDP
        (31) TransformationProof [EQUIVALENT, 0 ms]
        (32) QDP
        (33) TransformationProof [EQUIVALENT, 0 ms]
        (34) QDP
        (35) TransformationProof [EQUIVALENT, 0 ms]
        (36) QDP
        (37) TransformationProof [EQUIVALENT, 0 ms]
        (38) QDP
        (39) TransformationProof [EQUIVALENT, 0 ms]
        (40) QDP
        (41) TransformationProof [EQUIVALENT, 0 ms]
        (42) QDP
        (43) TransformationProof [EQUIVALENT, 0 ms]
        (44) QDP
        (45) TransformationProof [EQUIVALENT, 0 ms]
        (46) QDP
        (47) TransformationProof [EQUIVALENT, 0 ms]
        (48) QDP
        (49) TransformationProof [EQUIVALENT, 0 ms]
        (50) QDP
        (51) TransformationProof [EQUIVALENT, 0 ms]
        (52) QDP
        (53) TransformationProof [EQUIVALENT, 0 ms]
        (54) QDP
        (55) TransformationProof [EQUIVALENT, 0 ms]
        (56) QDP
        (57) TransformationProof [EQUIVALENT, 0 ms]
        (58) QDP
        (59) TransformationProof [EQUIVALENT, 0 ms]
        (60) QDP
        (61) TransformationProof [EQUIVALENT, 0 ms]
        (62) QDP
        (63) TransformationProof [EQUIVALENT, 0 ms]
        (64) QDP
        (65) TransformationProof [EQUIVALENT, 0 ms]
        (66) QDP
        (67) TransformationProof [EQUIVALENT, 0 ms]
        (68) QDP
        (69) TransformationProof [EQUIVALENT, 0 ms]
        (70) QDP
        (71) TransformationProof [EQUIVALENT, 0 ms]
        (72) QDP
        (73) TransformationProof [EQUIVALENT, 0 ms]
        (74) QDP
        (75) TransformationProof [EQUIVALENT, 0 ms]
        (76) QDP
        (77) TransformationProof [EQUIVALENT, 0 ms]
        (78) QDP
        (79) TransformationProof [EQUIVALENT, 0 ms]
        (80) QDP
        (81) TransformationProof [EQUIVALENT, 0 ms]
        (82) QDP
        (83) TransformationProof [EQUIVALENT, 0 ms]
        (84) QDP
        (85) TransformationProof [EQUIVALENT, 0 ms]
        (86) QDP
        (87) TransformationProof [EQUIVALENT, 0 ms]
        (88) QDP
        (89) TransformationProof [EQUIVALENT, 0 ms]
        (90) QDP
        (91) TransformationProof [EQUIVALENT, 0 ms]
        (92) QDP
        (93) TransformationProof [EQUIVALENT, 0 ms]
        (94) QDP
        (95) TransformationProof [EQUIVALENT, 0 ms]
        (96) QDP
        (97) TransformationProof [EQUIVALENT, 0 ms]
        (98) QDP
        (99) TransformationProof [EQUIVALENT, 0 ms]
        (100) QDP
        (101) TransformationProof [EQUIVALENT, 0 ms]
        (102) QDP
        (103) TransformationProof [EQUIVALENT, 0 ms]
        (104) QDP
        (105) TransformationProof [EQUIVALENT, 0 ms]
        (106) QDP
        (107) TransformationProof [EQUIVALENT, 0 ms]
        (108) QDP
        (109) TransformationProof [EQUIVALENT, 0 ms]
        (110) QDP
        (111) TransformationProof [EQUIVALENT, 0 ms]
        (112) QDP
        (113) TransformationProof [EQUIVALENT, 0 ms]
        (114) QDP
        (115) TransformationProof [EQUIVALENT, 0 ms]
        (116) QDP
        (117) TransformationProof [EQUIVALENT, 0 ms]
        (118) QDP
        (119) TransformationProof [EQUIVALENT, 0 ms]
        (120) QDP
        (121) TransformationProof [EQUIVALENT, 0 ms]
        (122) QDP
        (123) MNOCProof [EQUIVALENT, 0 ms]
        (124) QDP
        (125) NonTerminationLoopProof [COMPLETE, 0 ms]
        (126) NO


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   ack(0, y) -> s(y)
   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   init -> ack(s(s(s(s(s(s(s(0))))))), 0)
   run_again(x) -> run_again(init)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)
   init
   run_again(x0)


----------------------------------------

(1) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(2)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACK(s(x), 0) -> ACK(x, s(0))
   ACK(s(x), s(y)) -> ACK(x, ack(s(x), y))
   ACK(s(x), s(y)) -> ACK(s(x), y)
   INIT -> ACK(s(s(s(s(s(s(s(0))))))), 0)
   RUN_AGAIN(x) -> RUN_AGAIN(init)
   RUN_AGAIN(x) -> INIT

The TRS R consists of the following rules:

   ack(0, y) -> s(y)
   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   init -> ack(s(s(s(s(s(s(s(0))))))), 0)
   run_again(x) -> run_again(init)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)
   init
   run_again(x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(3) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 2 less nodes.
----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACK(s(x), s(y)) -> ACK(x, ack(s(x), y))
   ACK(s(x), s(y)) -> ACK(s(x), y)
   ACK(s(x), 0) -> ACK(x, s(0))

The TRS R consists of the following rules:

   ack(0, y) -> s(y)
   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   init -> ack(s(s(s(s(s(s(s(0))))))), 0)
   run_again(x) -> run_again(init)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)
   init
   run_again(x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(6) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(7)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACK(s(x), s(y)) -> ACK(x, ack(s(x), y))
   ACK(s(x), s(y)) -> ACK(s(x), y)
   ACK(s(x), 0) -> ACK(x, s(0))

The TRS R consists of the following rules:

   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(s(x), 0) -> ack(x, s(0))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)
   init
   run_again(x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(8) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   init
   run_again(x0)


----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACK(s(x), s(y)) -> ACK(x, ack(s(x), y))
   ACK(s(x), s(y)) -> ACK(s(x), y)
   ACK(s(x), 0) -> ACK(x, s(0))

The TRS R consists of the following rules:

   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(s(x), 0) -> ack(x, s(0))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(10) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*ACK(s(x), 0) -> ACK(x, s(0))
The graph contains the following edges 1 > 1


*ACK(s(x), s(y)) -> ACK(s(x), y)
The graph contains the following edges 1 >= 1, 2 > 2


*ACK(s(x), s(y)) -> ACK(x, ack(s(x), y))
The graph contains the following edges 1 > 1


----------------------------------------

(11)
YES

----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(init)

The TRS R consists of the following rules:

   ack(0, y) -> s(y)
   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   init -> ack(s(s(s(s(s(s(s(0))))))), 0)
   run_again(x) -> run_again(init)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)
   init
   run_again(x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(13) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(init)

The TRS R consists of the following rules:

   init -> ack(s(s(s(s(s(s(s(0))))))), 0)
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(s(x), 0) -> ack(x, s(0))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)
   init
   run_again(x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(15) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   run_again(x0)


----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(init)

The TRS R consists of the following rules:

   init -> ack(s(s(s(s(s(s(s(0))))))), 0)
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(s(x), 0) -> ack(x, s(0))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)
   init

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(17) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(init) at position [0] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(s(s(0))))))), 0)),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(s(s(0))))))), 0)))


----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(s(s(0))))))), 0))

The TRS R consists of the following rules:

   init -> ack(s(s(s(s(s(s(s(0))))))), 0)
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(s(x), 0) -> ack(x, s(0))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)
   init

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(19) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(s(s(0))))))), 0))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)
   init

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(21) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   init


----------------------------------------

(22)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(s(s(0))))))), 0))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(23) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(s(s(0))))))), 0)) at position [0] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(s(0)))))), s(0))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(s(0)))))), s(0))))


----------------------------------------

(24)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(s(0)))))), s(0)))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(25) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(s(0)))))), s(0))) at position [0] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(s(s(0)))))), 0))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(s(s(0)))))), 0))))


----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(s(s(0)))))), 0)))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(27) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(s(s(0)))))), 0))) at position [0,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(s(0))))), s(0)))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(s(0))))), s(0)))))


----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(s(0))))), s(0))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(29) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(s(0))))), s(0)))) at position [0,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(s(s(0))))), 0)))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(s(s(0))))), 0)))))


----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(s(s(0))))), 0))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(31) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(s(s(0))))), 0)))) at position [0,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(s(0)))), s(0))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(s(0)))), s(0))))))


----------------------------------------

(32)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(s(0)))), s(0)))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(33) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(s(0)))), s(0))))) at position [0,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(s(s(0)))), 0))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(s(s(0)))), 0))))))


----------------------------------------

(34)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(s(s(0)))), 0)))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(35) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(s(s(0)))), 0))))) at position [0,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(s(0))), s(0)))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(s(0))), s(0)))))))


----------------------------------------

(36)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(s(0))), s(0))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(37) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(s(0))), s(0)))))) at position [0,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(s(s(0))), 0)))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(s(s(0))), 0)))))))


----------------------------------------

(38)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(s(s(0))), 0))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(39) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(s(s(0))), 0)))))) at position [0,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(s(0)), s(0))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(s(0)), s(0))))))))


----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(s(0)), s(0)))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(41) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(s(0)), s(0))))))) at position [0,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), ack(s(s(0)), 0))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), ack(s(s(0)), 0))))))))


----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), ack(s(s(0)), 0)))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(43) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), ack(s(s(0)), 0))))))) at position [0,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), ack(s(0), s(0)))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), ack(s(0), s(0)))))))))


----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), ack(s(0), s(0))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(45) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), ack(s(0), s(0)))))))) at position [0,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), ack(0, ack(s(0), 0)))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), ack(0, ack(s(0), 0)))))))))


----------------------------------------

(46)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), ack(0, ack(s(0), 0))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(47) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), ack(0, ack(s(0), 0)))))))) at position [0,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), s(ack(s(0), 0)))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), s(ack(s(0), 0)))))))))


----------------------------------------

(48)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), s(ack(s(0), 0))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(49) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(s(0), s(ack(s(0), 0)))))))) at position [0,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(0, ack(s(0), ack(s(0), 0)))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(0, ack(s(0), ack(s(0), 0)))))))))


----------------------------------------

(50)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(0, ack(s(0), ack(s(0), 0))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(51) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), ack(0, ack(s(0), ack(s(0), 0)))))))) at position [0,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), s(ack(s(0), ack(s(0), 0)))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), s(ack(s(0), ack(s(0), 0)))))))))


----------------------------------------

(52)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), s(ack(s(0), ack(s(0), 0))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(53) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(s(0)), s(ack(s(0), ack(s(0), 0)))))))) at position [0,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(s(0), ack(s(0), 0)))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(s(0), ack(s(0), 0)))))))))


----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(s(0), ack(s(0), 0))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(55) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(s(0), ack(s(0), 0)))))))) at position [0,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(s(0), ack(0, s(0))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(s(0), ack(0, s(0))))))))))


----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(s(0), ack(0, s(0)))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(57) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(s(0), ack(0, s(0))))))))) at position [0,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(s(0), s(s(0))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(s(0), s(s(0))))))))))


----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(s(0), s(s(0)))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(59) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(s(0), s(s(0))))))))) at position [0,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(0, ack(s(0), s(0))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(0, ack(s(0), s(0))))))))))


----------------------------------------

(60)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(0, ack(s(0), s(0)))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(61) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), ack(0, ack(s(0), s(0))))))))) at position [0,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), s(ack(s(0), s(0))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), s(ack(s(0), s(0))))))))))


----------------------------------------

(62)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), s(ack(s(0), s(0)))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(63) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(s(0)), s(ack(s(0), s(0))))))))) at position [0,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(s(0)), ack(s(0), s(0))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(s(0)), ack(s(0), s(0))))))))))


----------------------------------------

(64)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(s(0)), ack(s(0), s(0)))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(65) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(s(0)), ack(s(0), s(0))))))))) at position [0,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(s(0)), ack(0, ack(s(0), 0))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(s(0)), ack(0, ack(s(0), 0))))))))))


----------------------------------------

(66)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(s(0)), ack(0, ack(s(0), 0)))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(67) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(s(0)), ack(0, ack(s(0), 0))))))))) at position [0,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(s(0)), s(ack(s(0), 0))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(s(0)), s(ack(s(0), 0))))))))))


----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(s(0)), s(ack(s(0), 0)))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(69) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(s(0)), s(ack(s(0), 0))))))))) at position [0,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), ack(s(0), 0))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), ack(s(0), 0))))))))))


----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), ack(s(0), 0)))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(71) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), ack(s(0), 0))))))))) at position [0,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), ack(0, s(0)))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), ack(0, s(0)))))))))))


----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), ack(0, s(0))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(73) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), ack(0, s(0)))))))))) at position [0,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), s(s(0)))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), s(s(0)))))))))))


----------------------------------------

(74)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), s(s(0))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(75) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), s(s(0)))))))))) at position [0,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), s(0)))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), s(0)))))))))))


----------------------------------------

(76)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), s(0))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(77) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), s(0)))))))))) at position [0,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), 0)))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), 0)))))))))))


----------------------------------------

(78)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), 0))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(79) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(s(0)), 0)))))))))) at position [0,1,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(0))))))))))))


----------------------------------------

(80)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(81) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(0))))))))))) at position [0,1,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), 0))))))))))))


----------------------------------------

(82)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(83) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), 0))))))))))) at position [0,1,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), 0))))))))))))


----------------------------------------

(84)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(85) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), 0))))))))))) at position [0,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), 0))))))))))))


----------------------------------------

(86)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(87) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), 0))))))))))) at position [0,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), 0))))))))))))


----------------------------------------

(88)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(89) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), 0))))))))))) at position [0,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), 0))))))))))))


----------------------------------------

(90)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(91) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), 0))))))))))) at position [0,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), ack(s(0), 0))))))))))))


----------------------------------------

(92)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(93) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), ack(s(0), 0))))))))))) at position [0,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))))


----------------------------------------

(94)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(95) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))) at position [0,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))))


----------------------------------------

(96)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(97) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))) at position [0,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))))


----------------------------------------

(98)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(99) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))) at position [0,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), s(ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), s(ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))))


----------------------------------------

(100)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), s(ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(101) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(s(0), s(ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))) at position [0,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(0, ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(0, ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))))


----------------------------------------

(102)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(0, ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(103) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), ack(0, ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))) at position [0,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), s(ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), s(ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))))


----------------------------------------

(104)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), s(ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(105) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(s(0))), s(ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))) at position [0,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))))


----------------------------------------

(106)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0)))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(107) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), 0))))))))))) at position [0,1,1,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, s(0)))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, s(0)))))))))))))


----------------------------------------

(108)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, s(0))))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(109) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, s(0)))))))))))) at position [0,1,1,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(s(0)))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(s(0)))))))))))))


----------------------------------------

(110)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(s(0))))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(111) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(s(0)))))))))))) at position [0,1,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), s(0)))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), s(0)))))))))))))


----------------------------------------

(112)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), s(0))))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(113) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), s(0)))))))))))) at position [0,1,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), s(0)))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), s(0)))))))))))))


----------------------------------------

(114)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), s(0))))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(115) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), s(0)))))))))))) at position [0,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), s(0)))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), s(0)))))))))))))


----------------------------------------

(116)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), s(0))))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(117) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), s(0)))))))))))) at position [0,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), s(0)))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), s(0)))))))))))))


----------------------------------------

(118)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), s(0))))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(119) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(s(0), s(ack(s(0), ack(s(0), s(0)))))))))))) at position [0,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), s(0)))))))))))),RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), s(0)))))))))))))


----------------------------------------

(120)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), s(0))))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(121) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule RUN_AGAIN(x) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(s(0), s(0)))))))))))) at position [0,1,1,1,1,1,1,1,1,1] we obtained the following new rules [LPAR04]:

   (RUN_AGAIN(y0) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(0, ack(s(0), 0)))))))))))),RUN_AGAIN(y0) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(0, ack(s(0), 0)))))))))))))


----------------------------------------

(122)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(y0) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(0, ack(s(0), 0))))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

The set Q consists of the following terms:

   ack(s(x0), 0)
   ack(s(x0), s(x1))
   ack(0, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(123) MNOCProof (EQUIVALENT)
We use the modular non-overlap check [FROCOS05] to decrease Q to the empty set.
----------------------------------------

(124)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RUN_AGAIN(y0) -> RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(0, ack(s(0), 0))))))))))))

The TRS R consists of the following rules:

   ack(s(x), 0) -> ack(x, s(0))
   ack(s(x), s(y)) -> ack(x, ack(s(x), y))
   ack(0, y) -> s(y)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(125) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = RUN_AGAIN(y0) evaluates to  t =RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(0, ack(s(0), 0))))))))))))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [y0 / ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(0, ack(s(0), 0)))))))))))]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from RUN_AGAIN(y0) to RUN_AGAIN(ack(s(s(s(s(s(0))))), ack(s(s(s(s(0)))), ack(s(s(0)), ack(s(s(s(0))), ack(s(0), ack(s(0), ack(0, ack(s(0), ack(s(0), ack(0, ack(s(0), 0)))))))))))).




----------------------------------------

(126)
NO
