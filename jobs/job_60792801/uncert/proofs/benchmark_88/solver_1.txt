YES
proof of /home/ff862203/input_KDRohjdGHV.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) DependencyPairsProof [EQUIVALENT, 0 ms]
(2) QDP
(3) DependencyGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) QDP
        (6) UsableRulesProof [EQUIVALENT, 0 ms]
        (7) QDP
        (8) QReductionProof [EQUIVALENT, 0 ms]
        (9) QDP
        (10) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (11) YES
    (12) QDP
        (13) UsableRulesProof [EQUIVALENT, 0 ms]
        (14) QDP
        (15) QReductionProof [EQUIVALENT, 0 ms]
        (16) QDP
        (17) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (18) YES
    (19) QDP
        (20) UsableRulesProof [EQUIVALENT, 0 ms]
        (21) QDP
        (22) QReductionProof [EQUIVALENT, 0 ms]
        (23) QDP
        (24) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (25) YES
    (26) QDP
        (27) UsableRulesProof [EQUIVALENT, 0 ms]
        (28) QDP
        (29) QReductionProof [EQUIVALENT, 0 ms]
        (30) QDP
        (31) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (32) YES
    (33) QDP
        (34) UsableRulesProof [EQUIVALENT, 0 ms]
        (35) QDP
        (36) QReductionProof [EQUIVALENT, 0 ms]
        (37) QDP
        (38) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (39) YES
    (40) QDP
        (41) UsableRulesProof [EQUIVALENT, 0 ms]
        (42) QDP
        (43) QReductionProof [EQUIVALENT, 0 ms]
        (44) QDP
        (45) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (46) YES
    (47) QDP
        (48) UsableRulesProof [EQUIVALENT, 0 ms]
        (49) QDP
        (50) QReductionProof [EQUIVALENT, 0 ms]
        (51) QDP
        (52) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (53) YES
    (54) QDP
        (55) UsableRulesProof [EQUIVALENT, 0 ms]
        (56) QDP
        (57) QReductionProof [EQUIVALENT, 0 ms]
        (58) QDP
        (59) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (60) YES
    (61) QDP
        (62) UsableRulesProof [EQUIVALENT, 0 ms]
        (63) QDP
        (64) QReductionProof [EQUIVALENT, 0 ms]
        (65) QDP
        (66) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (67) YES
    (68) QDP
        (69) UsableRulesProof [EQUIVALENT, 0 ms]
        (70) QDP
        (71) QReductionProof [EQUIVALENT, 0 ms]
        (72) QDP
        (73) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (74) YES
    (75) QDP
        (76) UsableRulesProof [EQUIVALENT, 0 ms]
        (77) QDP
        (78) QReductionProof [EQUIVALENT, 0 ms]
        (79) QDP
        (80) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (81) YES
    (82) QDP
        (83) UsableRulesProof [EQUIVALENT, 0 ms]
        (84) QDP
        (85) QReductionProof [EQUIVALENT, 0 ms]
        (86) QDP
        (87) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (88) YES
    (89) QDP
        (90) QDPQMonotonicMRRProof [EQUIVALENT, 159 ms]
        (91) QDP
        (92) QDPQMonotonicMRRProof [EQUIVALENT, 105 ms]
        (93) QDP
        (94) QDPQMonotonicMRRProof [EQUIVALENT, 78 ms]
        (95) QDP
        (96) QDPOrderProof [EQUIVALENT, 264 ms]
        (97) QDP
        (98) QDPOrderProof [EQUIVALENT, 251 ms]
        (99) QDP
        (100) QDPOrderProof [EQUIVALENT, 273 ms]
        (101) QDP
        (102) QDPOrderProof [EQUIVALENT, 252 ms]
        (103) QDP
        (104) QDPQMonotonicMRRProof [EQUIVALENT, 77 ms]
        (105) QDP
        (106) QDPOrderProof [EQUIVALENT, 153 ms]
        (107) QDP
        (108) QDPOrderProof [EQUIVALENT, 237 ms]
        (109) QDP
        (110) QDPOrderProof [EQUIVALENT, 192 ms]
        (111) QDP
        (112) QDPOrderProof [EQUIVALENT, 184 ms]
        (113) QDP
        (114) QDPOrderProof [EQUIVALENT, 229 ms]
        (115) QDP
        (116) DependencyGraphProof [EQUIVALENT, 0 ms]
        (117) QDP
        (118) QDPQMonotonicMRRProof [EQUIVALENT, 31 ms]
        (119) QDP
        (120) QDPOrderProof [EQUIVALENT, 198 ms]
        (121) QDP
        (122) QDPOrderProof [EQUIVALENT, 238 ms]
        (123) QDP
        (124) QDPQMonotonicMRRProof [EQUIVALENT, 28 ms]
        (125) QDP
        (126) QDPOrderProof [EQUIVALENT, 249 ms]
        (127) QDP
        (128) QDPOrderProof [EQUIVALENT, 0 ms]
        (129) QDP
        (130) QDPOrderProof [EQUIVALENT, 0 ms]
        (131) QDP
        (132) QDPQMonotonicMRRProof [EQUIVALENT, 26 ms]
        (133) QDP
        (134) QDPOrderProof [EQUIVALENT, 219 ms]
        (135) QDP
        (136) QDPQMonotonicMRRProof [EQUIVALENT, 0 ms]
        (137) QDP
        (138) QDPQMonotonicMRRProof [EQUIVALENT, 29 ms]
        (139) QDP
        (140) QDPOrderProof [EQUIVALENT, 153 ms]
        (141) QDP
        (142) PisEmptyProof [EQUIVALENT, 0 ms]
        (143) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))


----------------------------------------

(1) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(2)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   ACTIVE(from(X)) -> CONS(X, from(s(X)))
   ACTIVE(from(X)) -> FROM(s(X))
   ACTIVE(from(X)) -> S(X)
   ACTIVE(2ndspos(0, Z)) -> MARK(rnil)
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> RCONS(posrecip(Y), 2ndsneg(N, Z))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> POSRECIP(Y)
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> 2NDSNEG(N, Z)
   ACTIVE(2ndsneg(0, Z)) -> MARK(rnil)
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> RCONS(negrecip(Y), 2ndspos(N, Z))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> NEGRECIP(Y)
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> 2NDSPOS(N, Z)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   ACTIVE(pi(X)) -> 2NDSPOS(X, from(0))
   ACTIVE(pi(X)) -> FROM(0)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(plus(s(X), Y)) -> S(plus(X, Y))
   ACTIVE(plus(s(X), Y)) -> PLUS(X, Y)
   ACTIVE(times(0, Y)) -> MARK(0)
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   ACTIVE(times(s(X), Y)) -> PLUS(Y, times(X, Y))
   ACTIVE(times(s(X), Y)) -> TIMES(X, Y)
   ACTIVE(square(X)) -> MARK(times(X, X))
   ACTIVE(square(X)) -> TIMES(X, X)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   MARK(from(X)) -> FROM(mark(X))
   MARK(from(X)) -> MARK(X)
   MARK(cons(X1, X2)) -> ACTIVE(cons(mark(X1), X2))
   MARK(cons(X1, X2)) -> CONS(mark(X1), X2)
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> ACTIVE(s(mark(X)))
   MARK(s(X)) -> S(mark(X))
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   MARK(2ndspos(X1, X2)) -> 2NDSPOS(mark(X1), mark(X2))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(0) -> ACTIVE(0)
   MARK(rnil) -> ACTIVE(rnil)
   MARK(rcons(X1, X2)) -> ACTIVE(rcons(mark(X1), mark(X2)))
   MARK(rcons(X1, X2)) -> RCONS(mark(X1), mark(X2))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(posrecip(X)) -> ACTIVE(posrecip(mark(X)))
   MARK(posrecip(X)) -> POSRECIP(mark(X))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> 2NDSNEG(mark(X1), mark(X2))
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> ACTIVE(negrecip(mark(X)))
   MARK(negrecip(X)) -> NEGRECIP(mark(X))
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> PI(mark(X))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> PLUS(mark(X1), mark(X2))
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> TIMES(mark(X1), mark(X2))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))
   MARK(square(X)) -> SQUARE(mark(X))
   MARK(square(X)) -> MARK(X)
   FROM(mark(X)) -> FROM(X)
   FROM(active(X)) -> FROM(X)
   CONS(mark(X1), X2) -> CONS(X1, X2)
   CONS(X1, mark(X2)) -> CONS(X1, X2)
   CONS(active(X1), X2) -> CONS(X1, X2)
   CONS(X1, active(X2)) -> CONS(X1, X2)
   S(mark(X)) -> S(X)
   S(active(X)) -> S(X)
   2NDSPOS(mark(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(X1, mark(X2)) -> 2NDSPOS(X1, X2)
   2NDSPOS(active(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(X1, active(X2)) -> 2NDSPOS(X1, X2)
   RCONS(mark(X1), X2) -> RCONS(X1, X2)
   RCONS(X1, mark(X2)) -> RCONS(X1, X2)
   RCONS(active(X1), X2) -> RCONS(X1, X2)
   RCONS(X1, active(X2)) -> RCONS(X1, X2)
   POSRECIP(mark(X)) -> POSRECIP(X)
   POSRECIP(active(X)) -> POSRECIP(X)
   2NDSNEG(mark(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(X1, mark(X2)) -> 2NDSNEG(X1, X2)
   2NDSNEG(active(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(X1, active(X2)) -> 2NDSNEG(X1, X2)
   NEGRECIP(mark(X)) -> NEGRECIP(X)
   NEGRECIP(active(X)) -> NEGRECIP(X)
   PI(mark(X)) -> PI(X)
   PI(active(X)) -> PI(X)
   PLUS(mark(X1), X2) -> PLUS(X1, X2)
   PLUS(X1, mark(X2)) -> PLUS(X1, X2)
   PLUS(active(X1), X2) -> PLUS(X1, X2)
   PLUS(X1, active(X2)) -> PLUS(X1, X2)
   TIMES(mark(X1), X2) -> TIMES(X1, X2)
   TIMES(X1, mark(X2)) -> TIMES(X1, X2)
   TIMES(active(X1), X2) -> TIMES(X1, X2)
   TIMES(X1, active(X2)) -> TIMES(X1, X2)
   SQUARE(mark(X)) -> SQUARE(X)
   SQUARE(active(X)) -> SQUARE(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(3) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 13 SCCs with 33 less nodes.
----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SQUARE(active(X)) -> SQUARE(X)
   SQUARE(mark(X)) -> SQUARE(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(6) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(7)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SQUARE(active(X)) -> SQUARE(X)
   SQUARE(mark(X)) -> SQUARE(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(8) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(active(x0))
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SQUARE(active(X)) -> SQUARE(X)
   SQUARE(mark(X)) -> SQUARE(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   mark(times(x0, x1))
   active(square(x0))
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   active(pi(x0))
   active(from(x0))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(10) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*SQUARE(active(X)) -> SQUARE(X)
The graph contains the following edges 1 > 1


*SQUARE(mark(X)) -> SQUARE(X)
The graph contains the following edges 1 > 1


----------------------------------------

(11)
YES

----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TIMES(X1, mark(X2)) -> TIMES(X1, X2)
   TIMES(mark(X1), X2) -> TIMES(X1, X2)
   TIMES(active(X1), X2) -> TIMES(X1, X2)
   TIMES(X1, active(X2)) -> TIMES(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(13) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TIMES(X1, mark(X2)) -> TIMES(X1, X2)
   TIMES(mark(X1), X2) -> TIMES(X1, X2)
   TIMES(active(X1), X2) -> TIMES(X1, X2)
   TIMES(X1, active(X2)) -> TIMES(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(15) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(active(x0))
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TIMES(X1, mark(X2)) -> TIMES(X1, X2)
   TIMES(mark(X1), X2) -> TIMES(X1, X2)
   TIMES(active(X1), X2) -> TIMES(X1, X2)
   TIMES(X1, active(X2)) -> TIMES(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   mark(times(x0, x1))
   active(square(x0))
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   active(pi(x0))
   active(from(x0))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(17) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*TIMES(X1, mark(X2)) -> TIMES(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*TIMES(mark(X1), X2) -> TIMES(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*TIMES(active(X1), X2) -> TIMES(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*TIMES(X1, active(X2)) -> TIMES(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(18)
YES

----------------------------------------

(19)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PLUS(X1, mark(X2)) -> PLUS(X1, X2)
   PLUS(mark(X1), X2) -> PLUS(X1, X2)
   PLUS(active(X1), X2) -> PLUS(X1, X2)
   PLUS(X1, active(X2)) -> PLUS(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(20) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(21)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PLUS(X1, mark(X2)) -> PLUS(X1, X2)
   PLUS(mark(X1), X2) -> PLUS(X1, X2)
   PLUS(active(X1), X2) -> PLUS(X1, X2)
   PLUS(X1, active(X2)) -> PLUS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(22) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(active(x0))
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(23)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PLUS(X1, mark(X2)) -> PLUS(X1, X2)
   PLUS(mark(X1), X2) -> PLUS(X1, X2)
   PLUS(active(X1), X2) -> PLUS(X1, X2)
   PLUS(X1, active(X2)) -> PLUS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   mark(times(x0, x1))
   active(square(x0))
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   active(pi(x0))
   active(from(x0))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(24) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*PLUS(X1, mark(X2)) -> PLUS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*PLUS(mark(X1), X2) -> PLUS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*PLUS(active(X1), X2) -> PLUS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*PLUS(X1, active(X2)) -> PLUS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(25)
YES

----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PI(active(X)) -> PI(X)
   PI(mark(X)) -> PI(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(27) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PI(active(X)) -> PI(X)
   PI(mark(X)) -> PI(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(29) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(active(x0))
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PI(active(X)) -> PI(X)
   PI(mark(X)) -> PI(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   mark(times(x0, x1))
   active(square(x0))
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   active(pi(x0))
   active(from(x0))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(31) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*PI(active(X)) -> PI(X)
The graph contains the following edges 1 > 1


*PI(mark(X)) -> PI(X)
The graph contains the following edges 1 > 1


----------------------------------------

(32)
YES

----------------------------------------

(33)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   NEGRECIP(active(X)) -> NEGRECIP(X)
   NEGRECIP(mark(X)) -> NEGRECIP(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(34) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(35)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   NEGRECIP(active(X)) -> NEGRECIP(X)
   NEGRECIP(mark(X)) -> NEGRECIP(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(36) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(active(x0))
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(37)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   NEGRECIP(active(X)) -> NEGRECIP(X)
   NEGRECIP(mark(X)) -> NEGRECIP(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   mark(times(x0, x1))
   active(square(x0))
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   active(pi(x0))
   active(from(x0))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(38) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*NEGRECIP(active(X)) -> NEGRECIP(X)
The graph contains the following edges 1 > 1


*NEGRECIP(mark(X)) -> NEGRECIP(X)
The graph contains the following edges 1 > 1


----------------------------------------

(39)
YES

----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   2NDSNEG(X1, mark(X2)) -> 2NDSNEG(X1, X2)
   2NDSNEG(mark(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(active(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(X1, active(X2)) -> 2NDSNEG(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(41) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   2NDSNEG(X1, mark(X2)) -> 2NDSNEG(X1, X2)
   2NDSNEG(mark(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(active(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(X1, active(X2)) -> 2NDSNEG(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(43) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(active(x0))
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   2NDSNEG(X1, mark(X2)) -> 2NDSNEG(X1, X2)
   2NDSNEG(mark(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(active(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(X1, active(X2)) -> 2NDSNEG(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   mark(times(x0, x1))
   active(square(x0))
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   active(pi(x0))
   active(from(x0))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(45) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*2NDSNEG(X1, mark(X2)) -> 2NDSNEG(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*2NDSNEG(mark(X1), X2) -> 2NDSNEG(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*2NDSNEG(active(X1), X2) -> 2NDSNEG(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*2NDSNEG(X1, active(X2)) -> 2NDSNEG(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(46)
YES

----------------------------------------

(47)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   POSRECIP(active(X)) -> POSRECIP(X)
   POSRECIP(mark(X)) -> POSRECIP(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(48) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(49)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   POSRECIP(active(X)) -> POSRECIP(X)
   POSRECIP(mark(X)) -> POSRECIP(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(50) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(active(x0))
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(51)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   POSRECIP(active(X)) -> POSRECIP(X)
   POSRECIP(mark(X)) -> POSRECIP(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   mark(times(x0, x1))
   active(square(x0))
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   active(pi(x0))
   active(from(x0))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(52) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*POSRECIP(active(X)) -> POSRECIP(X)
The graph contains the following edges 1 > 1


*POSRECIP(mark(X)) -> POSRECIP(X)
The graph contains the following edges 1 > 1


----------------------------------------

(53)
YES

----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RCONS(X1, mark(X2)) -> RCONS(X1, X2)
   RCONS(mark(X1), X2) -> RCONS(X1, X2)
   RCONS(active(X1), X2) -> RCONS(X1, X2)
   RCONS(X1, active(X2)) -> RCONS(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(55) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RCONS(X1, mark(X2)) -> RCONS(X1, X2)
   RCONS(mark(X1), X2) -> RCONS(X1, X2)
   RCONS(active(X1), X2) -> RCONS(X1, X2)
   RCONS(X1, active(X2)) -> RCONS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(57) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(active(x0))
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RCONS(X1, mark(X2)) -> RCONS(X1, X2)
   RCONS(mark(X1), X2) -> RCONS(X1, X2)
   RCONS(active(X1), X2) -> RCONS(X1, X2)
   RCONS(X1, active(X2)) -> RCONS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   mark(times(x0, x1))
   active(square(x0))
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   active(pi(x0))
   active(from(x0))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(59) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*RCONS(X1, mark(X2)) -> RCONS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*RCONS(mark(X1), X2) -> RCONS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*RCONS(active(X1), X2) -> RCONS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*RCONS(X1, active(X2)) -> RCONS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(60)
YES

----------------------------------------

(61)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   2NDSPOS(X1, mark(X2)) -> 2NDSPOS(X1, X2)
   2NDSPOS(mark(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(active(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(X1, active(X2)) -> 2NDSPOS(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(62) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(63)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   2NDSPOS(X1, mark(X2)) -> 2NDSPOS(X1, X2)
   2NDSPOS(mark(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(active(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(X1, active(X2)) -> 2NDSPOS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(64) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(active(x0))
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(65)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   2NDSPOS(X1, mark(X2)) -> 2NDSPOS(X1, X2)
   2NDSPOS(mark(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(active(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(X1, active(X2)) -> 2NDSPOS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   mark(times(x0, x1))
   active(square(x0))
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   active(pi(x0))
   active(from(x0))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(66) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*2NDSPOS(X1, mark(X2)) -> 2NDSPOS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*2NDSPOS(mark(X1), X2) -> 2NDSPOS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*2NDSPOS(active(X1), X2) -> 2NDSPOS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*2NDSPOS(X1, active(X2)) -> 2NDSPOS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(67)
YES

----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S(active(X)) -> S(X)
   S(mark(X)) -> S(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(69) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S(active(X)) -> S(X)
   S(mark(X)) -> S(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(71) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(active(x0))
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S(active(X)) -> S(X)
   S(mark(X)) -> S(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   mark(times(x0, x1))
   active(square(x0))
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   active(pi(x0))
   active(from(x0))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(73) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*S(active(X)) -> S(X)
The graph contains the following edges 1 > 1


*S(mark(X)) -> S(X)
The graph contains the following edges 1 > 1


----------------------------------------

(74)
YES

----------------------------------------

(75)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   CONS(X1, mark(X2)) -> CONS(X1, X2)
   CONS(mark(X1), X2) -> CONS(X1, X2)
   CONS(active(X1), X2) -> CONS(X1, X2)
   CONS(X1, active(X2)) -> CONS(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(76) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(77)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   CONS(X1, mark(X2)) -> CONS(X1, X2)
   CONS(mark(X1), X2) -> CONS(X1, X2)
   CONS(active(X1), X2) -> CONS(X1, X2)
   CONS(X1, active(X2)) -> CONS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(78) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(active(x0))
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(79)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   CONS(X1, mark(X2)) -> CONS(X1, X2)
   CONS(mark(X1), X2) -> CONS(X1, X2)
   CONS(active(X1), X2) -> CONS(X1, X2)
   CONS(X1, active(X2)) -> CONS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   mark(times(x0, x1))
   active(square(x0))
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   active(pi(x0))
   active(from(x0))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(80) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*CONS(X1, mark(X2)) -> CONS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*CONS(mark(X1), X2) -> CONS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*CONS(active(X1), X2) -> CONS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*CONS(X1, active(X2)) -> CONS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(81)
YES

----------------------------------------

(82)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FROM(active(X)) -> FROM(X)
   FROM(mark(X)) -> FROM(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(83) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(84)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FROM(active(X)) -> FROM(X)
   FROM(mark(X)) -> FROM(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(85) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(active(x0))
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(86)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FROM(active(X)) -> FROM(X)
   FROM(mark(X)) -> FROM(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   mark(times(x0, x1))
   active(square(x0))
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   active(pi(x0))
   active(from(x0))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(87) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*FROM(active(X)) -> FROM(X)
The graph contains the following edges 1 > 1


*FROM(mark(X)) -> FROM(X)
The graph contains the following edges 1 > 1


----------------------------------------

(88)
YES

----------------------------------------

(89)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MARK(cons(X1, X2)) -> ACTIVE(cons(mark(X1), X2))
   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   MARK(rcons(X1, X2)) -> ACTIVE(rcons(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   MARK(s(X)) -> ACTIVE(s(mark(X)))
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(posrecip(X)) -> ACTIVE(posrecip(mark(X)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(square(X)) -> MARK(times(X, X))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> ACTIVE(negrecip(mark(X)))
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))
   MARK(square(X)) -> MARK(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(90) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(rcons(X1, X2)) -> ACTIVE(rcons(mark(X1), mark(X2)))
   MARK(s(X)) -> ACTIVE(s(mark(X)))
   MARK(negrecip(X)) -> ACTIVE(negrecip(mark(X)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = x_1
   POL(MARK(x_1)) = 1
   POL(active(x_1)) = 0
   POL(cons(x_1, x_2)) = 1
   POL(from(x_1)) = 1
   POL(mark(x_1)) = 0
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 1
   POL(plus(x_1, x_2)) = 1
   POL(posrecip(x_1)) = 1
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 1
   POL(times(x_1, x_2)) = 1


----------------------------------------

(91)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MARK(cons(X1, X2)) -> ACTIVE(cons(mark(X1), X2))
   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(posrecip(X)) -> ACTIVE(posrecip(mark(X)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(square(X)) -> MARK(times(X, X))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))
   MARK(square(X)) -> MARK(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(92) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(cons(X1, X2)) -> ACTIVE(cons(mark(X1), X2))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = x_1
   POL(MARK(x_1)) = 1
   POL(active(x_1)) = 0
   POL(cons(x_1, x_2)) = 0
   POL(from(x_1)) = 1
   POL(mark(x_1)) = 0
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 1
   POL(plus(x_1, x_2)) = 1
   POL(posrecip(x_1)) = 1
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 1
   POL(times(x_1, x_2)) = 1


----------------------------------------

(93)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(posrecip(X)) -> ACTIVE(posrecip(mark(X)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(square(X)) -> MARK(times(X, X))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))
   MARK(square(X)) -> MARK(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(94) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(posrecip(X)) -> ACTIVE(posrecip(mark(X)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = x_1
   POL(MARK(x_1)) = 1
   POL(active(x_1)) = 2*x_1
   POL(cons(x_1, x_2)) = 0
   POL(from(x_1)) = 1
   POL(mark(x_1)) = 2
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 1
   POL(plus(x_1, x_2)) = 1
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 1
   POL(times(x_1, x_2)) = 1


----------------------------------------

(95)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(square(X)) -> MARK(times(X, X))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))
   MARK(square(X)) -> MARK(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(96) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(square(X)) -> MARK(X)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(square(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(active(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)


----------------------------------------

(97)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(square(X)) -> MARK(times(X, X))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(98) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(2ndsneg(X1, X2)) -> MARK(X1)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[2A]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(square(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)


----------------------------------------

(99)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(square(X)) -> MARK(times(X, X))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(100) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(from(X)) -> MARK(X)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(square(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)


----------------------------------------

(101)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(square(X)) -> MARK(times(X, X))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(102) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ACTIVE(square(X)) -> MARK(times(X, X))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[3A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[3A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(square(x_1)) =  	[[4A]] 	 +  	[[2A]] 	* 	x_1
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)


----------------------------------------

(103)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(104) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(square(X)) -> ACTIVE(square(mark(X)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = x_1
   POL(MARK(x_1)) = 1
   POL(active(x_1)) = 0
   POL(cons(x_1, x_2)) = 0
   POL(from(x_1)) = 1
   POL(mark(x_1)) = 0
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 1
   POL(plus(x_1, x_2)) = 1
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 0
   POL(times(x_1, x_2)) = 1


----------------------------------------

(105)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(106) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(times(X1, X2)) -> MARK(X1)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[3A]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[3A]] 	 +  	[[2A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(107)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(108) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[1A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[1A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(109)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(110) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(plus(X1, X2)) -> MARK(X1)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[0A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[-I]] 	 +  	[[2A]] 	* 	x_1 	 +  	[[1A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[0A]] 	 +  	[[3A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(111)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(112) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(times(X1, X2)) -> MARK(X2)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[2A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[1A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[2A]] 	 +  	[[2A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(113)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(114) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(cons(X1, X2)) -> MARK(X1)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[0A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[-I]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(115)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(116) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(117)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(pi(X)) -> MARK(X)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(118) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(from(X)) -> ACTIVE(from(mark(X)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = x_1
   POL(MARK(x_1)) = 1
   POL(active(x_1)) = 0
   POL(cons(x_1, x_2)) = 0
   POL(from(x_1)) = 0
   POL(mark(x_1)) = 0
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 1
   POL(plus(x_1, x_2)) = 1
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 0
   POL(times(x_1, x_2)) = 1


----------------------------------------

(119)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(pi(X)) -> MARK(X)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(120) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(pi(X)) -> MARK(X)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(MARK(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[-I]] 	 +  	[[3A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[-I]] 	 +  	[[4A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(121)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(122) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(MARK(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[3A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[-I]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(123)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(124) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(pi(X)) -> ACTIVE(pi(mark(X)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = x_1
   POL(MARK(x_1)) = 1
   POL(active(x_1)) = 0
   POL(cons(x_1, x_2)) = 0
   POL(from(x_1)) = 0
   POL(mark(x_1)) = 0
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 0
   POL(plus(x_1, x_2)) = 1
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 0
   POL(times(x_1, x_2)) = 1


----------------------------------------

(125)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(negrecip(X)) -> MARK(X)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(126) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(rcons(X1, X2)) -> MARK(X1)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(MARK(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[-I]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(127)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(negrecip(X)) -> MARK(X)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(128) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(negrecip(X)) -> MARK(X)
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
ACTIVE(x1)  =  x1

2ndspos(x1, x2)  =  x1

s(x1)  =  x1

MARK(x1)  =  x1

rcons(x1, x2)  =  x2

2ndsneg(x1, x2)  =  x1

mark(x1)  =  x1

posrecip(x1)  =  x1

plus(x1, x2)  =  x2

negrecip(x1)  =  negrecip(x1)

times(x1, x2)  =  times

cons(x1, x2)  =  cons

active(x1)  =  x1

from(x1)  =  from

pi(x1)  =  x1

square(x1)  =  square

0  =  0

rnil  =  rnil


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   negrecip_1=1
   rnil=1
   0=2
   cons=2
   square=4
   from=3
   times=3

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(129)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(130) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(posrecip(X)) -> MARK(X)
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
ACTIVE(x1)  =  x1

2ndspos(x1, x2)  =  x1

s(x1)  =  x1

MARK(x1)  =  x1

rcons(x1, x2)  =  x2

2ndsneg(x1, x2)  =  x1

mark(x1)  =  x1

posrecip(x1)  =  posrecip(x1)

plus(x1, x2)  =  x2

times(x1, x2)  =  times

cons(x1, x2)  =  cons

active(x1)  =  x1

from(x1)  =  from

pi(x1)  =  x1

square(x1)  =  square

negrecip(x1)  =  negrecip

0  =  0

rnil  =  rnil


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   negrecip=1
   rnil=2
   0=3
   cons=2
   square=5
   posrecip_1=1
   from=3
   times=4

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(131)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(132) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(2ndspos(X1, X2)) -> MARK(X1)


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1 + 2*x_1
   POL(2ndspos(x_1, x_2)) = 1 + 2*x_1
   POL(ACTIVE(x_1)) = 2*x_1
   POL(MARK(x_1)) = 2*x_1
   POL(active(x_1)) = x_1
   POL(cons(x_1, x_2)) = 0
   POL(from(x_1)) = 0
   POL(mark(x_1)) = x_1
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 1 + 2*x_1
   POL(plus(x_1, x_2)) = 2*x_2
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = x_2
   POL(rnil) = 0
   POL(s(x_1)) = x_1
   POL(square(x_1)) = 2
   POL(times(x_1, x_2)) = 0


----------------------------------------

(133)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(134) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(s(X)) -> MARK(X)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> MARK(X2)
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
ACTIVE(x1)  =  ACTIVE(x1)

2ndspos(x1, x2)  =  2ndspos

s(x1)  =  s(x1)

cons(x1, x2)  =  x2

MARK(x1)  =  MARK(x1)

rcons(x1, x2)  =  x2

posrecip(x1)  =  posrecip

2ndsneg(x1, x2)  =  2ndsneg

negrecip(x1)  =  negrecip(x1)

mark(x1)  =  x1

plus(x1, x2)  =  plus(x1, x2)

0  =  0

times(x1, x2)  =  times(x1, x2)

active(x1)  =  x1

from(x1)  =  from

pi(x1)  =  pi

square(x1)  =  square(x1)

rnil  =  rnil


Recursive path order with status [RPO].
Quasi-Precedence: [2ndspos, 2ndsneg, 0, pi] > [ACTIVE_1, MARK_1, times_2] > posrecip
[2ndspos, 2ndsneg, 0, pi] > [ACTIVE_1, MARK_1, times_2] > negrecip_1
[2ndspos, 2ndsneg, 0, pi] > [ACTIVE_1, MARK_1, times_2] > plus_2 > [s_1, from]
[2ndspos, 2ndsneg, 0, pi] > rnil
square_1 > [ACTIVE_1, MARK_1, times_2] > posrecip
square_1 > [ACTIVE_1, MARK_1, times_2] > negrecip_1
square_1 > [ACTIVE_1, MARK_1, times_2] > plus_2 > [s_1, from]

Status: ACTIVE_1: [1]
2ndspos: []
s_1: multiset status
MARK_1: [1]
posrecip: multiset status
2ndsneg: []
negrecip_1: multiset status
plus_2: [2,1]
0: multiset status
times_2: [1,2]
from: []
pi: []
square_1: multiset status
rnil: multiset status


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(135)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(136) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = 2*x_1
   POL(MARK(x_1)) = 2
   POL(active(x_1)) = 0
   POL(cons(x_1, x_2)) = 0
   POL(from(x_1)) = 0
   POL(mark(x_1)) = 0
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 0
   POL(plus(x_1, x_2)) = 0
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 0
   POL(times(x_1, x_2)) = 1


----------------------------------------

(137)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(138) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = 2*x_1
   POL(MARK(x_1)) = 2
   POL(active(x_1)) = 0
   POL(cons(x_1, x_2)) = 0
   POL(from(x_1)) = 0
   POL(mark(x_1)) = 0
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 0
   POL(plus(x_1, x_2)) = 0
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 0
   POL(times(x_1, x_2)) = 0


----------------------------------------

(139)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(140) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ACTIVE(2ndspos(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
ACTIVE(x1)  =  x1

2ndspos(x1, x2)  =  x1

s(x1)  =  s(x1)

cons(x1, x2)  =  x2

MARK(x1)  =  MARK(x1)

rcons(x1, x2)  =  rcons(x1, x2)

posrecip(x1)  =  posrecip

2ndsneg(x1, x2)  =  x1

negrecip(x1)  =  negrecip

mark(x1)  =  x1

active(x1)  =  x1

from(x1)  =  from

pi(x1)  =  pi(x1)

0  =  0

plus(x1, x2)  =  plus(x1, x2)

times(x1, x2)  =  times(x1, x2)

square(x1)  =  square(x1)

rnil  =  rnil


Recursive path order with status [RPO].
Quasi-Precedence: from > s_1 > [MARK_1, rcons_2]
from > s_1 > posrecip
from > s_1 > negrecip
[0, rnil]
square_1 > times_2 > plus_2 > s_1 > [MARK_1, rcons_2]
square_1 > times_2 > plus_2 > s_1 > posrecip
square_1 > times_2 > plus_2 > s_1 > negrecip

Status: s_1: [1]
MARK_1: multiset status
rcons_2: [1,2]
posrecip: multiset status
negrecip: multiset status
from: []
pi_1: [1]
0: multiset status
plus_2: [1,2]
times_2: [1,2]
square_1: [1]
rnil: multiset status


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(141)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   from(active(x0))
   active(2ndspos(s(x0), cons(x1, cons(x2, x3))))
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   active(2ndsneg(s(x0), cons(x1, cons(x2, x3))))
   2ndspos(x0, active(x1))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(142) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(143)
YES
