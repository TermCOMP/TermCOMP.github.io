YES
proof of /home/ff862203/input_JjlARx4yPr.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) QTRSRRRProof [EQUIVALENT, 153 ms]
(2) QTRS
(3) QTRSRRRProof [EQUIVALENT, 43 ms]
(4) QTRS
(5) QTRSRRRProof [EQUIVALENT, 32 ms]
(6) QTRS
(7) QTRSRRRProof [EQUIVALENT, 60 ms]
(8) QTRS
(9) QTRSRRRProof [EQUIVALENT, 28 ms]
(10) QTRS
(11) QTRSRRRProof [EQUIVALENT, 18 ms]
(12) QTRS
(13) QTRSRRRProof [EQUIVALENT, 78 ms]
(14) QTRS
(15) QTRSRRRProof [EQUIVALENT, 25 ms]
(16) QTRS
(17) QTRSRRRProof [EQUIVALENT, 17 ms]
(18) QTRS
(19) QTRSRRRProof [EQUIVALENT, 11 ms]
(20) QTRS
(21) QTRSRRRProof [EQUIVALENT, 1 ms]
(22) QTRS
(23) QTRSRRRProof [EQUIVALENT, 0 ms]
(24) QTRS
(25) QTRSRRRProof [EQUIVALENT, 0 ms]
(26) QTRS
(27) QTRSRRRProof [EQUIVALENT, 3 ms]
(28) QTRS
(29) QTRSRRRProof [EQUIVALENT, 0 ms]
(30) QTRS
(31) RisEmptyProof [EQUIVALENT, 0 ms]
(32) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(__(__(X, Y), Z)) -> mark(__(X, __(Y, Z)))
   active(__(X, nil)) -> mark(X)
   active(__(nil, X)) -> mark(X)
   active(U11(tt)) -> mark(tt)
   active(U21(tt, V2)) -> mark(U22(isList(V2)))
   active(U22(tt)) -> mark(tt)
   active(U31(tt)) -> mark(tt)
   active(U41(tt, V2)) -> mark(U42(isNeList(V2)))
   active(U42(tt)) -> mark(tt)
   active(U51(tt, V2)) -> mark(U52(isList(V2)))
   active(U52(tt)) -> mark(tt)
   active(U61(tt)) -> mark(tt)
   active(U71(tt, P)) -> mark(U72(isPal(P)))
   active(U72(tt)) -> mark(tt)
   active(U81(tt)) -> mark(tt)
   active(isList(V)) -> mark(U11(isNeList(V)))
   active(isList(nil)) -> mark(tt)
   active(isList(__(V1, V2))) -> mark(U21(isList(V1), V2))
   active(isNeList(V)) -> mark(U31(isQid(V)))
   active(isNeList(__(V1, V2))) -> mark(U41(isList(V1), V2))
   active(isNeList(__(V1, V2))) -> mark(U51(isNeList(V1), V2))
   active(isNePal(V)) -> mark(U61(isQid(V)))
   active(isNePal(__(I, __(P, I)))) -> mark(U71(isQid(I), P))
   active(isPal(V)) -> mark(U81(isNePal(V)))
   active(isPal(nil)) -> mark(tt)
   active(isQid(a)) -> mark(tt)
   active(isQid(e)) -> mark(tt)
   active(isQid(i)) -> mark(tt)
   active(isQid(o)) -> mark(tt)
   active(isQid(u)) -> mark(tt)
   mark(__(X1, X2)) -> active(__(mark(X1), mark(X2)))
   mark(nil) -> active(nil)
   mark(U11(X)) -> active(U11(mark(X)))
   mark(tt) -> active(tt)
   mark(U21(X1, X2)) -> active(U21(mark(X1), X2))
   mark(U22(X)) -> active(U22(mark(X)))
   mark(isList(X)) -> active(isList(X))
   mark(U31(X)) -> active(U31(mark(X)))
   mark(U41(X1, X2)) -> active(U41(mark(X1), X2))
   mark(U42(X)) -> active(U42(mark(X)))
   mark(isNeList(X)) -> active(isNeList(X))
   mark(U51(X1, X2)) -> active(U51(mark(X1), X2))
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(U71(X1, X2)) -> active(U71(mark(X1), X2))
   mark(U72(X)) -> active(U72(mark(X)))
   mark(isPal(X)) -> active(isPal(X))
   mark(U81(X)) -> active(U81(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(isNePal(X)) -> active(isNePal(X))
   mark(a) -> active(a)
   mark(e) -> active(e)
   mark(i) -> active(i)
   mark(o) -> active(o)
   mark(u) -> active(u)
   __(mark(X1), X2) -> __(X1, X2)
   __(X1, mark(X2)) -> __(X1, X2)
   __(active(X1), X2) -> __(X1, X2)
   __(X1, active(X2)) -> __(X1, X2)
   U11(mark(X)) -> U11(X)
   U11(active(X)) -> U11(X)
   U21(mark(X1), X2) -> U21(X1, X2)
   U21(X1, mark(X2)) -> U21(X1, X2)
   U21(active(X1), X2) -> U21(X1, X2)
   U21(X1, active(X2)) -> U21(X1, X2)
   U22(mark(X)) -> U22(X)
   U22(active(X)) -> U22(X)
   isList(mark(X)) -> isList(X)
   isList(active(X)) -> isList(X)
   U31(mark(X)) -> U31(X)
   U31(active(X)) -> U31(X)
   U41(mark(X1), X2) -> U41(X1, X2)
   U41(X1, mark(X2)) -> U41(X1, X2)
   U41(active(X1), X2) -> U41(X1, X2)
   U41(X1, active(X2)) -> U41(X1, X2)
   U42(mark(X)) -> U42(X)
   U42(active(X)) -> U42(X)
   isNeList(mark(X)) -> isNeList(X)
   isNeList(active(X)) -> isNeList(X)
   U51(mark(X1), X2) -> U51(X1, X2)
   U51(X1, mark(X2)) -> U51(X1, X2)
   U51(active(X1), X2) -> U51(X1, X2)
   U51(X1, active(X2)) -> U51(X1, X2)
   U52(mark(X)) -> U52(X)
   U52(active(X)) -> U52(X)
   U61(mark(X)) -> U61(X)
   U61(active(X)) -> U61(X)
   U71(mark(X1), X2) -> U71(X1, X2)
   U71(X1, mark(X2)) -> U71(X1, X2)
   U71(active(X1), X2) -> U71(X1, X2)
   U71(X1, active(X2)) -> U71(X1, X2)
   U72(mark(X)) -> U72(X)
   U72(active(X)) -> U72(X)
   isPal(mark(X)) -> isPal(X)
   isPal(active(X)) -> isPal(X)
   U81(mark(X)) -> U81(X)
   U81(active(X)) -> U81(X)
   isQid(mark(X)) -> isQid(X)
   isQid(active(X)) -> isQid(X)
   isNePal(mark(X)) -> isNePal(X)
   isNePal(active(X)) -> isNePal(X)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(1) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U11(x_1)) = x_1
   POL(U21(x_1, x_2)) = x_1 + 2*x_2
   POL(U22(x_1)) = x_1
   POL(U31(x_1)) = x_1
   POL(U41(x_1, x_2)) = 2 + x_1 + 2*x_2
   POL(U42(x_1)) = 1 + x_1
   POL(U51(x_1, x_2)) = x_1 + 2*x_2
   POL(U52(x_1)) = x_1
   POL(U61(x_1)) = x_1
   POL(U71(x_1, x_2)) = x_1 + x_2
   POL(U72(x_1)) = x_1
   POL(U81(x_1)) = x_1
   POL(__(x_1, x_2)) = 1 + 2*x_1 + x_2
   POL(a) = 0
   POL(active(x_1)) = x_1
   POL(e) = 0
   POL(i) = 0
   POL(isList(x_1)) = 2*x_1
   POL(isNeList(x_1)) = 2*x_1
   POL(isNePal(x_1)) = x_1
   POL(isPal(x_1)) = x_1
   POL(isQid(x_1)) = x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(o) = 0
   POL(tt) = 0
   POL(u) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   active(__(__(X, Y), Z)) -> mark(__(X, __(Y, Z)))
   active(__(X, nil)) -> mark(X)
   active(__(nil, X)) -> mark(X)
   active(U41(tt, V2)) -> mark(U42(isNeList(V2)))
   active(U42(tt)) -> mark(tt)
   active(isList(__(V1, V2))) -> mark(U21(isList(V1), V2))
   active(isNeList(__(V1, V2))) -> mark(U51(isNeList(V1), V2))
   active(isNePal(__(I, __(P, I)))) -> mark(U71(isQid(I), P))




----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(U11(tt)) -> mark(tt)
   active(U21(tt, V2)) -> mark(U22(isList(V2)))
   active(U22(tt)) -> mark(tt)
   active(U31(tt)) -> mark(tt)
   active(U51(tt, V2)) -> mark(U52(isList(V2)))
   active(U52(tt)) -> mark(tt)
   active(U61(tt)) -> mark(tt)
   active(U71(tt, P)) -> mark(U72(isPal(P)))
   active(U72(tt)) -> mark(tt)
   active(U81(tt)) -> mark(tt)
   active(isList(V)) -> mark(U11(isNeList(V)))
   active(isList(nil)) -> mark(tt)
   active(isNeList(V)) -> mark(U31(isQid(V)))
   active(isNeList(__(V1, V2))) -> mark(U41(isList(V1), V2))
   active(isNePal(V)) -> mark(U61(isQid(V)))
   active(isPal(V)) -> mark(U81(isNePal(V)))
   active(isPal(nil)) -> mark(tt)
   active(isQid(a)) -> mark(tt)
   active(isQid(e)) -> mark(tt)
   active(isQid(i)) -> mark(tt)
   active(isQid(o)) -> mark(tt)
   active(isQid(u)) -> mark(tt)
   mark(__(X1, X2)) -> active(__(mark(X1), mark(X2)))
   mark(nil) -> active(nil)
   mark(U11(X)) -> active(U11(mark(X)))
   mark(tt) -> active(tt)
   mark(U21(X1, X2)) -> active(U21(mark(X1), X2))
   mark(U22(X)) -> active(U22(mark(X)))
   mark(isList(X)) -> active(isList(X))
   mark(U31(X)) -> active(U31(mark(X)))
   mark(U41(X1, X2)) -> active(U41(mark(X1), X2))
   mark(U42(X)) -> active(U42(mark(X)))
   mark(isNeList(X)) -> active(isNeList(X))
   mark(U51(X1, X2)) -> active(U51(mark(X1), X2))
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(U71(X1, X2)) -> active(U71(mark(X1), X2))
   mark(U72(X)) -> active(U72(mark(X)))
   mark(isPal(X)) -> active(isPal(X))
   mark(U81(X)) -> active(U81(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(isNePal(X)) -> active(isNePal(X))
   mark(a) -> active(a)
   mark(e) -> active(e)
   mark(i) -> active(i)
   mark(o) -> active(o)
   mark(u) -> active(u)
   __(mark(X1), X2) -> __(X1, X2)
   __(X1, mark(X2)) -> __(X1, X2)
   __(active(X1), X2) -> __(X1, X2)
   __(X1, active(X2)) -> __(X1, X2)
   U11(mark(X)) -> U11(X)
   U11(active(X)) -> U11(X)
   U21(mark(X1), X2) -> U21(X1, X2)
   U21(X1, mark(X2)) -> U21(X1, X2)
   U21(active(X1), X2) -> U21(X1, X2)
   U21(X1, active(X2)) -> U21(X1, X2)
   U22(mark(X)) -> U22(X)
   U22(active(X)) -> U22(X)
   isList(mark(X)) -> isList(X)
   isList(active(X)) -> isList(X)
   U31(mark(X)) -> U31(X)
   U31(active(X)) -> U31(X)
   U41(mark(X1), X2) -> U41(X1, X2)
   U41(X1, mark(X2)) -> U41(X1, X2)
   U41(active(X1), X2) -> U41(X1, X2)
   U41(X1, active(X2)) -> U41(X1, X2)
   U42(mark(X)) -> U42(X)
   U42(active(X)) -> U42(X)
   isNeList(mark(X)) -> isNeList(X)
   isNeList(active(X)) -> isNeList(X)
   U51(mark(X1), X2) -> U51(X1, X2)
   U51(X1, mark(X2)) -> U51(X1, X2)
   U51(active(X1), X2) -> U51(X1, X2)
   U51(X1, active(X2)) -> U51(X1, X2)
   U52(mark(X)) -> U52(X)
   U52(active(X)) -> U52(X)
   U61(mark(X)) -> U61(X)
   U61(active(X)) -> U61(X)
   U71(mark(X1), X2) -> U71(X1, X2)
   U71(X1, mark(X2)) -> U71(X1, X2)
   U71(active(X1), X2) -> U71(X1, X2)
   U71(X1, active(X2)) -> U71(X1, X2)
   U72(mark(X)) -> U72(X)
   U72(active(X)) -> U72(X)
   isPal(mark(X)) -> isPal(X)
   isPal(active(X)) -> isPal(X)
   U81(mark(X)) -> U81(X)
   U81(active(X)) -> U81(X)
   isQid(mark(X)) -> isQid(X)
   isQid(active(X)) -> isQid(X)
   isNePal(mark(X)) -> isNePal(X)
   isNePal(active(X)) -> isNePal(X)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(3) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U11(x_1)) = x_1
   POL(U21(x_1, x_2)) = 2 + x_1 + 2*x_2
   POL(U22(x_1)) = 2 + 2*x_1
   POL(U31(x_1)) = x_1
   POL(U41(x_1, x_2)) = x_1 + x_2
   POL(U42(x_1)) = x_1
   POL(U51(x_1, x_2)) = x_1 + x_2
   POL(U52(x_1)) = x_1
   POL(U61(x_1)) = x_1
   POL(U71(x_1, x_2)) = x_1 + 2*x_2
   POL(U72(x_1)) = x_1
   POL(U81(x_1)) = 2*x_1
   POL(__(x_1, x_2)) = x_1 + x_2
   POL(a) = 0
   POL(active(x_1)) = x_1
   POL(e) = 0
   POL(i) = 0
   POL(isList(x_1)) = x_1
   POL(isNeList(x_1)) = x_1
   POL(isNePal(x_1)) = x_1
   POL(isPal(x_1)) = 2*x_1
   POL(isQid(x_1)) = x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(o) = 0
   POL(tt) = 0
   POL(u) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   active(U22(tt)) -> mark(tt)




----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(U11(tt)) -> mark(tt)
   active(U21(tt, V2)) -> mark(U22(isList(V2)))
   active(U31(tt)) -> mark(tt)
   active(U51(tt, V2)) -> mark(U52(isList(V2)))
   active(U52(tt)) -> mark(tt)
   active(U61(tt)) -> mark(tt)
   active(U71(tt, P)) -> mark(U72(isPal(P)))
   active(U72(tt)) -> mark(tt)
   active(U81(tt)) -> mark(tt)
   active(isList(V)) -> mark(U11(isNeList(V)))
   active(isList(nil)) -> mark(tt)
   active(isNeList(V)) -> mark(U31(isQid(V)))
   active(isNeList(__(V1, V2))) -> mark(U41(isList(V1), V2))
   active(isNePal(V)) -> mark(U61(isQid(V)))
   active(isPal(V)) -> mark(U81(isNePal(V)))
   active(isPal(nil)) -> mark(tt)
   active(isQid(a)) -> mark(tt)
   active(isQid(e)) -> mark(tt)
   active(isQid(i)) -> mark(tt)
   active(isQid(o)) -> mark(tt)
   active(isQid(u)) -> mark(tt)
   mark(__(X1, X2)) -> active(__(mark(X1), mark(X2)))
   mark(nil) -> active(nil)
   mark(U11(X)) -> active(U11(mark(X)))
   mark(tt) -> active(tt)
   mark(U21(X1, X2)) -> active(U21(mark(X1), X2))
   mark(U22(X)) -> active(U22(mark(X)))
   mark(isList(X)) -> active(isList(X))
   mark(U31(X)) -> active(U31(mark(X)))
   mark(U41(X1, X2)) -> active(U41(mark(X1), X2))
   mark(U42(X)) -> active(U42(mark(X)))
   mark(isNeList(X)) -> active(isNeList(X))
   mark(U51(X1, X2)) -> active(U51(mark(X1), X2))
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(U71(X1, X2)) -> active(U71(mark(X1), X2))
   mark(U72(X)) -> active(U72(mark(X)))
   mark(isPal(X)) -> active(isPal(X))
   mark(U81(X)) -> active(U81(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(isNePal(X)) -> active(isNePal(X))
   mark(a) -> active(a)
   mark(e) -> active(e)
   mark(i) -> active(i)
   mark(o) -> active(o)
   mark(u) -> active(u)
   __(mark(X1), X2) -> __(X1, X2)
   __(X1, mark(X2)) -> __(X1, X2)
   __(active(X1), X2) -> __(X1, X2)
   __(X1, active(X2)) -> __(X1, X2)
   U11(mark(X)) -> U11(X)
   U11(active(X)) -> U11(X)
   U21(mark(X1), X2) -> U21(X1, X2)
   U21(X1, mark(X2)) -> U21(X1, X2)
   U21(active(X1), X2) -> U21(X1, X2)
   U21(X1, active(X2)) -> U21(X1, X2)
   U22(mark(X)) -> U22(X)
   U22(active(X)) -> U22(X)
   isList(mark(X)) -> isList(X)
   isList(active(X)) -> isList(X)
   U31(mark(X)) -> U31(X)
   U31(active(X)) -> U31(X)
   U41(mark(X1), X2) -> U41(X1, X2)
   U41(X1, mark(X2)) -> U41(X1, X2)
   U41(active(X1), X2) -> U41(X1, X2)
   U41(X1, active(X2)) -> U41(X1, X2)
   U42(mark(X)) -> U42(X)
   U42(active(X)) -> U42(X)
   isNeList(mark(X)) -> isNeList(X)
   isNeList(active(X)) -> isNeList(X)
   U51(mark(X1), X2) -> U51(X1, X2)
   U51(X1, mark(X2)) -> U51(X1, X2)
   U51(active(X1), X2) -> U51(X1, X2)
   U51(X1, active(X2)) -> U51(X1, X2)
   U52(mark(X)) -> U52(X)
   U52(active(X)) -> U52(X)
   U61(mark(X)) -> U61(X)
   U61(active(X)) -> U61(X)
   U71(mark(X1), X2) -> U71(X1, X2)
   U71(X1, mark(X2)) -> U71(X1, X2)
   U71(active(X1), X2) -> U71(X1, X2)
   U71(X1, active(X2)) -> U71(X1, X2)
   U72(mark(X)) -> U72(X)
   U72(active(X)) -> U72(X)
   isPal(mark(X)) -> isPal(X)
   isPal(active(X)) -> isPal(X)
   U81(mark(X)) -> U81(X)
   U81(active(X)) -> U81(X)
   isQid(mark(X)) -> isQid(X)
   isQid(active(X)) -> isQid(X)
   isNePal(mark(X)) -> isNePal(X)
   isNePal(active(X)) -> isNePal(X)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(5) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U11(x_1)) = x_1
   POL(U21(x_1, x_2)) = x_1 + x_2
   POL(U22(x_1)) = x_1
   POL(U31(x_1)) = x_1
   POL(U41(x_1, x_2)) = x_1 + x_2
   POL(U42(x_1)) = x_1
   POL(U51(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(U52(x_1)) = x_1
   POL(U61(x_1)) = x_1
   POL(U71(x_1, x_2)) = x_1 + 2*x_2
   POL(U72(x_1)) = 2*x_1
   POL(U81(x_1)) = x_1
   POL(__(x_1, x_2)) = x_1 + x_2
   POL(a) = 0
   POL(active(x_1)) = x_1
   POL(e) = 2
   POL(i) = 0
   POL(isList(x_1)) = x_1
   POL(isNeList(x_1)) = x_1
   POL(isNePal(x_1)) = x_1
   POL(isPal(x_1)) = x_1
   POL(isQid(x_1)) = x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(o) = 0
   POL(tt) = 0
   POL(u) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   active(isQid(e)) -> mark(tt)




----------------------------------------

(6)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(U11(tt)) -> mark(tt)
   active(U21(tt, V2)) -> mark(U22(isList(V2)))
   active(U31(tt)) -> mark(tt)
   active(U51(tt, V2)) -> mark(U52(isList(V2)))
   active(U52(tt)) -> mark(tt)
   active(U61(tt)) -> mark(tt)
   active(U71(tt, P)) -> mark(U72(isPal(P)))
   active(U72(tt)) -> mark(tt)
   active(U81(tt)) -> mark(tt)
   active(isList(V)) -> mark(U11(isNeList(V)))
   active(isList(nil)) -> mark(tt)
   active(isNeList(V)) -> mark(U31(isQid(V)))
   active(isNeList(__(V1, V2))) -> mark(U41(isList(V1), V2))
   active(isNePal(V)) -> mark(U61(isQid(V)))
   active(isPal(V)) -> mark(U81(isNePal(V)))
   active(isPal(nil)) -> mark(tt)
   active(isQid(a)) -> mark(tt)
   active(isQid(i)) -> mark(tt)
   active(isQid(o)) -> mark(tt)
   active(isQid(u)) -> mark(tt)
   mark(__(X1, X2)) -> active(__(mark(X1), mark(X2)))
   mark(nil) -> active(nil)
   mark(U11(X)) -> active(U11(mark(X)))
   mark(tt) -> active(tt)
   mark(U21(X1, X2)) -> active(U21(mark(X1), X2))
   mark(U22(X)) -> active(U22(mark(X)))
   mark(isList(X)) -> active(isList(X))
   mark(U31(X)) -> active(U31(mark(X)))
   mark(U41(X1, X2)) -> active(U41(mark(X1), X2))
   mark(U42(X)) -> active(U42(mark(X)))
   mark(isNeList(X)) -> active(isNeList(X))
   mark(U51(X1, X2)) -> active(U51(mark(X1), X2))
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(U71(X1, X2)) -> active(U71(mark(X1), X2))
   mark(U72(X)) -> active(U72(mark(X)))
   mark(isPal(X)) -> active(isPal(X))
   mark(U81(X)) -> active(U81(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(isNePal(X)) -> active(isNePal(X))
   mark(a) -> active(a)
   mark(e) -> active(e)
   mark(i) -> active(i)
   mark(o) -> active(o)
   mark(u) -> active(u)
   __(mark(X1), X2) -> __(X1, X2)
   __(X1, mark(X2)) -> __(X1, X2)
   __(active(X1), X2) -> __(X1, X2)
   __(X1, active(X2)) -> __(X1, X2)
   U11(mark(X)) -> U11(X)
   U11(active(X)) -> U11(X)
   U21(mark(X1), X2) -> U21(X1, X2)
   U21(X1, mark(X2)) -> U21(X1, X2)
   U21(active(X1), X2) -> U21(X1, X2)
   U21(X1, active(X2)) -> U21(X1, X2)
   U22(mark(X)) -> U22(X)
   U22(active(X)) -> U22(X)
   isList(mark(X)) -> isList(X)
   isList(active(X)) -> isList(X)
   U31(mark(X)) -> U31(X)
   U31(active(X)) -> U31(X)
   U41(mark(X1), X2) -> U41(X1, X2)
   U41(X1, mark(X2)) -> U41(X1, X2)
   U41(active(X1), X2) -> U41(X1, X2)
   U41(X1, active(X2)) -> U41(X1, X2)
   U42(mark(X)) -> U42(X)
   U42(active(X)) -> U42(X)
   isNeList(mark(X)) -> isNeList(X)
   isNeList(active(X)) -> isNeList(X)
   U51(mark(X1), X2) -> U51(X1, X2)
   U51(X1, mark(X2)) -> U51(X1, X2)
   U51(active(X1), X2) -> U51(X1, X2)
   U51(X1, active(X2)) -> U51(X1, X2)
   U52(mark(X)) -> U52(X)
   U52(active(X)) -> U52(X)
   U61(mark(X)) -> U61(X)
   U61(active(X)) -> U61(X)
   U71(mark(X1), X2) -> U71(X1, X2)
   U71(X1, mark(X2)) -> U71(X1, X2)
   U71(active(X1), X2) -> U71(X1, X2)
   U71(X1, active(X2)) -> U71(X1, X2)
   U72(mark(X)) -> U72(X)
   U72(active(X)) -> U72(X)
   isPal(mark(X)) -> isPal(X)
   isPal(active(X)) -> isPal(X)
   U81(mark(X)) -> U81(X)
   U81(active(X)) -> U81(X)
   isQid(mark(X)) -> isQid(X)
   isQid(active(X)) -> isQid(X)
   isNePal(mark(X)) -> isNePal(X)
   isNePal(active(X)) -> isNePal(X)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(7) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U11(x_1)) = x_1
   POL(U21(x_1, x_2)) = x_1 + 2*x_2
   POL(U22(x_1)) = x_1
   POL(U31(x_1)) = 2*x_1
   POL(U41(x_1, x_2)) = x_1 + x_2
   POL(U42(x_1)) = x_1
   POL(U51(x_1, x_2)) = 2 + x_1 + 2*x_2
   POL(U52(x_1)) = x_1
   POL(U61(x_1)) = x_1
   POL(U71(x_1, x_2)) = 2 + x_1 + x_2
   POL(U72(x_1)) = x_1
   POL(U81(x_1)) = x_1
   POL(__(x_1, x_2)) = x_1 + x_2
   POL(a) = 0
   POL(active(x_1)) = x_1
   POL(e) = 0
   POL(i) = 0
   POL(isList(x_1)) = 2*x_1
   POL(isNeList(x_1)) = 2*x_1
   POL(isNePal(x_1)) = x_1
   POL(isPal(x_1)) = x_1
   POL(isQid(x_1)) = x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(o) = 0
   POL(tt) = 0
   POL(u) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   active(U51(tt, V2)) -> mark(U52(isList(V2)))
   active(U71(tt, P)) -> mark(U72(isPal(P)))




----------------------------------------

(8)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(U11(tt)) -> mark(tt)
   active(U21(tt, V2)) -> mark(U22(isList(V2)))
   active(U31(tt)) -> mark(tt)
   active(U52(tt)) -> mark(tt)
   active(U61(tt)) -> mark(tt)
   active(U72(tt)) -> mark(tt)
   active(U81(tt)) -> mark(tt)
   active(isList(V)) -> mark(U11(isNeList(V)))
   active(isList(nil)) -> mark(tt)
   active(isNeList(V)) -> mark(U31(isQid(V)))
   active(isNeList(__(V1, V2))) -> mark(U41(isList(V1), V2))
   active(isNePal(V)) -> mark(U61(isQid(V)))
   active(isPal(V)) -> mark(U81(isNePal(V)))
   active(isPal(nil)) -> mark(tt)
   active(isQid(a)) -> mark(tt)
   active(isQid(i)) -> mark(tt)
   active(isQid(o)) -> mark(tt)
   active(isQid(u)) -> mark(tt)
   mark(__(X1, X2)) -> active(__(mark(X1), mark(X2)))
   mark(nil) -> active(nil)
   mark(U11(X)) -> active(U11(mark(X)))
   mark(tt) -> active(tt)
   mark(U21(X1, X2)) -> active(U21(mark(X1), X2))
   mark(U22(X)) -> active(U22(mark(X)))
   mark(isList(X)) -> active(isList(X))
   mark(U31(X)) -> active(U31(mark(X)))
   mark(U41(X1, X2)) -> active(U41(mark(X1), X2))
   mark(U42(X)) -> active(U42(mark(X)))
   mark(isNeList(X)) -> active(isNeList(X))
   mark(U51(X1, X2)) -> active(U51(mark(X1), X2))
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(U71(X1, X2)) -> active(U71(mark(X1), X2))
   mark(U72(X)) -> active(U72(mark(X)))
   mark(isPal(X)) -> active(isPal(X))
   mark(U81(X)) -> active(U81(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(isNePal(X)) -> active(isNePal(X))
   mark(a) -> active(a)
   mark(e) -> active(e)
   mark(i) -> active(i)
   mark(o) -> active(o)
   mark(u) -> active(u)
   __(mark(X1), X2) -> __(X1, X2)
   __(X1, mark(X2)) -> __(X1, X2)
   __(active(X1), X2) -> __(X1, X2)
   __(X1, active(X2)) -> __(X1, X2)
   U11(mark(X)) -> U11(X)
   U11(active(X)) -> U11(X)
   U21(mark(X1), X2) -> U21(X1, X2)
   U21(X1, mark(X2)) -> U21(X1, X2)
   U21(active(X1), X2) -> U21(X1, X2)
   U21(X1, active(X2)) -> U21(X1, X2)
   U22(mark(X)) -> U22(X)
   U22(active(X)) -> U22(X)
   isList(mark(X)) -> isList(X)
   isList(active(X)) -> isList(X)
   U31(mark(X)) -> U31(X)
   U31(active(X)) -> U31(X)
   U41(mark(X1), X2) -> U41(X1, X2)
   U41(X1, mark(X2)) -> U41(X1, X2)
   U41(active(X1), X2) -> U41(X1, X2)
   U41(X1, active(X2)) -> U41(X1, X2)
   U42(mark(X)) -> U42(X)
   U42(active(X)) -> U42(X)
   isNeList(mark(X)) -> isNeList(X)
   isNeList(active(X)) -> isNeList(X)
   U51(mark(X1), X2) -> U51(X1, X2)
   U51(X1, mark(X2)) -> U51(X1, X2)
   U51(active(X1), X2) -> U51(X1, X2)
   U51(X1, active(X2)) -> U51(X1, X2)
   U52(mark(X)) -> U52(X)
   U52(active(X)) -> U52(X)
   U61(mark(X)) -> U61(X)
   U61(active(X)) -> U61(X)
   U71(mark(X1), X2) -> U71(X1, X2)
   U71(X1, mark(X2)) -> U71(X1, X2)
   U71(active(X1), X2) -> U71(X1, X2)
   U71(X1, active(X2)) -> U71(X1, X2)
   U72(mark(X)) -> U72(X)
   U72(active(X)) -> U72(X)
   isPal(mark(X)) -> isPal(X)
   isPal(active(X)) -> isPal(X)
   U81(mark(X)) -> U81(X)
   U81(active(X)) -> U81(X)
   isQid(mark(X)) -> isQid(X)
   isQid(active(X)) -> isQid(X)
   isNePal(mark(X)) -> isNePal(X)
   isNePal(active(X)) -> isNePal(X)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(9) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U11(x_1)) = x_1
   POL(U21(x_1, x_2)) = x_1 + 2*x_2
   POL(U22(x_1)) = x_1
   POL(U31(x_1)) = x_1
   POL(U41(x_1, x_2)) = x_1 + x_2
   POL(U42(x_1)) = 2*x_1
   POL(U51(x_1, x_2)) = x_1 + 2*x_2
   POL(U52(x_1)) = 2*x_1
   POL(U61(x_1)) = x_1
   POL(U71(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(U72(x_1)) = x_1
   POL(U81(x_1)) = x_1
   POL(__(x_1, x_2)) = x_1 + x_2
   POL(a) = 0
   POL(active(x_1)) = x_1
   POL(e) = 0
   POL(i) = 1
   POL(isList(x_1)) = 2*x_1
   POL(isNeList(x_1)) = 2*x_1
   POL(isNePal(x_1)) = 2*x_1
   POL(isPal(x_1)) = 2 + 2*x_1
   POL(isQid(x_1)) = 2*x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(o) = 0
   POL(tt) = 0
   POL(u) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   active(isPal(V)) -> mark(U81(isNePal(V)))
   active(isPal(nil)) -> mark(tt)
   active(isQid(i)) -> mark(tt)




----------------------------------------

(10)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(U11(tt)) -> mark(tt)
   active(U21(tt, V2)) -> mark(U22(isList(V2)))
   active(U31(tt)) -> mark(tt)
   active(U52(tt)) -> mark(tt)
   active(U61(tt)) -> mark(tt)
   active(U72(tt)) -> mark(tt)
   active(U81(tt)) -> mark(tt)
   active(isList(V)) -> mark(U11(isNeList(V)))
   active(isList(nil)) -> mark(tt)
   active(isNeList(V)) -> mark(U31(isQid(V)))
   active(isNeList(__(V1, V2))) -> mark(U41(isList(V1), V2))
   active(isNePal(V)) -> mark(U61(isQid(V)))
   active(isQid(a)) -> mark(tt)
   active(isQid(o)) -> mark(tt)
   active(isQid(u)) -> mark(tt)
   mark(__(X1, X2)) -> active(__(mark(X1), mark(X2)))
   mark(nil) -> active(nil)
   mark(U11(X)) -> active(U11(mark(X)))
   mark(tt) -> active(tt)
   mark(U21(X1, X2)) -> active(U21(mark(X1), X2))
   mark(U22(X)) -> active(U22(mark(X)))
   mark(isList(X)) -> active(isList(X))
   mark(U31(X)) -> active(U31(mark(X)))
   mark(U41(X1, X2)) -> active(U41(mark(X1), X2))
   mark(U42(X)) -> active(U42(mark(X)))
   mark(isNeList(X)) -> active(isNeList(X))
   mark(U51(X1, X2)) -> active(U51(mark(X1), X2))
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(U71(X1, X2)) -> active(U71(mark(X1), X2))
   mark(U72(X)) -> active(U72(mark(X)))
   mark(isPal(X)) -> active(isPal(X))
   mark(U81(X)) -> active(U81(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(isNePal(X)) -> active(isNePal(X))
   mark(a) -> active(a)
   mark(e) -> active(e)
   mark(i) -> active(i)
   mark(o) -> active(o)
   mark(u) -> active(u)
   __(mark(X1), X2) -> __(X1, X2)
   __(X1, mark(X2)) -> __(X1, X2)
   __(active(X1), X2) -> __(X1, X2)
   __(X1, active(X2)) -> __(X1, X2)
   U11(mark(X)) -> U11(X)
   U11(active(X)) -> U11(X)
   U21(mark(X1), X2) -> U21(X1, X2)
   U21(X1, mark(X2)) -> U21(X1, X2)
   U21(active(X1), X2) -> U21(X1, X2)
   U21(X1, active(X2)) -> U21(X1, X2)
   U22(mark(X)) -> U22(X)
   U22(active(X)) -> U22(X)
   isList(mark(X)) -> isList(X)
   isList(active(X)) -> isList(X)
   U31(mark(X)) -> U31(X)
   U31(active(X)) -> U31(X)
   U41(mark(X1), X2) -> U41(X1, X2)
   U41(X1, mark(X2)) -> U41(X1, X2)
   U41(active(X1), X2) -> U41(X1, X2)
   U41(X1, active(X2)) -> U41(X1, X2)
   U42(mark(X)) -> U42(X)
   U42(active(X)) -> U42(X)
   isNeList(mark(X)) -> isNeList(X)
   isNeList(active(X)) -> isNeList(X)
   U51(mark(X1), X2) -> U51(X1, X2)
   U51(X1, mark(X2)) -> U51(X1, X2)
   U51(active(X1), X2) -> U51(X1, X2)
   U51(X1, active(X2)) -> U51(X1, X2)
   U52(mark(X)) -> U52(X)
   U52(active(X)) -> U52(X)
   U61(mark(X)) -> U61(X)
   U61(active(X)) -> U61(X)
   U71(mark(X1), X2) -> U71(X1, X2)
   U71(X1, mark(X2)) -> U71(X1, X2)
   U71(active(X1), X2) -> U71(X1, X2)
   U71(X1, active(X2)) -> U71(X1, X2)
   U72(mark(X)) -> U72(X)
   U72(active(X)) -> U72(X)
   isPal(mark(X)) -> isPal(X)
   isPal(active(X)) -> isPal(X)
   U81(mark(X)) -> U81(X)
   U81(active(X)) -> U81(X)
   isQid(mark(X)) -> isQid(X)
   isQid(active(X)) -> isQid(X)
   isNePal(mark(X)) -> isNePal(X)
   isNePal(active(X)) -> isNePal(X)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(11) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U11(x_1)) = x_1
   POL(U21(x_1, x_2)) = x_1 + 2*x_2
   POL(U22(x_1)) = x_1
   POL(U31(x_1)) = x_1
   POL(U41(x_1, x_2)) = x_1 + x_2
   POL(U42(x_1)) = x_1
   POL(U51(x_1, x_2)) = 2*x_1 + x_2
   POL(U52(x_1)) = 2*x_1
   POL(U61(x_1)) = x_1
   POL(U71(x_1, x_2)) = x_1 + 2*x_2
   POL(U72(x_1)) = 1 + x_1
   POL(U81(x_1)) = x_1
   POL(__(x_1, x_2)) = x_1 + x_2
   POL(a) = 0
   POL(active(x_1)) = x_1
   POL(e) = 0
   POL(i) = 0
   POL(isList(x_1)) = x_1
   POL(isNeList(x_1)) = x_1
   POL(isNePal(x_1)) = 2*x_1
   POL(isPal(x_1)) = 2*x_1
   POL(isQid(x_1)) = x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(o) = 0
   POL(tt) = 0
   POL(u) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   active(U72(tt)) -> mark(tt)




----------------------------------------

(12)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(U11(tt)) -> mark(tt)
   active(U21(tt, V2)) -> mark(U22(isList(V2)))
   active(U31(tt)) -> mark(tt)
   active(U52(tt)) -> mark(tt)
   active(U61(tt)) -> mark(tt)
   active(U81(tt)) -> mark(tt)
   active(isList(V)) -> mark(U11(isNeList(V)))
   active(isList(nil)) -> mark(tt)
   active(isNeList(V)) -> mark(U31(isQid(V)))
   active(isNeList(__(V1, V2))) -> mark(U41(isList(V1), V2))
   active(isNePal(V)) -> mark(U61(isQid(V)))
   active(isQid(a)) -> mark(tt)
   active(isQid(o)) -> mark(tt)
   active(isQid(u)) -> mark(tt)
   mark(__(X1, X2)) -> active(__(mark(X1), mark(X2)))
   mark(nil) -> active(nil)
   mark(U11(X)) -> active(U11(mark(X)))
   mark(tt) -> active(tt)
   mark(U21(X1, X2)) -> active(U21(mark(X1), X2))
   mark(U22(X)) -> active(U22(mark(X)))
   mark(isList(X)) -> active(isList(X))
   mark(U31(X)) -> active(U31(mark(X)))
   mark(U41(X1, X2)) -> active(U41(mark(X1), X2))
   mark(U42(X)) -> active(U42(mark(X)))
   mark(isNeList(X)) -> active(isNeList(X))
   mark(U51(X1, X2)) -> active(U51(mark(X1), X2))
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(U71(X1, X2)) -> active(U71(mark(X1), X2))
   mark(U72(X)) -> active(U72(mark(X)))
   mark(isPal(X)) -> active(isPal(X))
   mark(U81(X)) -> active(U81(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(isNePal(X)) -> active(isNePal(X))
   mark(a) -> active(a)
   mark(e) -> active(e)
   mark(i) -> active(i)
   mark(o) -> active(o)
   mark(u) -> active(u)
   __(mark(X1), X2) -> __(X1, X2)
   __(X1, mark(X2)) -> __(X1, X2)
   __(active(X1), X2) -> __(X1, X2)
   __(X1, active(X2)) -> __(X1, X2)
   U11(mark(X)) -> U11(X)
   U11(active(X)) -> U11(X)
   U21(mark(X1), X2) -> U21(X1, X2)
   U21(X1, mark(X2)) -> U21(X1, X2)
   U21(active(X1), X2) -> U21(X1, X2)
   U21(X1, active(X2)) -> U21(X1, X2)
   U22(mark(X)) -> U22(X)
   U22(active(X)) -> U22(X)
   isList(mark(X)) -> isList(X)
   isList(active(X)) -> isList(X)
   U31(mark(X)) -> U31(X)
   U31(active(X)) -> U31(X)
   U41(mark(X1), X2) -> U41(X1, X2)
   U41(X1, mark(X2)) -> U41(X1, X2)
   U41(active(X1), X2) -> U41(X1, X2)
   U41(X1, active(X2)) -> U41(X1, X2)
   U42(mark(X)) -> U42(X)
   U42(active(X)) -> U42(X)
   isNeList(mark(X)) -> isNeList(X)
   isNeList(active(X)) -> isNeList(X)
   U51(mark(X1), X2) -> U51(X1, X2)
   U51(X1, mark(X2)) -> U51(X1, X2)
   U51(active(X1), X2) -> U51(X1, X2)
   U51(X1, active(X2)) -> U51(X1, X2)
   U52(mark(X)) -> U52(X)
   U52(active(X)) -> U52(X)
   U61(mark(X)) -> U61(X)
   U61(active(X)) -> U61(X)
   U71(mark(X1), X2) -> U71(X1, X2)
   U71(X1, mark(X2)) -> U71(X1, X2)
   U71(active(X1), X2) -> U71(X1, X2)
   U71(X1, active(X2)) -> U71(X1, X2)
   U72(mark(X)) -> U72(X)
   U72(active(X)) -> U72(X)
   isPal(mark(X)) -> isPal(X)
   isPal(active(X)) -> isPal(X)
   U81(mark(X)) -> U81(X)
   U81(active(X)) -> U81(X)
   isQid(mark(X)) -> isQid(X)
   isQid(active(X)) -> isQid(X)
   isNePal(mark(X)) -> isNePal(X)
   isNePal(active(X)) -> isNePal(X)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(13) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U11(x_1)) = 2*x_1
   POL(U21(x_1, x_2)) = x_1 + 2*x_2
   POL(U22(x_1)) = x_1
   POL(U31(x_1)) = x_1
   POL(U41(x_1, x_2)) = x_1 + x_2
   POL(U42(x_1)) = x_1
   POL(U51(x_1, x_2)) = x_1 + x_2
   POL(U52(x_1)) = x_1
   POL(U61(x_1)) = 2*x_1
   POL(U71(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(U72(x_1)) = x_1
   POL(U81(x_1)) = x_1
   POL(__(x_1, x_2)) = 2*x_1 + x_2
   POL(a) = 0
   POL(active(x_1)) = x_1
   POL(e) = 0
   POL(i) = 0
   POL(isList(x_1)) = 2*x_1
   POL(isNeList(x_1)) = x_1
   POL(isNePal(x_1)) = 2*x_1
   POL(isPal(x_1)) = 2*x_1
   POL(isQid(x_1)) = x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(o) = 0
   POL(tt) = 0
   POL(u) = 2
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   active(isQid(u)) -> mark(tt)




----------------------------------------

(14)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(U11(tt)) -> mark(tt)
   active(U21(tt, V2)) -> mark(U22(isList(V2)))
   active(U31(tt)) -> mark(tt)
   active(U52(tt)) -> mark(tt)
   active(U61(tt)) -> mark(tt)
   active(U81(tt)) -> mark(tt)
   active(isList(V)) -> mark(U11(isNeList(V)))
   active(isList(nil)) -> mark(tt)
   active(isNeList(V)) -> mark(U31(isQid(V)))
   active(isNeList(__(V1, V2))) -> mark(U41(isList(V1), V2))
   active(isNePal(V)) -> mark(U61(isQid(V)))
   active(isQid(a)) -> mark(tt)
   active(isQid(o)) -> mark(tt)
   mark(__(X1, X2)) -> active(__(mark(X1), mark(X2)))
   mark(nil) -> active(nil)
   mark(U11(X)) -> active(U11(mark(X)))
   mark(tt) -> active(tt)
   mark(U21(X1, X2)) -> active(U21(mark(X1), X2))
   mark(U22(X)) -> active(U22(mark(X)))
   mark(isList(X)) -> active(isList(X))
   mark(U31(X)) -> active(U31(mark(X)))
   mark(U41(X1, X2)) -> active(U41(mark(X1), X2))
   mark(U42(X)) -> active(U42(mark(X)))
   mark(isNeList(X)) -> active(isNeList(X))
   mark(U51(X1, X2)) -> active(U51(mark(X1), X2))
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(U71(X1, X2)) -> active(U71(mark(X1), X2))
   mark(U72(X)) -> active(U72(mark(X)))
   mark(isPal(X)) -> active(isPal(X))
   mark(U81(X)) -> active(U81(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(isNePal(X)) -> active(isNePal(X))
   mark(a) -> active(a)
   mark(e) -> active(e)
   mark(i) -> active(i)
   mark(o) -> active(o)
   mark(u) -> active(u)
   __(mark(X1), X2) -> __(X1, X2)
   __(X1, mark(X2)) -> __(X1, X2)
   __(active(X1), X2) -> __(X1, X2)
   __(X1, active(X2)) -> __(X1, X2)
   U11(mark(X)) -> U11(X)
   U11(active(X)) -> U11(X)
   U21(mark(X1), X2) -> U21(X1, X2)
   U21(X1, mark(X2)) -> U21(X1, X2)
   U21(active(X1), X2) -> U21(X1, X2)
   U21(X1, active(X2)) -> U21(X1, X2)
   U22(mark(X)) -> U22(X)
   U22(active(X)) -> U22(X)
   isList(mark(X)) -> isList(X)
   isList(active(X)) -> isList(X)
   U31(mark(X)) -> U31(X)
   U31(active(X)) -> U31(X)
   U41(mark(X1), X2) -> U41(X1, X2)
   U41(X1, mark(X2)) -> U41(X1, X2)
   U41(active(X1), X2) -> U41(X1, X2)
   U41(X1, active(X2)) -> U41(X1, X2)
   U42(mark(X)) -> U42(X)
   U42(active(X)) -> U42(X)
   isNeList(mark(X)) -> isNeList(X)
   isNeList(active(X)) -> isNeList(X)
   U51(mark(X1), X2) -> U51(X1, X2)
   U51(X1, mark(X2)) -> U51(X1, X2)
   U51(active(X1), X2) -> U51(X1, X2)
   U51(X1, active(X2)) -> U51(X1, X2)
   U52(mark(X)) -> U52(X)
   U52(active(X)) -> U52(X)
   U61(mark(X)) -> U61(X)
   U61(active(X)) -> U61(X)
   U71(mark(X1), X2) -> U71(X1, X2)
   U71(X1, mark(X2)) -> U71(X1, X2)
   U71(active(X1), X2) -> U71(X1, X2)
   U71(X1, active(X2)) -> U71(X1, X2)
   U72(mark(X)) -> U72(X)
   U72(active(X)) -> U72(X)
   isPal(mark(X)) -> isPal(X)
   isPal(active(X)) -> isPal(X)
   U81(mark(X)) -> U81(X)
   U81(active(X)) -> U81(X)
   isQid(mark(X)) -> isQid(X)
   isQid(active(X)) -> isQid(X)
   isNePal(mark(X)) -> isNePal(X)
   isNePal(active(X)) -> isNePal(X)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(15) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U11(x_1)) = x_1
   POL(U21(x_1, x_2)) = x_1 + 2*x_2
   POL(U22(x_1)) = x_1
   POL(U31(x_1)) = x_1
   POL(U41(x_1, x_2)) = x_1 + x_2
   POL(U42(x_1)) = x_1
   POL(U51(x_1, x_2)) = 2*x_1 + x_2
   POL(U52(x_1)) = x_1
   POL(U61(x_1)) = x_1
   POL(U71(x_1, x_2)) = x_1 + 2*x_2
   POL(U72(x_1)) = x_1
   POL(U81(x_1)) = x_1
   POL(__(x_1, x_2)) = 2*x_1 + x_2
   POL(a) = 0
   POL(active(x_1)) = x_1
   POL(e) = 0
   POL(i) = 0
   POL(isList(x_1)) = 2*x_1
   POL(isNeList(x_1)) = 2*x_1
   POL(isNePal(x_1)) = 2*x_1
   POL(isPal(x_1)) = 2*x_1
   POL(isQid(x_1)) = 2*x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(o) = 1
   POL(tt) = 0
   POL(u) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   active(isQid(o)) -> mark(tt)




----------------------------------------

(16)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(U11(tt)) -> mark(tt)
   active(U21(tt, V2)) -> mark(U22(isList(V2)))
   active(U31(tt)) -> mark(tt)
   active(U52(tt)) -> mark(tt)
   active(U61(tt)) -> mark(tt)
   active(U81(tt)) -> mark(tt)
   active(isList(V)) -> mark(U11(isNeList(V)))
   active(isList(nil)) -> mark(tt)
   active(isNeList(V)) -> mark(U31(isQid(V)))
   active(isNeList(__(V1, V2))) -> mark(U41(isList(V1), V2))
   active(isNePal(V)) -> mark(U61(isQid(V)))
   active(isQid(a)) -> mark(tt)
   mark(__(X1, X2)) -> active(__(mark(X1), mark(X2)))
   mark(nil) -> active(nil)
   mark(U11(X)) -> active(U11(mark(X)))
   mark(tt) -> active(tt)
   mark(U21(X1, X2)) -> active(U21(mark(X1), X2))
   mark(U22(X)) -> active(U22(mark(X)))
   mark(isList(X)) -> active(isList(X))
   mark(U31(X)) -> active(U31(mark(X)))
   mark(U41(X1, X2)) -> active(U41(mark(X1), X2))
   mark(U42(X)) -> active(U42(mark(X)))
   mark(isNeList(X)) -> active(isNeList(X))
   mark(U51(X1, X2)) -> active(U51(mark(X1), X2))
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(U71(X1, X2)) -> active(U71(mark(X1), X2))
   mark(U72(X)) -> active(U72(mark(X)))
   mark(isPal(X)) -> active(isPal(X))
   mark(U81(X)) -> active(U81(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(isNePal(X)) -> active(isNePal(X))
   mark(a) -> active(a)
   mark(e) -> active(e)
   mark(i) -> active(i)
   mark(o) -> active(o)
   mark(u) -> active(u)
   __(mark(X1), X2) -> __(X1, X2)
   __(X1, mark(X2)) -> __(X1, X2)
   __(active(X1), X2) -> __(X1, X2)
   __(X1, active(X2)) -> __(X1, X2)
   U11(mark(X)) -> U11(X)
   U11(active(X)) -> U11(X)
   U21(mark(X1), X2) -> U21(X1, X2)
   U21(X1, mark(X2)) -> U21(X1, X2)
   U21(active(X1), X2) -> U21(X1, X2)
   U21(X1, active(X2)) -> U21(X1, X2)
   U22(mark(X)) -> U22(X)
   U22(active(X)) -> U22(X)
   isList(mark(X)) -> isList(X)
   isList(active(X)) -> isList(X)
   U31(mark(X)) -> U31(X)
   U31(active(X)) -> U31(X)
   U41(mark(X1), X2) -> U41(X1, X2)
   U41(X1, mark(X2)) -> U41(X1, X2)
   U41(active(X1), X2) -> U41(X1, X2)
   U41(X1, active(X2)) -> U41(X1, X2)
   U42(mark(X)) -> U42(X)
   U42(active(X)) -> U42(X)
   isNeList(mark(X)) -> isNeList(X)
   isNeList(active(X)) -> isNeList(X)
   U51(mark(X1), X2) -> U51(X1, X2)
   U51(X1, mark(X2)) -> U51(X1, X2)
   U51(active(X1), X2) -> U51(X1, X2)
   U51(X1, active(X2)) -> U51(X1, X2)
   U52(mark(X)) -> U52(X)
   U52(active(X)) -> U52(X)
   U61(mark(X)) -> U61(X)
   U61(active(X)) -> U61(X)
   U71(mark(X1), X2) -> U71(X1, X2)
   U71(X1, mark(X2)) -> U71(X1, X2)
   U71(active(X1), X2) -> U71(X1, X2)
   U71(X1, active(X2)) -> U71(X1, X2)
   U72(mark(X)) -> U72(X)
   U72(active(X)) -> U72(X)
   isPal(mark(X)) -> isPal(X)
   isPal(active(X)) -> isPal(X)
   U81(mark(X)) -> U81(X)
   U81(active(X)) -> U81(X)
   isQid(mark(X)) -> isQid(X)
   isQid(active(X)) -> isQid(X)
   isNePal(mark(X)) -> isNePal(X)
   isNePal(active(X)) -> isNePal(X)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(17) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U11(x_1)) = x_1
   POL(U21(x_1, x_2)) = 2 + 2*x_1 + 2*x_2
   POL(U22(x_1)) = x_1
   POL(U31(x_1)) = 2*x_1
   POL(U41(x_1, x_2)) = x_1 + 2*x_2
   POL(U42(x_1)) = 2*x_1
   POL(U51(x_1, x_2)) = x_1 + 2*x_2
   POL(U52(x_1)) = 2 + x_1
   POL(U61(x_1)) = x_1
   POL(U71(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(U72(x_1)) = x_1
   POL(U81(x_1)) = 1 + x_1
   POL(__(x_1, x_2)) = 2 + x_1 + x_2
   POL(a) = 2
   POL(active(x_1)) = x_1
   POL(e) = 0
   POL(i) = 0
   POL(isList(x_1)) = 2 + 2*x_1
   POL(isNeList(x_1)) = 2*x_1
   POL(isNePal(x_1)) = 2*x_1
   POL(isPal(x_1)) = 2*x_1
   POL(isQid(x_1)) = x_1
   POL(mark(x_1)) = x_1
   POL(nil) = 0
   POL(o) = 0
   POL(tt) = 1
   POL(u) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   active(U21(tt, V2)) -> mark(U22(isList(V2)))
   active(U31(tt)) -> mark(tt)
   active(U52(tt)) -> mark(tt)
   active(U81(tt)) -> mark(tt)
   active(isList(V)) -> mark(U11(isNeList(V)))
   active(isList(nil)) -> mark(tt)
   active(isNeList(__(V1, V2))) -> mark(U41(isList(V1), V2))
   active(isQid(a)) -> mark(tt)




----------------------------------------

(18)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(U11(tt)) -> mark(tt)
   active(U61(tt)) -> mark(tt)
   active(isNeList(V)) -> mark(U31(isQid(V)))
   active(isNePal(V)) -> mark(U61(isQid(V)))
   mark(__(X1, X2)) -> active(__(mark(X1), mark(X2)))
   mark(nil) -> active(nil)
   mark(U11(X)) -> active(U11(mark(X)))
   mark(tt) -> active(tt)
   mark(U21(X1, X2)) -> active(U21(mark(X1), X2))
   mark(U22(X)) -> active(U22(mark(X)))
   mark(isList(X)) -> active(isList(X))
   mark(U31(X)) -> active(U31(mark(X)))
   mark(U41(X1, X2)) -> active(U41(mark(X1), X2))
   mark(U42(X)) -> active(U42(mark(X)))
   mark(isNeList(X)) -> active(isNeList(X))
   mark(U51(X1, X2)) -> active(U51(mark(X1), X2))
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(U71(X1, X2)) -> active(U71(mark(X1), X2))
   mark(U72(X)) -> active(U72(mark(X)))
   mark(isPal(X)) -> active(isPal(X))
   mark(U81(X)) -> active(U81(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(isNePal(X)) -> active(isNePal(X))
   mark(a) -> active(a)
   mark(e) -> active(e)
   mark(i) -> active(i)
   mark(o) -> active(o)
   mark(u) -> active(u)
   __(mark(X1), X2) -> __(X1, X2)
   __(X1, mark(X2)) -> __(X1, X2)
   __(active(X1), X2) -> __(X1, X2)
   __(X1, active(X2)) -> __(X1, X2)
   U11(mark(X)) -> U11(X)
   U11(active(X)) -> U11(X)
   U21(mark(X1), X2) -> U21(X1, X2)
   U21(X1, mark(X2)) -> U21(X1, X2)
   U21(active(X1), X2) -> U21(X1, X2)
   U21(X1, active(X2)) -> U21(X1, X2)
   U22(mark(X)) -> U22(X)
   U22(active(X)) -> U22(X)
   isList(mark(X)) -> isList(X)
   isList(active(X)) -> isList(X)
   U31(mark(X)) -> U31(X)
   U31(active(X)) -> U31(X)
   U41(mark(X1), X2) -> U41(X1, X2)
   U41(X1, mark(X2)) -> U41(X1, X2)
   U41(active(X1), X2) -> U41(X1, X2)
   U41(X1, active(X2)) -> U41(X1, X2)
   U42(mark(X)) -> U42(X)
   U42(active(X)) -> U42(X)
   isNeList(mark(X)) -> isNeList(X)
   isNeList(active(X)) -> isNeList(X)
   U51(mark(X1), X2) -> U51(X1, X2)
   U51(X1, mark(X2)) -> U51(X1, X2)
   U51(active(X1), X2) -> U51(X1, X2)
   U51(X1, active(X2)) -> U51(X1, X2)
   U52(mark(X)) -> U52(X)
   U52(active(X)) -> U52(X)
   U61(mark(X)) -> U61(X)
   U61(active(X)) -> U61(X)
   U71(mark(X1), X2) -> U71(X1, X2)
   U71(X1, mark(X2)) -> U71(X1, X2)
   U71(active(X1), X2) -> U71(X1, X2)
   U71(X1, active(X2)) -> U71(X1, X2)
   U72(mark(X)) -> U72(X)
   U72(active(X)) -> U72(X)
   isPal(mark(X)) -> isPal(X)
   isPal(active(X)) -> isPal(X)
   U81(mark(X)) -> U81(X)
   U81(active(X)) -> U81(X)
   isQid(mark(X)) -> isQid(X)
   isQid(active(X)) -> isQid(X)
   isNePal(mark(X)) -> isNePal(X)
   isNePal(active(X)) -> isNePal(X)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(19) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U11(x_1)) = 1 + x_1
   POL(U21(x_1, x_2)) = 1 + x_1 + 2*x_2
   POL(U22(x_1)) = 1 + 2*x_1
   POL(U31(x_1)) = x_1
   POL(U41(x_1, x_2)) = 1 + x_1 + x_2
   POL(U42(x_1)) = 1 + x_1
   POL(U51(x_1, x_2)) = 1 + 2*x_1 + x_2
   POL(U52(x_1)) = 2*x_1
   POL(U61(x_1)) = x_1
   POL(U71(x_1, x_2)) = 1 + x_1 + 2*x_2
   POL(U72(x_1)) = 1 + x_1
   POL(U81(x_1)) = 1 + 2*x_1
   POL(__(x_1, x_2)) = 1 + 2*x_1 + 2*x_2
   POL(a) = 0
   POL(active(x_1)) = x_1
   POL(e) = 0
   POL(i) = 0
   POL(isList(x_1)) = 1 + 2*x_1
   POL(isNeList(x_1)) = 1 + 2*x_1
   POL(isNePal(x_1)) = 2*x_1
   POL(isPal(x_1)) = 1 + 2*x_1
   POL(isQid(x_1)) = x_1
   POL(mark(x_1)) = 2*x_1
   POL(nil) = 0
   POL(o) = 0
   POL(tt) = 0
   POL(u) = 1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   active(U11(tt)) -> mark(tt)
   active(isNeList(V)) -> mark(U31(isQid(V)))
   mark(__(X1, X2)) -> active(__(mark(X1), mark(X2)))
   mark(U11(X)) -> active(U11(mark(X)))
   mark(U21(X1, X2)) -> active(U21(mark(X1), X2))
   mark(U22(X)) -> active(U22(mark(X)))
   mark(isList(X)) -> active(isList(X))
   mark(U41(X1, X2)) -> active(U41(mark(X1), X2))
   mark(U42(X)) -> active(U42(mark(X)))
   mark(isNeList(X)) -> active(isNeList(X))
   mark(U51(X1, X2)) -> active(U51(mark(X1), X2))
   mark(U71(X1, X2)) -> active(U71(mark(X1), X2))
   mark(U72(X)) -> active(U72(mark(X)))
   mark(isPal(X)) -> active(isPal(X))
   mark(U81(X)) -> active(U81(mark(X)))
   mark(u) -> active(u)




----------------------------------------

(20)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(U61(tt)) -> mark(tt)
   active(isNePal(V)) -> mark(U61(isQid(V)))
   mark(nil) -> active(nil)
   mark(tt) -> active(tt)
   mark(U31(X)) -> active(U31(mark(X)))
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(isNePal(X)) -> active(isNePal(X))
   mark(a) -> active(a)
   mark(e) -> active(e)
   mark(i) -> active(i)
   mark(o) -> active(o)
   __(mark(X1), X2) -> __(X1, X2)
   __(X1, mark(X2)) -> __(X1, X2)
   __(active(X1), X2) -> __(X1, X2)
   __(X1, active(X2)) -> __(X1, X2)
   U11(mark(X)) -> U11(X)
   U11(active(X)) -> U11(X)
   U21(mark(X1), X2) -> U21(X1, X2)
   U21(X1, mark(X2)) -> U21(X1, X2)
   U21(active(X1), X2) -> U21(X1, X2)
   U21(X1, active(X2)) -> U21(X1, X2)
   U22(mark(X)) -> U22(X)
   U22(active(X)) -> U22(X)
   isList(mark(X)) -> isList(X)
   isList(active(X)) -> isList(X)
   U31(mark(X)) -> U31(X)
   U31(active(X)) -> U31(X)
   U41(mark(X1), X2) -> U41(X1, X2)
   U41(X1, mark(X2)) -> U41(X1, X2)
   U41(active(X1), X2) -> U41(X1, X2)
   U41(X1, active(X2)) -> U41(X1, X2)
   U42(mark(X)) -> U42(X)
   U42(active(X)) -> U42(X)
   isNeList(mark(X)) -> isNeList(X)
   isNeList(active(X)) -> isNeList(X)
   U51(mark(X1), X2) -> U51(X1, X2)
   U51(X1, mark(X2)) -> U51(X1, X2)
   U51(active(X1), X2) -> U51(X1, X2)
   U51(X1, active(X2)) -> U51(X1, X2)
   U52(mark(X)) -> U52(X)
   U52(active(X)) -> U52(X)
   U61(mark(X)) -> U61(X)
   U61(active(X)) -> U61(X)
   U71(mark(X1), X2) -> U71(X1, X2)
   U71(X1, mark(X2)) -> U71(X1, X2)
   U71(active(X1), X2) -> U71(X1, X2)
   U71(X1, active(X2)) -> U71(X1, X2)
   U72(mark(X)) -> U72(X)
   U72(active(X)) -> U72(X)
   isPal(mark(X)) -> isPal(X)
   isPal(active(X)) -> isPal(X)
   U81(mark(X)) -> U81(X)
   U81(active(X)) -> U81(X)
   isQid(mark(X)) -> isQid(X)
   isQid(active(X)) -> isQid(X)
   isNePal(mark(X)) -> isNePal(X)
   isNePal(active(X)) -> isNePal(X)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(21) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U11(x_1)) = x_1
   POL(U21(x_1, x_2)) = x_1 + x_2
   POL(U22(x_1)) = x_1
   POL(U31(x_1)) = 2 + 2*x_1
   POL(U41(x_1, x_2)) = x_1 + x_2
   POL(U42(x_1)) = x_1
   POL(U51(x_1, x_2)) = x_1 + x_2
   POL(U52(x_1)) = 1 + x_1
   POL(U61(x_1)) = 1 + x_1
   POL(U71(x_1, x_2)) = x_1 + x_2
   POL(U72(x_1)) = x_1
   POL(U81(x_1)) = x_1
   POL(__(x_1, x_2)) = x_1 + x_2
   POL(a) = 0
   POL(active(x_1)) = 1 + x_1
   POL(e) = 1
   POL(i) = 1
   POL(isList(x_1)) = x_1
   POL(isNeList(x_1)) = x_1
   POL(isNePal(x_1)) = 2 + 2*x_1
   POL(isPal(x_1)) = x_1
   POL(isQid(x_1)) = x_1
   POL(mark(x_1)) = 1 + 2*x_1
   POL(nil) = 2
   POL(o) = 1
   POL(tt) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   active(U61(tt)) -> mark(tt)
   mark(nil) -> active(nil)
   mark(isNePal(X)) -> active(isNePal(X))
   mark(e) -> active(e)
   mark(i) -> active(i)
   mark(o) -> active(o)
   __(mark(X1), X2) -> __(X1, X2)
   __(X1, mark(X2)) -> __(X1, X2)
   __(active(X1), X2) -> __(X1, X2)
   __(X1, active(X2)) -> __(X1, X2)
   U11(mark(X)) -> U11(X)
   U11(active(X)) -> U11(X)
   U21(mark(X1), X2) -> U21(X1, X2)
   U21(X1, mark(X2)) -> U21(X1, X2)
   U21(active(X1), X2) -> U21(X1, X2)
   U21(X1, active(X2)) -> U21(X1, X2)
   U22(mark(X)) -> U22(X)
   U22(active(X)) -> U22(X)
   isList(mark(X)) -> isList(X)
   isList(active(X)) -> isList(X)
   U31(mark(X)) -> U31(X)
   U31(active(X)) -> U31(X)
   U41(mark(X1), X2) -> U41(X1, X2)
   U41(X1, mark(X2)) -> U41(X1, X2)
   U41(active(X1), X2) -> U41(X1, X2)
   U41(X1, active(X2)) -> U41(X1, X2)
   U42(mark(X)) -> U42(X)
   U42(active(X)) -> U42(X)
   isNeList(mark(X)) -> isNeList(X)
   isNeList(active(X)) -> isNeList(X)
   U51(mark(X1), X2) -> U51(X1, X2)
   U51(X1, mark(X2)) -> U51(X1, X2)
   U51(active(X1), X2) -> U51(X1, X2)
   U51(X1, active(X2)) -> U51(X1, X2)
   U52(mark(X)) -> U52(X)
   U52(active(X)) -> U52(X)
   U61(mark(X)) -> U61(X)
   U61(active(X)) -> U61(X)
   U71(mark(X1), X2) -> U71(X1, X2)
   U71(X1, mark(X2)) -> U71(X1, X2)
   U71(active(X1), X2) -> U71(X1, X2)
   U71(X1, active(X2)) -> U71(X1, X2)
   U72(mark(X)) -> U72(X)
   U72(active(X)) -> U72(X)
   isPal(mark(X)) -> isPal(X)
   isPal(active(X)) -> isPal(X)
   U81(mark(X)) -> U81(X)
   U81(active(X)) -> U81(X)
   isQid(mark(X)) -> isQid(X)
   isQid(active(X)) -> isQid(X)
   isNePal(mark(X)) -> isNePal(X)
   isNePal(active(X)) -> isNePal(X)




----------------------------------------

(22)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(isNePal(V)) -> mark(U61(isQid(V)))
   mark(tt) -> active(tt)
   mark(U31(X)) -> active(U31(mark(X)))
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(a) -> active(a)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(23) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U31(x_1)) = 1 + x_1
   POL(U52(x_1)) = x_1
   POL(U61(x_1)) = x_1
   POL(a) = 0
   POL(active(x_1)) = x_1
   POL(isNePal(x_1)) = 2*x_1
   POL(isQid(x_1)) = x_1
   POL(mark(x_1)) = 2*x_1
   POL(tt) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   mark(U31(X)) -> active(U31(mark(X)))




----------------------------------------

(24)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(isNePal(V)) -> mark(U61(isQid(V)))
   mark(tt) -> active(tt)
   mark(U52(X)) -> active(U52(mark(X)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(a) -> active(a)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(25) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U52(x_1)) = 1 + x_1
   POL(U61(x_1)) = x_1
   POL(a) = 0
   POL(active(x_1)) = x_1
   POL(isNePal(x_1)) = 2*x_1
   POL(isQid(x_1)) = x_1
   POL(mark(x_1)) = 2*x_1
   POL(tt) = 1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   mark(tt) -> active(tt)
   mark(U52(X)) -> active(U52(mark(X)))




----------------------------------------

(26)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(isNePal(V)) -> mark(U61(isQid(V)))
   mark(U61(X)) -> active(U61(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(a) -> active(a)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(27) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U61(x_1)) = 2*x_1
   POL(a) = 0
   POL(active(x_1)) = x_1
   POL(isNePal(x_1)) = 2 + 2*x_1
   POL(isQid(x_1)) = x_1
   POL(mark(x_1)) = x_1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   active(isNePal(V)) -> mark(U61(isQid(V)))




----------------------------------------

(28)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   mark(U61(X)) -> active(U61(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(a) -> active(a)

The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(29) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U61(x_1)) = 1 + x_1
   POL(a) = 2
   POL(active(x_1)) = x_1
   POL(isQid(x_1)) = 2 + 2*x_1
   POL(mark(x_1)) = 1 + 2*x_1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   mark(U61(X)) -> active(U61(mark(X)))
   mark(isQid(X)) -> active(isQid(X))
   mark(a) -> active(a)




----------------------------------------

(30)
Obligation:
Q restricted rewrite system:
R is empty.
The set Q consists of the following terms:

   U72(mark(x0))
   isQid(mark(x0))
   U42(active(x0))
   mark(U11(x0))
   U51(x0, active(x1))
   U21(mark(x0), x1)
   active(U11(tt))
   U41(active(x0), x1)
   mark(a)
   active(U42(tt))
   isNePal(active(x0))
   mark(U41(x0, x1))
   active(U31(tt))
   U22(active(x0))
   U31(mark(x0))
   active(isQid(o))
   active(isQid(i))
   active(isQid(u))
   U71(x0, active(x1))
   U51(x0, mark(x1))
   active(U61(tt))
   U21(x0, active(x1))
   isNeList(mark(x0))
   active(U81(tt))
   __(x0, mark(x1))
   U61(active(x0))
   U22(mark(x0))
   mark(U72(x0))
   active(U51(tt, x0))
   U71(x0, mark(x1))
   U42(mark(x0))
   mark(U31(x0))
   U41(mark(x0), x1)
   isPal(mark(x0))
   mark(nil)
   mark(U52(x0))
   U31(active(x0))
   active(isPal(x0))
   U61(mark(x0))
   mark(isList(x0))
   mark(isPal(x0))
   isNePal(mark(x0))
   U71(active(x0), x1)
   mark(u)
   U52(active(x0))
   active(isList(x0))
   mark(isQid(x0))
   isNeList(active(x0))
   U51(active(x0), x1)
   U41(x0, active(x1))
   isPal(active(x0))
   mark(U61(x0))
   active(__(__(x0, x1), x2))
   mark(o)
   mark(tt)
   isList(active(x0))
   active(U52(tt))
   mark(e)
   __(x0, active(x1))
   mark(__(x0, x1))
   U21(x0, mark(x1))
   mark(U81(x0))
   active(isNePal(x0))
   U41(x0, mark(x1))
   U81(active(x0))
   mark(U22(x0))
   active(isQid(a))
   active(isQid(e))
   U21(active(x0), x1)
   mark(U42(x0))
   U51(mark(x0), x1)
   mark(U21(x0, x1))
   active(U41(tt, x0))
   isQid(active(x0))
   active(isNeList(x0))
   mark(i)
   U11(mark(x0))
   active(U22(tt))
   active(U71(tt, x0))
   U72(active(x0))
   U71(mark(x0), x1)
   mark(U51(x0, x1))
   __(active(x0), x1)
   U52(mark(x0))
   active(U21(tt, x0))
   mark(isNeList(x0))
   U81(mark(x0))
   active(__(x0, nil))
   active(__(nil, x0))
   U11(active(x0))
   __(mark(x0), x1)
   isList(mark(x0))
   mark(U71(x0, x1))
   active(U72(tt))
   mark(isNePal(x0))


----------------------------------------

(31) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(32)
YES
