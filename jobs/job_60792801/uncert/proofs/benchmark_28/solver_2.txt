YES

Problem 1: 

(VAR vu95NonEmpty k l lu39 s su39 t tu39 x xu39 y z)
(RULES
and(ffalse,y) -> ffalse
and(ftrue,y) -> y
eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
eq(apply(t,s),lambda(x,t)) -> ffalse
eq(apply(t,s),var(l)) -> ffalse
eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
eq(cons(t,l),nil) -> ffalse
eq(lambda(x,t),apply(t,s)) -> ffalse
eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
eq(lambda(x,t),var(l)) -> ffalse
eq(nil,cons(t,l)) -> ffalse
eq(nil,nil) -> ftrue
eq(var(l),apply(t,s)) -> ffalse
eq(var(l),lambda(x,t)) -> ffalse
eq(var(l),var(lu39)) -> eq(l,lu39)
if(ffalse,var(k),var(lu39)) -> var(lu39)
if(ftrue,var(k),var(lu39)) -> var(k)
ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
)
 
(STRATEGY INNERMOST)

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 EQ(apply(t,s),apply(tu39,su39)) -> AND(eq(t,tu39),eq(s,su39))
 EQ(apply(t,s),apply(tu39,su39)) -> EQ(s,su39)
 EQ(apply(t,s),apply(tu39,su39)) -> EQ(t,tu39)
 EQ(cons(t,l),cons(tu39,lu39)) -> AND(eq(t,tu39),eq(l,lu39))
 EQ(cons(t,l),cons(tu39,lu39)) -> EQ(l,lu39)
 EQ(cons(t,l),cons(tu39,lu39)) -> EQ(t,tu39)
 EQ(lambda(x,t),lambda(xu39,tu39)) -> AND(eq(x,xu39),eq(t,tu39))
 EQ(lambda(x,t),lambda(xu39,tu39)) -> EQ(t,tu39)
 EQ(lambda(x,t),lambda(xu39,tu39)) -> EQ(x,xu39)
 EQ(var(l),var(lu39)) -> EQ(l,lu39)
 REN(var(l),var(k),var(lu39)) -> EQ(l,lu39)
 REN(var(l),var(k),var(lu39)) -> IF(eq(l,lu39),var(k),var(lu39))
 REN(x,y,apply(t,s)) -> REN(x,y,s)
 REN(x,y,apply(t,s)) -> REN(x,y,t)
 REN(x,y,lambda(z,t)) -> REN(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t))
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))

Problem 1: 

SCC Processor:
-> Pairs:
 EQ(apply(t,s),apply(tu39,su39)) -> AND(eq(t,tu39),eq(s,su39))
 EQ(apply(t,s),apply(tu39,su39)) -> EQ(s,su39)
 EQ(apply(t,s),apply(tu39,su39)) -> EQ(t,tu39)
 EQ(cons(t,l),cons(tu39,lu39)) -> AND(eq(t,tu39),eq(l,lu39))
 EQ(cons(t,l),cons(tu39,lu39)) -> EQ(l,lu39)
 EQ(cons(t,l),cons(tu39,lu39)) -> EQ(t,tu39)
 EQ(lambda(x,t),lambda(xu39,tu39)) -> AND(eq(x,xu39),eq(t,tu39))
 EQ(lambda(x,t),lambda(xu39,tu39)) -> EQ(t,tu39)
 EQ(lambda(x,t),lambda(xu39,tu39)) -> EQ(x,xu39)
 EQ(var(l),var(lu39)) -> EQ(l,lu39)
 REN(var(l),var(k),var(lu39)) -> EQ(l,lu39)
 REN(var(l),var(k),var(lu39)) -> IF(eq(l,lu39),var(k),var(lu39))
 REN(x,y,apply(t,s)) -> REN(x,y,s)
 REN(x,y,apply(t,s)) -> REN(x,y,t)
 REN(x,y,lambda(z,t)) -> REN(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t))
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 EQ(apply(t,s),apply(tu39,su39)) -> EQ(s,su39)
 EQ(apply(t,s),apply(tu39,su39)) -> EQ(t,tu39)
 EQ(cons(t,l),cons(tu39,lu39)) -> EQ(l,lu39)
 EQ(cons(t,l),cons(tu39,lu39)) -> EQ(t,tu39)
 EQ(lambda(x,t),lambda(xu39,tu39)) -> EQ(t,tu39)
 EQ(lambda(x,t),lambda(xu39,tu39)) -> EQ(x,xu39)
 EQ(var(l),var(lu39)) -> EQ(l,lu39)
->->-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
->->Cycle:
->->-> Pairs:
 REN(x,y,apply(t,s)) -> REN(x,y,s)
 REN(x,y,apply(t,s)) -> REN(x,y,t)
 REN(x,y,lambda(z,t)) -> REN(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t))
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
->->-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))


The problem is decomposed in 2 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 EQ(apply(t,s),apply(tu39,su39)) -> EQ(s,su39)
 EQ(apply(t,s),apply(tu39,su39)) -> EQ(t,tu39)
 EQ(cons(t,l),cons(tu39,lu39)) -> EQ(l,lu39)
 EQ(cons(t,l),cons(tu39,lu39)) -> EQ(t,tu39)
 EQ(lambda(x,t),lambda(xu39,tu39)) -> EQ(t,tu39)
 EQ(lambda(x,t),lambda(xu39,tu39)) -> EQ(x,xu39)
 EQ(var(l),var(lu39)) -> EQ(l,lu39)
-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
->Projection:
 pi(EQ) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Reduction Pairs Processor:
-> Pairs:
 REN(x,y,apply(t,s)) -> REN(x,y,s)
 REN(x,y,apply(t,s)) -> REN(x,y,t)
 REN(x,y,lambda(z,t)) -> REN(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t))
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
-> Usable rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[and](X1,X2) = X2
[eq](X1,X2) = 2
[if](X1,X2,X3) = 2
[ren](X1,X2,X3) = X3
[apply](X1,X2) = 2.X1 + 2.X2 + 1
[cons](X1,X2) = 2
[fSNonEmpty] = 0
[ffalse] = 0
[lambda](X1,X2) = 2.X2 + 2
[nil] = 1
[ftrue] = 1
[var](X) = 2
[AND](X1,X2) = 0
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[REN](X1,X2,X3) = 2.X2 + 2.X3

Problem 1.2: 

SCC Processor:
-> Pairs:
 REN(x,y,apply(t,s)) -> REN(x,y,t)
 REN(x,y,lambda(z,t)) -> REN(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t))
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 REN(x,y,apply(t,s)) -> REN(x,y,t)
 REN(x,y,lambda(z,t)) -> REN(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t))
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
->->-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))

Problem 1.2: 

Reduction Pairs Processor:
-> Pairs:
 REN(x,y,apply(t,s)) -> REN(x,y,t)
 REN(x,y,lambda(z,t)) -> REN(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t))
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
-> Usable rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[and](X1,X2) = X2
[eq](X1,X2) = 2
[if](X1,X2,X3) = 2.X2 + X3
[ren](X1,X2,X3) = 2.X1 + 2.X2 + X3
[apply](X1,X2) = X1 + 1
[cons](X1,X2) = 1
[fSNonEmpty] = 0
[ffalse] = 0
[lambda](X1,X2) = 2.X1 + X2 + 1
[nil] = 0
[ftrue] = 1
[var](X) = 0
[AND](X1,X2) = 0
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[REN](X1,X2,X3) = 2.X1 + 2.X3

Problem 1.2: 

SCC Processor:
-> Pairs:
 REN(x,y,lambda(z,t)) -> REN(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t))
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 REN(x,y,lambda(z,t)) -> REN(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t))
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
->->-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))

Problem 1.2: 

Reduction Pairs Processor:
-> Pairs:
 REN(x,y,lambda(z,t)) -> REN(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t))
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
-> Usable rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[and](X1,X2) = X2
[eq](X1,X2) = 2
[if](X1,X2,X3) = 2
[ren](X1,X2,X3) = X3
[apply](X1,X2) = 2.X2
[cons](X1,X2) = 0
[fSNonEmpty] = 0
[ffalse] = 0
[lambda](X1,X2) = 2.X2 + 1
[nil] = 0
[ftrue] = 2
[var](X) = 2
[AND](X1,X2) = 0
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[REN](X1,X2,X3) = X2 + 2.X3

Problem 1.2: 

SCC Processor:
-> Pairs:
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
->->-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))

Problem 1.2: 

Subterm Processor:
-> Pairs:
 REN(x,y,lambda(z,t)) -> REN(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)
-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
->Projection:
 pi(REN) = 3

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(ffalse,y) -> ffalse
 and(ftrue,y) -> y
 eq(apply(t,s),apply(tu39,su39)) -> and(eq(t,tu39),eq(s,su39))
 eq(apply(t,s),lambda(x,t)) -> ffalse
 eq(apply(t,s),var(l)) -> ffalse
 eq(cons(t,l),cons(tu39,lu39)) -> and(eq(t,tu39),eq(l,lu39))
 eq(cons(t,l),nil) -> ffalse
 eq(lambda(x,t),apply(t,s)) -> ffalse
 eq(lambda(x,t),lambda(xu39,tu39)) -> and(eq(x,xu39),eq(t,tu39))
 eq(lambda(x,t),var(l)) -> ffalse
 eq(nil,cons(t,l)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(l),apply(t,s)) -> ffalse
 eq(var(l),lambda(x,t)) -> ffalse
 eq(var(l),var(lu39)) -> eq(l,lu39)
 if(ffalse,var(k),var(lu39)) -> var(lu39)
 if(ftrue,var(k),var(lu39)) -> var(k)
 ren(var(l),var(k),var(lu39)) -> if(eq(l,lu39),var(k),var(lu39))
 ren(x,y,apply(t,s)) -> apply(ren(x,y,t),ren(x,y,s))
 ren(x,y,lambda(z,t)) -> lambda(var(cons(x,cons(y,cons(lambda(z,t),nil)))),ren(x,y,ren(z,var(cons(x,cons(y,cons(lambda(z,t),nil)))),t)))
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
