YES
proof of /home/ff862203/input_nwxt7hA4Mo.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) QTRSRRRProof [EQUIVALENT, 30 ms]
(2) QTRS
(3) QTRSRRRProof [EQUIVALENT, 0 ms]
(4) QTRS
(5) RisEmptyProof [EQUIVALENT, 0 ms]
(6) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   append(@l1, @l2) -> append#1(@l1, @l2)
   append#1(::(@x, @xs), @l2) -> ::(@x, append(@xs, @l2))
   append#1(nil, @l2) -> @l2
   subtrees(@t) -> subtrees#1(@t)
   subtrees#1(leaf) -> nil
   subtrees#1(node(@x, @t1, @t2)) -> subtrees#2(subtrees(@t1), @t1, @t2, @x)
   subtrees#2(@l1, @t1, @t2, @x) -> subtrees#3(subtrees(@t2), @l1, @t1, @t2, @x)
   subtrees#3(@l2, @l1, @t1, @t2, @x) -> ::(node(@x, @t1, @t2), append(@l1, @l2))

The set Q consists of the following terms:

   append#1(::(x0, x1), x2)
   append(x0, x1)
   subtrees#2(x0, x1, x2, x3)
   subtrees#3(x0, x1, x2, x3, x4)
   subtrees#1(node(x0, x1, x2))
   subtrees#1(leaf)
   append#1(nil, x0)
   subtrees(x0)


----------------------------------------

(1) QTRSRRRProof (EQUIVALENT)
Used ordering:
Quasi precedence:
[nil, subtrees_1, subtrees#1_1, subtrees#2_4] > [node_3, subtrees#3_5] > [append_2, append#1_2] > ::_2


Status:
append_2: multiset status
append#1_2: multiset status
::_2: multiset status
nil: multiset status
subtrees_1: [1]
subtrees#1_1: [1]
leaf: multiset status
node_3: multiset status
subtrees#2_4: [3,1,2,4]
subtrees#3_5: multiset status

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   append#1(::(@x, @xs), @l2) -> ::(@x, append(@xs, @l2))
   append#1(nil, @l2) -> @l2
   subtrees#1(leaf) -> nil
   subtrees#1(node(@x, @t1, @t2)) -> subtrees#2(subtrees(@t1), @t1, @t2, @x)
   subtrees#2(@l1, @t1, @t2, @x) -> subtrees#3(subtrees(@t2), @l1, @t1, @t2, @x)
   subtrees#3(@l2, @l1, @t1, @t2, @x) -> ::(node(@x, @t1, @t2), append(@l1, @l2))




----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   append(@l1, @l2) -> append#1(@l1, @l2)
   subtrees(@t) -> subtrees#1(@t)

The set Q consists of the following terms:

   append#1(::(x0, x1), x2)
   append(x0, x1)
   subtrees#2(x0, x1, x2, x3)
   subtrees#3(x0, x1, x2, x3, x4)
   subtrees#1(node(x0, x1, x2))
   subtrees#1(leaf)
   append#1(nil, x0)
   subtrees(x0)


----------------------------------------

(3) QTRSRRRProof (EQUIVALENT)
Used ordering:
Knuth-Bendix order [KBO] with precedence:subtrees_1 > subtrees#1_1 > append_2 > append#1_2

and weight map:

   subtrees_1=1
   subtrees#1_1=1
   append_2=0
   append#1_2=0

The variable weight is 1With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   append(@l1, @l2) -> append#1(@l1, @l2)
   subtrees(@t) -> subtrees#1(@t)




----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
R is empty.
The set Q consists of the following terms:

   append#1(::(x0, x1), x2)
   append(x0, x1)
   subtrees#2(x0, x1, x2, x3)
   subtrees#3(x0, x1, x2, x3, x4)
   subtrees#1(node(x0, x1, x2))
   subtrees#1(leaf)
   append#1(nil, x0)
   subtrees(x0)


----------------------------------------

(5) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(6)
YES
