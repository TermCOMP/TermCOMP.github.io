YES
proof of /home/ff862203/input_qH7B03Grj7.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) DependencyPairsProof [EQUIVALENT, 36 ms]
(2) QDP
(3) DependencyGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) QDP
        (6) UsableRulesProof [EQUIVALENT, 0 ms]
        (7) QDP
        (8) QReductionProof [EQUIVALENT, 0 ms]
        (9) QDP
        (10) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (11) YES
    (12) QDP
        (13) UsableRulesProof [EQUIVALENT, 0 ms]
        (14) QDP
        (15) QReductionProof [EQUIVALENT, 0 ms]
        (16) QDP
        (17) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (18) YES
    (19) QDP
        (20) UsableRulesProof [EQUIVALENT, 0 ms]
        (21) QDP
        (22) QReductionProof [EQUIVALENT, 0 ms]
        (23) QDP
        (24) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (25) YES
    (26) QDP
        (27) UsableRulesProof [EQUIVALENT, 0 ms]
        (28) QDP
        (29) QReductionProof [EQUIVALENT, 0 ms]
        (30) QDP
        (31) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (32) YES
    (33) QDP
        (34) UsableRulesProof [EQUIVALENT, 0 ms]
        (35) QDP
        (36) QReductionProof [EQUIVALENT, 0 ms]
        (37) QDP
        (38) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (39) YES
    (40) QDP
        (41) UsableRulesProof [EQUIVALENT, 0 ms]
        (42) QDP
        (43) QReductionProof [EQUIVALENT, 0 ms]
        (44) QDP
        (45) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (46) YES
    (47) QDP
        (48) UsableRulesProof [EQUIVALENT, 0 ms]
        (49) QDP
        (50) QReductionProof [EQUIVALENT, 0 ms]
        (51) QDP
        (52) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (53) YES
    (54) QDP
        (55) UsableRulesProof [EQUIVALENT, 0 ms]
        (56) QDP
        (57) QReductionProof [EQUIVALENT, 0 ms]
        (58) QDP
        (59) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (60) YES
    (61) QDP
        (62) UsableRulesProof [EQUIVALENT, 0 ms]
        (63) QDP
        (64) QReductionProof [EQUIVALENT, 0 ms]
        (65) QDP
        (66) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (67) YES
    (68) QDP
        (69) UsableRulesProof [EQUIVALENT, 0 ms]
        (70) QDP
        (71) QReductionProof [EQUIVALENT, 0 ms]
        (72) QDP
        (73) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (74) YES
    (75) QDP
        (76) UsableRulesProof [EQUIVALENT, 0 ms]
        (77) QDP
        (78) QReductionProof [EQUIVALENT, 0 ms]
        (79) QDP
        (80) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (81) YES
    (82) QDP
        (83) UsableRulesProof [EQUIVALENT, 0 ms]
        (84) QDP
        (85) QReductionProof [EQUIVALENT, 0 ms]
        (86) QDP
        (87) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (88) YES
    (89) QDP
        (90) UsableRulesProof [EQUIVALENT, 0 ms]
        (91) QDP
        (92) QReductionProof [EQUIVALENT, 0 ms]
        (93) QDP
        (94) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (95) YES
    (96) QDP
        (97) QDPQMonotonicMRRProof [EQUIVALENT, 210 ms]
        (98) QDP
        (99) QDPQMonotonicMRRProof [EQUIVALENT, 91 ms]
        (100) QDP
        (101) QDPOrderProof [EQUIVALENT, 291 ms]
        (102) QDP
        (103) QDPOrderProof [EQUIVALENT, 286 ms]
        (104) QDP
        (105) QDPOrderProof [EQUIVALENT, 289 ms]
        (106) QDP
        (107) QDPQMonotonicMRRProof [EQUIVALENT, 14 ms]
        (108) QDP
        (109) QDPOrderProof [EQUIVALENT, 301 ms]
        (110) QDP
        (111) QDPOrderProof [EQUIVALENT, 286 ms]
        (112) QDP
        (113) QDPQMonotonicMRRProof [EQUIVALENT, 54 ms]
        (114) QDP
        (115) QDPOrderProof [EQUIVALENT, 244 ms]
        (116) QDP
        (117) QDPOrderProof [EQUIVALENT, 270 ms]
        (118) QDP
        (119) QDPOrderProof [EQUIVALENT, 264 ms]
        (120) QDP
        (121) QDPOrderProof [EQUIVALENT, 274 ms]
        (122) QDP
        (123) QDPOrderProof [EQUIVALENT, 233 ms]
        (124) QDP
        (125) QDPOrderProof [EQUIVALENT, 283 ms]
        (126) QDP
        (127) QDPOrderProof [EQUIVALENT, 242 ms]
        (128) QDP
        (129) QDPOrderProof [EQUIVALENT, 195 ms]
        (130) QDP
        (131) QDPOrderProof [EQUIVALENT, 288 ms]
        (132) QDP
        (133) DependencyGraphProof [EQUIVALENT, 0 ms]
        (134) QDP
        (135) QDPQMonotonicMRRProof [EQUIVALENT, 43 ms]
        (136) QDP
        (137) QDPQMonotonicMRRProof [EQUIVALENT, 42 ms]
        (138) QDP
        (139) QDPQMonotonicMRRProof [EQUIVALENT, 81 ms]
        (140) QDP
        (141) QDPOrderProof [EQUIVALENT, 336 ms]
        (142) QDP
        (143) DependencyGraphProof [EQUIVALENT, 0 ms]
        (144) QDP
        (145) QDPOrderProof [EQUIVALENT, 45 ms]
        (146) QDP
        (147) DependencyGraphProof [EQUIVALENT, 0 ms]
        (148) QDP
        (149) QDPOrderProof [EQUIVALENT, 5 ms]
        (150) QDP
        (151) DependencyGraphProof [EQUIVALENT, 0 ms]
        (152) TRUE


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))


----------------------------------------

(1) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(2)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   ACTIVE(from(X)) -> CONS(X, from(s(X)))
   ACTIVE(from(X)) -> FROM(s(X))
   ACTIVE(from(X)) -> S(X)
   ACTIVE(2ndspos(0, Z)) -> MARK(rnil)
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> 2NDSPOS(s(N), cons2(X, Z))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> CONS2(X, Z)
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> RCONS(posrecip(Y), 2ndsneg(N, Z))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> POSRECIP(Y)
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> 2NDSNEG(N, Z)
   ACTIVE(2ndsneg(0, Z)) -> MARK(rnil)
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> 2NDSNEG(s(N), cons2(X, Z))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> CONS2(X, Z)
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> RCONS(negrecip(Y), 2ndspos(N, Z))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> NEGRECIP(Y)
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> 2NDSPOS(N, Z)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   ACTIVE(pi(X)) -> 2NDSPOS(X, from(0))
   ACTIVE(pi(X)) -> FROM(0)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(plus(s(X), Y)) -> S(plus(X, Y))
   ACTIVE(plus(s(X), Y)) -> PLUS(X, Y)
   ACTIVE(times(0, Y)) -> MARK(0)
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   ACTIVE(times(s(X), Y)) -> PLUS(Y, times(X, Y))
   ACTIVE(times(s(X), Y)) -> TIMES(X, Y)
   ACTIVE(square(X)) -> MARK(times(X, X))
   ACTIVE(square(X)) -> TIMES(X, X)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   MARK(from(X)) -> FROM(mark(X))
   MARK(from(X)) -> MARK(X)
   MARK(cons(X1, X2)) -> ACTIVE(cons(mark(X1), X2))
   MARK(cons(X1, X2)) -> CONS(mark(X1), X2)
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> ACTIVE(s(mark(X)))
   MARK(s(X)) -> S(mark(X))
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   MARK(2ndspos(X1, X2)) -> 2NDSPOS(mark(X1), mark(X2))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(0) -> ACTIVE(0)
   MARK(rnil) -> ACTIVE(rnil)
   MARK(cons2(X1, X2)) -> ACTIVE(cons2(X1, mark(X2)))
   MARK(cons2(X1, X2)) -> CONS2(X1, mark(X2))
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> ACTIVE(rcons(mark(X1), mark(X2)))
   MARK(rcons(X1, X2)) -> RCONS(mark(X1), mark(X2))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(posrecip(X)) -> ACTIVE(posrecip(mark(X)))
   MARK(posrecip(X)) -> POSRECIP(mark(X))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> 2NDSNEG(mark(X1), mark(X2))
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> ACTIVE(negrecip(mark(X)))
   MARK(negrecip(X)) -> NEGRECIP(mark(X))
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> PI(mark(X))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> PLUS(mark(X1), mark(X2))
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> TIMES(mark(X1), mark(X2))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))
   MARK(square(X)) -> SQUARE(mark(X))
   MARK(square(X)) -> MARK(X)
   FROM(mark(X)) -> FROM(X)
   FROM(active(X)) -> FROM(X)
   CONS(mark(X1), X2) -> CONS(X1, X2)
   CONS(X1, mark(X2)) -> CONS(X1, X2)
   CONS(active(X1), X2) -> CONS(X1, X2)
   CONS(X1, active(X2)) -> CONS(X1, X2)
   S(mark(X)) -> S(X)
   S(active(X)) -> S(X)
   2NDSPOS(mark(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(X1, mark(X2)) -> 2NDSPOS(X1, X2)
   2NDSPOS(active(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(X1, active(X2)) -> 2NDSPOS(X1, X2)
   CONS2(mark(X1), X2) -> CONS2(X1, X2)
   CONS2(X1, mark(X2)) -> CONS2(X1, X2)
   CONS2(active(X1), X2) -> CONS2(X1, X2)
   CONS2(X1, active(X2)) -> CONS2(X1, X2)
   RCONS(mark(X1), X2) -> RCONS(X1, X2)
   RCONS(X1, mark(X2)) -> RCONS(X1, X2)
   RCONS(active(X1), X2) -> RCONS(X1, X2)
   RCONS(X1, active(X2)) -> RCONS(X1, X2)
   POSRECIP(mark(X)) -> POSRECIP(X)
   POSRECIP(active(X)) -> POSRECIP(X)
   2NDSNEG(mark(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(X1, mark(X2)) -> 2NDSNEG(X1, X2)
   2NDSNEG(active(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(X1, active(X2)) -> 2NDSNEG(X1, X2)
   NEGRECIP(mark(X)) -> NEGRECIP(X)
   NEGRECIP(active(X)) -> NEGRECIP(X)
   PI(mark(X)) -> PI(X)
   PI(active(X)) -> PI(X)
   PLUS(mark(X1), X2) -> PLUS(X1, X2)
   PLUS(X1, mark(X2)) -> PLUS(X1, X2)
   PLUS(active(X1), X2) -> PLUS(X1, X2)
   PLUS(X1, active(X2)) -> PLUS(X1, X2)
   TIMES(mark(X1), X2) -> TIMES(X1, X2)
   TIMES(X1, mark(X2)) -> TIMES(X1, X2)
   TIMES(active(X1), X2) -> TIMES(X1, X2)
   TIMES(X1, active(X2)) -> TIMES(X1, X2)
   SQUARE(mark(X)) -> SQUARE(X)
   SQUARE(active(X)) -> SQUARE(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(3) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 14 SCCs with 38 less nodes.
----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SQUARE(active(X)) -> SQUARE(X)
   SQUARE(mark(X)) -> SQUARE(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(6) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(7)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SQUARE(active(X)) -> SQUARE(X)
   SQUARE(mark(X)) -> SQUARE(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(8) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SQUARE(active(X)) -> SQUARE(X)
   SQUARE(mark(X)) -> SQUARE(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(10) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*SQUARE(active(X)) -> SQUARE(X)
The graph contains the following edges 1 > 1


*SQUARE(mark(X)) -> SQUARE(X)
The graph contains the following edges 1 > 1


----------------------------------------

(11)
YES

----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TIMES(X1, mark(X2)) -> TIMES(X1, X2)
   TIMES(mark(X1), X2) -> TIMES(X1, X2)
   TIMES(active(X1), X2) -> TIMES(X1, X2)
   TIMES(X1, active(X2)) -> TIMES(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(13) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TIMES(X1, mark(X2)) -> TIMES(X1, X2)
   TIMES(mark(X1), X2) -> TIMES(X1, X2)
   TIMES(active(X1), X2) -> TIMES(X1, X2)
   TIMES(X1, active(X2)) -> TIMES(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(15) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TIMES(X1, mark(X2)) -> TIMES(X1, X2)
   TIMES(mark(X1), X2) -> TIMES(X1, X2)
   TIMES(active(X1), X2) -> TIMES(X1, X2)
   TIMES(X1, active(X2)) -> TIMES(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(17) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*TIMES(X1, mark(X2)) -> TIMES(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*TIMES(mark(X1), X2) -> TIMES(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*TIMES(active(X1), X2) -> TIMES(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*TIMES(X1, active(X2)) -> TIMES(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(18)
YES

----------------------------------------

(19)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PLUS(X1, mark(X2)) -> PLUS(X1, X2)
   PLUS(mark(X1), X2) -> PLUS(X1, X2)
   PLUS(active(X1), X2) -> PLUS(X1, X2)
   PLUS(X1, active(X2)) -> PLUS(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(20) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(21)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PLUS(X1, mark(X2)) -> PLUS(X1, X2)
   PLUS(mark(X1), X2) -> PLUS(X1, X2)
   PLUS(active(X1), X2) -> PLUS(X1, X2)
   PLUS(X1, active(X2)) -> PLUS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(22) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(23)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PLUS(X1, mark(X2)) -> PLUS(X1, X2)
   PLUS(mark(X1), X2) -> PLUS(X1, X2)
   PLUS(active(X1), X2) -> PLUS(X1, X2)
   PLUS(X1, active(X2)) -> PLUS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(24) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*PLUS(X1, mark(X2)) -> PLUS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*PLUS(mark(X1), X2) -> PLUS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*PLUS(active(X1), X2) -> PLUS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*PLUS(X1, active(X2)) -> PLUS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(25)
YES

----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PI(active(X)) -> PI(X)
   PI(mark(X)) -> PI(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(27) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PI(active(X)) -> PI(X)
   PI(mark(X)) -> PI(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(29) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PI(active(X)) -> PI(X)
   PI(mark(X)) -> PI(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(31) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*PI(active(X)) -> PI(X)
The graph contains the following edges 1 > 1


*PI(mark(X)) -> PI(X)
The graph contains the following edges 1 > 1


----------------------------------------

(32)
YES

----------------------------------------

(33)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   NEGRECIP(active(X)) -> NEGRECIP(X)
   NEGRECIP(mark(X)) -> NEGRECIP(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(34) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(35)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   NEGRECIP(active(X)) -> NEGRECIP(X)
   NEGRECIP(mark(X)) -> NEGRECIP(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(36) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(37)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   NEGRECIP(active(X)) -> NEGRECIP(X)
   NEGRECIP(mark(X)) -> NEGRECIP(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(38) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*NEGRECIP(active(X)) -> NEGRECIP(X)
The graph contains the following edges 1 > 1


*NEGRECIP(mark(X)) -> NEGRECIP(X)
The graph contains the following edges 1 > 1


----------------------------------------

(39)
YES

----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   2NDSNEG(X1, mark(X2)) -> 2NDSNEG(X1, X2)
   2NDSNEG(mark(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(active(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(X1, active(X2)) -> 2NDSNEG(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(41) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   2NDSNEG(X1, mark(X2)) -> 2NDSNEG(X1, X2)
   2NDSNEG(mark(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(active(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(X1, active(X2)) -> 2NDSNEG(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(43) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   2NDSNEG(X1, mark(X2)) -> 2NDSNEG(X1, X2)
   2NDSNEG(mark(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(active(X1), X2) -> 2NDSNEG(X1, X2)
   2NDSNEG(X1, active(X2)) -> 2NDSNEG(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(45) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*2NDSNEG(X1, mark(X2)) -> 2NDSNEG(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*2NDSNEG(mark(X1), X2) -> 2NDSNEG(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*2NDSNEG(active(X1), X2) -> 2NDSNEG(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*2NDSNEG(X1, active(X2)) -> 2NDSNEG(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(46)
YES

----------------------------------------

(47)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   POSRECIP(active(X)) -> POSRECIP(X)
   POSRECIP(mark(X)) -> POSRECIP(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(48) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(49)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   POSRECIP(active(X)) -> POSRECIP(X)
   POSRECIP(mark(X)) -> POSRECIP(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(50) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(51)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   POSRECIP(active(X)) -> POSRECIP(X)
   POSRECIP(mark(X)) -> POSRECIP(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(52) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*POSRECIP(active(X)) -> POSRECIP(X)
The graph contains the following edges 1 > 1


*POSRECIP(mark(X)) -> POSRECIP(X)
The graph contains the following edges 1 > 1


----------------------------------------

(53)
YES

----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RCONS(X1, mark(X2)) -> RCONS(X1, X2)
   RCONS(mark(X1), X2) -> RCONS(X1, X2)
   RCONS(active(X1), X2) -> RCONS(X1, X2)
   RCONS(X1, active(X2)) -> RCONS(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(55) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RCONS(X1, mark(X2)) -> RCONS(X1, X2)
   RCONS(mark(X1), X2) -> RCONS(X1, X2)
   RCONS(active(X1), X2) -> RCONS(X1, X2)
   RCONS(X1, active(X2)) -> RCONS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(57) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   RCONS(X1, mark(X2)) -> RCONS(X1, X2)
   RCONS(mark(X1), X2) -> RCONS(X1, X2)
   RCONS(active(X1), X2) -> RCONS(X1, X2)
   RCONS(X1, active(X2)) -> RCONS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(59) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*RCONS(X1, mark(X2)) -> RCONS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*RCONS(mark(X1), X2) -> RCONS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*RCONS(active(X1), X2) -> RCONS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*RCONS(X1, active(X2)) -> RCONS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(60)
YES

----------------------------------------

(61)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   CONS2(X1, mark(X2)) -> CONS2(X1, X2)
   CONS2(mark(X1), X2) -> CONS2(X1, X2)
   CONS2(active(X1), X2) -> CONS2(X1, X2)
   CONS2(X1, active(X2)) -> CONS2(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(62) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(63)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   CONS2(X1, mark(X2)) -> CONS2(X1, X2)
   CONS2(mark(X1), X2) -> CONS2(X1, X2)
   CONS2(active(X1), X2) -> CONS2(X1, X2)
   CONS2(X1, active(X2)) -> CONS2(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(64) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(65)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   CONS2(X1, mark(X2)) -> CONS2(X1, X2)
   CONS2(mark(X1), X2) -> CONS2(X1, X2)
   CONS2(active(X1), X2) -> CONS2(X1, X2)
   CONS2(X1, active(X2)) -> CONS2(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(66) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*CONS2(X1, mark(X2)) -> CONS2(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*CONS2(mark(X1), X2) -> CONS2(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*CONS2(active(X1), X2) -> CONS2(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*CONS2(X1, active(X2)) -> CONS2(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(67)
YES

----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   2NDSPOS(X1, mark(X2)) -> 2NDSPOS(X1, X2)
   2NDSPOS(mark(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(active(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(X1, active(X2)) -> 2NDSPOS(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(69) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   2NDSPOS(X1, mark(X2)) -> 2NDSPOS(X1, X2)
   2NDSPOS(mark(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(active(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(X1, active(X2)) -> 2NDSPOS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(71) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   2NDSPOS(X1, mark(X2)) -> 2NDSPOS(X1, X2)
   2NDSPOS(mark(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(active(X1), X2) -> 2NDSPOS(X1, X2)
   2NDSPOS(X1, active(X2)) -> 2NDSPOS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(73) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*2NDSPOS(X1, mark(X2)) -> 2NDSPOS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*2NDSPOS(mark(X1), X2) -> 2NDSPOS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*2NDSPOS(active(X1), X2) -> 2NDSPOS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*2NDSPOS(X1, active(X2)) -> 2NDSPOS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(74)
YES

----------------------------------------

(75)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S(active(X)) -> S(X)
   S(mark(X)) -> S(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(76) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(77)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S(active(X)) -> S(X)
   S(mark(X)) -> S(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(78) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(79)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S(active(X)) -> S(X)
   S(mark(X)) -> S(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(80) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*S(active(X)) -> S(X)
The graph contains the following edges 1 > 1


*S(mark(X)) -> S(X)
The graph contains the following edges 1 > 1


----------------------------------------

(81)
YES

----------------------------------------

(82)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   CONS(X1, mark(X2)) -> CONS(X1, X2)
   CONS(mark(X1), X2) -> CONS(X1, X2)
   CONS(active(X1), X2) -> CONS(X1, X2)
   CONS(X1, active(X2)) -> CONS(X1, X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(83) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(84)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   CONS(X1, mark(X2)) -> CONS(X1, X2)
   CONS(mark(X1), X2) -> CONS(X1, X2)
   CONS(active(X1), X2) -> CONS(X1, X2)
   CONS(X1, active(X2)) -> CONS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(85) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(86)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   CONS(X1, mark(X2)) -> CONS(X1, X2)
   CONS(mark(X1), X2) -> CONS(X1, X2)
   CONS(active(X1), X2) -> CONS(X1, X2)
   CONS(X1, active(X2)) -> CONS(X1, X2)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(87) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*CONS(X1, mark(X2)) -> CONS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


*CONS(mark(X1), X2) -> CONS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*CONS(active(X1), X2) -> CONS(X1, X2)
The graph contains the following edges 1 > 1, 2 >= 2


*CONS(X1, active(X2)) -> CONS(X1, X2)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(88)
YES

----------------------------------------

(89)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FROM(active(X)) -> FROM(X)
   FROM(mark(X)) -> FROM(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(90) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(91)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FROM(active(X)) -> FROM(X)
   FROM(mark(X)) -> FROM(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(92) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   pi(active(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   posrecip(active(x0))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   rcons(mark(x0), x1)
   cons(x0, mark(x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   2ndspos(x0, mark(x1))


----------------------------------------

(93)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FROM(active(X)) -> FROM(X)
   FROM(mark(X)) -> FROM(X)

R is empty.
The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   mark(times(x0, x1))
   active(square(x0))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   active(plus(0, x0))
   mark(2ndsneg(x0, x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   mark(rcons(x0, x1))
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(94) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*FROM(active(X)) -> FROM(X)
The graph contains the following edges 1 > 1


*FROM(mark(X)) -> FROM(X)
The graph contains the following edges 1 > 1


----------------------------------------

(95)
YES

----------------------------------------

(96)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MARK(cons(X1, X2)) -> ACTIVE(cons(mark(X1), X2))
   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   MARK(rcons(X1, X2)) -> ACTIVE(rcons(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   MARK(s(X)) -> ACTIVE(s(mark(X)))
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(cons2(X1, X2)) -> ACTIVE(cons2(X1, mark(X2)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(posrecip(X)) -> ACTIVE(posrecip(mark(X)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(square(X)) -> MARK(times(X, X))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> ACTIVE(negrecip(mark(X)))
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))
   MARK(square(X)) -> MARK(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(97) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(rcons(X1, X2)) -> ACTIVE(rcons(mark(X1), mark(X2)))
   MARK(s(X)) -> ACTIVE(s(mark(X)))
   MARK(cons2(X1, X2)) -> ACTIVE(cons2(X1, mark(X2)))
   MARK(negrecip(X)) -> ACTIVE(negrecip(mark(X)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = x_1
   POL(MARK(x_1)) = 1
   POL(active(x_1)) = 0
   POL(cons(x_1, x_2)) = 1
   POL(cons2(x_1, x_2)) = 0
   POL(from(x_1)) = 1
   POL(mark(x_1)) = 0
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 1
   POL(plus(x_1, x_2)) = 1
   POL(posrecip(x_1)) = 1
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 1
   POL(times(x_1, x_2)) = 1


----------------------------------------

(98)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MARK(cons(X1, X2)) -> ACTIVE(cons(mark(X1), X2))
   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(posrecip(X)) -> ACTIVE(posrecip(mark(X)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(square(X)) -> MARK(times(X, X))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))
   MARK(square(X)) -> MARK(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(99) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(cons(X1, X2)) -> ACTIVE(cons(mark(X1), X2))
   MARK(posrecip(X)) -> ACTIVE(posrecip(mark(X)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = x_1
   POL(MARK(x_1)) = 1
   POL(active(x_1)) = 2*x_1
   POL(cons(x_1, x_2)) = 0
   POL(cons2(x_1, x_2)) = 0
   POL(from(x_1)) = 1
   POL(mark(x_1)) = 2
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 1
   POL(plus(x_1, x_2)) = 1
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 1
   POL(times(x_1, x_2)) = 1


----------------------------------------

(100)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(square(X)) -> MARK(times(X, X))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))
   MARK(square(X)) -> MARK(X)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(101) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(square(X)) -> MARK(X)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(square(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(active(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)


----------------------------------------

(102)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(square(X)) -> MARK(times(X, X))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(pi(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(103) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(pi(X)) -> MARK(X)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(square(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)


----------------------------------------

(104)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(square(X)) -> MARK(times(X, X))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(105) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ACTIVE(square(X)) -> MARK(times(X, X))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(square(x_1)) =  	[[2A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(active(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)


----------------------------------------

(106)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)
   MARK(square(X)) -> ACTIVE(square(mark(X)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(107) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(square(X)) -> ACTIVE(square(mark(X)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = 2*x_1
   POL(MARK(x_1)) = 2
   POL(active(x_1)) = 0
   POL(cons(x_1, x_2)) = 0
   POL(cons2(x_1, x_2)) = 0
   POL(from(x_1)) = 1
   POL(mark(x_1)) = 0
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 1
   POL(plus(x_1, x_2)) = 1
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 0
   POL(times(x_1, x_2)) = 1


----------------------------------------

(108)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(2ndspos(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(109) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(2ndspos(X1, X2)) -> MARK(X1)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[5A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[4A]] 	 +  	[[2A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[2A]] 	 +  	[[2A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[5A]] 	 +  	[[2A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(110)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(111) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ACTIVE(pi(X)) -> MARK(2ndspos(X, from(0)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[3A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[1A]]
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(112)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(pi(X)) -> ACTIVE(pi(mark(X)))
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(113) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(pi(X)) -> ACTIVE(pi(mark(X)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = x_1
   POL(MARK(x_1)) = 1
   POL(active(x_1)) = 0
   POL(cons(x_1, x_2)) = 0
   POL(cons2(x_1, x_2)) = 0
   POL(from(x_1)) = 1
   POL(mark(x_1)) = 0
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 0
   POL(plus(x_1, x_2)) = 1
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 0
   POL(times(x_1, x_2)) = 1


----------------------------------------

(114)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> MARK(X1)
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(115) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(times(X1, X2)) -> MARK(X1)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[3A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[3A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[2A]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[1A]] 	 +  	[[4A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[3A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(116)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> MARK(X)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(117) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(from(X)) -> MARK(X)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(118)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(119) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(times(X1, X2)) -> MARK(X2)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[1A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[0A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(120)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X1)
   MARK(plus(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(121) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(plus(X1, X2)) -> MARK(X1)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[1A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[1A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(122)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X1)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(123) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(rcons(X1, X2)) -> MARK(X1)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[2A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[2A]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[1A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[-I]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[2A]] 	 +  	[[2A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(124)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(negrecip(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(125) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(negrecip(X)) -> MARK(X)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(126)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(posrecip(X)) -> MARK(X)
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(plus(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(127) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(posrecip(X)) -> MARK(X)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[1A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(128)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X1)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(plus(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(129) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(2ndsneg(X1, X2)) -> MARK(X1)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[0A]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[0A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[1A]] 	 +  	[[2A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[0A]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(130)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(cons(X1, X2)) -> MARK(X1)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(plus(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(131) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MARK(cons(X1, X2)) -> MARK(X1)
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(ACTIVE(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(from(x_1)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL(MARK(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(mark(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndspos(x_1, x_2)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(cons2(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(rcons(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(posrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(2ndsneg(x_1, x_2)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(negrecip(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(plus(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(times(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[-I]] 	* 	x_2
>>>

   <<<
 POL(active(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(pi(x_1)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(square(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(rnil) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(132)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(from(X)) -> MARK(cons(X, from(s(X))))
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(plus(X1, X2)) -> MARK(X2)

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(133) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(134)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   MARK(from(X)) -> ACTIVE(from(mark(X)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(135) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(from(X)) -> ACTIVE(from(mark(X)))


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 1
   POL(2ndspos(x_1, x_2)) = 1
   POL(ACTIVE(x_1)) = x_1
   POL(MARK(x_1)) = 1
   POL(active(x_1)) = 0
   POL(cons(x_1, x_2)) = 0
   POL(cons2(x_1, x_2)) = 0
   POL(from(x_1)) = 0
   POL(mark(x_1)) = 0
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 0
   POL(plus(x_1, x_2)) = 1
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = 0
   POL(rnil) = 0
   POL(s(x_1)) = 0
   POL(square(x_1)) = 0
   POL(times(x_1, x_2)) = 1


----------------------------------------

(136)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(137) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(2ndspos(X1, X2)) -> MARK(X2)
   MARK(2ndsneg(X1, X2)) -> MARK(X2)


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 2 + 2*x_2
   POL(2ndspos(x_1, x_2)) = 2 + 2*x_2
   POL(ACTIVE(x_1)) = x_1
   POL(MARK(x_1)) = x_1
   POL(active(x_1)) = x_1
   POL(cons(x_1, x_2)) = 2*x_2
   POL(cons2(x_1, x_2)) = 2*x_2
   POL(from(x_1)) = 0
   POL(mark(x_1)) = x_1
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 2
   POL(plus(x_1, x_2)) = 2*x_2
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = x_2
   POL(rnil) = 2
   POL(s(x_1)) = x_1
   POL(square(x_1)) = 0
   POL(times(x_1, x_2)) = 0


----------------------------------------

(138)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(cons2(X1, X2)) -> MARK(X2)
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(139) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   MARK(cons2(X1, X2)) -> MARK(X2)


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(2ndsneg(x_1, x_2)) = 0
   POL(2ndspos(x_1, x_2)) = 0
   POL(ACTIVE(x_1)) = 2*x_1
   POL(MARK(x_1)) = 2*x_1
   POL(active(x_1)) = x_1
   POL(cons(x_1, x_2)) = 0
   POL(cons2(x_1, x_2)) = 2 + 2*x_2
   POL(from(x_1)) = 2
   POL(mark(x_1)) = x_1
   POL(negrecip(x_1)) = 0
   POL(pi(x_1)) = 0
   POL(plus(x_1, x_2)) = x_2
   POL(posrecip(x_1)) = 0
   POL(rcons(x_1, x_2)) = 2*x_2
   POL(rnil) = 0
   POL(s(x_1)) = x_1
   POL(square(x_1)) = 0
   POL(times(x_1, x_2)) = 0


----------------------------------------

(140)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> MARK(X2)
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(141) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ACTIVE(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(posrecip(Y), 2ndsneg(N, Z)))
   MARK(rcons(X1, X2)) -> MARK(X2)
   ACTIVE(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> MARK(rcons(negrecip(Y), 2ndspos(N, Z)))
   ACTIVE(plus(0, Y)) -> MARK(Y)
   MARK(s(X)) -> MARK(X)
   ACTIVE(plus(s(X), Y)) -> MARK(s(plus(X, Y)))
   ACTIVE(times(s(X), Y)) -> MARK(plus(Y, times(X, Y)))
   MARK(plus(X1, X2)) -> MARK(X2)
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
ACTIVE(x1)  =  ACTIVE(x1)

2ndspos(x1, x2)  =  x1

s(x1)  =  s(x1)

cons(x1, x2)  =  cons(x1)

MARK(x1)  =  MARK(x1)

cons2(x1, x2)  =  x1

mark(x1)  =  x1

rcons(x1, x2)  =  rcons(x1, x2)

posrecip(x1)  =  posrecip

2ndsneg(x1, x2)  =  2ndsneg(x1)

negrecip(x1)  =  negrecip

plus(x1, x2)  =  plus(x1, x2)

0  =  0

times(x1, x2)  =  times(x1, x2)

active(x1)  =  x1

from(x1)  =  from(x1)

pi(x1)  =  pi(x1)

square(x1)  =  square(x1)

rnil  =  rnil


Recursive path order with status [RPO].
Quasi-Precedence: [ACTIVE_1, MARK_1, 0] > times_2 > plus_2 > s_1 > rcons_2
[ACTIVE_1, MARK_1, 0] > times_2 > plus_2 > s_1 > posrecip
[ACTIVE_1, MARK_1, 0] > times_2 > plus_2 > s_1 > 2ndsneg_1 > rnil
[ACTIVE_1, MARK_1, 0] > times_2 > plus_2 > s_1 > negrecip
pi_1 > [cons_1, from_1]
square_1 > times_2 > plus_2 > s_1 > rcons_2
square_1 > times_2 > plus_2 > s_1 > posrecip
square_1 > times_2 > plus_2 > s_1 > 2ndsneg_1 > rnil
square_1 > times_2 > plus_2 > s_1 > negrecip

Status: ACTIVE_1: [1]
s_1: [1]
cons_1: multiset status
MARK_1: [1]
rcons_2: multiset status
posrecip: multiset status
2ndsneg_1: multiset status
negrecip: []
plus_2: [2,1]
0: multiset status
times_2: [2,1]
from_1: multiset status
pi_1: [1]
square_1: [1]
rnil: multiset status


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(142)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   MARK(plus(X1, X2)) -> ACTIVE(plus(mark(X1), mark(X2)))
   MARK(times(X1, X2)) -> ACTIVE(times(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(143) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(144)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(145) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ACTIVE(2ndspos(s(N), cons(X, Z))) -> MARK(2ndspos(s(N), cons2(X, Z)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
MARK(x1)  =  x1

2ndspos(x1, x2)  =  2ndspos(x2)

ACTIVE(x1)  =  x1

mark(x1)  =  x1

cons(x1, x2)  =  cons

cons2(x1, x2)  =  cons2

2ndsneg(x1, x2)  =  2ndsneg

active(x1)  =  x1

from(x1)  =  from

rcons(x1, x2)  =  rcons

pi(x1)  =  pi

plus(x1, x2)  =  x2

s(x1)  =  s

times(x1, x2)  =  times

square(x1)  =  square

posrecip(x1)  =  posrecip

negrecip(x1)  =  negrecip

0  =  0

rnil  =  rnil


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   rnil=5
   rcons=6
   square=4
   posrecip=2
   times=3
   cons2=4
   s=1
   negrecip=2
   2ndspos_1=7
   pi=14
   0=2
   cons=5
   2ndsneg=8
   from=6

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(146)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MARK(2ndspos(X1, X2)) -> ACTIVE(2ndspos(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(147) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(148)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))
   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(149) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ACTIVE(2ndsneg(s(N), cons(X, Z))) -> MARK(2ndsneg(s(N), cons2(X, Z)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
MARK(x1)  =  x1

2ndsneg(x1, x2)  =  2ndsneg(x2)

ACTIVE(x1)  =  x1

mark(x1)  =  x1

cons(x1, x2)  =  cons

cons2(x1, x2)  =  cons2

active(x1)  =  x1

from(x1)  =  from

2ndspos(x1, x2)  =  2ndspos

rcons(x1, x2)  =  rcons

pi(x1)  =  pi

plus(x1, x2)  =  x2

s(x1)  =  s

times(x1, x2)  =  times

square(x1)  =  square

posrecip(x1)  =  posrecip

negrecip(x1)  =  negrecip

0  =  0

rnil  =  rnil


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   rnil=6
   rcons=8
   square=4
   posrecip=2
   times=3
   cons2=5
   s=1
   negrecip=2
   2ndspos=11
   pi=12
   0=2
   cons=6
   2ndsneg_1=7
   from=7

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   mark(from(X)) -> active(from(mark(X)))
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   mark(s(X)) -> active(s(mark(X)))
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   active(square(X)) -> mark(times(X, X))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(square(X)) -> active(square(mark(X)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(times(0, Y)) -> mark(0)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   from(active(X)) -> from(X)
   from(mark(X)) -> from(X)
   s(active(X)) -> s(X)
   s(mark(X)) -> s(X)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   posrecip(active(X)) -> posrecip(X)
   posrecip(mark(X)) -> posrecip(X)
   negrecip(active(X)) -> negrecip(X)
   negrecip(mark(X)) -> negrecip(X)
   pi(active(X)) -> pi(X)
   pi(mark(X)) -> pi(X)
   square(active(X)) -> square(X)
   square(mark(X)) -> square(X)


----------------------------------------

(150)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MARK(2ndsneg(X1, X2)) -> ACTIVE(2ndsneg(mark(X1), mark(X2)))

The TRS R consists of the following rules:

   active(from(X)) -> mark(cons(X, from(s(X))))
   active(2ndspos(0, Z)) -> mark(rnil)
   active(2ndspos(s(N), cons(X, Z))) -> mark(2ndspos(s(N), cons2(X, Z)))
   active(2ndspos(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(posrecip(Y), 2ndsneg(N, Z)))
   active(2ndsneg(0, Z)) -> mark(rnil)
   active(2ndsneg(s(N), cons(X, Z))) -> mark(2ndsneg(s(N), cons2(X, Z)))
   active(2ndsneg(s(N), cons2(X, cons(Y, Z)))) -> mark(rcons(negrecip(Y), 2ndspos(N, Z)))
   active(pi(X)) -> mark(2ndspos(X, from(0)))
   active(plus(0, Y)) -> mark(Y)
   active(plus(s(X), Y)) -> mark(s(plus(X, Y)))
   active(times(0, Y)) -> mark(0)
   active(times(s(X), Y)) -> mark(plus(Y, times(X, Y)))
   active(square(X)) -> mark(times(X, X))
   mark(from(X)) -> active(from(mark(X)))
   mark(cons(X1, X2)) -> active(cons(mark(X1), X2))
   mark(s(X)) -> active(s(mark(X)))
   mark(2ndspos(X1, X2)) -> active(2ndspos(mark(X1), mark(X2)))
   mark(0) -> active(0)
   mark(rnil) -> active(rnil)
   mark(cons2(X1, X2)) -> active(cons2(X1, mark(X2)))
   mark(rcons(X1, X2)) -> active(rcons(mark(X1), mark(X2)))
   mark(posrecip(X)) -> active(posrecip(mark(X)))
   mark(2ndsneg(X1, X2)) -> active(2ndsneg(mark(X1), mark(X2)))
   mark(negrecip(X)) -> active(negrecip(mark(X)))
   mark(pi(X)) -> active(pi(mark(X)))
   mark(plus(X1, X2)) -> active(plus(mark(X1), mark(X2)))
   mark(times(X1, X2)) -> active(times(mark(X1), mark(X2)))
   mark(square(X)) -> active(square(mark(X)))
   from(mark(X)) -> from(X)
   from(active(X)) -> from(X)
   cons(mark(X1), X2) -> cons(X1, X2)
   cons(X1, mark(X2)) -> cons(X1, X2)
   cons(active(X1), X2) -> cons(X1, X2)
   cons(X1, active(X2)) -> cons(X1, X2)
   s(mark(X)) -> s(X)
   s(active(X)) -> s(X)
   2ndspos(mark(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, mark(X2)) -> 2ndspos(X1, X2)
   2ndspos(active(X1), X2) -> 2ndspos(X1, X2)
   2ndspos(X1, active(X2)) -> 2ndspos(X1, X2)
   cons2(mark(X1), X2) -> cons2(X1, X2)
   cons2(X1, mark(X2)) -> cons2(X1, X2)
   cons2(active(X1), X2) -> cons2(X1, X2)
   cons2(X1, active(X2)) -> cons2(X1, X2)
   rcons(mark(X1), X2) -> rcons(X1, X2)
   rcons(X1, mark(X2)) -> rcons(X1, X2)
   rcons(active(X1), X2) -> rcons(X1, X2)
   rcons(X1, active(X2)) -> rcons(X1, X2)
   posrecip(mark(X)) -> posrecip(X)
   posrecip(active(X)) -> posrecip(X)
   2ndsneg(mark(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, mark(X2)) -> 2ndsneg(X1, X2)
   2ndsneg(active(X1), X2) -> 2ndsneg(X1, X2)
   2ndsneg(X1, active(X2)) -> 2ndsneg(X1, X2)
   negrecip(mark(X)) -> negrecip(X)
   negrecip(active(X)) -> negrecip(X)
   pi(mark(X)) -> pi(X)
   pi(active(X)) -> pi(X)
   plus(mark(X1), X2) -> plus(X1, X2)
   plus(X1, mark(X2)) -> plus(X1, X2)
   plus(active(X1), X2) -> plus(X1, X2)
   plus(X1, active(X2)) -> plus(X1, X2)
   times(mark(X1), X2) -> times(X1, X2)
   times(X1, mark(X2)) -> times(X1, X2)
   times(active(X1), X2) -> times(X1, X2)
   times(X1, active(X2)) -> times(X1, X2)
   square(mark(X)) -> square(X)
   square(active(X)) -> square(X)

The set Q consists of the following terms:

   active(times(s(x0), x1))
   mark(rnil)
   cons2(x0, mark(x1))
   from(active(x0))
   cons2(mark(x0), x1)
   rcons(x0, active(x1))
   mark(times(x0, x1))
   pi(active(x0))
   active(square(x0))
   times(x0, mark(x1))
   times(mark(x0), x1)
   2ndspos(x0, active(x1))
   active(2ndspos(s(x0), cons(x1, x2)))
   active(pi(x0))
   posrecip(active(x0))
   active(from(x0))
   active(2ndsneg(s(x0), cons(x1, x2)))
   2ndspos(mark(x0), x1)
   negrecip(mark(x0))
   cons(x0, active(x1))
   active(2ndspos(s(x0), cons2(x1, cons(x2, x3))))
   mark(0)
   active(times(0, x0))
   mark(cons(x0, x1))
   2ndsneg(x0, active(x1))
   cons2(active(x0), x1)
   negrecip(active(x0))
   active(plus(0, x0))
   rcons(x0, mark(x1))
   plus(mark(x0), x1)
   square(mark(x0))
   rcons(active(x0), x1)
   mark(2ndsneg(x0, x1))
   times(active(x0), x1)
   s(active(x0))
   times(x0, active(x1))
   active(2ndspos(0, x0))
   mark(from(x0))
   rcons(mark(x0), x1)
   mark(posrecip(x0))
   mark(cons2(x0, x1))
   cons(x0, mark(x1))
   mark(rcons(x0, x1))
   cons(mark(x0), x1)
   plus(x0, active(x1))
   square(active(x0))
   plus(active(x0), x1)
   mark(negrecip(x0))
   mark(2ndspos(x0, x1))
   from(mark(x0))
   2ndsneg(mark(x0), x1)
   2ndsneg(x0, mark(x1))
   pi(mark(x0))
   active(2ndsneg(s(x0), cons2(x1, cons(x2, x3))))
   active(2ndsneg(0, x0))
   active(plus(s(x0), x1))
   mark(s(x0))
   plus(x0, mark(x1))
   cons(active(x0), x1)
   posrecip(mark(x0))
   s(mark(x0))
   cons2(x0, active(x1))
   2ndsneg(active(x0), x1)
   2ndspos(active(x0), x1)
   mark(plus(x0, x1))
   mark(square(x0))
   mark(pi(x0))
   2ndspos(x0, mark(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(151) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(152)
TRUE
