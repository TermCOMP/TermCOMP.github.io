YES

Problem 1: 

(VAR vu95NonEmpty X X1 X2 X3 Y)
(RULES
active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
active(g(b)) -> mark(c)
active(b) -> mark(c)
f(active(X1),X2,X3) -> f(X1,X2,X3)
f(mark(X1),X2,X3) -> f(X1,X2,X3)
f(X1,active(X2),X3) -> f(X1,X2,X3)
f(X1,mark(X2),X3) -> f(X1,X2,X3)
f(X1,X2,active(X3)) -> f(X1,X2,X3)
f(X1,X2,mark(X3)) -> f(X1,X2,X3)
g(active(X)) -> g(X)
g(mark(X)) -> g(X)
mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
mark(g(X)) -> active(g(mark(X)))
mark(b) -> active(b)
mark(c) -> active(c)
)
 
(STRATEGY INNERMOST)

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 ACTIVE(f(X,g(X),Y)) -> F(Y,Y,Y)
 ACTIVE(f(X,g(X),Y)) -> MARK(f(Y,Y,Y))
 ACTIVE(g(b)) -> MARK(c)
 ACTIVE(b) -> MARK(c)
 F(active(X1),X2,X3) -> F(X1,X2,X3)
 F(mark(X1),X2,X3) -> F(X1,X2,X3)
 F(X1,active(X2),X3) -> F(X1,X2,X3)
 F(X1,mark(X2),X3) -> F(X1,X2,X3)
 F(X1,X2,active(X3)) -> F(X1,X2,X3)
 F(X1,X2,mark(X3)) -> F(X1,X2,X3)
 G(active(X)) -> G(X)
 G(mark(X)) -> G(X)
 MARK(f(X1,X2,X3)) -> ACTIVE(f(X1,X2,X3))
 MARK(g(X)) -> ACTIVE(g(mark(X)))
 MARK(g(X)) -> G(mark(X))
 MARK(g(X)) -> MARK(X)
 MARK(b) -> ACTIVE(b)
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)

Problem 1: 

SCC Processor:
-> Pairs:
 ACTIVE(f(X,g(X),Y)) -> F(Y,Y,Y)
 ACTIVE(f(X,g(X),Y)) -> MARK(f(Y,Y,Y))
 ACTIVE(g(b)) -> MARK(c)
 ACTIVE(b) -> MARK(c)
 F(active(X1),X2,X3) -> F(X1,X2,X3)
 F(mark(X1),X2,X3) -> F(X1,X2,X3)
 F(X1,active(X2),X3) -> F(X1,X2,X3)
 F(X1,mark(X2),X3) -> F(X1,X2,X3)
 F(X1,X2,active(X3)) -> F(X1,X2,X3)
 F(X1,X2,mark(X3)) -> F(X1,X2,X3)
 G(active(X)) -> G(X)
 G(mark(X)) -> G(X)
 MARK(f(X1,X2,X3)) -> ACTIVE(f(X1,X2,X3))
 MARK(g(X)) -> ACTIVE(g(mark(X)))
 MARK(g(X)) -> G(mark(X))
 MARK(g(X)) -> MARK(X)
 MARK(b) -> ACTIVE(b)
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 G(active(X)) -> G(X)
 G(mark(X)) -> G(X)
->->-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->->Cycle:
->->-> Pairs:
 F(active(X1),X2,X3) -> F(X1,X2,X3)
 F(mark(X1),X2,X3) -> F(X1,X2,X3)
 F(X1,active(X2),X3) -> F(X1,X2,X3)
 F(X1,mark(X2),X3) -> F(X1,X2,X3)
 F(X1,X2,active(X3)) -> F(X1,X2,X3)
 F(X1,X2,mark(X3)) -> F(X1,X2,X3)
->->-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->->Cycle:
->->-> Pairs:
 ACTIVE(f(X,g(X),Y)) -> MARK(f(Y,Y,Y))
 MARK(f(X1,X2,X3)) -> ACTIVE(f(X1,X2,X3))
 MARK(g(X)) -> ACTIVE(g(mark(X)))
 MARK(g(X)) -> MARK(X)
->->-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)


The problem is decomposed in 3 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 G(active(X)) -> G(X)
 G(mark(X)) -> G(X)
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Projection:
 pi(G) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Subterm Processor:
-> Pairs:
 F(active(X1),X2,X3) -> F(X1,X2,X3)
 F(mark(X1),X2,X3) -> F(X1,X2,X3)
 F(X1,active(X2),X3) -> F(X1,X2,X3)
 F(X1,mark(X2),X3) -> F(X1,X2,X3)
 F(X1,X2,active(X3)) -> F(X1,X2,X3)
 F(X1,X2,mark(X3)) -> F(X1,X2,X3)
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Projection:
 pi(F) = 1

Problem 1.2: 

SCC Processor:
-> Pairs:
 F(X1,active(X2),X3) -> F(X1,X2,X3)
 F(X1,mark(X2),X3) -> F(X1,X2,X3)
 F(X1,X2,active(X3)) -> F(X1,X2,X3)
 F(X1,X2,mark(X3)) -> F(X1,X2,X3)
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 F(X1,active(X2),X3) -> F(X1,X2,X3)
 F(X1,mark(X2),X3) -> F(X1,X2,X3)
 F(X1,X2,active(X3)) -> F(X1,X2,X3)
 F(X1,X2,mark(X3)) -> F(X1,X2,X3)
->->-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)

Problem 1.2: 

Subterm Processor:
-> Pairs:
 F(X1,active(X2),X3) -> F(X1,X2,X3)
 F(X1,mark(X2),X3) -> F(X1,X2,X3)
 F(X1,X2,active(X3)) -> F(X1,X2,X3)
 F(X1,X2,mark(X3)) -> F(X1,X2,X3)
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Projection:
 pi(F) = 2

Problem 1.2: 

SCC Processor:
-> Pairs:
 F(X1,X2,active(X3)) -> F(X1,X2,X3)
 F(X1,X2,mark(X3)) -> F(X1,X2,X3)
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 F(X1,X2,active(X3)) -> F(X1,X2,X3)
 F(X1,X2,mark(X3)) -> F(X1,X2,X3)
->->-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)

Problem 1.2: 

Subterm Processor:
-> Pairs:
 F(X1,X2,active(X3)) -> F(X1,X2,X3)
 F(X1,X2,mark(X3)) -> F(X1,X2,X3)
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Projection:
 pi(F) = 3

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Reduction Pairs Processor:
-> Pairs:
 ACTIVE(f(X,g(X),Y)) -> MARK(f(Y,Y,Y))
 MARK(f(X1,X2,X3)) -> ACTIVE(f(X1,X2,X3))
 MARK(g(X)) -> ACTIVE(g(mark(X)))
 MARK(g(X)) -> MARK(X)
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
-> Usable rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[active](X) = X + 1
[f](X1,X2,X3) = 0
[g](X) = 2.X + 2
[mark](X) = 2.X + 1
[b] = 0
[c] = 0
[fSNonEmpty] = 0
[ACTIVE](X) = 2
[F](X1,X2,X3) = 0
[G](X) = 0
[MARK](X) = X + 2

Problem 1.3: 

SCC Processor:
-> Pairs:
 ACTIVE(f(X,g(X),Y)) -> MARK(f(Y,Y,Y))
 MARK(f(X1,X2,X3)) -> ACTIVE(f(X1,X2,X3))
 MARK(g(X)) -> MARK(X)
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 ACTIVE(f(X,g(X),Y)) -> MARK(f(Y,Y,Y))
 MARK(f(X1,X2,X3)) -> ACTIVE(f(X1,X2,X3))
 MARK(g(X)) -> MARK(X)
->->-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)

Problem 1.3: 

Reduction Pairs Processor:
-> Pairs:
 ACTIVE(f(X,g(X),Y)) -> MARK(f(Y,Y,Y))
 MARK(f(X1,X2,X3)) -> ACTIVE(f(X1,X2,X3))
 MARK(g(X)) -> MARK(X)
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
-> Usable rules:
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[active](X) = 0
[f](X1,X2,X3) = 0
[g](X) = 2.X + 2
[mark](X) = 0
[b] = 0
[c] = 0
[fSNonEmpty] = 0
[ACTIVE](X) = 2
[F](X1,X2,X3) = 0
[G](X) = 0
[MARK](X) = 2.X + 2

Problem 1.3: 

SCC Processor:
-> Pairs:
 ACTIVE(f(X,g(X),Y)) -> MARK(f(Y,Y,Y))
 MARK(f(X1,X2,X3)) -> ACTIVE(f(X1,X2,X3))
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 ACTIVE(f(X,g(X),Y)) -> MARK(f(Y,Y,Y))
 MARK(f(X1,X2,X3)) -> ACTIVE(f(X1,X2,X3))
->->-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)

Problem 1.3: 

Reduction Pair Processor:
-> Pairs:
 ACTIVE(f(X,g(X),Y)) -> MARK(f(Y,Y,Y))
 MARK(f(X1,X2,X3)) -> ACTIVE(f(X1,X2,X3))
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
-> Usable rules:
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
->Mace4 Output:
 ============================== Mace4 =================================
Mace4 (64) version 2009-11A, November 2009.
Process 208 was started by ff862203 on r23m0027.hpc.itc.rwth-aachen.de,
Wed Sep  3 16:05:01 2025
The command was "./mace4 -c -f /tmp/mace421-36.in".
============================== end of head ===========================

============================== INPUT =================================

% Reading from file /tmp/mace421-36.in

assign(max_seconds,20).

formulas(assumptions).
gtrsim_s0(x,y) & sqsupset_s0(y,z) -> sqsupset_s0(x,z) # label(compatibility).
succeq_s0(x,y) & sqsupset_s0(y,z) -> sqsupset_s0(x,z) # label(compatibility).
gtrsim_s0(x,y) & succeq_s0(y,z) -> gtrsim_s0(x,z) # label(compatibility).
arrow_s0(x1,y) -> arrow_s0(f2(x1),f2(y)) # label(congruence).
arrow_s0(x1,y) -> arrow_s0(f3(x1,x2,x3),f3(y,x2,x3)) # label(congruence).
arrow_s0(x2,y) -> arrow_s0(f3(x1,x2,x3),f3(x1,y,x3)) # label(congruence).
arrow_s0(x3,y) -> arrow_s0(f3(x1,x2,x3),f3(x1,x2,y)) # label(congruence).
arrow_s0(x1,y) -> arrow_s0(f4(x1),f4(y)) # label(congruence).
arrow_s0(x1,y) -> arrow_s0(f5(x1),f5(y)) # label(congruence).
arrow_s0(x1,y) -> arrow_s0(f10(x1),f10(y)) # label(congruence).
arrow_s0(x1,y) -> arrow_s0(f13(x1),f13(y)) # label(congruence).
arrow_s0(f3(f2(x2),x3,x4),f3(x2,x3,x4)) # label(replacement).
arrow_s0(f3(f5(x2),x3,x4),f3(x2,x3,x4)) # label(replacement).
arrow_s0(f3(x2,f2(x3),x4),f3(x2,x3,x4)) # label(replacement).
arrow_s0(f3(x2,f5(x3),x4),f3(x2,x3,x4)) # label(replacement).
arrow_s0(f3(x2,x3,f2(x4)),f3(x2,x3,x4)) # label(replacement).
arrow_s0(f3(x2,x3,f5(x4)),f3(x2,x3,x4)) # label(replacement).
arrow_s0(x,y) -> gtrsim_s0(x,y) # label(inclusion).
sqsupset_s0(f10(f3(x1,f4(x1),x5)),f13(f3(x5,x5,x5))) # label(replacement).
succeq_s0(f13(f3(x2,x3,x4)),f10(f3(x2,x3,x4))) # label(replacement).
sqsupset_s0(x,y) -> sqsupsetStar_s0(x,y) # label(inclusion).
sqsupset_s0(x,y) & sqsupsetStar_s0(y,z) -> sqsupsetStar_s0(x,z) # label(compatibility).
end_of_list.

formulas(goals).
(exists x sqsupsetStar_s0(x,x)) # label(wellfoundedness).
end_of_list.

============================== end of input ==========================

============================== PROCESS NON-CLAUSAL FORMULAS ==========

% Formulas that are not ordinary clauses:
1 gtrsim_s0(x,y) & sqsupset_s0(y,z) -> sqsupset_s0(x,z) # label(compatibility) # label(non_clause).  [assumption].
2 succeq_s0(x,y) & sqsupset_s0(y,z) -> sqsupset_s0(x,z) # label(compatibility) # label(non_clause).  [assumption].
3 gtrsim_s0(x,y) & succeq_s0(y,z) -> gtrsim_s0(x,z) # label(compatibility) # label(non_clause).  [assumption].
4 arrow_s0(x1,y) -> arrow_s0(f2(x1),f2(y)) # label(congruence) # label(non_clause).  [assumption].
5 arrow_s0(x1,y) -> arrow_s0(f3(x1,x2,x3),f3(y,x2,x3)) # label(congruence) # label(non_clause).  [assumption].
6 arrow_s0(x2,y) -> arrow_s0(f3(x1,x2,x3),f3(x1,y,x3)) # label(congruence) # label(non_clause).  [assumption].
7 arrow_s0(x3,y) -> arrow_s0(f3(x1,x2,x3),f3(x1,x2,y)) # label(congruence) # label(non_clause).  [assumption].
8 arrow_s0(x1,y) -> arrow_s0(f4(x1),f4(y)) # label(congruence) # label(non_clause).  [assumption].
9 arrow_s0(x1,y) -> arrow_s0(f5(x1),f5(y)) # label(congruence) # label(non_clause).  [assumption].
10 arrow_s0(x1,y) -> arrow_s0(f10(x1),f10(y)) # label(congruence) # label(non_clause).  [assumption].
11 arrow_s0(x1,y) -> arrow_s0(f13(x1),f13(y)) # label(congruence) # label(non_clause).  [assumption].
12 arrow_s0(x,y) -> gtrsim_s0(x,y) # label(inclusion) # label(non_clause).  [assumption].
13 sqsupset_s0(x,y) -> sqsupsetStar_s0(x,y) # label(inclusion) # label(non_clause).  [assumption].
14 sqsupset_s0(x,y) & sqsupsetStar_s0(y,z) -> sqsupsetStar_s0(x,z) # label(compatibility) # label(non_clause).  [assumption].
15 (exists x sqsupsetStar_s0(x,x)) # label(wellfoundedness) # label(non_clause) # label(goal).  [goal].

============================== end of process non-clausal formulas ===

============================== CLAUSES FOR SEARCH ====================

formulas(mace4_clauses).
-gtrsim_s0(x,y) | -sqsupset_s0(y,z) | sqsupset_s0(x,z) # label(compatibility).
-succeq_s0(x,y) | -sqsupset_s0(y,z) | sqsupset_s0(x,z) # label(compatibility).
-gtrsim_s0(x,y) | -succeq_s0(y,z) | gtrsim_s0(x,z) # label(compatibility).
-arrow_s0(x,y) | arrow_s0(f2(x),f2(y)) # label(congruence).
-arrow_s0(x,y) | arrow_s0(f3(x,z,u),f3(y,z,u)) # label(congruence).
-arrow_s0(x,y) | arrow_s0(f3(z,x,u),f3(z,y,u)) # label(congruence).
-arrow_s0(x,y) | arrow_s0(f3(z,u,x),f3(z,u,y)) # label(congruence).
-arrow_s0(x,y) | arrow_s0(f4(x),f4(y)) # label(congruence).
-arrow_s0(x,y) | arrow_s0(f5(x),f5(y)) # label(congruence).
-arrow_s0(x,y) | arrow_s0(f10(x),f10(y)) # label(congruence).
-arrow_s0(x,y) | arrow_s0(f13(x),f13(y)) # label(congruence).
arrow_s0(f3(f2(x),y,z),f3(x,y,z)) # label(replacement).
arrow_s0(f3(f5(x),y,z),f3(x,y,z)) # label(replacement).
arrow_s0(f3(x,f2(y),z),f3(x,y,z)) # label(replacement).
arrow_s0(f3(x,f5(y),z),f3(x,y,z)) # label(replacement).
arrow_s0(f3(x,y,f2(z)),f3(x,y,z)) # label(replacement).
arrow_s0(f3(x,y,f5(z)),f3(x,y,z)) # label(replacement).
-arrow_s0(x,y) | gtrsim_s0(x,y) # label(inclusion).
sqsupset_s0(f10(f3(x,f4(x),y)),f13(f3(y,y,y))) # label(replacement).
succeq_s0(f13(f3(x,y,z)),f10(f3(x,y,z))) # label(replacement).
-sqsupset_s0(x,y) | sqsupsetStar_s0(x,y) # label(inclusion).
-sqsupset_s0(x,y) | -sqsupsetStar_s0(y,z) | sqsupsetStar_s0(x,z) # label(compatibility).
-sqsupsetStar_s0(x,x) # label(wellfoundedness).
end_of_list.

============================== end of clauses for search =============

% There are no natural numbers in the input.

============================== DOMAIN SIZE 2 =========================

============================== MODEL =================================

interpretation( 2, [number=1, seconds=0], [

        function(f10(_), [ 0, 1 ]),

        function(f13(_), [ 0, 1 ]),

        function(f2(_), [ 0, 1 ]),

        function(f4(_), [ 1, 0 ]),

        function(f5(_), [ 0, 1 ]),

        function(f3(_,_,_), [
			   0, 0,
			   1, 1,
			   1, 1,
			   0, 0 ]),

        relation(arrow_s0(_,_), [
			   1, 0,
			   0, 1 ]),

        relation(gtrsim_s0(_,_), [
			   1, 0,
			   0, 1 ]),

        relation(sqsupsetStar_s0(_,_), [
			   0, 0,
			   1, 0 ]),

        relation(sqsupset_s0(_,_), [
			   0, 0,
			   1, 0 ]),

        relation(succeq_s0(_,_), [
			   1, 0,
			   0, 1 ])
]).

============================== end of model ==========================

============================== STATISTICS ============================

For domain size 2.

Current CPU time: 0.00 seconds (total CPU time: 0.00 seconds).
Ground clauses: seen=170, kept=170.
Selections=166, assignments=322, propagations=291, current_models=1.
Rewrite_terms=4674, rewrite_bools=3044, indexes=764.
Rules_from_neg_clauses=16, cross_offs=16.

============================== end of statistics =====================

User_CPU=0.00, System_CPU=0.00, Wall_clock=0.

Exiting with 1 model.

Process 208 exit (max_models) Wed Sep  3 16:05:01 2025
The process finished Wed Sep  3 16:05:01 2025


Mace4 cooked interpretation:

% number = 1
% seconds = 0

% Interpretation of size 2

f10(0) = 0.
f10(1) = 1.

f13(0) = 0.
f13(1) = 1.

f2(0) = 0.
f2(1) = 1.

f4(0) = 1.
f4(1) = 0.

f5(0) = 0.
f5(1) = 1.

f3(0,0,0) = 0.
f3(0,0,1) = 0.
f3(0,1,0) = 1.
f3(0,1,1) = 1.
f3(1,0,0) = 1.
f3(1,0,1) = 1.
f3(1,1,0) = 0.
f3(1,1,1) = 0.

  arrow_s0(0,0).
- arrow_s0(0,1).
- arrow_s0(1,0).
  arrow_s0(1,1).

  gtrsim_s0(0,0).
- gtrsim_s0(0,1).
- gtrsim_s0(1,0).
  gtrsim_s0(1,1).

- sqsupsetStar_s0(0,0).
- sqsupsetStar_s0(0,1).
  sqsupsetStar_s0(1,0).
- sqsupsetStar_s0(1,1).

- sqsupset_s0(0,0).
- sqsupset_s0(0,1).
  sqsupset_s0(1,0).
- sqsupset_s0(1,1).

  succeq_s0(0,0).
- succeq_s0(0,1).
- succeq_s0(1,0).
  succeq_s0(1,1).


Problem 1.3: 

SCC Processor:
-> Pairs:
 MARK(f(X1,X2,X3)) -> ACTIVE(f(X1,X2,X3))
-> Rules:
 active(f(X,g(X),Y)) -> mark(f(Y,Y,Y))
 active(g(b)) -> mark(c)
 active(b) -> mark(c)
 f(active(X1),X2,X3) -> f(X1,X2,X3)
 f(mark(X1),X2,X3) -> f(X1,X2,X3)
 f(X1,active(X2),X3) -> f(X1,X2,X3)
 f(X1,mark(X2),X3) -> f(X1,X2,X3)
 f(X1,X2,active(X3)) -> f(X1,X2,X3)
 f(X1,X2,mark(X3)) -> f(X1,X2,X3)
 g(active(X)) -> g(X)
 g(mark(X)) -> g(X)
 mark(f(X1,X2,X3)) -> active(f(X1,X2,X3))
 mark(g(X)) -> active(g(mark(X)))
 mark(b) -> active(b)
 mark(c) -> active(c)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
