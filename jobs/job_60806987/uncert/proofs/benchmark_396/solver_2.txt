YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/wDrj1.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPDepGraphProof [EQUIVALENT, 0 ms]
(4) RelADPP
(5) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
(6) QDP
(7) TransformationProof [EQUIVALENT, 0 ms]
(8) QDP
(9) TransformationProof [EQUIVALENT, 0 ms]
(10) QDP
(11) TransformationProof [EQUIVALENT, 0 ms]
(12) QDP
(13) QDPOrderProof [EQUIVALENT, 2721 ms]
(14) QDP
(15) QDPBoundsTAProof [EQUIVALENT, 0 ms]
(16) QDP
(17) DependencyGraphProof [EQUIVALENT, 0 ms]
(18) TRUE


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   b(a(x)) -> b(b(b(b(x))))

The relative TRS consists of the following S rules:

   a(b(x)) -> a(b(c(a(x))))
   b(c(x)) -> a(a(a(a(x))))


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(x)) -> B(b(b(b(x))))
   b(a(x)) -> b(B(b(b(x))))
   b(a(x)) -> b(b(B(b(x))))
   b(a(x)) -> b(b(b(B(x))))

and relative ADPs:

   a(b(x)) -> A(B(c(a(x))))
   a(b(x)) -> A(b(c(A(x))))
   a(b(x)) -> a(B(c(A(x))))
   b(c(x)) -> A(A(a(a(x))))
   b(c(x)) -> A(a(A(a(x))))
   b(c(x)) -> A(a(a(A(x))))
   b(c(x)) -> a(A(A(a(x))))
   b(c(x)) -> a(A(a(A(x))))
   b(c(x)) -> a(a(A(A(x))))


----------------------------------------

(3) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(4)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(x)) -> b(b(b(B(x))))
   b(a(x)) -> B(b(b(b(x))))
   b(a(x)) -> b(b(B(b(x))))
   b(a(x)) -> b(B(b(b(x))))

and relative ADPs:

   a(b(x)) -> a(b(c(a(x))))
   b(c(x)) -> a(a(a(a(x))))


----------------------------------------

(5) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(6)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(x)) -> B(x)
   B(a(x)) -> B(b(x))
   B(a(x)) -> B(b(b(b(x))))
   B(a(x)) -> B(b(b(x)))

The TRS R consists of the following rules:

   a(b(x)) -> a(b(c(a(x))))
   b(a(x)) -> b(b(b(b(x))))
   b(c(x)) -> a(a(a(a(x))))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(7) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule B(a(x)) -> B(b(x)) at position [0] we obtained the following new rules [LPAR04]:

   (B(a(a(x0))) -> B(b(b(b(b(x0))))),B(a(a(x0))) -> B(b(b(b(b(x0))))))
   (B(a(c(x0))) -> B(a(a(a(a(x0))))),B(a(c(x0))) -> B(a(a(a(a(x0))))))


----------------------------------------

(8)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(x)) -> B(x)
   B(a(x)) -> B(b(b(b(x))))
   B(a(x)) -> B(b(b(x)))
   B(a(a(x0))) -> B(b(b(b(b(x0)))))
   B(a(c(x0))) -> B(a(a(a(a(x0)))))

The TRS R consists of the following rules:

   a(b(x)) -> a(b(c(a(x))))
   b(a(x)) -> b(b(b(b(x))))
   b(c(x)) -> a(a(a(a(x))))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(9) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule B(a(x)) -> B(b(b(b(x)))) at position [0] we obtained the following new rules [LPAR04]:

   (B(a(a(x0))) -> B(b(b(b(b(b(b(x0))))))),B(a(a(x0))) -> B(b(b(b(b(b(b(x0))))))))
   (B(a(c(x0))) -> B(b(b(a(a(a(a(x0))))))),B(a(c(x0))) -> B(b(b(a(a(a(a(x0))))))))


----------------------------------------

(10)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(x)) -> B(x)
   B(a(x)) -> B(b(b(x)))
   B(a(a(x0))) -> B(b(b(b(b(x0)))))
   B(a(c(x0))) -> B(a(a(a(a(x0)))))
   B(a(a(x0))) -> B(b(b(b(b(b(b(x0)))))))
   B(a(c(x0))) -> B(b(b(a(a(a(a(x0)))))))

The TRS R consists of the following rules:

   a(b(x)) -> a(b(c(a(x))))
   b(a(x)) -> b(b(b(b(x))))
   b(c(x)) -> a(a(a(a(x))))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(11) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule B(a(x)) -> B(b(b(x))) at position [0] we obtained the following new rules [LPAR04]:

   (B(a(a(x0))) -> B(b(b(b(b(b(x0)))))),B(a(a(x0))) -> B(b(b(b(b(b(x0)))))))
   (B(a(c(x0))) -> B(b(a(a(a(a(x0)))))),B(a(c(x0))) -> B(b(a(a(a(a(x0)))))))


----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(x)) -> B(x)
   B(a(a(x0))) -> B(b(b(b(b(x0)))))
   B(a(c(x0))) -> B(a(a(a(a(x0)))))
   B(a(a(x0))) -> B(b(b(b(b(b(b(x0)))))))
   B(a(c(x0))) -> B(b(b(a(a(a(a(x0)))))))
   B(a(a(x0))) -> B(b(b(b(b(b(x0))))))
   B(a(c(x0))) -> B(b(a(a(a(a(x0))))))

The TRS R consists of the following rules:

   a(b(x)) -> a(b(c(a(x))))
   b(a(x)) -> b(b(b(b(x))))
   b(c(x)) -> a(a(a(a(x))))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(13) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   B(a(a(x0))) -> B(b(b(b(b(x0)))))
   B(a(a(x0))) -> B(b(b(b(b(b(b(x0)))))))
   B(a(c(x0))) -> B(b(b(a(a(a(a(x0)))))))
   B(a(a(x0))) -> B(b(b(b(b(b(x0))))))
   B(a(c(x0))) -> B(b(a(a(a(a(x0))))))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(B(x_1)) =  	[[-I]] 	 +  	[[0A, 1A, 0A]] 	* 	x_1
>>>

   <<<
 POL(a(x_1)) =  	[[-I], [-I], [-I]] 	 +  	[[0A, 0A, -I], [0A, 0A, 0A], [-I, -I, -I]] 	* 	x_1
>>>

   <<<
 POL(b(x_1)) =  	[[-I], [-I], [-I]] 	 +  	[[0A, 0A, 0A], [-I, -I, 0A], [-I, -I, -I]] 	* 	x_1
>>>

   <<<
 POL(c(x_1)) =  	[[-I], [-I], [-I]] 	 +  	[[0A, -I, 0A], [0A, -I, 0A], [0A, 0A, 0A]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a(b(x)) -> a(b(c(a(x))))
   b(a(x)) -> b(b(b(b(x))))
   b(c(x)) -> a(a(a(a(x))))


----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(x)) -> B(x)
   B(a(c(x0))) -> B(a(a(a(a(x0)))))

The TRS R consists of the following rules:

   a(b(x)) -> a(b(c(a(x))))
   b(a(x)) -> b(b(b(b(x))))
   b(c(x)) -> a(a(a(a(x))))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(15) QDPBoundsTAProof (EQUIVALENT)
The DP-Problem (P, R) could be shown to be Match-DP-Bounded [TAB_NONLEFTLINEAR] by 2 for the Rule: 
   B(a(x)) -> B(x)
by considering the usable rules: 

   a(b(x)) -> a(b(c(a(x))))
   b(c(x)) -> a(a(a(a(x))))

The compatible tree automaton used to show the Match-DP-Boundedness is represented by: 
final states : [0]
transitions: 
#0() -> 1
B0(1) -> 0
#0() -> 5
a0(5) -> 4
a0(4) -> 3
a0(3) -> 3
a0(3) -> 2
B0(2) -> 0
B0(3) -> 0
a0(5) -> 8
c0(8) -> 7
b0(7) -> 6
a0(6) -> 4
a0(7) -> 9
c0(9) -> 7
a0(8) -> 10
a0(10) -> 3
a0(3) -> 6
B0(4) -> 0
a0(6) -> 8
a0(9) -> 10
B0(10) -> 0
B0(5) -> 0
B0(6) -> 0
B0(8) -> 0
B0(9) -> 0
B0(7) -> 0
B1(3) -> 0
B1(4) -> 0
B1(10) -> 0
B1(5) -> 0
B1(6) -> 0
B1(8) -> 0
B1(9) -> 0
B1(7) -> 0
a1(8) -> 13
a1(13) -> 12
a1(12) -> 12
a1(12) -> 11
B1(11) -> 0
a1(9) -> 13
B2(12) -> 0
B2(13) -> 0
B2(8) -> 0
B2(9) -> 0

----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x0))) -> B(a(a(a(a(x0)))))

The TRS R consists of the following rules:

   a(b(x)) -> a(b(c(a(x))))
   b(a(x)) -> b(b(b(b(x))))
   b(c(x)) -> a(a(a(a(x))))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(17) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(18)
TRUE
