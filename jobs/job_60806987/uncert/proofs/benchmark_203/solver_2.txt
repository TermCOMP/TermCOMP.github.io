YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/C75jY.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRS S Cleaner [EQUIVALENT, 0 ms]
(2) RelTRS
(3) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(4) RelADPP
(5) RelADPDerelatifying2Proof [SOUND, 0 ms]
(6) OR
    (7) RelADPP
        (8) RelADPReductionPairProof [EQUIVALENT, 18 ms]
        (9) RelADPP
        (10) RelADPDerelatifyingProof [EQUIVALENT, 2 ms]
        (11) QDP
        (12) MRRProof [EQUIVALENT, 6 ms]
        (13) QDP
        (14) PisEmptyProof [EQUIVALENT, 0 ms]
        (15) YES
    (16) RelADPP
        (17) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (18) OR
            (19) RelADPP
            (20) RelADPP
                (21) RelADPReductionPairProof [EQUIVALENT, 14 ms]
                (22) RelADPP
            (23) RelADPP
            (24) RelADPP
    (25) RelADPP
        (26) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (27) OR
            (28) RelADPP
                (29) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                (30) RelADPP
            (31) RelADPP
            (32) RelADPP
            (33) RelADPP
    (34) RelADPP
        (35) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (36) OR
            (37) RelADPP
                (38) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (39) OR
                    (40) RelADPP
                    (41) RelADPP
                    (42) RelADPP
            (43) RelADPP
                (44) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                (45) RelADPP
                (46) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                (47) RelADPP
                (48) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (49) RelADPP
            (50) RelADPP
            (51) RelADPP
                (52) RelADPDerelatifying2Proof [SOUND, 3 ms]
                (53) OR
                    (54) RelADPP
                    (55) RelADPP
                    (56) RelADPP
    (57) RelADPP
        (58) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (59) OR
            (60) RelADPP
            (61) RelADPP
                (62) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                (63) RelADPP
            (64) RelADPP
            (65) RelADPP


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   a(b(c(x1))) -> b(a(a(x1)))
   a(b(b(x1))) -> b(c(a(x1)))

The relative TRS consists of the following S rules:

   c(a(a(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(a(x1)))
   c(b(c(x1))) -> a(c(c(x1)))
   c(b(a(x1))) -> a(a(b(x1)))


----------------------------------------

(1) RelTRS S Cleaner (EQUIVALENT)
We have deleted all rules from S that have the shape t -> t:

   a(b(a(x1))) -> a(b(a(x1)))


----------------------------------------

(2)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   a(b(c(x1))) -> b(a(a(x1)))
   a(b(b(x1))) -> b(c(a(x1)))

The relative TRS consists of the following S rules:

   c(a(a(x1))) -> c(a(b(x1)))
   c(b(c(x1))) -> a(c(c(x1)))
   c(b(a(x1))) -> a(a(b(x1)))


----------------------------------------

(3) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(4)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(b(x1))) -> b(c(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> C(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(c(x1))) -> A(c(C(x1)))
   c(b(c(x1))) -> a(C(C(x1)))
   c(b(a(x1))) -> A(A(b(x1)))


----------------------------------------

(5) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(6)
Complex Obligation (OR)

----------------------------------------

(7)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(a(a(x1))) -> c(A(b(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(a(a(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> b(c(A(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(8) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(a(a(x1))) -> c(A(b(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   a(b(b(x1))) -> b(c(A(x1)))

Relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> C(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(9)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> b(a(a(x1)))
   c(a(a(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> b(c(a(x1)))
   c(b(c(x1))) -> a(c(c(x1)))
   c(b(a(x1))) -> a(a(b(x1)))


----------------------------------------

(10) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(a(x1))) -> C(a(b(x1)))

The TRS R consists of the following rules:

   a(b(c(x1))) -> b(a(a(x1)))
   c(a(a(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> b(c(a(x1)))
   c(b(c(x1))) -> a(c(c(x1)))
   c(b(a(x1))) -> a(a(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(12) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C(a(a(x1))) -> C(a(b(x1)))

Strictly oriented rules of the TRS R:

   a(b(c(x1))) -> b(a(a(x1)))
   c(a(a(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> b(c(a(x1)))
   c(b(c(x1))) -> a(c(c(x1)))
   c(b(a(x1))) -> a(a(b(x1)))

Used ordering: Knuth-Bendix order [KBO] with precedence:c_1 > C_1 > a_1 > b_1

and weight map:

   a_1=1
   b_1=1
   c_1=1
   C_1=1

The variable weight is 1

----------------------------------------

(13)
Obligation:
Q DP problem:
P is empty.
R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(14) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(15)
YES

----------------------------------------

(16)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(a(a(x1))) -> C(A(b(x1)))
   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(17) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(18)
Complex Obligation (OR)

----------------------------------------

(19)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(a(a(x1))) -> C(A(b(x1)))
   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(20)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   c(a(a(x1))) -> c(A(b(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(a(a(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(21) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   c(a(a(x1))) -> c(A(b(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

Relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> C(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(22)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> b(a(a(x1)))
   c(a(a(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> b(c(a(x1)))
   c(b(c(x1))) -> a(c(c(x1)))
   c(b(a(x1))) -> a(a(b(x1)))


----------------------------------------

(23)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   c(b(a(x1))) -> a(A(b(x1)))
   c(b(a(x1))) -> A(a(b(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(a(a(x1))) -> C(A(b(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(24)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(a(a(x1))) -> C(A(b(x1)))
   c(b(a(x1))) -> A(A(b(x1)))


----------------------------------------

(25)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(a(a(x1))) -> C(A(b(x1)))
   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(26) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(27)
Complex Obligation (OR)

----------------------------------------

(28)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(a(a(x1))) -> c(A(b(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   c(a(a(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(29) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(a(a(x1))) -> c(A(b(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

Relative ADPs:

   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> C(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(30)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> b(a(a(x1)))
   c(a(a(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> b(c(a(x1)))
   c(b(c(x1))) -> a(c(c(x1)))
   c(b(a(x1))) -> a(a(b(x1)))


----------------------------------------

(31)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   c(b(a(x1))) -> a(A(b(x1)))
   c(b(a(x1))) -> A(a(b(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(a(a(x1))) -> C(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(32)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(a(a(x1))) -> C(A(b(x1)))
   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(33)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(a(a(x1))) -> C(A(b(x1)))
   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))


----------------------------------------

(34)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(a(a(x1))) -> C(A(b(x1)))
   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))


----------------------------------------

(35) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(36)
Complex Obligation (OR)

----------------------------------------

(37)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(a(a(x1))) -> C(A(b(x1)))
   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))


----------------------------------------

(38) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(39)
Complex Obligation (OR)

----------------------------------------

(40)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   c(a(a(x1))) -> c(A(b(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   c(a(a(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))


----------------------------------------

(41)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   c(b(a(x1))) -> a(A(b(x1)))
   c(b(a(x1))) -> A(a(b(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(a(a(x1))) -> C(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))


----------------------------------------

(42)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(a(a(x1))) -> C(A(b(x1)))
   c(b(a(x1))) -> A(A(b(x1)))


----------------------------------------

(43)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   c(a(a(x1))) -> c(A(b(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   c(a(a(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> b(c(A(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(b(a(x1))) -> A(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))


----------------------------------------

(44) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   c(a(a(x1))) -> c(A(b(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))

Relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(b(a(x1))) -> A(A(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> b(C(a(x1)))
   c(a(a(x1))) -> C(a(b(x1)))

Relative ADPs:

   c(b(c(x1))) -> A(C(c(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(45)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> b(C(a(x1)))
   c(a(a(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> b(a(a(x1)))
   c(a(a(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> b(c(a(x1)))
   c(b(c(x1))) -> a(c(c(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(a(x1))) -> a(a(b(x1)))


----------------------------------------

(46) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> b(a(a(x1)))
   c(a(a(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> b(c(a(x1)))
   c(b(c(x1))) -> a(c(c(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(a(x1))) -> a(a(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> b(C(a(x1)))
   c(a(a(x1))) -> C(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(47)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> b(C(a(x1)))
   c(a(a(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> b(a(a(x1)))
   c(a(a(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> b(c(a(x1)))
   c(b(c(x1))) -> a(c(c(x1)))
   c(b(a(x1))) -> a(a(b(x1)))


----------------------------------------

(48) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(49)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> b(a(a(x1)))
   c(a(a(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> b(c(a(x1)))
   c(b(c(x1))) -> a(c(c(x1)))
   c(b(a(x1))) -> a(a(b(x1)))


----------------------------------------

(50)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   c(b(a(x1))) -> a(A(b(x1)))
   c(b(a(x1))) -> A(a(b(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(a(a(x1))) -> C(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))


----------------------------------------

(51)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(a(a(x1))) -> C(A(b(x1)))
   c(b(a(x1))) -> A(A(b(x1)))


----------------------------------------

(52) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(53)
Complex Obligation (OR)

----------------------------------------

(54)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(a(a(x1))) -> C(A(b(x1)))
   c(b(a(x1))) -> A(A(b(x1)))


----------------------------------------

(55)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   c(a(a(x1))) -> c(A(b(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   c(a(a(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(b(a(x1))) -> A(A(b(x1)))


----------------------------------------

(56)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   c(b(a(x1))) -> a(A(b(x1)))
   c(b(a(x1))) -> A(a(b(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(a(a(x1))) -> C(A(b(x1)))


----------------------------------------

(57)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   c(b(a(x1))) -> a(A(b(x1)))
   c(b(a(x1))) -> A(a(b(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   a(b(b(x1))) -> b(c(A(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(a(a(x1))) -> C(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(58) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(59)
Complex Obligation (OR)

----------------------------------------

(60)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   c(b(a(x1))) -> a(A(b(x1)))
   c(b(a(x1))) -> A(a(b(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(a(a(x1))) -> C(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(61)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(a(a(x1))) -> c(A(b(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   c(b(a(x1))) -> a(A(b(x1)))
   c(b(a(x1))) -> A(a(b(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(a(a(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> b(c(A(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(62) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(a(a(x1))) -> c(A(b(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   c(b(a(x1))) -> a(A(b(x1)))
   c(b(a(x1))) -> A(a(b(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   a(b(b(x1))) -> b(c(A(x1)))

Relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(b(c(x1))) -> A(C(c(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> C(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(63)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> b(a(a(x1)))
   c(a(a(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> b(c(a(x1)))
   c(b(c(x1))) -> a(c(c(x1)))
   c(b(a(x1))) -> a(a(b(x1)))


----------------------------------------

(64)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   c(b(a(x1))) -> a(A(b(x1)))
   c(b(a(x1))) -> A(a(b(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   a(b(b(x1))) -> b(c(A(x1)))
   c(b(c(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(a(a(x1))) -> C(A(b(x1)))
   c(b(c(x1))) -> a(C(C(x1)))


----------------------------------------

(65)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> b(A(a(x1)))
   c(b(c(x1))) -> a(C(c(x1)))
   a(b(b(x1))) -> b(C(a(x1)))
   c(b(a(x1))) -> a(A(b(x1)))
   c(b(a(x1))) -> A(a(b(x1)))
   a(b(c(x1))) -> b(a(A(x1)))
   c(b(c(x1))) -> a(c(C(x1)))
   a(b(b(x1))) -> b(c(A(x1)))

and relative ADPs:

   c(b(c(x1))) -> A(c(C(x1)))
   c(a(a(x1))) -> C(A(b(x1)))
   c(b(c(x1))) -> A(C(c(x1)))

