YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/W515J.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPDerelatifying2Proof [SOUND, 0 ms]
(4) OR
    (5) RelADPP
        (6) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (7) OR
            (8) RelADPP
                (9) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (10) OR
                    (11) RelADPP
                        (12) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (13) OR
                            (14) RelADPP
                                (15) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (16) OR
                                    (17) RelADPP
                                        (18) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                        (19) RelADPP
                                    (20) RelADPP
                            (21) RelADPP
                                (22) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (23) OR
                                    (24) RelADPP
                                        (25) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                        (26) RelADPP
                                    (27) RelADPP
                                        (28) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (29) RelADPP
                            (30) RelADPP
                                (31) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (32) OR
                                    (33) RelADPP
                                        (34) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (35) RelADPP
                                    (36) RelADPP
                                        (37) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                        (38) RelADPP
                                        (39) RelADPCleverAfsProof [SOUND, 27 ms]
                                        (40) QDP
                    (41) RelADPP
                        (42) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (43) OR
                            (44) RelADPP
                                (45) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (46) OR
                                    (47) RelADPP
                                        (48) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (49) RelADPP
                                    (50) RelADPP
                            (51) RelADPP
                                (52) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                (53) RelADPP
                                (54) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (55) AND
                                    (56) RelADPP
                                        (57) RelADPCleverAfsProof [SOUND, 16 ms]
                                        (58) QDP
                                    (59) RelADPP
                                        (60) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (61) QDP
                                    (62) RelADPP
                            (63) RelADPP
                                (64) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (65) OR
                                    (66) RelADPP
                                    (67) RelADPP
                    (68) RelADPP
                        (69) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (70) OR
                            (71) RelADPP
                                (72) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (73) OR
                                    (74) RelADPP
                                    (75) RelADPP
                            (76) RelADPP
                                (77) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (78) RelADPP
                                (79) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (80) AND
                                    (81) RelADPP
                                        (82) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (83) QDP
                                    (84) RelADPP
                                        (85) RelADPCleverAfsProof [SOUND, 18 ms]
                                        (86) QDP
                                    (87) RelADPP
                            (88) RelADPP
                                (89) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (90) RelADPP
                                (91) RelADPCleverAfsProof [SOUND, 38 ms]
                                (92) QDP
                    (93) RelADPP
                        (94) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (95) OR
                            (96) RelADPP
                                (97) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (98) OR
                                    (99) RelADPP
                                    (100) RelADPP
                                        (101) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                                        (102) RelADPP
                            (103) RelADPP
                                (104) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (105) OR
                                    (106) RelADPP
                                    (107) RelADPP
                                        (108) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                        (109) RelADPP
                                        (110) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (111) AND
                                            (112) RelADPP
                                            (113) RelADPP
                            (114) RelADPP
                                (115) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                                (116) RelADPP
                                (117) RelADPCleverAfsProof [SOUND, 10 ms]
                                (118) QDP
            (119) RelADPP
                (120) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (121) OR
                    (122) RelADPP
                        (123) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (124) OR
                            (125) RelADPP
                                (126) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (127) OR
                                    (128) RelADPP
                                    (129) RelADPP
                            (130) RelADPP
                                (131) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (132) OR
                                    (133) RelADPP
                                    (134) RelADPP
                            (135) RelADPP
                                (136) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (137) OR
                                    (138) RelADPP
                                    (139) RelADPP
                    (140) RelADPP
                        (141) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (142) OR
                            (143) RelADPP
                                (144) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (145) OR
                                    (146) RelADPP
                                    (147) RelADPP
                            (148) RelADPP
                                (149) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (150) OR
                                    (151) RelADPP
                                    (152) RelADPP
                            (153) RelADPP
                                (154) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (155) OR
                                    (156) RelADPP
                                    (157) RelADPP
                    (158) RelADPP
                        (159) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (160) OR
                            (161) RelADPP
                                (162) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (163) OR
                                    (164) RelADPP
                                    (165) RelADPP
                            (166) RelADPP
                                (167) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (168) OR
                                    (169) RelADPP
                                    (170) RelADPP
                            (171) RelADPP
                                (172) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (173) RelADPP
                                (174) RelADPCleverAfsProof [SOUND, 17 ms]
                                (175) QDP
                    (176) RelADPP
                        (177) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (178) OR
                            (179) RelADPP
                                (180) RelADPDerelatifying2Proof [SOUND, 4 ms]
                                (181) OR
                                    (182) RelADPP
                                    (183) RelADPP
                            (184) RelADPP
                                (185) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (186) OR
                                    (187) RelADPP
                                    (188) RelADPP
                            (189) RelADPP
                                (190) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                (191) RelADPP
                                (192) RelADPCleverAfsProof [SOUND, 37 ms]
                                (193) QDP
            (194) RelADPP
                (195) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (196) OR
                    (197) RelADPP
                        (198) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (199) OR
                            (200) RelADPP
                                (201) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (202) OR
                                    (203) RelADPP
                                    (204) RelADPP
                            (205) RelADPP
                                (206) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (207) RelADPP
                                (208) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (209) AND
                                    (210) RelADPP
                                        (211) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (212) QDP
                                    (213) RelADPP
                                        (214) RelADPCleverAfsProof [SOUND, 7 ms]
                                        (215) QDP
                                    (216) RelADPP
                            (217) RelADPP
                                (218) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (219) OR
                                    (220) RelADPP
                                    (221) RelADPP
                    (222) RelADPP
                        (223) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (224) OR
                            (225) RelADPP
                                (226) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (227) OR
                                    (228) RelADPP
                                        (229) RelADPReductionPairProof [EQUIVALENT, 22 ms]
                                        (230) RelADPP
                                        (231) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (232) AND
                                            (233) RelADPP
                                                (234) RelADPCleverAfsProof [SOUND, 14 ms]
                                                (235) QDP
                                            (236) RelADPP
                                            (237) RelADPP
                                                (238) RelADPCleverAfsProof [SOUND, 14 ms]
                                                (239) QDP
                                    (240) RelADPP
                                        (241) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (242) RelADPP
                            (243) RelADPP
                                (244) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (245) OR
                                    (246) RelADPP
                                        (247) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                        (248) RelADPP
                                        (249) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (250) AND
                                            (251) RelADPP
                                            (252) RelADPP
                                            (253) RelADPP
                                    (254) RelADPP
                                        (255) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                        (256) RelADPP
                            (257) RelADPP
                                (258) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (259) OR
                                    (260) RelADPP
                                        (261) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (262) RelADPP
                                    (263) RelADPP
                                        (264) RelADPReductionPairProof [EQUIVALENT, 13 ms]
                                        (265) RelADPP
                    (266) RelADPP
                        (267) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (268) OR
                            (269) RelADPP
                                (270) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                                (271) RelADPP
                                (272) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (273) AND
                                    (274) RelADPP
                                        (275) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (276) QDP
                                    (277) RelADPP
                                        (278) RelADPCleverAfsProof [SOUND, 18 ms]
                                        (279) QDP
                                    (280) RelADPP
                                        (281) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (282) QDP
                            (283) RelADPP
                                (284) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (285) OR
                                    (286) RelADPP
                                        (287) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (288) RelADPP
                                    (289) RelADPP
                                        (290) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (291) RelADPP
                            (292) RelADPP
                                (293) RelADPReductionPairProof [EQUIVALENT, 11 ms]
                                (294) RelADPP
                                (295) RelADPCleverAfsProof [SOUND, 9 ms]
                                (296) QDP
                                (297) MRRProof [EQUIVALENT, 4 ms]
                                (298) QDP
                                (299) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (300) AND
                                    (301) QDP
                                    (302) QDP
                    (303) RelADPP
                        (304) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (305) OR
                            (306) RelADPP
                                (307) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (308) OR
                                    (309) RelADPP
                                    (310) RelADPP
                            (311) RelADPP
                                (312) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (313) OR
                                    (314) RelADPP
                                    (315) RelADPP
                            (316) RelADPP
                                (317) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (318) RelADPP
                                (319) RelADPCleverAfsProof [SOUND, 43 ms]
                                (320) QDP
            (321) RelADPP
                (322) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (323) OR
                    (324) RelADPP
                        (325) RelADPDerelatifying2Proof [SOUND, 2 ms]
                        (326) OR
                            (327) RelADPP
                                (328) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (329) OR
                                    (330) RelADPP
                                    (331) RelADPP
                            (332) RelADPP
                                (333) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (334) RelADPP
                                (335) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (336) AND
                                    (337) RelADPP
                                        (338) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (339) QDP
                                    (340) RelADPP
                                        (341) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (342) QDP
                                    (343) RelADPP
                            (344) RelADPP
                                (345) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                (346) RelADPP
                                (347) RelADPCleverAfsProof [SOUND, 38 ms]
                                (348) QDP
                    (349) RelADPP
                        (350) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (351) OR
                            (352) RelADPP
                                (353) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (354) OR
                                    (355) RelADPP
                                    (356) RelADPP
                            (357) RelADPP
                                (358) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (359) OR
                                    (360) RelADPP
                                    (361) RelADPP
                            (362) RelADPP
                                (363) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (364) RelADPP
                                (365) RelADPCleverAfsProof [SOUND, 28 ms]
                                (366) QDP
                    (367) RelADPP
                        (368) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (369) OR
                            (370) RelADPP
                                (371) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (372) RelADPP
                                (373) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (374) AND
                                    (375) RelADPP
                                        (376) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (377) QDP
                                    (378) RelADPP
                                        (379) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (380) QDP
                                    (381) RelADPP
                            (382) RelADPP
                                (383) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (384) OR
                                    (385) RelADPP
                                    (386) RelADPP
                            (387) RelADPP
                                (388) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (389) RelADPP
                                (390) RelADPCleverAfsProof [SOUND, 9 ms]
                                (391) QDP
                    (392) RelADPP
                        (393) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                        (394) RelADPP
                        (395) RelADPCleverAfsProof [SOUND, 14 ms]
                        (396) QDP
                        (397) MRRProof [EQUIVALENT, 6 ms]
                        (398) QDP
                        (399) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (400) AND
                            (401) QDP
                                (402) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (403) YES
                            (404) QDP
                                (405) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (406) YES
            (407) RelADPP
                (408) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (409) OR
                    (410) RelADPP
                        (411) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (412) OR
                            (413) RelADPP
                                (414) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (415) OR
                                    (416) RelADPP
                                        (417) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (418) RelADPP
                                    (419) RelADPP
                                        (420) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (421) RelADPP
                                        (422) RelADPCleverAfsProof [SOUND, 38 ms]
                                        (423) QDP
                            (424) RelADPP
                                (425) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (426) OR
                                    (427) RelADPP
                                        (428) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (429) RelADPP
                                    (430) RelADPP
                                        (431) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (432) RelADPP
                                        (433) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (434) AND
                                            (435) RelADPP
                                                (436) RelADPCleverAfsProof [SOUND, 24 ms]
                                                (437) QDP
                                            (438) RelADPP
                                                (439) RelADPCleverAfsProof [SOUND, 5 ms]
                                                (440) QDP
                            (441) RelADPP
                                (442) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (443) RelADPP
                                (444) RelADPCleverAfsProof [SOUND, 10 ms]
                                (445) QDP
                                (446) MRRProof [EQUIVALENT, 6 ms]
                                (447) QDP
                                (448) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (449) AND
                                    (450) QDP
                                    (451) QDP
                    (452) RelADPP
                        (453) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (454) OR
                            (455) RelADPP
                                (456) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (457) OR
                                    (458) RelADPP
                                        (459) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                        (460) RelADPP
                                    (461) RelADPP
                                        (462) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (463) RelADPP
                                        (464) RelADPCleverAfsProof [SOUND, 6 ms]
                                        (465) QDP
                            (466) RelADPP
                                (467) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (468) OR
                                    (469) RelADPP
                                        (470) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                        (471) RelADPP
                                    (472) RelADPP
                                        (473) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (474) RelADPP
                                        (475) RelADPCleverAfsProof [SOUND, 29 ms]
                                        (476) QDP
                            (477) RelADPP
                                (478) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (479) RelADPP
                                (480) RelADPCleverAfsProof [SOUND, 30 ms]
                                (481) QDP
                                (482) MRRProof [EQUIVALENT, 4 ms]
                                (483) QDP
                                (484) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (485) AND
                                    (486) QDP
                                    (487) QDP
                    (488) RelADPP
                        (489) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (490) OR
                            (491) RelADPP
                                (492) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (493) OR
                                    (494) RelADPP
                                        (495) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (496) RelADPP
                                    (497) RelADPP
                                        (498) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (499) RelADPP
                                        (500) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (501) AND
                                            (502) RelADPP
                                                (503) RelADPCleverAfsProof [SOUND, 13 ms]
                                                (504) QDP
                                            (505) RelADPP
                                                (506) RelADPCleverAfsProof [SOUND, 14 ms]
                                                (507) QDP
                            (508) RelADPP
                                (509) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (510) OR
                                    (511) RelADPP
                                        (512) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                        (513) RelADPP
                                    (514) RelADPP
                                        (515) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (516) RelADPP
                                        (517) RelADPCleverAfsProof [SOUND, 36 ms]
                                        (518) QDP
                            (519) RelADPP
                                (520) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (521) RelADPP
                                (522) RelADPCleverAfsProof [SOUND, 10 ms]
                                (523) QDP
                                (524) MRRProof [EQUIVALENT, 4 ms]
                                (525) QDP
                                (526) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (527) AND
                                    (528) QDP
                                    (529) QDP
                    (530) RelADPP
                        (531) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                        (532) RelADPP
                        (533) RelADPCleverAfsProof [SOUND, 43 ms]
                        (534) QDP
                        (535) MRRProof [EQUIVALENT, 9 ms]
                        (536) QDP
                        (537) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (538) AND
                            (539) QDP
                            (540) QDP
    (541) RelADPP
        (542) RelADPDerelatifying2Proof [SOUND, 5 ms]
        (543) OR
            (544) RelADPP
                (545) RelADPDerelatifying2Proof [SOUND, 8 ms]
                (546) OR
                    (547) RelADPP
                        (548) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (549) OR
                            (550) RelADPP
                                (551) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (552) OR
                                    (553) RelADPP
                                    (554) RelADPP
                            (555) RelADPP
                                (556) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                (557) RelADPP
                                (558) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (559) AND
                                    (560) RelADPP
                                        (561) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (562) QDP
                                    (563) RelADPP
                                        (564) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (565) QDP
                                    (566) RelADPP
                            (567) RelADPP
                                (568) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (569) RelADPP
                                (570) RelADPCleverAfsProof [SOUND, 17 ms]
                                (571) QDP
                    (572) RelADPP
                        (573) RelADPDerelatifying2Proof [SOUND, 2 ms]
                        (574) OR
                            (575) RelADPP
                                (576) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (577) OR
                                    (578) RelADPP
                                    (579) RelADPP
                            (580) RelADPP
                                (581) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (582) OR
                                    (583) RelADPP
                                    (584) RelADPP
                            (585) RelADPP
                                (586) RelADPDerelatifying2Proof [SOUND, 4 ms]
                                (587) OR
                                    (588) RelADPP
                                    (589) RelADPP
                    (590) RelADPP
                        (591) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (592) OR
                            (593) RelADPP
                                (594) RelADPReductionPairProof [EQUIVALENT, 14 ms]
                                (595) RelADPP
                                (596) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (597) AND
                                    (598) RelADPP
                                        (599) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (600) QDP
                                    (601) RelADPP
                                        (602) RelADPCleverAfsProof [SOUND, 24 ms]
                                        (603) QDP
                                    (604) RelADPP
                            (605) RelADPP
                                (606) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (607) OR
                                    (608) RelADPP
                                    (609) RelADPP
                            (610) RelADPP
                                (611) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (612) OR
                                    (613) RelADPP
                                    (614) RelADPP
                    (615) RelADPP
                        (616) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (617) OR
                            (618) RelADPP
                                (619) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                (620) RelADPP
                                (621) RelADPCleverAfsProof [SOUND, 27 ms]
                                (622) QDP
                            (623) RelADPP
                                (624) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (625) OR
                                    (626) RelADPP
                                    (627) RelADPP
                            (628) RelADPP
                                (629) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (630) OR
                                    (631) RelADPP
                                    (632) RelADPP
            (633) RelADPP
                (634) RelADPDerelatifying2Proof [SOUND, 7 ms]
                (635) OR
                    (636) RelADPP
                        (637) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (638) OR
                            (639) RelADPP
                                (640) RelADPDerelatifying2Proof [SOUND, 5 ms]
                                (641) OR
                                    (642) RelADPP
                                    (643) RelADPP
                            (644) RelADPP
                                (645) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (646) RelADPP
                                (647) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (648) AND
                                    (649) RelADPP
                                        (650) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (651) QDP
                                    (652) RelADPP
                                        (653) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (654) QDP
                                    (655) RelADPP
                            (656) RelADPP
                                (657) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (658) RelADPP
                                (659) RelADPCleverAfsProof [SOUND, 26 ms]
                                (660) QDP
                    (661) RelADPP
                        (662) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (663) OR
                            (664) RelADPP
                                (665) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (666) OR
                                    (667) RelADPP
                                    (668) RelADPP
                            (669) RelADPP
                                (670) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (671) OR
                                    (672) RelADPP
                                    (673) RelADPP
                            (674) RelADPP
                                (675) RelADPReductionPairProof [EQUIVALENT, 21 ms]
                                (676) RelADPP
                                (677) RelADPCleverAfsProof [SOUND, 38 ms]
                                (678) QDP
                    (679) RelADPP
                        (680) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (681) OR
                            (682) RelADPP
                                (683) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (684) RelADPP
                                (685) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (686) AND
                                    (687) RelADPP
                                        (688) RelADPCleverAfsProof [SOUND, 13 ms]
                                        (689) QDP
                                    (690) RelADPP
                                        (691) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (692) QDP
                                    (693) RelADPP
                            (694) RelADPP
                                (695) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (696) OR
                                    (697) RelADPP
                                    (698) RelADPP
                            (699) RelADPP
                                (700) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (701) RelADPP
                                (702) RelADPCleverAfsProof [SOUND, 7 ms]
                                (703) QDP
                    (704) RelADPP
                        (705) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                        (706) RelADPP
                        (707) RelADPCleverAfsProof [SOUND, 10 ms]
                        (708) QDP
                        (709) MRRProof [EQUIVALENT, 4 ms]
                        (710) QDP
                        (711) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (712) AND
                            (713) QDP
                            (714) QDP
            (715) RelADPP
                (716) RelADPDerelatifying2Proof [SOUND, 5 ms]
                (717) OR
                    (718) RelADPP
                        (719) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (720) OR
                            (721) RelADPP
                                (722) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (723) OR
                                    (724) RelADPP
                                    (725) RelADPP
                            (726) RelADPP
                                (727) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (728) OR
                                    (729) RelADPP
                                    (730) RelADPP
                            (731) RelADPP
                                (732) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (733) OR
                                    (734) RelADPP
                                    (735) RelADPP
                    (736) RelADPP
                        (737) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (738) OR
                            (739) RelADPP
                                (740) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (741) OR
                                    (742) RelADPP
                                    (743) RelADPP
                            (744) RelADPP
                                (745) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (746) OR
                                    (747) RelADPP
                                    (748) RelADPP
                            (749) RelADPP
                                (750) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                (751) RelADPP
                                (752) RelADPCleverAfsProof [SOUND, 28 ms]
                                (753) QDP
                    (754) RelADPP
                        (755) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (756) OR
                            (757) RelADPP
                                (758) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (759) OR
                                    (760) RelADPP
                                    (761) RelADPP
                            (762) RelADPP
                                (763) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (764) OR
                                    (765) RelADPP
                                    (766) RelADPP
                            (767) RelADPP
                                (768) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (769) OR
                                    (770) RelADPP
                                    (771) RelADPP
                    (772) RelADPP
                        (773) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (774) OR
                            (775) RelADPP
                                (776) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (777) OR
                                    (778) RelADPP
                                    (779) RelADPP
                            (780) RelADPP
                                (781) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (782) RelADPP
                                (783) RelADPCleverAfsProof [SOUND, 26 ms]
                                (784) QDP
                            (785) RelADPP
                                (786) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (787) OR
                                    (788) RelADPP
                                    (789) RelADPP
            (790) RelADPP
                (791) RelADPDerelatifying2Proof [SOUND, 7 ms]
                (792) OR
                    (793) RelADPP
                        (794) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (795) OR
                            (796) RelADPP
                                (797) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                (798) RelADPP
                                (799) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (800) AND
                                    (801) RelADPP
                                        (802) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (803) QDP
                                    (804) RelADPP
                                        (805) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (806) QDP
                                    (807) RelADPP
                            (808) RelADPP
                                (809) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (810) OR
                                    (811) RelADPP
                                    (812) RelADPP
                            (813) RelADPP
                                (814) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (815) OR
                                    (816) RelADPP
                                    (817) RelADPP
                    (818) RelADPP
                        (819) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (820) OR
                            (821) RelADPP
                                (822) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                (823) RelADPP
                                (824) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (825) AND
                                    (826) RelADPP
                                        (827) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (828) QDP
                                    (829) RelADPP
                                        (830) RelADPCleverAfsProof [SOUND, 16 ms]
                                        (831) QDP
                                    (832) RelADPP
                            (833) RelADPP
                                (834) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (835) OR
                                    (836) RelADPP
                                    (837) RelADPP
                            (838) RelADPP
                                (839) RelADPReductionPairProof [EQUIVALENT, 13 ms]
                                (840) RelADPP
                                (841) RelADPCleverAfsProof [SOUND, 36 ms]
                                (842) QDP
                    (843) RelADPP
                        (844) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (845) OR
                            (846) RelADPP
                                (847) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (848) OR
                                    (849) RelADPP
                                    (850) RelADPP
                            (851) RelADPP
                                (852) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (853) OR
                                    (854) RelADPP
                                    (855) RelADPP
                            (856) RelADPP
                                (857) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (858) OR
                                    (859) RelADPP
                                    (860) RelADPP
                    (861) RelADPP
                        (862) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (863) OR
                            (864) RelADPP
                                (865) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (866) OR
                                    (867) RelADPP
                                    (868) RelADPP
                            (869) RelADPP
                                (870) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (871) RelADPP
                                (872) RelADPCleverAfsProof [SOUND, 9 ms]
                                (873) QDP
                            (874) RelADPP
                                (875) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (876) OR
                                    (877) RelADPP
                                    (878) RelADPP
            (879) RelADPP
                (880) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (881) OR
                    (882) RelADPP
                        (883) RelADPDerelatifying2Proof [SOUND, 2 ms]
                        (884) OR
                            (885) RelADPP
                                (886) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (887) RelADPP
                                (888) RelADPCleverAfsProof [SOUND, 21 ms]
                                (889) QDP
                            (890) RelADPP
                                (891) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (892) OR
                                    (893) RelADPP
                                    (894) RelADPP
                            (895) RelADPP
                                (896) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (897) OR
                                    (898) RelADPP
                                    (899) RelADPP
                    (900) RelADPP
                        (901) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                        (902) RelADPP
                        (903) RelADPCleverAfsProof [SOUND, 10 ms]
                        (904) QDP
                        (905) MRRProof [EQUIVALENT, 4 ms]
                        (906) QDP
                        (907) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (908) AND
                            (909) QDP
                            (910) QDP
                    (911) RelADPP
                        (912) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (913) OR
                            (914) RelADPP
                                (915) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (916) OR
                                    (917) RelADPP
                                    (918) RelADPP
                            (919) RelADPP
                                (920) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                (921) RelADPP
                                (922) RelADPCleverAfsProof [SOUND, 30 ms]
                                (923) QDP
                            (924) RelADPP
                                (925) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (926) OR
                                    (927) RelADPP
                                    (928) RelADPP
                    (929) RelADPP
                        (930) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (931) OR
                            (932) RelADPP
                                (933) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (934) OR
                                    (935) RelADPP
                                    (936) RelADPP
                            (937) RelADPP
                                (938) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                (939) RelADPP
                                (940) RelADPCleverAfsProof [SOUND, 28 ms]
                                (941) QDP
                            (942) RelADPP
                                (943) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (944) OR
                                    (945) RelADPP
                                    (946) RelADPP
    (947) RelADPP
        (948) RelADPDerelatifying2Proof [SOUND, 14 ms]
        (949) OR
            (950) RelADPP
                (951) RelADPDerelatifying2Proof [SOUND, 4 ms]
                (952) OR
                    (953) RelADPP
                        (954) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (955) OR
                            (956) RelADPP
                                (957) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (958) OR
                                    (959) RelADPP
                                    (960) RelADPP
                            (961) RelADPP
                                (962) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (963) OR
                                    (964) RelADPP
                                    (965) RelADPP
                            (966) RelADPP
                                (967) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (968) RelADPP
                                (969) RelADPCleverAfsProof [SOUND, 27 ms]
                                (970) QDP
                    (971) RelADPP
                        (972) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (973) OR
                            (974) RelADPP
                                (975) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (976) OR
                                    (977) RelADPP
                                    (978) RelADPP
                            (979) RelADPP
                                (980) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (981) OR
                                    (982) RelADPP
                                    (983) RelADPP
                            (984) RelADPP
                                (985) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (986) OR
                                    (987) RelADPP
                                    (988) RelADPP
                    (989) RelADPP
                        (990) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (991) OR
                            (992) RelADPP
                                (993) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (994) OR
                                    (995) RelADPP
                                    (996) RelADPP
                            (997) RelADPP
                                (998) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (999) OR
                                    (1000) RelADPP
                                    (1001) RelADPP
                            (1002) RelADPP
                                (1003) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1004) OR
                                    (1005) RelADPP
                                    (1006) RelADPP
                    (1007) RelADPP
                        (1008) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1009) OR
                            (1010) RelADPP
                                (1011) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1012) RelADPP
                                (1013) RelADPCleverAfsProof [SOUND, 20 ms]
                                (1014) QDP
                            (1015) RelADPP
                                (1016) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1017) OR
                                    (1018) RelADPP
                                    (1019) RelADPP
                            (1020) RelADPP
                                (1021) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1022) OR
                                    (1023) RelADPP
                                    (1024) RelADPP
            (1025) RelADPP
                (1026) RelADPDerelatifying2Proof [SOUND, 5 ms]
                (1027) OR
                    (1028) RelADPP
                        (1029) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1030) OR
                            (1031) RelADPP
                                (1032) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1033) OR
                                    (1034) RelADPP
                                    (1035) RelADPP
                            (1036) RelADPP
                                (1037) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1038) OR
                                    (1039) RelADPP
                                    (1040) RelADPP
                            (1041) RelADPP
                                (1042) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (1043) RelADPP
                                (1044) RelADPCleverAfsProof [SOUND, 28 ms]
                                (1045) QDP
                    (1046) RelADPP
                        (1047) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1048) OR
                            (1049) RelADPP
                                (1050) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1051) OR
                                    (1052) RelADPP
                                    (1053) RelADPP
                            (1054) RelADPP
                                (1055) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1056) OR
                                    (1057) RelADPP
                                    (1058) RelADPP
                            (1059) RelADPP
                                (1060) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (1061) RelADPP
                                (1062) RelADPCleverAfsProof [SOUND, 27 ms]
                                (1063) QDP
                    (1064) RelADPP
                        (1065) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1066) OR
                            (1067) RelADPP
                                (1068) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1069) OR
                                    (1070) RelADPP
                                    (1071) RelADPP
                            (1072) RelADPP
                                (1073) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1074) OR
                                    (1075) RelADPP
                                    (1076) RelADPP
                            (1077) RelADPP
                                (1078) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (1079) RelADPP
                                (1080) RelADPCleverAfsProof [SOUND, 36 ms]
                                (1081) QDP
                    (1082) RelADPP
                        (1083) RelADPReductionPairProof [EQUIVALENT, 22 ms]
                        (1084) RelADPP
                        (1085) RelADPCleverAfsProof [SOUND, 21 ms]
                        (1086) QDP
                        (1087) MRRProof [EQUIVALENT, 4 ms]
                        (1088) QDP
                        (1089) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (1090) AND
                            (1091) QDP
                            (1092) QDP
            (1093) RelADPP
                (1094) RelADPDerelatifying2Proof [SOUND, 4 ms]
                (1095) OR
                    (1096) RelADPP
                        (1097) RelADPDerelatifying2Proof [SOUND, 2 ms]
                        (1098) OR
                            (1099) RelADPP
                                (1100) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1101) OR
                                    (1102) RelADPP
                                    (1103) RelADPP
                            (1104) RelADPP
                                (1105) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1106) OR
                                    (1107) RelADPP
                                    (1108) RelADPP
                            (1109) RelADPP
                                (1110) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1111) OR
                                    (1112) RelADPP
                                    (1113) RelADPP
                    (1114) RelADPP
                        (1115) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1116) OR
                            (1117) RelADPP
                                (1118) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1119) OR
                                    (1120) RelADPP
                                    (1121) RelADPP
                            (1122) RelADPP
                                (1123) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1124) OR
                                    (1125) RelADPP
                                    (1126) RelADPP
                            (1127) RelADPP
                                (1128) RelADPReductionPairProof [EQUIVALENT, 22 ms]
                                (1129) RelADPP
                                (1130) RelADPCleverAfsProof [SOUND, 37 ms]
                                (1131) QDP
                    (1132) RelADPP
                        (1133) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1134) OR
                            (1135) RelADPP
                                (1136) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1137) OR
                                    (1138) RelADPP
                                    (1139) RelADPP
                            (1140) RelADPP
                                (1141) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (1142) OR
                                    (1143) RelADPP
                                    (1144) RelADPP
                            (1145) RelADPP
                                (1146) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1147) OR
                                    (1148) RelADPP
                                    (1149) RelADPP
                    (1150) RelADPP
                        (1151) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1152) OR
                            (1153) RelADPP
                                (1154) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1155) OR
                                    (1156) RelADPP
                                    (1157) RelADPP
                            (1158) RelADPP
                                (1159) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (1160) RelADPP
                                (1161) RelADPCleverAfsProof [SOUND, 7 ms]
                                (1162) QDP
                            (1163) RelADPP
                                (1164) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1165) OR
                                    (1166) RelADPP
                                    (1167) RelADPP
            (1168) RelADPP
                (1169) RelADPDerelatifying2Proof [SOUND, 1 ms]
                (1170) OR
                    (1171) RelADPP
                        (1172) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1173) OR
                            (1174) RelADPP
                                (1175) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1176) OR
                                    (1177) RelADPP
                                    (1178) RelADPP
                            (1179) RelADPP
                                (1180) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1181) OR
                                    (1182) RelADPP
                                    (1183) RelADPP
                            (1184) RelADPP
                                (1185) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1186) OR
                                    (1187) RelADPP
                                    (1188) RelADPP
                    (1189) RelADPP
                        (1190) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1191) OR
                            (1192) RelADPP
                                (1193) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1194) OR
                                    (1195) RelADPP
                                    (1196) RelADPP
                            (1197) RelADPP
                                (1198) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1199) OR
                                    (1200) RelADPP
                                    (1201) RelADPP
                            (1202) RelADPP
                                (1203) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (1204) RelADPP
                    (1205) RelADPP
                        (1206) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1207) OR
                            (1208) RelADPP
                                (1209) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1210) OR
                                    (1211) RelADPP
                                    (1212) RelADPP
                            (1213) RelADPP
                                (1214) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1215) OR
                                    (1216) RelADPP
                                    (1217) RelADPP
                            (1218) RelADPP
                                (1219) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1220) OR
                                    (1221) RelADPP
                                    (1222) RelADPP
                    (1223) RelADPP
                        (1224) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1225) OR
                            (1226) RelADPP
                                (1227) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1228) OR
                                    (1229) RelADPP
                                    (1230) RelADPP
                            (1231) RelADPP
                                (1232) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (1233) RelADPP
                                (1234) RelADPCleverAfsProof [SOUND, 37 ms]
                                (1235) QDP
                            (1236) RelADPP
                                (1237) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1238) OR
                                    (1239) RelADPP
                                    (1240) RelADPP
            (1241) RelADPP
                (1242) RelADPDerelatifying2Proof [SOUND, 5 ms]
                (1243) OR
                    (1244) RelADPP
                        (1245) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1246) OR
                            (1247) RelADPP
                                (1248) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (1249) RelADPP
                                (1250) RelADPCleverAfsProof [SOUND, 8 ms]
                                (1251) QDP
                            (1252) RelADPP
                                (1253) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1254) OR
                                    (1255) RelADPP
                                    (1256) RelADPP
                            (1257) RelADPP
                                (1258) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1259) OR
                                    (1260) RelADPP
                                    (1261) RelADPP
                    (1262) RelADPP
                        (1263) RelADPReductionPairProof [EQUIVALENT, 12 ms]
                        (1264) RelADPP
                        (1265) RelADPCleverAfsProof [SOUND, 11 ms]
                        (1266) QDP
                        (1267) MRRProof [EQUIVALENT, 3 ms]
                        (1268) QDP
                        (1269) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (1270) AND
                            (1271) QDP
                            (1272) QDP
                    (1273) RelADPP
                        (1274) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1275) OR
                            (1276) RelADPP
                            (1277) RelADPP
                                (1278) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (1279) RelADPP
                            (1280) RelADPP
                                (1281) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1282) OR
                                    (1283) RelADPP
                                    (1284) RelADPP
                    (1285) RelADPP
                        (1286) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1287) OR
                            (1288) RelADPP
                                (1289) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1290) OR
                                    (1291) RelADPP
                                    (1292) RelADPP
                            (1293) RelADPP
                                (1294) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (1295) RelADPP
                                (1296) RelADPCleverAfsProof [SOUND, 37 ms]
                                (1297) QDP
                            (1298) RelADPP
                                (1299) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1300) OR
                                    (1301) RelADPP
                                    (1302) RelADPP
    (1303) RelADPP
        (1304) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (1305) OR
            (1306) RelADPP
                (1307) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1308) OR
                    (1309) RelADPP
                        (1310) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (1311) OR
                            (1312) RelADPP
                                (1313) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1314) OR
                                    (1315) RelADPP
                                        (1316) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                        (1317) RelADPP
                                        (1318) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1319) AND
                                            (1320) RelADPP
                                                (1321) RelADPCleverAfsProof [SOUND, 24 ms]
                                                (1322) QDP
                                            (1323) RelADPP
                                            (1324) RelADPP
                                                (1325) RelADPCleverAfsProof [SOUND, 14 ms]
                                                (1326) QDP
                                    (1327) RelADPP
                                        (1328) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1329) RelADPP
                            (1330) RelADPP
                                (1331) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1332) OR
                                    (1333) RelADPP
                                        (1334) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (1335) RelADPP
                                        (1336) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1337) AND
                                            (1338) RelADPP
                                                (1339) RelADPCleverAfsProof [SOUND, 6 ms]
                                                (1340) QDP
                                            (1341) RelADPP
                                            (1342) RelADPP
                                                (1343) RelADPCleverAfsProof [SOUND, 15 ms]
                                                (1344) QDP
                                    (1345) RelADPP
                                        (1346) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (1347) RelADPP
                                        (1348) RelADPCleverAfsProof [SOUND, 37 ms]
                                        (1349) QDP
                            (1350) RelADPP
                                (1351) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1352) OR
                                    (1353) RelADPP
                                        (1354) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1355) RelADPP
                                    (1356) RelADPP
                                        (1357) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (1358) RelADPP
                                        (1359) RelADPCleverAfsProof [SOUND, 37 ms]
                                        (1360) QDP
                    (1361) RelADPP
                        (1362) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1363) OR
                            (1364) RelADPP
                                (1365) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1366) OR
                                    (1367) RelADPP
                                        (1368) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (1369) RelADPP
                                        (1370) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1371) AND
                                            (1372) RelADPP
                                                (1373) RelADPCleverAfsProof [SOUND, 5 ms]
                                                (1374) QDP
                                            (1375) RelADPP
                                            (1376) RelADPP
                                                (1377) RelADPCleverAfsProof [SOUND, 5 ms]
                                                (1378) QDP
                                    (1379) RelADPP
                                        (1380) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1381) RelADPP
                            (1382) RelADPP
                                (1383) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (1384) RelADPP
                                (1385) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1386) AND
                                    (1387) RelADPP
                                        (1388) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (1389) QDP
                                        (1390) MRRProof [EQUIVALENT, 1 ms]
                                        (1391) QDP
                                        (1392) PisEmptyProof [EQUIVALENT, 0 ms]
                                        (1393) YES
                                    (1394) RelADPP
                                        (1395) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (1396) QDP
                                        (1397) MRRProof [EQUIVALENT, 1 ms]
                                        (1398) QDP
                                    (1399) RelADPP
                                        (1400) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (1401) QDP
                            (1402) RelADPP
                                (1403) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1404) OR
                                    (1405) RelADPP
                                        (1406) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1407) RelADPP
                                    (1408) RelADPP
                                        (1409) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                        (1410) RelADPP
                                        (1411) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1412) AND
                                            (1413) RelADPP
                                            (1414) RelADPP
                    (1415) RelADPP
                        (1416) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1417) OR
                            (1418) RelADPP
                                (1419) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1420) OR
                                    (1421) RelADPP
                                        (1422) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (1423) RelADPP
                                        (1424) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1425) AND
                                            (1426) RelADPP
                                            (1427) RelADPP
                                            (1428) RelADPP
                                    (1429) RelADPP
                                        (1430) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                        (1431) RelADPP
                                        (1432) RelADPCleverAfsProof [SOUND, 18 ms]
                                        (1433) QDP
                            (1434) RelADPP
                                (1435) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (1436) RelADPP
                                (1437) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1438) AND
                                    (1439) RelADPP
                                        (1440) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (1441) QDP
                                        (1442) MRRProof [EQUIVALENT, 1 ms]
                                        (1443) QDP
                                        (1444) PisEmptyProof [EQUIVALENT, 0 ms]
                                        (1445) YES
                                    (1446) RelADPP
                                        (1447) RelADPCleverAfsProof [SOUND, 9 ms]
                                        (1448) QDP
                                        (1449) MRRProof [EQUIVALENT, 2 ms]
                                        (1450) QDP
                                    (1451) RelADPP
                                        (1452) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (1453) QDP
                            (1454) RelADPP
                                (1455) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (1456) RelADPP
                                (1457) RelADPCleverAfsProof [SOUND, 10 ms]
                                (1458) QDP
                                (1459) MRRProof [EQUIVALENT, 4 ms]
                                (1460) QDP
                                (1461) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (1462) AND
                                    (1463) QDP
                                    (1464) QDP
                    (1465) RelADPP
                        (1466) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1467) OR
                            (1468) RelADPP
                                (1469) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1470) OR
                                    (1471) RelADPP
                                        (1472) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1473) RelADPP
                                    (1474) RelADPP
                                        (1475) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (1476) RelADPP
                                        (1477) RelADPCleverAfsProof [SOUND, 18 ms]
                                        (1478) QDP
                            (1479) RelADPP
                                (1480) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1481) OR
                                    (1482) RelADPP
                                        (1483) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1484) RelADPP
                                    (1485) RelADPP
                                        (1486) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (1487) RelADPP
                                        (1488) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1489) AND
                                            (1490) RelADPP
                                                (1491) RelADPCleverAfsProof [SOUND, 16 ms]
                                                (1492) QDP
                                            (1493) RelADPP
                                                (1494) RelADPCleverAfsProof [SOUND, 15 ms]
                                                (1495) QDP
                            (1496) RelADPP
                                (1497) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (1498) RelADPP
                                (1499) RelADPCleverAfsProof [SOUND, 20 ms]
                                (1500) QDP
                                (1501) MRRProof [EQUIVALENT, 4 ms]
                                (1502) QDP
                                (1503) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (1504) AND
                                    (1505) QDP
                                    (1506) QDP
            (1507) RelADPP
                (1508) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1509) OR
                    (1510) RelADPP
                        (1511) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1512) OR
                            (1513) RelADPP
                                (1514) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1515) OR
                                    (1516) RelADPP
                                        (1517) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                        (1518) RelADPP
                                        (1519) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1520) AND
                                            (1521) RelADPP
                                                (1522) RelADPCleverAfsProof [SOUND, 4 ms]
                                                (1523) QDP
                                            (1524) RelADPP
                                            (1525) RelADPP
                                                (1526) RelADPCleverAfsProof [SOUND, 16 ms]
                                                (1527) QDP
                                    (1528) RelADPP
                                        (1529) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1530) RelADPP
                            (1531) RelADPP
                                (1532) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1533) OR
                                    (1534) RelADPP
                                        (1535) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (1536) RelADPP
                                        (1537) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1538) AND
                                            (1539) RelADPP
                                                (1540) RelADPCleverAfsProof [SOUND, 15 ms]
                                                (1541) QDP
                                            (1542) RelADPP
                                            (1543) RelADPP
                                                (1544) RelADPCleverAfsProof [SOUND, 14 ms]
                                                (1545) QDP
                                    (1546) RelADPP
                                        (1547) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (1548) RelADPP
                                        (1549) RelADPCleverAfsProof [SOUND, 28 ms]
                                        (1550) QDP
                            (1551) RelADPP
                                (1552) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1553) OR
                                    (1554) RelADPP
                                        (1555) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1556) RelADPP
                                    (1557) RelADPP
                                        (1558) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (1559) RelADPP
                                        (1560) RelADPCleverAfsProof [SOUND, 6 ms]
                                        (1561) QDP
                    (1562) RelADPP
                        (1563) RelADPDerelatifying2Proof [SOUND, 2 ms]
                        (1564) OR
                            (1565) RelADPP
                                (1566) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1567) OR
                                    (1568) RelADPP
                                        (1569) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (1570) RelADPP
                                        (1571) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1572) AND
                                            (1573) RelADPP
                                                (1574) RelADPCleverAfsProof [SOUND, 15 ms]
                                                (1575) QDP
                                            (1576) RelADPP
                                            (1577) RelADPP
                                                (1578) RelADPCleverAfsProof [SOUND, 14 ms]
                                                (1579) QDP
                                    (1580) RelADPP
                                        (1581) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1582) RelADPP
                            (1583) RelADPP
                                (1584) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1585) OR
                                    (1586) RelADPP
                                        (1587) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                        (1588) RelADPP
                                        (1589) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1590) AND
                                            (1591) RelADPP
                                                (1592) RelADPCleverAfsProof [SOUND, 4 ms]
                                                (1593) QDP
                                            (1594) RelADPP
                                            (1595) RelADPP
                                                (1596) RelADPCleverAfsProof [SOUND, 14 ms]
                                                (1597) QDP
                                    (1598) RelADPP
                                        (1599) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1600) RelADPP
                            (1601) RelADPP
                                (1602) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1603) OR
                                    (1604) RelADPP
                                        (1605) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1606) RelADPP
                                    (1607) RelADPP
                                        (1608) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1609) RelADPP
                    (1610) RelADPP
                        (1611) RelADPDerelatifying2Proof [SOUND, 5 ms]
                        (1612) OR
                            (1613) RelADPP
                                (1614) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1615) OR
                                    (1616) RelADPP
                                        (1617) RelADPReductionPairProof [EQUIVALENT, 20 ms]
                                        (1618) RelADPP
                                        (1619) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1620) AND
                                            (1621) RelADPP
                                            (1622) RelADPP
                                            (1623) RelADPP
                                    (1624) RelADPP
                                        (1625) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (1626) RelADPP
                                        (1627) RelADPCleverAfsProof [SOUND, 27 ms]
                                        (1628) QDP
                            (1629) RelADPP
                                (1630) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1631) OR
                                    (1632) RelADPP
                                        (1633) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (1634) RelADPP
                                        (1635) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1636) AND
                                            (1637) RelADPP
                                                (1638) RelADPCleverAfsProof [SOUND, 5 ms]
                                                (1639) QDP
                                            (1640) RelADPP
                                            (1641) RelADPP
                                                (1642) RelADPCleverAfsProof [SOUND, 15 ms]
                                                (1643) QDP
                                    (1644) RelADPP
                                        (1645) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1646) RelADPP
                            (1647) RelADPP
                                (1648) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1649) OR
                                    (1650) RelADPP
                                        (1651) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (1652) RelADPP
                                        (1653) RelADPCleverAfsProof [SOUND, 18 ms]
                                        (1654) QDP
                                    (1655) RelADPP
                                        (1656) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1657) RelADPP
                    (1658) RelADPP
                        (1659) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (1660) OR
                            (1661) RelADPP
                                (1662) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1663) OR
                                    (1664) RelADPP
                                        (1665) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1666) RelADPP
                                    (1667) RelADPP
                                        (1668) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (1669) RelADPP
                                        (1670) RelADPCleverAfsProof [SOUND, 17 ms]
                                        (1671) QDP
                            (1672) RelADPP
                                (1673) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1674) OR
                                    (1675) RelADPP
                                        (1676) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1677) RelADPP
                                    (1678) RelADPP
                                        (1679) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1680) RelADPP
                            (1681) RelADPP
                                (1682) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1683) OR
                                    (1684) RelADPP
                                        (1685) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                        (1686) RelADPP
                                        (1687) RelADPCleverAfsProof [SOUND, 27 ms]
                                        (1688) QDP
                                    (1689) RelADPP
                                        (1690) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1691) RelADPP
            (1692) RelADPP
                (1693) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1694) OR
                    (1695) RelADPP
                        (1696) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1697) OR
                            (1698) RelADPP
                                (1699) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1700) OR
                                    (1701) RelADPP
                                        (1702) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (1703) RelADPP
                                        (1704) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1705) AND
                                            (1706) RelADPP
                                                (1707) RelADPCleverAfsProof [SOUND, 14 ms]
                                                (1708) QDP
                                            (1709) RelADPP
                                            (1710) RelADPP
                                                (1711) RelADPCleverAfsProof [SOUND, 13 ms]
                                                (1712) QDP
                                    (1713) RelADPP
                                        (1714) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1715) RelADPP
                            (1716) RelADPP
                                (1717) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (1718) RelADPP
                                (1719) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1720) AND
                                    (1721) RelADPP
                                        (1722) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (1723) QDP
                                        (1724) MRRProof [EQUIVALENT, 1 ms]
                                        (1725) QDP
                                    (1726) RelADPP
                                        (1727) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (1728) QDP
                                        (1729) MRRProof [EQUIVALENT, 2 ms]
                                        (1730) QDP
                                    (1731) RelADPP
                                        (1732) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (1733) QDP
                            (1734) RelADPP
                                (1735) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1736) OR
                                    (1737) RelADPP
                                        (1738) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1739) RelADPP
                                    (1740) RelADPP
                                        (1741) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                        (1742) RelADPP
                                        (1743) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1744) AND
                                            (1745) RelADPP
                                            (1746) RelADPP
                    (1747) RelADPP
                        (1748) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1749) OR
                            (1750) RelADPP
                                (1751) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1752) OR
                                    (1753) RelADPP
                                        (1754) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (1755) RelADPP
                                        (1756) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1757) AND
                                            (1758) RelADPP
                                                (1759) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (1760) QDP
                                            (1761) RelADPP
                                            (1762) RelADPP
                                                (1763) RelADPCleverAfsProof [SOUND, 14 ms]
                                                (1764) QDP
                                    (1765) RelADPP
                                        (1766) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1767) RelADPP
                            (1768) RelADPP
                                (1769) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1770) OR
                                    (1771) RelADPP
                                        (1772) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                        (1773) RelADPP
                                        (1774) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1775) AND
                                            (1776) RelADPP
                                                (1777) RelADPCleverAfsProof [SOUND, 14 ms]
                                                (1778) QDP
                                            (1779) RelADPP
                                            (1780) RelADPP
                                                (1781) RelADPCleverAfsProof [SOUND, 15 ms]
                                                (1782) QDP
                                    (1783) RelADPP
                                        (1784) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1785) RelADPP
                            (1786) RelADPP
                                (1787) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1788) OR
                                    (1789) RelADPP
                                        (1790) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1791) RelADPP
                                    (1792) RelADPP
                                        (1793) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1794) RelADPP
                    (1795) RelADPP
                        (1796) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1797) OR
                            (1798) RelADPP
                                (1799) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1800) RelADPP
                                (1801) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1802) AND
                                    (1803) RelADPP
                                        (1804) RelADPCleverAfsProof [SOUND, 16 ms]
                                        (1805) QDP
                                        (1806) MRRProof [EQUIVALENT, 3 ms]
                                        (1807) QDP
                                        (1808) PisEmptyProof [EQUIVALENT, 0 ms]
                                        (1809) YES
                                    (1810) RelADPP
                                        (1811) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (1812) QDP
                                        (1813) MRRProof [EQUIVALENT, 2 ms]
                                        (1814) QDP
                                    (1815) RelADPP
                                        (1816) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (1817) QDP
                            (1818) RelADPP
                                (1819) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1820) OR
                                    (1821) RelADPP
                                        (1822) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (1823) RelADPP
                                        (1824) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1825) AND
                                            (1826) RelADPP
                                                (1827) RelADPCleverAfsProof [SOUND, 5 ms]
                                                (1828) QDP
                                            (1829) RelADPP
                                            (1830) RelADPP
                                                (1831) RelADPCleverAfsProof [SOUND, 25 ms]
                                                (1832) QDP
                                    (1833) RelADPP
                                        (1834) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1835) RelADPP
                            (1836) RelADPP
                                (1837) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1838) OR
                                    (1839) RelADPP
                                        (1840) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (1841) RelADPP
                                        (1842) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1843) AND
                                            (1844) RelADPP
                                                (1845) RelADPCleverAfsProof [SOUND, 6 ms]
                                                (1846) QDP
                                            (1847) RelADPP
                                                (1848) RelADPCleverAfsProof [SOUND, 6 ms]
                                                (1849) QDP
                                    (1850) RelADPP
                                        (1851) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1852) RelADPP
                    (1853) RelADPP
                        (1854) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1855) OR
                            (1856) RelADPP
                                (1857) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1858) OR
                                    (1859) RelADPP
                                        (1860) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1861) RelADPP
                                    (1862) RelADPP
                                        (1863) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (1864) RelADPP
                                        (1865) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1866) AND
                                            (1867) RelADPP
                                            (1868) RelADPP
                            (1869) RelADPP
                                (1870) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1871) OR
                                    (1872) RelADPP
                                        (1873) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1874) RelADPP
                                    (1875) RelADPP
                                        (1876) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                        (1877) RelADPP
                            (1878) RelADPP
                                (1879) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1880) OR
                                    (1881) RelADPP
                                        (1882) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (1883) RelADPP
                                        (1884) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1885) AND
                                            (1886) RelADPP
                                                (1887) RelADPCleverAfsProof [SOUND, 13 ms]
                                                (1888) QDP
                                            (1889) RelADPP
                                                (1890) RelADPCleverAfsProof [SOUND, 24 ms]
                                                (1891) QDP
                                    (1892) RelADPP
                                        (1893) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1894) RelADPP
            (1895) RelADPP
                (1896) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1897) OR
                    (1898) RelADPP
                        (1899) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1900) OR
                            (1901) RelADPP
                                (1902) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1903) OR
                                    (1904) RelADPP
                                        (1905) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (1906) RelADPP
                                        (1907) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1908) AND
                                            (1909) RelADPP
                                                (1910) RelADPCleverAfsProof [SOUND, 24 ms]
                                                (1911) QDP
                                            (1912) RelADPP
                                            (1913) RelADPP
                                                (1914) RelADPCleverAfsProof [SOUND, 16 ms]
                                                (1915) QDP
                                    (1916) RelADPP
                                        (1917) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (1918) RelADPP
                                        (1919) RelADPCleverAfsProof [SOUND, 17 ms]
                                        (1920) QDP
                            (1921) RelADPP
                                (1922) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (1923) RelADPP
                                (1924) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1925) AND
                                    (1926) RelADPP
                                        (1927) RelADPCleverAfsProof [SOUND, 9 ms]
                                        (1928) QDP
                                        (1929) MRRProof [EQUIVALENT, 2 ms]
                                        (1930) QDP
                                        (1931) PisEmptyProof [EQUIVALENT, 0 ms]
                                        (1932) YES
                                    (1933) RelADPP
                                        (1934) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (1935) QDP
                                        (1936) MRRProof [EQUIVALENT, 2 ms]
                                        (1937) QDP
                                    (1938) RelADPP
                                        (1939) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (1940) QDP
                            (1941) RelADPP
                                (1942) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1943) RelADPP
                                (1944) RelADPCleverAfsProof [SOUND, 10 ms]
                                (1945) QDP
                                (1946) MRRProof [EQUIVALENT, 3 ms]
                                (1947) QDP
                                (1948) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (1949) AND
                                    (1950) QDP
                                    (1951) QDP
                    (1952) RelADPP
                        (1953) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1954) OR
                            (1955) RelADPP
                                (1956) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1957) OR
                                    (1958) RelADPP
                                        (1959) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (1960) RelADPP
                                        (1961) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1962) AND
                                            (1963) RelADPP
                                                (1964) RelADPCleverAfsProof [SOUND, 14 ms]
                                                (1965) QDP
                                            (1966) RelADPP
                                            (1967) RelADPP
                                                (1968) RelADPCleverAfsProof [SOUND, 14 ms]
                                                (1969) QDP
                                    (1970) RelADPP
                                        (1971) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (1972) RelADPP
                                        (1973) RelADPCleverAfsProof [SOUND, 7 ms]
                                        (1974) QDP
                            (1975) RelADPP
                                (1976) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1977) OR
                                    (1978) RelADPP
                                        (1979) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (1980) RelADPP
                                        (1981) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1982) AND
                                            (1983) RelADPP
                                                (1984) RelADPCleverAfsProof [SOUND, 4 ms]
                                                (1985) QDP
                                            (1986) RelADPP
                                            (1987) RelADPP
                                                (1988) RelADPCleverAfsProof [SOUND, 4 ms]
                                                (1989) QDP
                                    (1990) RelADPP
                                        (1991) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1992) RelADPP
                            (1993) RelADPP
                                (1994) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1995) OR
                                    (1996) RelADPP
                                        (1997) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                        (1998) RelADPP
                                        (1999) RelADPCleverAfsProof [SOUND, 27 ms]
                                        (2000) QDP
                                    (2001) RelADPP
                                        (2002) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2003) RelADPP
                    (2004) RelADPP
                        (2005) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (2006) OR
                            (2007) RelADPP
                                (2008) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (2009) RelADPP
                                (2010) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2011) AND
                                    (2012) RelADPP
                                        (2013) RelADPCleverAfsProof [SOUND, 16 ms]
                                        (2014) QDP
                                        (2015) MRRProof [EQUIVALENT, 1 ms]
                                        (2016) QDP
                                        (2017) PisEmptyProof [EQUIVALENT, 0 ms]
                                        (2018) YES
                                    (2019) RelADPP
                                        (2020) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (2021) QDP
                                        (2022) MRRProof [EQUIVALENT, 1 ms]
                                        (2023) QDP
                                    (2024) RelADPP
                                        (2025) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (2026) QDP
                            (2027) RelADPP
                                (2028) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (2029) OR
                                    (2030) RelADPP
                                        (2031) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (2032) RelADPP
                                        (2033) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2034) AND
                                            (2035) RelADPP
                                            (2036) RelADPP
                                            (2037) RelADPP
                                    (2038) RelADPP
                                        (2039) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2040) RelADPP
                            (2041) RelADPP
                                (2042) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2043) OR
                                    (2044) RelADPP
                                        (2045) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (2046) RelADPP
                                        (2047) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2048) AND
                                            (2049) RelADPP
                                            (2050) RelADPP
                                    (2051) RelADPP
                                        (2052) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2053) RelADPP
                    (2054) RelADPP
                        (2055) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (2056) OR
                            (2057) RelADPP
                                (2058) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (2059) RelADPP
                                (2060) RelADPCleverAfsProof [SOUND, 41 ms]
                                (2061) QDP
                                (2062) MRRProof [EQUIVALENT, 4 ms]
                                (2063) QDP
                                (2064) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (2065) AND
                                    (2066) QDP
                                    (2067) QDP
                            (2068) RelADPP
                                (2069) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2070) OR
                                    (2071) RelADPP
                                        (2072) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                        (2073) RelADPP
                                        (2074) RelADPCleverAfsProof [SOUND, 16 ms]
                                        (2075) QDP
                                    (2076) RelADPP
                                        (2077) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2078) RelADPP
                            (2079) RelADPP
                                (2080) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2081) OR
                                    (2082) RelADPP
                                        (2083) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (2084) RelADPP
                                        (2085) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2086) AND
                                            (2087) RelADPP
                                            (2088) RelADPP
                                    (2089) RelADPP
                                        (2090) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2091) RelADPP
            (2092) RelADPP
                (2093) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (2094) OR
                    (2095) RelADPP
                        (2096) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (2097) OR
                            (2098) RelADPP
                                (2099) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2100) OR
                                    (2101) RelADPP
                                        (2102) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2103) RelADPP
                                    (2104) RelADPP
                                        (2105) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                        (2106) RelADPP
                                        (2107) RelADPCleverAfsProof [SOUND, 38 ms]
                                        (2108) QDP
                            (2109) RelADPP
                                (2110) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2111) OR
                                    (2112) RelADPP
                                        (2113) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2114) RelADPP
                                    (2115) RelADPP
                                        (2116) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                        (2117) RelADPP
                                        (2118) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2119) AND
                                            (2120) RelADPP
                                            (2121) RelADPP
                            (2122) RelADPP
                                (2123) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (2124) RelADPP
                                (2125) RelADPCleverAfsProof [SOUND, 11 ms]
                                (2126) QDP
                                (2127) MRRProof [EQUIVALENT, 4 ms]
                                (2128) QDP
                                (2129) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (2130) AND
                                    (2131) QDP
                                    (2132) QDP
                    (2133) RelADPP
                        (2134) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (2135) OR
                            (2136) RelADPP
                                (2137) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2138) OR
                                    (2139) RelADPP
                                        (2140) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2141) RelADPP
                                    (2142) RelADPP
                                        (2143) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (2144) RelADPP
                                        (2145) RelADPCleverAfsProof [SOUND, 0 ms]
                                        (2146) QDP
                            (2147) RelADPP
                                (2148) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2149) OR
                                    (2150) RelADPP
                                        (2151) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2152) RelADPP
                                    (2153) RelADPP
                                        (2154) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2155) RelADPP
                            (2156) RelADPP
                                (2157) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2158) OR
                                    (2159) RelADPP
                                        (2160) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (2161) RelADPP
                                        (2162) RelADPCleverAfsProof [SOUND, 7 ms]
                                        (2163) QDP
                                    (2164) RelADPP
                                        (2165) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2166) RelADPP
                    (2167) RelADPP
                        (2168) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2169) OR
                            (2170) RelADPP
                                (2171) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2172) OR
                                    (2173) RelADPP
                                        (2174) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2175) RelADPP
                                    (2176) RelADPP
                                        (2177) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (2178) RelADPP
                                        (2179) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2180) AND
                                            (2181) RelADPP
                                                (2182) RelADPCleverAfsProof [SOUND, 24 ms]
                                                (2183) QDP
                                            (2184) RelADPP
                                                (2185) RelADPCleverAfsProof [SOUND, 24 ms]
                                                (2186) QDP
                            (2187) RelADPP
                                (2188) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2189) OR
                                    (2190) RelADPP
                                        (2191) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2192) RelADPP
                                    (2193) RelADPP
                                        (2194) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2195) RelADPP
                            (2196) RelADPP
                                (2197) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2198) OR
                                    (2199) RelADPP
                                        (2200) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                        (2201) RelADPP
                                        (2202) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2203) AND
                                            (2204) RelADPP
                                                (2205) RelADPCleverAfsProof [SOUND, 15 ms]
                                                (2206) QDP
                                            (2207) RelADPP
                                                (2208) RelADPCleverAfsProof [SOUND, 24 ms]
                                                (2209) QDP
                                    (2210) RelADPP
                                        (2211) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2212) RelADPP
                    (2213) RelADPP
                        (2214) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (2215) OR
                            (2216) RelADPP
                                (2217) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (2218) RelADPP
                                (2219) RelADPCleverAfsProof [SOUND, 9 ms]
                                (2220) QDP
                                (2221) MRRProof [EQUIVALENT, 4 ms]
                                (2222) QDP
                                (2223) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (2224) AND
                                    (2225) QDP
                                    (2226) QDP
                            (2227) RelADPP
                                (2228) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2229) OR
                                    (2230) RelADPP
                                        (2231) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (2232) RelADPP
                                        (2233) RelADPCleverAfsProof [SOUND, 17 ms]
                                        (2234) QDP
                                    (2235) RelADPP
                                        (2236) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2237) RelADPP
                            (2238) RelADPP
                                (2239) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2240) OR
                                    (2241) RelADPP
                                        (2242) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (2243) RelADPP
                                        (2244) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2245) AND
                                            (2246) RelADPP
                                            (2247) RelADPP
                                    (2248) RelADPP
                                        (2249) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2250) RelADPP
    (2251) RelADPP
        (2252) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (2253) OR
            (2254) RelADPP
                (2255) RelADPDerelatifying2Proof [SOUND, 4 ms]
                (2256) OR
                    (2257) RelADPP
                        (2258) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2259) OR
                            (2260) RelADPP
                                (2261) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2262) OR
                                    (2263) RelADPP
                                    (2264) RelADPP
                            (2265) RelADPP
                                (2266) RelADPReductionPairProof [EQUIVALENT, 11 ms]
                                (2267) RelADPP
                                (2268) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2269) AND
                                    (2270) RelADPP
                                        (2271) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (2272) QDP
                                    (2273) RelADPP
                                        (2274) RelADPCleverAfsProof [SOUND, 16 ms]
                                        (2275) QDP
                                    (2276) RelADPP
                            (2277) RelADPP
                                (2278) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2279) OR
                                    (2280) RelADPP
                                    (2281) RelADPP
                    (2282) RelADPP
                        (2283) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2284) OR
                            (2285) RelADPP
                                (2286) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2287) OR
                                    (2288) RelADPP
                                    (2289) RelADPP
                            (2290) RelADPP
                                (2291) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2292) OR
                                    (2293) RelADPP
                                    (2294) RelADPP
                            (2295) RelADPP
                                (2296) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2297) OR
                                    (2298) RelADPP
                                    (2299) RelADPP
                    (2300) RelADPP
                        (2301) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2302) OR
                            (2303) RelADPP
                                (2304) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (2305) RelADPP
                                (2306) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2307) AND
                                    (2308) RelADPP
                                        (2309) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (2310) QDP
                                    (2311) RelADPP
                                        (2312) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (2313) QDP
                                    (2314) RelADPP
                            (2315) RelADPP
                                (2316) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2317) OR
                                    (2318) RelADPP
                                    (2319) RelADPP
                            (2320) RelADPP
                                (2321) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2322) OR
                                    (2323) RelADPP
                                    (2324) RelADPP
                    (2325) RelADPP
                        (2326) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2327) OR
                            (2328) RelADPP
                                (2329) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2330) OR
                                    (2331) RelADPP
                                    (2332) RelADPP
                            (2333) RelADPP
                                (2334) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2335) OR
                                    (2336) RelADPP
                                    (2337) RelADPP
                            (2338) RelADPP
                                (2339) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2340) OR
                                    (2341) RelADPP
                                    (2342) RelADPP
            (2343) RelADPP
                (2344) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (2345) OR
                    (2346) RelADPP
                        (2347) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2348) OR
                            (2349) RelADPP
                                (2350) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2351) OR
                                    (2352) RelADPP
                                    (2353) RelADPP
                            (2354) RelADPP
                                (2355) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (2356) RelADPP
                                (2357) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2358) AND
                                    (2359) RelADPP
                                        (2360) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (2361) QDP
                                    (2362) RelADPP
                                        (2363) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (2364) QDP
                                    (2365) RelADPP
                            (2366) RelADPP
                                (2367) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2368) OR
                                    (2369) RelADPP
                                    (2370) RelADPP
                    (2371) RelADPP
                        (2372) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (2373) OR
                            (2374) RelADPP
                                (2375) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2376) OR
                                    (2377) RelADPP
                                    (2378) RelADPP
                            (2379) RelADPP
                                (2380) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (2381) OR
                                    (2382) RelADPP
                                    (2383) RelADPP
                            (2384) RelADPP
                                (2385) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2386) OR
                                    (2387) RelADPP
                                    (2388) RelADPP
                    (2389) RelADPP
                        (2390) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2391) OR
                            (2392) RelADPP
                                (2393) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (2394) RelADPP
                                (2395) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2396) AND
                                    (2397) RelADPP
                                        (2398) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (2399) QDP
                                    (2400) RelADPP
                                        (2401) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (2402) QDP
                                    (2403) RelADPP
                            (2404) RelADPP
                                (2405) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2406) OR
                                    (2407) RelADPP
                                    (2408) RelADPP
                            (2409) RelADPP
                                (2410) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (2411) RelADPP
                                (2412) RelADPCleverAfsProof [SOUND, 29 ms]
                                (2413) QDP
                    (2414) RelADPP
                        (2415) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (2416) OR
                            (2417) RelADPP
                                (2418) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2419) OR
                                    (2420) RelADPP
                                    (2421) RelADPP
                            (2422) RelADPP
                                (2423) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2424) OR
                                    (2425) RelADPP
                                    (2426) RelADPP
                            (2427) RelADPP
                                (2428) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (2429) RelADPP
                                (2430) RelADPCleverAfsProof [SOUND, 8 ms]
                                (2431) QDP
            (2432) RelADPP
                (2433) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (2434) OR
                    (2435) RelADPP
                        (2436) RelADPDerelatifying2Proof [SOUND, 2 ms]
                        (2437) OR
                            (2438) RelADPP
                                (2439) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (2440) OR
                                    (2441) RelADPP
                                    (2442) RelADPP
                            (2443) RelADPP
                                (2444) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2445) OR
                                    (2446) RelADPP
                                    (2447) RelADPP
                            (2448) RelADPP
                                (2449) RelADPDerelatifying2Proof [SOUND, 5 ms]
                                (2450) OR
                                    (2451) RelADPP
                                    (2452) RelADPP
                    (2453) RelADPP
                        (2454) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2455) OR
                            (2456) RelADPP
                                (2457) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2458) OR
                                    (2459) RelADPP
                                    (2460) RelADPP
                            (2461) RelADPP
                                (2462) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2463) OR
                                    (2464) RelADPP
                                    (2465) RelADPP
                            (2466) RelADPP
                                (2467) RelADPDerelatifying2Proof [SOUND, 4 ms]
                                (2468) OR
                                    (2469) RelADPP
                                    (2470) RelADPP
                    (2471) RelADPP
                        (2472) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2473) OR
                            (2474) RelADPP
                                (2475) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (2476) OR
                                    (2477) RelADPP
                                    (2478) RelADPP
                            (2479) RelADPP
                                (2480) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (2481) OR
                                    (2482) RelADPP
                                    (2483) RelADPP
                            (2484) RelADPP
                                (2485) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2486) OR
                                    (2487) RelADPP
                                    (2488) RelADPP
                    (2489) RelADPP
                        (2490) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2491) OR
                            (2492) RelADPP
                                (2493) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (2494) OR
                                    (2495) RelADPP
                                    (2496) RelADPP
                            (2497) RelADPP
                                (2498) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2499) OR
                                    (2500) RelADPP
                                    (2501) RelADPP
                            (2502) RelADPP
                                (2503) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2504) OR
                                    (2505) RelADPP
                                    (2506) RelADPP
            (2507) RelADPP
                (2508) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (2509) OR
                    (2510) RelADPP
                        (2511) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2512) OR
                            (2513) RelADPP
                                (2514) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (2515) RelADPP
                                (2516) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2517) AND
                                    (2518) RelADPP
                                        (2519) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (2520) QDP
                                    (2521) RelADPP
                                        (2522) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (2523) QDP
                                    (2524) RelADPP
                            (2525) RelADPP
                                (2526) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2527) OR
                                    (2528) RelADPP
                                    (2529) RelADPP
                            (2530) RelADPP
                                (2531) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2532) OR
                                    (2533) RelADPP
                                    (2534) RelADPP
                    (2535) RelADPP
                        (2536) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2537) OR
                            (2538) RelADPP
                                (2539) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (2540) RelADPP
                                (2541) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2542) AND
                                    (2543) RelADPP
                                        (2544) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (2545) QDP
                                    (2546) RelADPP
                                        (2547) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (2548) QDP
                                    (2549) RelADPP
                            (2550) RelADPP
                                (2551) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2552) OR
                                    (2553) RelADPP
                                    (2554) RelADPP
                            (2555) RelADPP
                                (2556) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                (2557) RelADPP
                                (2558) RelADPCleverAfsProof [SOUND, 8 ms]
                                (2559) QDP
                    (2560) RelADPP
                        (2561) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2562) OR
                            (2563) RelADPP
                                (2564) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2565) OR
                                    (2566) RelADPP
                                    (2567) RelADPP
                            (2568) RelADPP
                                (2569) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2570) OR
                                    (2571) RelADPP
                                    (2572) RelADPP
                            (2573) RelADPP
                                (2574) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2575) OR
                                    (2576) RelADPP
                                    (2577) RelADPP
                    (2578) RelADPP
                        (2579) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2580) OR
                            (2581) RelADPP
                                (2582) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2583) OR
                                    (2584) RelADPP
                                    (2585) RelADPP
                            (2586) RelADPP
                                (2587) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (2588) RelADPP
                                (2589) RelADPCleverAfsProof [SOUND, 7 ms]
                                (2590) QDP
                            (2591) RelADPP
                                (2592) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2593) OR
                                    (2594) RelADPP
                                    (2595) RelADPP
            (2596) RelADPP
                (2597) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (2598) OR
                    (2599) RelADPP
                        (2600) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2601) OR
                            (2602) RelADPP
                                (2603) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (2604) OR
                                    (2605) RelADPP
                                        (2606) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2607) RelADPP
                                    (2608) RelADPP
                                        (2609) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                        (2610) RelADPP
                                        (2611) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2612) AND
                                            (2613) RelADPP
                                            (2614) RelADPP
                            (2615) RelADPP
                                (2616) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2617) OR
                                    (2618) RelADPP
                                        (2619) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2620) RelADPP
                                    (2621) RelADPP
                                        (2622) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2623) RelADPP
                            (2624) RelADPP
                                (2625) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2626) OR
                                    (2627) RelADPP
                                        (2628) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                        (2629) RelADPP
                                    (2630) RelADPP
                    (2631) RelADPP
                        (2632) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2633) OR
                            (2634) RelADPP
                                (2635) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2636) OR
                                    (2637) RelADPP
                                    (2638) RelADPP
                            (2639) RelADPP
                                (2640) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2641) OR
                                    (2642) RelADPP
                                    (2643) RelADPP
                            (2644) RelADPP
                                (2645) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                (2646) RelADPP
                                (2647) RelADPCleverAfsProof [SOUND, 19 ms]
                                (2648) QDP
                    (2649) RelADPP
                        (2650) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2651) OR
                            (2652) RelADPP
                                (2653) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2654) OR
                                    (2655) RelADPP
                                    (2656) RelADPP
                            (2657) RelADPP
                                (2658) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2659) OR
                                    (2660) RelADPP
                                    (2661) RelADPP
                            (2662) RelADPP
                                (2663) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2664) OR
                                    (2665) RelADPP
                                    (2666) RelADPP
                    (2667) RelADPP
                        (2668) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2669) OR
                            (2670) RelADPP
                                (2671) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2672) OR
                                    (2673) RelADPP
                                        (2674) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (2675) RelADPP
                                    (2676) RelADPP
                            (2677) RelADPP
                                (2678) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (2679) RelADPP
                                (2680) RelADPCleverAfsProof [SOUND, 7 ms]
                                (2681) QDP
                                (2682) MRRProof [EQUIVALENT, 3 ms]
                                (2683) QDP
                                (2684) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (2685) AND
                                    (2686) QDP
                                    (2687) QDP
                            (2688) RelADPP
                                (2689) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2690) OR
                                    (2691) RelADPP
                                    (2692) RelADPP
                                        (2693) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (2694) RelADPP
    (2695) RelADPP
        (2696) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (2697) OR
            (2698) RelADPP
                (2699) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (2700) OR
                    (2701) RelADPP
                        (2702) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2703) OR
                            (2704) RelADPP
                                (2705) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2706) OR
                                    (2707) RelADPP
                                    (2708) RelADPP
                            (2709) RelADPP
                                (2710) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2711) OR
                                    (2712) RelADPP
                                    (2713) RelADPP
                            (2714) RelADPP
                                (2715) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2716) OR
                                    (2717) RelADPP
                                    (2718) RelADPP
                    (2719) RelADPP
                        (2720) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2721) OR
                            (2722) RelADPP
                                (2723) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2724) OR
                                    (2725) RelADPP
                                    (2726) RelADPP
                            (2727) RelADPP
                                (2728) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2729) OR
                                    (2730) RelADPP
                                    (2731) RelADPP
                            (2732) RelADPP
                                (2733) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2734) OR
                                    (2735) RelADPP
                                    (2736) RelADPP
                    (2737) RelADPP
                        (2738) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2739) OR
                            (2740) RelADPP
                                (2741) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2742) OR
                                    (2743) RelADPP
                                    (2744) RelADPP
                            (2745) RelADPP
                                (2746) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2747) OR
                                    (2748) RelADPP
                                    (2749) RelADPP
                            (2750) RelADPP
                                (2751) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2752) OR
                                    (2753) RelADPP
                                    (2754) RelADPP
                    (2755) RelADPP
                        (2756) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2757) OR
                            (2758) RelADPP
                                (2759) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2760) OR
                                    (2761) RelADPP
                                    (2762) RelADPP
                            (2763) RelADPP
                                (2764) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2765) OR
                                    (2766) RelADPP
                                    (2767) RelADPP
                            (2768) RelADPP
                                (2769) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2770) OR
                                    (2771) RelADPP
                                    (2772) RelADPP
            (2773) RelADPP
                (2774) RelADPDerelatifying2Proof [SOUND, 1 ms]
                (2775) OR
                    (2776) RelADPP
                        (2777) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2778) OR
                            (2779) RelADPP
                                (2780) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2781) OR
                                    (2782) RelADPP
                                    (2783) RelADPP
                            (2784) RelADPP
                                (2785) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2786) OR
                                    (2787) RelADPP
                                    (2788) RelADPP
                            (2789) RelADPP
                                (2790) RelADPDerelatifying2Proof [SOUND, 4 ms]
                                (2791) OR
                                    (2792) RelADPP
                                    (2793) RelADPP
                    (2794) RelADPP
                        (2795) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2796) OR
                            (2797) RelADPP
                                (2798) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (2799) OR
                                    (2800) RelADPP
                                    (2801) RelADPP
                            (2802) RelADPP
                                (2803) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2804) OR
                                    (2805) RelADPP
                                    (2806) RelADPP
                            (2807) RelADPP
                                (2808) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2809) OR
                                    (2810) RelADPP
                                    (2811) RelADPP
                    (2812) RelADPP
                        (2813) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2814) OR
                            (2815) RelADPP
                                (2816) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2817) OR
                                    (2818) RelADPP
                                    (2819) RelADPP
                            (2820) RelADPP
                                (2821) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2822) OR
                                    (2823) RelADPP
                                    (2824) RelADPP
                            (2825) RelADPP
                                (2826) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (2827) RelADPP
                                (2828) RelADPCleverAfsProof [SOUND, 7 ms]
                                (2829) QDP
                    (2830) RelADPP
                        (2831) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2832) OR
                            (2833) RelADPP
                                (2834) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2835) OR
                                    (2836) RelADPP
                                    (2837) RelADPP
                            (2838) RelADPP
                                (2839) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (2840) OR
                                    (2841) RelADPP
                                    (2842) RelADPP
                            (2843) RelADPP
                                (2844) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (2845) RelADPP
                                (2846) RelADPCleverAfsProof [SOUND, 36 ms]
                                (2847) QDP
            (2848) RelADPP
                (2849) RelADPDerelatifying2Proof [SOUND, 6 ms]
                (2850) OR
                    (2851) RelADPP
                        (2852) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (2853) OR
                            (2854) RelADPP
                                (2855) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2856) OR
                                    (2857) RelADPP
                                    (2858) RelADPP
                            (2859) RelADPP
                                (2860) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2861) OR
                                    (2862) RelADPP
                                    (2863) RelADPP
                            (2864) RelADPP
                                (2865) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2866) OR
                                    (2867) RelADPP
                                    (2868) RelADPP
                    (2869) RelADPP
                        (2870) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (2871) OR
                            (2872) RelADPP
                                (2873) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2874) OR
                                    (2875) RelADPP
                                    (2876) RelADPP
                            (2877) RelADPP
                                (2878) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2879) OR
                                    (2880) RelADPP
                                    (2881) RelADPP
                            (2882) RelADPP
                                (2883) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2884) OR
                                    (2885) RelADPP
                                    (2886) RelADPP
                    (2887) RelADPP
                        (2888) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2889) OR
                            (2890) RelADPP
                                (2891) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2892) OR
                                    (2893) RelADPP
                                    (2894) RelADPP
                            (2895) RelADPP
                                (2896) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2897) OR
                                    (2898) RelADPP
                                    (2899) RelADPP
                            (2900) RelADPP
                                (2901) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2902) OR
                                    (2903) RelADPP
                                    (2904) RelADPP
                    (2905) RelADPP
                        (2906) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2907) OR
                            (2908) RelADPP
                                (2909) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (2910) OR
                                    (2911) RelADPP
                                    (2912) RelADPP
                            (2913) RelADPP
                                (2914) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2915) OR
                                    (2916) RelADPP
                                    (2917) RelADPP
                            (2918) RelADPP
                                (2919) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (2920) OR
                                    (2921) RelADPP
                                    (2922) RelADPP
            (2923) RelADPP
                (2924) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (2925) OR
                    (2926) RelADPP
                        (2927) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2928) OR
                            (2929) RelADPP
                                (2930) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2931) OR
                                    (2932) RelADPP
                                        (2933) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                        (2934) RelADPP
                                        (2935) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2936) AND
                                            (2937) RelADPP
                                            (2938) RelADPP
                                            (2939) RelADPP
                                    (2940) RelADPP
                                        (2941) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                        (2942) RelADPP
                            (2943) RelADPP
                                (2944) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2945) OR
                                    (2946) RelADPP
                                        (2947) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                        (2948) RelADPP
                                    (2949) RelADPP
                            (2950) RelADPP
                                (2951) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2952) OR
                                    (2953) RelADPP
                                        (2954) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (2955) RelADPP
                                    (2956) RelADPP
                    (2957) RelADPP
                        (2958) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2959) OR
                            (2960) RelADPP
                                (2961) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2962) OR
                                    (2963) RelADPP
                                    (2964) RelADPP
                            (2965) RelADPP
                                (2966) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2967) OR
                                    (2968) RelADPP
                                    (2969) RelADPP
                            (2970) RelADPP
                                (2971) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (2972) RelADPP
                                (2973) RelADPCleverAfsProof [SOUND, 10 ms]
                                (2974) QDP
                    (2975) RelADPP
                        (2976) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2977) OR
                            (2978) RelADPP
                                (2979) RelADPDerelatifying2Proof [SOUND, 4 ms]
                                (2980) OR
                                    (2981) RelADPP
                                        (2982) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                        (2983) RelADPP
                                        (2984) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2985) AND
                                            (2986) RelADPP
                                            (2987) RelADPP
                                            (2988) RelADPP
                                    (2989) RelADPP
                                        (2990) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (2991) RelADPP
                            (2992) RelADPP
                                (2993) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2994) OR
                                    (2995) RelADPP
                                        (2996) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                        (2997) RelADPP
                                        (2998) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2999) AND
                                            (3000) RelADPP
                                            (3001) RelADPP
                                            (3002) RelADPP
                                    (3003) RelADPP
                                        (3004) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                        (3005) RelADPP
                            (3006) RelADPP
                                (3007) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (3008) OR
                                    (3009) RelADPP
                                    (3010) RelADPP
                                        (3011) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (3012) RelADPP
                    (3013) RelADPP
                        (3014) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (3015) OR
                            (3016) RelADPP
                                (3017) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (3018) OR
                                    (3019) RelADPP
                                    (3020) RelADPP
                            (3021) RelADPP
                                (3022) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (3023) RelADPP
                                (3024) RelADPCleverAfsProof [SOUND, 7 ms]
                                (3025) QDP
                            (3026) RelADPP
                                (3027) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (3028) OR
                                    (3029) RelADPP
                                    (3030) RelADPP
            (3031) RelADPP
                (3032) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (3033) OR
                    (3034) RelADPP
                        (3035) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (3036) OR
                            (3037) RelADPP
                                (3038) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (3039) OR
                                    (3040) RelADPP
                                    (3041) RelADPP
                            (3042) RelADPP
                                (3043) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (3044) OR
                                    (3045) RelADPP
                                    (3046) RelADPP
                            (3047) RelADPP
                                (3048) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (3049) OR
                                    (3050) RelADPP
                                    (3051) RelADPP
                    (3052) RelADPP
                        (3053) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (3054) OR
                            (3055) RelADPP
                                (3056) RelADPDerelatifying2Proof [SOUND, 4 ms]
                                (3057) OR
                                    (3058) RelADPP
                                        (3059) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                        (3060) RelADPP
                                    (3061) RelADPP
                                        (3062) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                        (3063) RelADPP
                                        (3064) RelADPCleverAfsProof [SOUND, 26 ms]
                                        (3065) QDP
                            (3066) RelADPP
                                (3067) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (3068) OR
                                    (3069) RelADPP
                                        (3070) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (3071) RelADPP
                                    (3072) RelADPP
                                        (3073) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                        (3074) RelADPP
                                        (3075) RelADPCleverAfsProof [SOUND, 27 ms]
                                        (3076) QDP
                            (3077) RelADPP
                                (3078) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (3079) RelADPP
                                (3080) RelADPCleverAfsProof [SOUND, 8 ms]
                                (3081) QDP
                    (3082) RelADPP
                        (3083) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (3084) OR
                            (3085) RelADPP
                                (3086) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (3087) OR
                                    (3088) RelADPP
                                    (3089) RelADPP
                            (3090) RelADPP
                                (3091) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (3092) OR
                                    (3093) RelADPP
                                    (3094) RelADPP
                            (3095) RelADPP
                                (3096) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (3097) OR
                                    (3098) RelADPP
                                    (3099) RelADPP
                    (3100) RelADPP
                        (3101) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (3102) OR
                            (3103) RelADPP
                                (3104) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (3105) OR
                                    (3106) RelADPP
                                    (3107) RelADPP
                            (3108) RelADPP
                                (3109) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                (3110) RelADPP
                                (3111) RelADPCleverAfsProof [SOUND, 7 ms]
                                (3112) QDP
                            (3113) RelADPP
                                (3114) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (3115) OR
                                    (3116) RelADPP
                                    (3117) RelADPP


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   c(a(b(x1))) -> c(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))

The relative TRS consists of the following S rules:

   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(A(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))
   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(3) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 6 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(4)
Complex Obligation (OR)

----------------------------------------

(5)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(6) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(7)
Complex Obligation (OR)

----------------------------------------

(8)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(9) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(10)
Complex Obligation (OR)

----------------------------------------

(11)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(12) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(13)
Complex Obligation (OR)

----------------------------------------

(14)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(15) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(16)
Complex Obligation (OR)

----------------------------------------

(17)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(18) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(19)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(20)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(21)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(22) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(23)
Complex Obligation (OR)

----------------------------------------

(24)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(25) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(26)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(27)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(28) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(29)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(30)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(31) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(32)
Complex Obligation (OR)

----------------------------------------

(33)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(34) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(35)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(36)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(37) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(38)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(39) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(41)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(42) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(43)
Complex Obligation (OR)

----------------------------------------

(44)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(45) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(46)
Complex Obligation (OR)

----------------------------------------

(47)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(48) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(49)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(50)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(51)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(52) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(53)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(54) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(55)
Complex Obligation (AND)

----------------------------------------

(56)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(57) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(59)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(60) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(61)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(62)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(63)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(64) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(65)
Complex Obligation (OR)

----------------------------------------

(66)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(67)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(68)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(69) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(70)
Complex Obligation (OR)

----------------------------------------

(71)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(72) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(73)
Complex Obligation (OR)

----------------------------------------

(74)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(75)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(76)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(77) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(78)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(79) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(80)
Complex Obligation (AND)

----------------------------------------

(81)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(82) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(83)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(84)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(85) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(86)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(87)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(88)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(89) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(90)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(91) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(92)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(93)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(94) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(95)
Complex Obligation (OR)

----------------------------------------

(96)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(97) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(98)
Complex Obligation (OR)

----------------------------------------

(99)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(100)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(101) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(102)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(103)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(104) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(105)
Complex Obligation (OR)

----------------------------------------

(106)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(107)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(108) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(109)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(110) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(111)
Complex Obligation (AND)

----------------------------------------

(112)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(113)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(114)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(115) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(116)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(117) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(118)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(119)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(120) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(121)
Complex Obligation (OR)

----------------------------------------

(122)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(123) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(124)
Complex Obligation (OR)

----------------------------------------

(125)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(126) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(127)
Complex Obligation (OR)

----------------------------------------

(128)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(129)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(130)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(131) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(132)
Complex Obligation (OR)

----------------------------------------

(133)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(134)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(135)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(136) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(137)
Complex Obligation (OR)

----------------------------------------

(138)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(139)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(140)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(141) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(142)
Complex Obligation (OR)

----------------------------------------

(143)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(144) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(145)
Complex Obligation (OR)

----------------------------------------

(146)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(147)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(148)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(149) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(150)
Complex Obligation (OR)

----------------------------------------

(151)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(152)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(153)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(154) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(155)
Complex Obligation (OR)

----------------------------------------

(156)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(157)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(158)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(159) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(160)
Complex Obligation (OR)

----------------------------------------

(161)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(162) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(163)
Complex Obligation (OR)

----------------------------------------

(164)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(165)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(166)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(167) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(168)
Complex Obligation (OR)

----------------------------------------

(169)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(170)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(171)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(172) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(173)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(174) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(175)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(176)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(177) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(178)
Complex Obligation (OR)

----------------------------------------

(179)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(180) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(181)
Complex Obligation (OR)

----------------------------------------

(182)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(183)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(184)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(185) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(186)
Complex Obligation (OR)

----------------------------------------

(187)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(188)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(189)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(190) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(191)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(192) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(193)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(194)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(195) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(196)
Complex Obligation (OR)

----------------------------------------

(197)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(198) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(199)
Complex Obligation (OR)

----------------------------------------

(200)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(201) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(202)
Complex Obligation (OR)

----------------------------------------

(203)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(204)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(205)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(206) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(207)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(208) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(209)
Complex Obligation (AND)

----------------------------------------

(210)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(211) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(212)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(213)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(214) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(215)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(216)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(217)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(218) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(219)
Complex Obligation (OR)

----------------------------------------

(220)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(221)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(222)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(223) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(224)
Complex Obligation (OR)

----------------------------------------

(225)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(226) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(227)
Complex Obligation (OR)

----------------------------------------

(228)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(229) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(230)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(231) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(232)
Complex Obligation (AND)

----------------------------------------

(233)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(234) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(235)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(236)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(237)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(238) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(239)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(240)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(241) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(242)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(243)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(244) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(245)
Complex Obligation (OR)

----------------------------------------

(246)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(247) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(248)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(249) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(250)
Complex Obligation (AND)

----------------------------------------

(251)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(252)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(253)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(254)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(255) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(256)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(257)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(258) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(259)
Complex Obligation (OR)

----------------------------------------

(260)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(261) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(262)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(263)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(264) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(265)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(266)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(267) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(268)
Complex Obligation (OR)

----------------------------------------

(269)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(270) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(271)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(272) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(273)
Complex Obligation (AND)

----------------------------------------

(274)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(275) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(276)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(277)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(278) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(279)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(280)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(281) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(282)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(a(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(283)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(284) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(285)
Complex Obligation (OR)

----------------------------------------

(286)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(287) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(288)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(289)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(290) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(291)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(292)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(293) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(294)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(295) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(296)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(297) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(298)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(299) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(300)
Complex Obligation (AND)

----------------------------------------

(301)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(302)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(303)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(304) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(305)
Complex Obligation (OR)

----------------------------------------

(306)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(307) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(308)
Complex Obligation (OR)

----------------------------------------

(309)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(310)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(311)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(312) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(313)
Complex Obligation (OR)

----------------------------------------

(314)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(315)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(316)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(317) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(318)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(319) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(320)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(321)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(322) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(323)
Complex Obligation (OR)

----------------------------------------

(324)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(325) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(326)
Complex Obligation (OR)

----------------------------------------

(327)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(328) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(329)
Complex Obligation (OR)

----------------------------------------

(330)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(331)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(332)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(333) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(334)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(335) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(336)
Complex Obligation (AND)

----------------------------------------

(337)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(338) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(339)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(340)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(341) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(342)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(343)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(344)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(345) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(346)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(347) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(348)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(349)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(350) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(351)
Complex Obligation (OR)

----------------------------------------

(352)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(353) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(354)
Complex Obligation (OR)

----------------------------------------

(355)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(356)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(357)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(358) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(359)
Complex Obligation (OR)

----------------------------------------

(360)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(361)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(362)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(363) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(364)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(365) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(366)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(367)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(368) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(369)
Complex Obligation (OR)

----------------------------------------

(370)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(371) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(372)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(373) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(374)
Complex Obligation (AND)

----------------------------------------

(375)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(376) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(377)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(378)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(379) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(380)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(381)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(382)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(383) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(384)
Complex Obligation (OR)

----------------------------------------

(385)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(386)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(387)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(388) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(389)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(390) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(391)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(392)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(393) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(394)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(395) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(396)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(397) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(398)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(399) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(400)
Complex Obligation (AND)

----------------------------------------

(401)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(402) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 4. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
225827, 225828, 225829, 225830, 225831, 225832, 225833, 225834, 225835, 225836, 225837, 225838, 225839, 225840, 225841, 225842, 225849, 225850, 225851, 225852, 225853, 225854, 225855, 225856, 225857, 225858, 225859, 225860, 225867, 225868

Node 225827 is start node and node 225828 is final node.

Those nodes are connected through the following edges:

* 225827 to 225829 labelled c0_1(0), a0_1(0)* 225827 to 225831 labelled a0_1(0)* 225827 to 225833 labelled b0_1(0), B0_1(0)* 225827 to 225835 labelled c0_1(1)* 225827 to 225849 labelled b0_1(1), B0_1(1)* 225827 to 225851 labelled b0_1(2), B0_1(2)* 225828 to 225828 labelled #_1(0)* 225829 to 225830 labelled a0_1(0), c0_1(1)* 225829 to 225835 labelled c0_1(1)* 225830 to 225828 labelled c0_1(0), a0_1(0)* 225830 to 225835 labelled c0_1(1), a0_1(1)* 225830 to 225837 labelled a0_1(1)* 225830 to 225841 labelled c0_1(2)* 225831 to 225832 labelled c0_1(0)* 225832 to 225828 labelled b0_1(0)* 225832 to 225839 labelled b0_1(1)* 225832 to 225851 labelled b0_1(2)* 225833 to 225834 labelled a0_1(0)* 225833 to 225835 labelled c0_1(1), a0_1(1)* 225833 to 225837 labelled a0_1(1)* 225833 to 225841 labelled c0_1(2)* 225834 to 225828 labelled b0_1(0)* 225834 to 225839 labelled b0_1(1)* 225834 to 225851 labelled b0_1(2)* 225835 to 225836 labelled a0_1(1)* 225835 to 225835 labelled c0_1(1)* 225835 to 225853 labelled c0_1(2)* 225836 to 225828 labelled c0_1(1), a0_1(1)* 225836 to 225835 labelled c0_1(1), a0_1(1)* 225836 to 225837 labelled a0_1(1), c0_1(1)* 225836 to 225840 labelled c0_1(1)* 225836 to 225841 labelled c0_1(2)* 225836 to 225852 labelled c0_1(1)* 225837 to 225838 labelled c0_1(1)* 225838 to 225828 labelled b0_1(1)* 225838 to 225839 labelled b0_1(1)* 225838 to 225851 labelled b0_1(2)* 225839 to 225840 labelled a0_1(1)* 225839 to 225835 labelled c0_1(1), a0_1(1)* 225839 to 225837 labelled a0_1(1)* 225839 to 225841 labelled c0_1(2)* 225840 to 225828 labelled b0_1(1)* 225840 to 225839 labelled b0_1(1)* 225840 to 225851 labelled b0_1(2)* 225841 to 225842 labelled a0_1(2)* 225841 to 225835 labelled c0_1(1)* 225841 to 225853 labelled c0_1(2)* 225842 to 225828 labelled a0_1(2)* 225842 to 225835 labelled c0_1(1), a0_1(1), a0_1(2), c0_1(2)* 225842 to 225837 labelled a0_1(1), a0_1(2), c0_1(2)* 225842 to 225840 labelled c0_1(2)* 225842 to 225841 labelled c0_1(2)* 225842 to 225852 labelled c0_1(2)* 225849 to 225850 labelled a0_1(1)* 225849 to 225855 labelled c0_1(2)* 225849 to 225841 labelled c0_1(2)* 225850 to 225835 labelled b0_1(1)* 225850 to 225851 labelled b0_1(2)* 225850 to 225853 labelled b0_1(1)* 225851 to 225852 labelled a0_1(2)* 225851 to 225855 labelled c0_1(2)* 225851 to 225859 labelled c0_1(3)* 225852 to 225835 labelled b0_1(2)* 225852 to 225851 labelled b0_1(2)* 225852 to 225853 labelled b0_1(2)* 225852 to 225857 labelled b0_1(3)* 225852 to 225841 labelled b0_1(2)* 225853 to 225854 labelled a0_1(2)* 225853 to 225841 labelled c0_1(2)* 225854 to 225836 labelled a0_1(2)* 225854 to 225835 labelled c0_1(1)* 225854 to 225853 labelled c0_1(2)* 225855 to 225856 labelled a0_1(2)* 225856 to 225836 labelled c0_1(2)* 225856 to 225835 labelled c0_1(1)* 225856 to 225854 labelled c0_1(2)* 225857 to 225858 labelled a0_1(3)* 225857 to 225859 labelled c0_1(3)* 225857 to 225867 labelled c0_1(4)* 225858 to 225853 labelled b0_1(3)* 225858 to 225841 labelled b0_1(3)* 225858 to 225851 labelled b0_1(2)* 225858 to 225857 labelled b0_1(3)* 225859 to 225860 labelled a0_1(3)* 225860 to 225852 labelled c0_1(3)* 225860 to 225854 labelled c0_1(3)* 225860 to 225858 labelled c0_1(3)* 225860 to 225842 labelled c0_1(3)* 225860 to 225835 labelled c0_1(1)* 225867 to 225868 labelled a0_1(4)* 225868 to 225858 labelled c0_1(4)


----------------------------------------

(403)
YES

----------------------------------------

(404)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(405) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 4. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
215457, 215458, 215471, 215472, 215473, 215474, 215475, 215476, 215534, 215535, 215536, 215537, 215538, 215539, 215540, 215541, 215542, 215543, 215544, 215545, 215546, 215547, 215548, 215549, 215550, 215551, 215552, 215553, 215592, 215593

Node 215457 is start node and node 215458 is final node.

Those nodes are connected through the following edges:

* 215457 to 215471 labelled c0_1(0), a0_1(0), C0_1(0)* 215457 to 215473 labelled a0_1(0)* 215457 to 215475 labelled b0_1(0)* 215457 to 215534 labelled c0_1(1)* 215457 to 215542 labelled b0_1(1)* 215457 to 215544 labelled b0_1(2)* 215458 to 215458 labelled #_1(0)* 215471 to 215472 labelled a0_1(0), c0_1(1)* 215471 to 215534 labelled c0_1(1)* 215472 to 215458 labelled c0_1(0), a0_1(0)* 215472 to 215534 labelled c0_1(1), a0_1(1)* 215472 to 215536 labelled a0_1(1)* 215472 to 215540 labelled c0_1(2)* 215473 to 215474 labelled c0_1(0)* 215474 to 215458 labelled b0_1(0)* 215474 to 215538 labelled b0_1(1)* 215474 to 215544 labelled b0_1(2)* 215475 to 215476 labelled a0_1(0)* 215475 to 215534 labelled c0_1(1), a0_1(1)* 215475 to 215536 labelled a0_1(1)* 215475 to 215540 labelled c0_1(2)* 215476 to 215458 labelled b0_1(0)* 215476 to 215538 labelled b0_1(1)* 215476 to 215544 labelled b0_1(2)* 215534 to 215535 labelled a0_1(1)* 215534 to 215534 labelled c0_1(1)* 215534 to 215546 labelled c0_1(2)* 215535 to 215458 labelled c0_1(1), a0_1(1)* 215535 to 215534 labelled c0_1(1), a0_1(1)* 215535 to 215536 labelled a0_1(1), c0_1(1)* 215535 to 215539 labelled c0_1(1)* 215535 to 215540 labelled c0_1(2)* 215535 to 215545 labelled c0_1(1)* 215536 to 215537 labelled c0_1(1)* 215537 to 215458 labelled b0_1(1)* 215537 to 215538 labelled b0_1(1)* 215537 to 215544 labelled b0_1(2)* 215538 to 215539 labelled a0_1(1)* 215538 to 215534 labelled c0_1(1), a0_1(1)* 215538 to 215536 labelled a0_1(1)* 215538 to 215540 labelled c0_1(2)* 215539 to 215458 labelled b0_1(1)* 215539 to 215538 labelled b0_1(1)* 215539 to 215544 labelled b0_1(2)* 215540 to 215541 labelled a0_1(2)* 215540 to 215534 labelled c0_1(1)* 215540 to 215546 labelled c0_1(2)* 215541 to 215458 labelled a0_1(2)* 215541 to 215534 labelled c0_1(1), a0_1(1), a0_1(2), c0_1(2)* 215541 to 215536 labelled a0_1(1), a0_1(2), c0_1(2)* 215541 to 215539 labelled c0_1(2)* 215541 to 215540 labelled c0_1(2)* 215541 to 215545 labelled c0_1(2)* 215542 to 215543 labelled a0_1(1)* 215542 to 215548 labelled c0_1(2)* 215542 to 215540 labelled c0_1(2)* 215543 to 215534 labelled b0_1(1)* 215543 to 215544 labelled b0_1(2)* 215543 to 215546 labelled b0_1(1)* 215544 to 215545 labelled a0_1(2)* 215544 to 215548 labelled c0_1(2)* 215544 to 215552 labelled c0_1(3)* 215545 to 215534 labelled b0_1(2)* 215545 to 215544 labelled b0_1(2)* 215545 to 215546 labelled b0_1(2)* 215545 to 215550 labelled b0_1(3)* 215545 to 215540 labelled b0_1(2)* 215546 to 215547 labelled a0_1(2)* 215546 to 215540 labelled c0_1(2)* 215547 to 215535 labelled a0_1(2)* 215547 to 215534 labelled c0_1(1)* 215547 to 215546 labelled c0_1(2)* 215548 to 215549 labelled a0_1(2)* 215549 to 215535 labelled c0_1(2)* 215549 to 215534 labelled c0_1(1)* 215549 to 215547 labelled c0_1(2)* 215550 to 215551 labelled a0_1(3)* 215550 to 215552 labelled c0_1(3)* 215550 to 215592 labelled c0_1(4)* 215551 to 215546 labelled b0_1(3)* 215551 to 215540 labelled b0_1(3)* 215551 to 215544 labelled b0_1(2)* 215551 to 215550 labelled b0_1(3)* 215552 to 215553 labelled a0_1(3)* 215553 to 215545 labelled c0_1(3)* 215553 to 215547 labelled c0_1(3)* 215553 to 215551 labelled c0_1(3)* 215553 to 215541 labelled c0_1(3)* 215553 to 215534 labelled c0_1(1)* 215592 to 215593 labelled a0_1(4)* 215593 to 215551 labelled c0_1(4)


----------------------------------------

(406)
YES

----------------------------------------

(407)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(408) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(409)
Complex Obligation (OR)

----------------------------------------

(410)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(411) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(412)
Complex Obligation (OR)

----------------------------------------

(413)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(414) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(415)
Complex Obligation (OR)

----------------------------------------

(416)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(417) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(418)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(419)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(420) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(421)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(422) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(423)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(424)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(425) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(426)
Complex Obligation (OR)

----------------------------------------

(427)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(428) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(429)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(430)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(431) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(432)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(433) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(434)
Complex Obligation (AND)

----------------------------------------

(435)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(436) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b(x1)

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, b_1, c_1]

Status: a_1: multiset status
b_1: multiset status
c_1: multiset status


----------------------------------------

(437)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(438)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(439) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

B(x1)  =  B(x1)

c(x1)  =  x1

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, B_1] > a

Status: b_1: [1]
B_1: [1]
a: multiset status


----------------------------------------

(440)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a)

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b0(c0(c0(x1))) -> b0(a)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(441)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(442) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(443)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(444) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(445)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(446) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(447)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(448) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(449)
Complex Obligation (AND)

----------------------------------------

(450)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(451)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(452)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(453) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(454)
Complex Obligation (OR)

----------------------------------------

(455)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(456) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(457)
Complex Obligation (OR)

----------------------------------------

(458)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(459) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(460)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(461)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(462) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(463)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(464) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(465)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(466)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(467) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(468)
Complex Obligation (OR)

----------------------------------------

(469)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(470) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(471)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(472)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(473) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(474)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(475) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(476)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(477)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(478) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(479)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(480) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(481)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(482) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(483)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(484) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(485)
Complex Obligation (AND)

----------------------------------------

(486)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(487)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(488)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(489) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(490)
Complex Obligation (OR)

----------------------------------------

(491)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(492) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(493)
Complex Obligation (OR)

----------------------------------------

(494)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(495) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(496)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(497)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(498) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(499)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(500) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(501)
Complex Obligation (AND)

----------------------------------------

(502)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(503) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b(x1)

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, b_1, c_1]

Status: a_1: multiset status
b_1: multiset status
c_1: multiset status


----------------------------------------

(504)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(505)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(506) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

B(x1)  =  B(x1)

c(x1)  =  x1

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, B_1] > a

Status: b_1: [1]
B_1: [1]
a: multiset status


----------------------------------------

(507)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a)

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b0(c0(c0(x1))) -> b0(a)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(508)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(509) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(510)
Complex Obligation (OR)

----------------------------------------

(511)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(512) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(513)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(514)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(515) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(516)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(517) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(518)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(519)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(520) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(521)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(522) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(523)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(524) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(525)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(526) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(527)
Complex Obligation (AND)

----------------------------------------

(528)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(529)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(530)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(531) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(532)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(533) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(534)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(535) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(536)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(537) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(538)
Complex Obligation (AND)

----------------------------------------

(539)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(540)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(541)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(542) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(543)
Complex Obligation (OR)

----------------------------------------

(544)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(545) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(546)
Complex Obligation (OR)

----------------------------------------

(547)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(548) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(549)
Complex Obligation (OR)

----------------------------------------

(550)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(551) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(552)
Complex Obligation (OR)

----------------------------------------

(553)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(554)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(555)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(556) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(557)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(558) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(559)
Complex Obligation (AND)

----------------------------------------

(560)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(561) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(562)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(563)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(564) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(565)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(566)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(567)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(568) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(569)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(570) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(571)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(572)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(573) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(574)
Complex Obligation (OR)

----------------------------------------

(575)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(576) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(577)
Complex Obligation (OR)

----------------------------------------

(578)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(579)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(580)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(581) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(582)
Complex Obligation (OR)

----------------------------------------

(583)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(584)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(585)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(586) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(587)
Complex Obligation (OR)

----------------------------------------

(588)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(589)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(590)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(591) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(592)
Complex Obligation (OR)

----------------------------------------

(593)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(594) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(595)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(596) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(597)
Complex Obligation (AND)

----------------------------------------

(598)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(599) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(600)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(601)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(602) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(603)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(604)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(605)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(606) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(607)
Complex Obligation (OR)

----------------------------------------

(608)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(609)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(610)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(611) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(612)
Complex Obligation (OR)

----------------------------------------

(613)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(614)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(615)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(616) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(617)
Complex Obligation (OR)

----------------------------------------

(618)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(619) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(620)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(621) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(622)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(623)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(624) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(625)
Complex Obligation (OR)

----------------------------------------

(626)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(627)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(628)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(629) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(630)
Complex Obligation (OR)

----------------------------------------

(631)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(632)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(633)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(634) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(635)
Complex Obligation (OR)

----------------------------------------

(636)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(637) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(638)
Complex Obligation (OR)

----------------------------------------

(639)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(640) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(641)
Complex Obligation (OR)

----------------------------------------

(642)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(643)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(644)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(645) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(646)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(647) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(648)
Complex Obligation (AND)

----------------------------------------

(649)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(650) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(651)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(652)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(653) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(654)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(655)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(656)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(657) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(658)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(659) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(660)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(661)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(662) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(663)
Complex Obligation (OR)

----------------------------------------

(664)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(665) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(666)
Complex Obligation (OR)

----------------------------------------

(667)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(668)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(669)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(670) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(671)
Complex Obligation (OR)

----------------------------------------

(672)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(673)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(674)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(675) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(676)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(677) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(678)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(679)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(680) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(681)
Complex Obligation (OR)

----------------------------------------

(682)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(683) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(684)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(685) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(686)
Complex Obligation (AND)

----------------------------------------

(687)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(688) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(689)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(690)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(691) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(692)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(693)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(694)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(695) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(696)
Complex Obligation (OR)

----------------------------------------

(697)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(698)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(699)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(700) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(701)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(702) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(703)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(704)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(705) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(706)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(707) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(708)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(709) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(710)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(711) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(712)
Complex Obligation (AND)

----------------------------------------

(713)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(714)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(715)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(716) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(717)
Complex Obligation (OR)

----------------------------------------

(718)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(719) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(720)
Complex Obligation (OR)

----------------------------------------

(721)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(722) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(723)
Complex Obligation (OR)

----------------------------------------

(724)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(725)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(726)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(727) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(728)
Complex Obligation (OR)

----------------------------------------

(729)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(730)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(731)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(732) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(733)
Complex Obligation (OR)

----------------------------------------

(734)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(735)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(736)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(737) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(738)
Complex Obligation (OR)

----------------------------------------

(739)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(740) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(741)
Complex Obligation (OR)

----------------------------------------

(742)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(743)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(744)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(745) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(746)
Complex Obligation (OR)

----------------------------------------

(747)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(748)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(749)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(750) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(751)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(752) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(753)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(754)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(755) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(756)
Complex Obligation (OR)

----------------------------------------

(757)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(758) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(759)
Complex Obligation (OR)

----------------------------------------

(760)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(761)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(762)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(763) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(764)
Complex Obligation (OR)

----------------------------------------

(765)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(766)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(767)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(768) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(769)
Complex Obligation (OR)

----------------------------------------

(770)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(771)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(772)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(773) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(774)
Complex Obligation (OR)

----------------------------------------

(775)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(776) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(777)
Complex Obligation (OR)

----------------------------------------

(778)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(779)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(780)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(781) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(782)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(783) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(784)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(785)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(786) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(787)
Complex Obligation (OR)

----------------------------------------

(788)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(789)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(790)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(791) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(792)
Complex Obligation (OR)

----------------------------------------

(793)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(794) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(795)
Complex Obligation (OR)

----------------------------------------

(796)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(797) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(798)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(799) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(800)
Complex Obligation (AND)

----------------------------------------

(801)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(802) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(803)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(804)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(805) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(806)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(807)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(808)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(809) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(810)
Complex Obligation (OR)

----------------------------------------

(811)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(812)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(813)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(814) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(815)
Complex Obligation (OR)

----------------------------------------

(816)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(817)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(818)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(819) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(820)
Complex Obligation (OR)

----------------------------------------

(821)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(822) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(823)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(824) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(825)
Complex Obligation (AND)

----------------------------------------

(826)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(827) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(828)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(829)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(830) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(831)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(832)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(833)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(834) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(835)
Complex Obligation (OR)

----------------------------------------

(836)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(837)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(838)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(839) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(840)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(841) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(842)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(843)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(844) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(845)
Complex Obligation (OR)

----------------------------------------

(846)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(847) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(848)
Complex Obligation (OR)

----------------------------------------

(849)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(850)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(851)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(852) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(853)
Complex Obligation (OR)

----------------------------------------

(854)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(855)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(856)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(857) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(858)
Complex Obligation (OR)

----------------------------------------

(859)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(860)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(861)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(862) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(863)
Complex Obligation (OR)

----------------------------------------

(864)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(865) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(866)
Complex Obligation (OR)

----------------------------------------

(867)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(868)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(869)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(870) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(871)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(872) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(873)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(874)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(875) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(876)
Complex Obligation (OR)

----------------------------------------

(877)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(878)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(879)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(880) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(881)
Complex Obligation (OR)

----------------------------------------

(882)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(883) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(884)
Complex Obligation (OR)

----------------------------------------

(885)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(886) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(887)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(888) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(889)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(890)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(891) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(892)
Complex Obligation (OR)

----------------------------------------

(893)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(894)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(895)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(896) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(897)
Complex Obligation (OR)

----------------------------------------

(898)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(899)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(900)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(901) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(902)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(903) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(904)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(905) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(906)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(907) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(908)
Complex Obligation (AND)

----------------------------------------

(909)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(910)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(911)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(912) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(913)
Complex Obligation (OR)

----------------------------------------

(914)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(915) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(916)
Complex Obligation (OR)

----------------------------------------

(917)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(918)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(919)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(920) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(921)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(922) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(923)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(924)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(925) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(926)
Complex Obligation (OR)

----------------------------------------

(927)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(928)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(929)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(930) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(931)
Complex Obligation (OR)

----------------------------------------

(932)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(933) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(934)
Complex Obligation (OR)

----------------------------------------

(935)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(936)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(937)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(938) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(939)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(940) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(941)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(942)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(943) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(944)
Complex Obligation (OR)

----------------------------------------

(945)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(946)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(947)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(948) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(949)
Complex Obligation (OR)

----------------------------------------

(950)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(951) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(952)
Complex Obligation (OR)

----------------------------------------

(953)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(954) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(955)
Complex Obligation (OR)

----------------------------------------

(956)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(957) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(958)
Complex Obligation (OR)

----------------------------------------

(959)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(960)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(961)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(962) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(963)
Complex Obligation (OR)

----------------------------------------

(964)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(965)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(966)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(967) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(968)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(969) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(970)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(971)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(972) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(973)
Complex Obligation (OR)

----------------------------------------

(974)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(975) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(976)
Complex Obligation (OR)

----------------------------------------

(977)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(978)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(979)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(980) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(981)
Complex Obligation (OR)

----------------------------------------

(982)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(983)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(984)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(985) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(986)
Complex Obligation (OR)

----------------------------------------

(987)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(988)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(989)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(990) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(991)
Complex Obligation (OR)

----------------------------------------

(992)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(993) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(994)
Complex Obligation (OR)

----------------------------------------

(995)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(996)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(997)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(998) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(999)
Complex Obligation (OR)

----------------------------------------

(1000)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1001)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1002)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1003) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1004)
Complex Obligation (OR)

----------------------------------------

(1005)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1006)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1007)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1008) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1009)
Complex Obligation (OR)

----------------------------------------

(1010)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1011) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1012)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1013) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1014)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1015)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1016) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1017)
Complex Obligation (OR)

----------------------------------------

(1018)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1019)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1020)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1021) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1022)
Complex Obligation (OR)

----------------------------------------

(1023)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1024)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1025)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1026) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1027)
Complex Obligation (OR)

----------------------------------------

(1028)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1029) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1030)
Complex Obligation (OR)

----------------------------------------

(1031)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1032) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1033)
Complex Obligation (OR)

----------------------------------------

(1034)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1035)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1036)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1037) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1038)
Complex Obligation (OR)

----------------------------------------

(1039)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1040)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1041)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1042) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1043)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1044) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1045)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1046)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1047) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1048)
Complex Obligation (OR)

----------------------------------------

(1049)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1050) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1051)
Complex Obligation (OR)

----------------------------------------

(1052)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1053)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1054)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1055) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1056)
Complex Obligation (OR)

----------------------------------------

(1057)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1058)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(1059)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1060) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1061)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1062) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1063)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1064)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1065) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1066)
Complex Obligation (OR)

----------------------------------------

(1067)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1068) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1069)
Complex Obligation (OR)

----------------------------------------

(1070)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1071)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1072)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1073) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1074)
Complex Obligation (OR)

----------------------------------------

(1075)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1076)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(1077)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1078) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1079)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1080) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1081)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1082)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1083) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(1084)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1085) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1086)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1087) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1088)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1089) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(1090)
Complex Obligation (AND)

----------------------------------------

(1091)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1092)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1093)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1094) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1095)
Complex Obligation (OR)

----------------------------------------

(1096)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1097) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1098)
Complex Obligation (OR)

----------------------------------------

(1099)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1100) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1101)
Complex Obligation (OR)

----------------------------------------

(1102)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1103)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1104)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1105) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1106)
Complex Obligation (OR)

----------------------------------------

(1107)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1108)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1109)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1110) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1111)
Complex Obligation (OR)

----------------------------------------

(1112)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1113)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1114)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1115) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1116)
Complex Obligation (OR)

----------------------------------------

(1117)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1118) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1119)
Complex Obligation (OR)

----------------------------------------

(1120)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1121)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1122)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1123) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1124)
Complex Obligation (OR)

----------------------------------------

(1125)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1126)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(1127)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1128) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1129)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1130) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1131)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1132)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1133) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1134)
Complex Obligation (OR)

----------------------------------------

(1135)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1136) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1137)
Complex Obligation (OR)

----------------------------------------

(1138)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1139)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1140)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1141) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1142)
Complex Obligation (OR)

----------------------------------------

(1143)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1144)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(1145)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1146) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1147)
Complex Obligation (OR)

----------------------------------------

(1148)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1149)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(1150)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1151) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1152)
Complex Obligation (OR)

----------------------------------------

(1153)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1154) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1155)
Complex Obligation (OR)

----------------------------------------

(1156)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1157)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1158)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1159) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1160)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1161) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1162)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1163)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1164) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1165)
Complex Obligation (OR)

----------------------------------------

(1166)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1167)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(1168)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1169) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1170)
Complex Obligation (OR)

----------------------------------------

(1171)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1172) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1173)
Complex Obligation (OR)

----------------------------------------

(1174)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1175) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1176)
Complex Obligation (OR)

----------------------------------------

(1177)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1178)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1179)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1180) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1181)
Complex Obligation (OR)

----------------------------------------

(1182)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1183)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1184)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1185) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1186)
Complex Obligation (OR)

----------------------------------------

(1187)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1188)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1189)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1190) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1191)
Complex Obligation (OR)

----------------------------------------

(1192)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1193) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1194)
Complex Obligation (OR)

----------------------------------------

(1195)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1196)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1197)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1198) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1199)
Complex Obligation (OR)

----------------------------------------

(1200)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1201)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(1202)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1203) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1204)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1205)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1206) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1207)
Complex Obligation (OR)

----------------------------------------

(1208)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1209) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1210)
Complex Obligation (OR)

----------------------------------------

(1211)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1212)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1213)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1214) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1215)
Complex Obligation (OR)

----------------------------------------

(1216)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1217)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(1218)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1219) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1220)
Complex Obligation (OR)

----------------------------------------

(1221)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1222)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(1223)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1224) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1225)
Complex Obligation (OR)

----------------------------------------

(1226)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1227) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1228)
Complex Obligation (OR)

----------------------------------------

(1229)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1230)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1231)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1232) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1233)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1234) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1235)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1236)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1237) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1238)
Complex Obligation (OR)

----------------------------------------

(1239)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1240)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(1241)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1242) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1243)
Complex Obligation (OR)

----------------------------------------

(1244)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1245) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1246)
Complex Obligation (OR)

----------------------------------------

(1247)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1248) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1249)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1250) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1251)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1252)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1253) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1254)
Complex Obligation (OR)

----------------------------------------

(1255)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1256)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1257)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1258) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1259)
Complex Obligation (OR)

----------------------------------------

(1260)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1261)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1262)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1263) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(1264)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1265) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1266)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1267) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1268)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1269) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(1270)
Complex Obligation (AND)

----------------------------------------

(1271)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1272)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1273)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1274) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1275)
Complex Obligation (OR)

----------------------------------------

(1276)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1277)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1278) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1279)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1280)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1281) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1282)
Complex Obligation (OR)

----------------------------------------

(1283)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1284)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(1285)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1286) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1287)
Complex Obligation (OR)

----------------------------------------

(1288)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1289) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1290)
Complex Obligation (OR)

----------------------------------------

(1291)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1292)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1293)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1294) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1295)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1296) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1297)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1298)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1299) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1300)
Complex Obligation (OR)

----------------------------------------

(1301)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1302)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(1303)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1304) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1305)
Complex Obligation (OR)

----------------------------------------

(1306)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1307) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1308)
Complex Obligation (OR)

----------------------------------------

(1309)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1310) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1311)
Complex Obligation (OR)

----------------------------------------

(1312)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1313) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1314)
Complex Obligation (OR)

----------------------------------------

(1315)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1316) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1317)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1318) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1319)
Complex Obligation (AND)

----------------------------------------

(1320)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1321) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1322)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1323)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1324)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1325) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1326)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1327)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1328) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1329)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1330)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1331) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1332)
Complex Obligation (OR)

----------------------------------------

(1333)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1334) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1335)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1336) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1337)
Complex Obligation (AND)

----------------------------------------

(1338)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1339) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1340)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1341)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1342)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1343) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1344)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1345)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1346) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1347)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1348) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1349)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1350)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1351) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1352)
Complex Obligation (OR)

----------------------------------------

(1353)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1354) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1355)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1356)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1357) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1358)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1359) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1360)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1361)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1362) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1363)
Complex Obligation (OR)

----------------------------------------

(1364)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1365) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1366)
Complex Obligation (OR)

----------------------------------------

(1367)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1368) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1369)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1370) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1371)
Complex Obligation (AND)

----------------------------------------

(1372)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1373) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1374)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1375)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1376)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1377) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1378)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1379)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1380) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1381)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1382)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1383) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1384)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1385) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1386)
Complex Obligation (AND)

----------------------------------------

(1387)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1388) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1389)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1390) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(b)) -> C0(a0(c))

Strictly oriented rules of the TRS R:

   a0(b) -> c
   a0(b) -> a0(c)
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:C0_1 > b > a0_1 > c

and weight map:

   c=4
   b=5
   a0_1=1
   C0_1=1

The variable weight is 1

----------------------------------------

(1391)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1392) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1393)
YES

----------------------------------------

(1394)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1395) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1396)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1397) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b) -> A0(a)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 0
   POL(b) = 1
   POL(c0(x_1)) = x_1


----------------------------------------

(1398)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1399)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1400) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1401)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(a(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1402)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1403) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1404)
Complex Obligation (OR)

----------------------------------------

(1405)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1406) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1407)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1408)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1409) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(1410)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1411) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(1412)
Complex Obligation (AND)

----------------------------------------

(1413)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1414)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1415)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1416) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1417)
Complex Obligation (OR)

----------------------------------------

(1418)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1419) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1420)
Complex Obligation (OR)

----------------------------------------

(1421)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1422) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1423)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1424) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1425)
Complex Obligation (AND)

----------------------------------------

(1426)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1427)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1428)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1429)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1430) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1431)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1432) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1433)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1434)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1435) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1436)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1437) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1438)
Complex Obligation (AND)

----------------------------------------

(1439)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1440) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1441)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1442) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(b)) -> C0(a0(c))

Strictly oriented rules of the TRS R:

   a0(b) -> c
   a0(b) -> a0(c)
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 2
   POL(c) = 0


----------------------------------------

(1443)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1444) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1445)
YES

----------------------------------------

(1446)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1447) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1448)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1449) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b) -> A0(a)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 0
   POL(b) = 1
   POL(c0(x_1)) = x_1


----------------------------------------

(1450)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1451)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1452) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1453)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(a(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1454)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1455) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1456)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1457) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1458)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1459) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1460)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1461) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(1462)
Complex Obligation (AND)

----------------------------------------

(1463)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1464)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1465)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1466) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1467)
Complex Obligation (OR)

----------------------------------------

(1468)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1469) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1470)
Complex Obligation (OR)

----------------------------------------

(1471)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1472) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1473)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1474)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1475) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1476)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1477) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1478)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1479)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1480) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1481)
Complex Obligation (OR)

----------------------------------------

(1482)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1483) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1484)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1485)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1486) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(1487)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1488) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(1489)
Complex Obligation (AND)

----------------------------------------

(1490)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1491) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b(x1)

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, b_1, c_1]

Status: a_1: multiset status
b_1: multiset status
c_1: multiset status


----------------------------------------

(1492)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1493)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1494) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

B(x1)  =  B(x1)

c(x1)  =  x1

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, B_1] > a

Status: b_1: [1]
B_1: [1]
a: multiset status


----------------------------------------

(1495)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a)

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b0(c0(c0(x1))) -> b0(a)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1496)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1497) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1498)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1499) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1500)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1501) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1502)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1503) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(1504)
Complex Obligation (AND)

----------------------------------------

(1505)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1506)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1507)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1508) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1509)
Complex Obligation (OR)

----------------------------------------

(1510)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1511) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1512)
Complex Obligation (OR)

----------------------------------------

(1513)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1514) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1515)
Complex Obligation (OR)

----------------------------------------

(1516)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1517) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1518)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1519) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1520)
Complex Obligation (AND)

----------------------------------------

(1521)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1522) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1523)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1524)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1525)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1526) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1527)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1528)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1529) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1530)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1531)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1532) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1533)
Complex Obligation (OR)

----------------------------------------

(1534)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1535) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1536)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1537) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1538)
Complex Obligation (AND)

----------------------------------------

(1539)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1540) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1541)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1542)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1543)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1544) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1545)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1546)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1547) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1548)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1549) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1550)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1551)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1552) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1553)
Complex Obligation (OR)

----------------------------------------

(1554)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1555) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1556)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1557)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1558) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1559)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1560) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1561)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1562)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1563) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1564)
Complex Obligation (OR)

----------------------------------------

(1565)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1566) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1567)
Complex Obligation (OR)

----------------------------------------

(1568)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1569) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1570)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1571) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1572)
Complex Obligation (AND)

----------------------------------------

(1573)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1574) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1575)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1576)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1577)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1578) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1579)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1580)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1581) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1582)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1583)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1584) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1585)
Complex Obligation (OR)

----------------------------------------

(1586)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1587) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1588)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1589) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1590)
Complex Obligation (AND)

----------------------------------------

(1591)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1592) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1593)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1594)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1595)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1596) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1597)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1598)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1599) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1600)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1601)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1602) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1603)
Complex Obligation (OR)

----------------------------------------

(1604)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1605) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1606)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1607)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1608) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1609)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1610)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1611) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1612)
Complex Obligation (OR)

----------------------------------------

(1613)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1614) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1615)
Complex Obligation (OR)

----------------------------------------

(1616)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1617) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1618)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1619) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1620)
Complex Obligation (AND)

----------------------------------------

(1621)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1622)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1623)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1624)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1625) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1626)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1627) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1628)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1629)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1630) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1631)
Complex Obligation (OR)

----------------------------------------

(1632)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1633) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1634)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1635) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1636)
Complex Obligation (AND)

----------------------------------------

(1637)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1638) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1639)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1640)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1641)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1642) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1643)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1644)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1645) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1646)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1647)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1648) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1649)
Complex Obligation (OR)

----------------------------------------

(1650)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1651) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1652)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1653) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1654)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1655)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1656) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1657)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1658)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1659) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1660)
Complex Obligation (OR)

----------------------------------------

(1661)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1662) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1663)
Complex Obligation (OR)

----------------------------------------

(1664)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1665) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1666)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1667)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1668) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1669)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1670) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1671)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1672)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1673) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1674)
Complex Obligation (OR)

----------------------------------------

(1675)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1676) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1677)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1678)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1679) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1680)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1681)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1682) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1683)
Complex Obligation (OR)

----------------------------------------

(1684)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1685) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1686)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1687) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1688)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1689)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1690) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1691)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1692)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1693) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1694)
Complex Obligation (OR)

----------------------------------------

(1695)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1696) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1697)
Complex Obligation (OR)

----------------------------------------

(1698)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1699) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1700)
Complex Obligation (OR)

----------------------------------------

(1701)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1702) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1703)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1704) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1705)
Complex Obligation (AND)

----------------------------------------

(1706)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1707) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1708)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1709)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1710)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1711) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1712)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1713)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1714) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1715)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1716)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1717) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1718)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1719) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1720)
Complex Obligation (AND)

----------------------------------------

(1721)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1722) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1723)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1724) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(b)) -> C0(a0(c))

Strictly oriented rules of the TRS R:

   a0(b) -> c
   a0(b) -> a0(c)
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:C0_1 > b > a0_1 > c

and weight map:

   c=4
   b=5
   a0_1=1
   C0_1=1

The variable weight is 1

----------------------------------------

(1725)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1726)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1727) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1728)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1729) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b) -> A0(a)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 0
   POL(b) = 1
   POL(c0(x_1)) = x_1


----------------------------------------

(1730)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1731)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1732) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1733)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(a(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1734)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1735) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1736)
Complex Obligation (OR)

----------------------------------------

(1737)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1738) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1739)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1740)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1741) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(1742)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1743) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(1744)
Complex Obligation (AND)

----------------------------------------

(1745)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1746)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1747)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1748) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1749)
Complex Obligation (OR)

----------------------------------------

(1750)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1751) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1752)
Complex Obligation (OR)

----------------------------------------

(1753)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1754) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1755)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1756) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1757)
Complex Obligation (AND)

----------------------------------------

(1758)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1759) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1760)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1761)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1762)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1763) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1764)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1765)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1766) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1767)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1768)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1769) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1770)
Complex Obligation (OR)

----------------------------------------

(1771)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1772) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1773)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1774) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1775)
Complex Obligation (AND)

----------------------------------------

(1776)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1777) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1778)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1779)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1780)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1781) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1782)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1783)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1784) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1785)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1786)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1787) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1788)
Complex Obligation (OR)

----------------------------------------

(1789)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1790) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1791)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1792)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1793) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1794)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1795)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1796) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1797)
Complex Obligation (OR)

----------------------------------------

(1798)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1799) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1800)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1801) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1802)
Complex Obligation (AND)

----------------------------------------

(1803)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1804) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1805)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1806) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(b)) -> C0(a0(c))

Strictly oriented rules of the TRS R:

   a0(b) -> c
   a0(b) -> a0(c)
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 2
   POL(c) = 0


----------------------------------------

(1807)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1808) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1809)
YES

----------------------------------------

(1810)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1811) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1812)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1813) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b) -> A0(a)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 0
   POL(b) = 1
   POL(c0(x_1)) = x_1


----------------------------------------

(1814)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1815)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1816) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1817)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(a(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1818)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1819) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1820)
Complex Obligation (OR)

----------------------------------------

(1821)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1822) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1823)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1824) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1825)
Complex Obligation (AND)

----------------------------------------

(1826)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1827) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1828)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1829)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1830)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1831) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1832)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1833)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1834) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1835)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1836)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1837) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1838)
Complex Obligation (OR)

----------------------------------------

(1839)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1840) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(1841)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1842) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(1843)
Complex Obligation (AND)

----------------------------------------

(1844)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1845) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b(x1)

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, b_1, c_1]

Status: a_1: multiset status
b_1: multiset status
c_1: multiset status


----------------------------------------

(1846)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1847)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1848) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

B(x1)  =  B(x1)

c(x1)  =  x1

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, B_1] > a

Status: b_1: [1]
B_1: [1]
a: multiset status


----------------------------------------

(1849)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a)

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b0(c0(c0(x1))) -> b0(a)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1850)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1851) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1852)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1853)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1854) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1855)
Complex Obligation (OR)

----------------------------------------

(1856)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1857) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1858)
Complex Obligation (OR)

----------------------------------------

(1859)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1860) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1861)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1862)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1863) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(1864)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1865) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(1866)
Complex Obligation (AND)

----------------------------------------

(1867)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1868)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1869)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1870) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1871)
Complex Obligation (OR)

----------------------------------------

(1872)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(1873) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1874)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1875)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1876) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1877)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1878)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1879) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1880)
Complex Obligation (OR)

----------------------------------------

(1881)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(1882) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(1883)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1884) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(1885)
Complex Obligation (AND)

----------------------------------------

(1886)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1887) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b(x1)

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, b_1, c_1]

Status: a_1: multiset status
b_1: multiset status
c_1: multiset status


----------------------------------------

(1888)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1889)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1890) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

B(x1)  =  B(x1)

c(x1)  =  x1

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, B_1] > a

Status: b_1: [1]
B_1: [1]
a: multiset status


----------------------------------------

(1891)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a)

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b0(c0(c0(x1))) -> b0(a)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1892)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1893) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1894)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1895)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1896) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1897)
Complex Obligation (OR)

----------------------------------------

(1898)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1899) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1900)
Complex Obligation (OR)

----------------------------------------

(1901)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1902) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1903)
Complex Obligation (OR)

----------------------------------------

(1904)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1905) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1906)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1907) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1908)
Complex Obligation (AND)

----------------------------------------

(1909)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1910) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1911)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1912)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1913)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1914) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1915)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1916)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1917) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1918)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1919) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1920)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1921)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1922) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1923)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1924) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1925)
Complex Obligation (AND)

----------------------------------------

(1926)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1927) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1928)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1929) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(b)) -> C0(a0(c))

Strictly oriented rules of the TRS R:

   a0(b) -> c
   a0(b) -> a0(c)
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 2
   POL(c) = 0


----------------------------------------

(1930)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1931) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1932)
YES

----------------------------------------

(1933)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1934) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1935)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1936) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b) -> A0(a)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 0
   POL(b) = 1
   POL(c0(x_1)) = x_1


----------------------------------------

(1937)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1938)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1939) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1940)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(a(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1941)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1942) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1943)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1944) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1945)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1946) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1947)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1948) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(1949)
Complex Obligation (AND)

----------------------------------------

(1950)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1951)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1952)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1953) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1954)
Complex Obligation (OR)

----------------------------------------

(1955)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1956) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1957)
Complex Obligation (OR)

----------------------------------------

(1958)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1959) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1960)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1961) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1962)
Complex Obligation (AND)

----------------------------------------

(1963)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1964) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1965)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1966)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1967)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1968) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1969)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1970)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1971) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1972)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1973) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(1974)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1975)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1976) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1977)
Complex Obligation (OR)

----------------------------------------

(1978)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(1979) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1980)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1981) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1982)
Complex Obligation (AND)

----------------------------------------

(1983)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1984) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1985)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1986)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1987)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(1988) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(1989)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1990)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(1991) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1992)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(1993)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1994) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1995)
Complex Obligation (OR)

----------------------------------------

(1996)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(1997) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(1998)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(1999) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2000)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2001)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2002) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2003)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2004)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2005) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2006)
Complex Obligation (OR)

----------------------------------------

(2007)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2008) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2009)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2010) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2011)
Complex Obligation (AND)

----------------------------------------

(2012)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2013) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(2014)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2015) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(b)) -> C0(a0(c))

Strictly oriented rules of the TRS R:

   a0(b) -> c
   a0(b) -> a0(c)
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 2
   POL(c) = 0


----------------------------------------

(2016)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2017) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(2018)
YES

----------------------------------------

(2019)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2020) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(2021)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2022) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b) -> A0(a)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 0
   POL(b) = 1
   POL(c0(x_1)) = x_1


----------------------------------------

(2023)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2024)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2025) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2026)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(a(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2027)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2028) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2029)
Complex Obligation (OR)

----------------------------------------

(2030)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2031) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2032)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2033) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2034)
Complex Obligation (AND)

----------------------------------------

(2035)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2036)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2037)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2038)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2039) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2040)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2041)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2042) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2043)
Complex Obligation (OR)

----------------------------------------

(2044)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2045) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(2046)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2047) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(2048)
Complex Obligation (AND)

----------------------------------------

(2049)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2050)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2051)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2052) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2053)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2054)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2055) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2056)
Complex Obligation (OR)

----------------------------------------

(2057)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2058) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2059)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2060) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2061)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2062) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(2063)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2064) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(2065)
Complex Obligation (AND)

----------------------------------------

(2066)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2067)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2068)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2069) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2070)
Complex Obligation (OR)

----------------------------------------

(2071)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2072) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2073)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2074) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2075)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2076)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2077) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2078)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2079)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2080) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2081)
Complex Obligation (OR)

----------------------------------------

(2082)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2083) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(2084)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2085) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(2086)
Complex Obligation (AND)

----------------------------------------

(2087)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2088)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2089)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2090) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2091)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2092)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2093) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2094)
Complex Obligation (OR)

----------------------------------------

(2095)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2096) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2097)
Complex Obligation (OR)

----------------------------------------

(2098)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2099) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2100)
Complex Obligation (OR)

----------------------------------------

(2101)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2102) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2103)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2104)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2105) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2106)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2107) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2108)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2109)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2110) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2111)
Complex Obligation (OR)

----------------------------------------

(2112)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2113) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2114)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2115)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2116) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(2117)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2118) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(2119)
Complex Obligation (AND)

----------------------------------------

(2120)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2121)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2122)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2123) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2124)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2125) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2126)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2127) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(2128)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2129) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(2130)
Complex Obligation (AND)

----------------------------------------

(2131)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2132)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2133)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2134) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2135)
Complex Obligation (OR)

----------------------------------------

(2136)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2137) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2138)
Complex Obligation (OR)

----------------------------------------

(2139)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2140) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2141)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2142)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2143) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2144)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2145) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2146)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2147)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2148) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2149)
Complex Obligation (OR)

----------------------------------------

(2150)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2151) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2152)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2153)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2154) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2155)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2156)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2157) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2158)
Complex Obligation (OR)

----------------------------------------

(2159)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2160) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2161)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2162) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2163)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2164)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2165) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2166)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2167)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2168) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2169)
Complex Obligation (OR)

----------------------------------------

(2170)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2171) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2172)
Complex Obligation (OR)

----------------------------------------

(2173)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2174) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2175)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2176)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2177) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(2178)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2179) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(2180)
Complex Obligation (AND)

----------------------------------------

(2181)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2182) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b(x1)

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, b_1, c_1]

Status: a_1: multiset status
b_1: multiset status
c_1: multiset status


----------------------------------------

(2183)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2184)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2185) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

B(x1)  =  B(x1)

c(x1)  =  x1

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, B_1] > a

Status: b_1: [1]
B_1: [1]
a: multiset status


----------------------------------------

(2186)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a)

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b0(c0(c0(x1))) -> b0(a)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2187)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2188) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2189)
Complex Obligation (OR)

----------------------------------------

(2190)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2191) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2192)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2193)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2194) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2195)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2196)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2197) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2198)
Complex Obligation (OR)

----------------------------------------

(2199)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2200) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(2201)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2202) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(2203)
Complex Obligation (AND)

----------------------------------------

(2204)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2205) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b(x1)

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, b_1, c_1]

Status: a_1: multiset status
b_1: multiset status
c_1: multiset status


----------------------------------------

(2206)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2207)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2208) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

B(x1)  =  B(x1)

c(x1)  =  x1

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, B_1] > a

Status: b_1: [1]
B_1: [1]
a: multiset status


----------------------------------------

(2209)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a)

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b0(c0(c0(x1))) -> b0(a)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2210)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2211) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2212)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2213)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2214) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2215)
Complex Obligation (OR)

----------------------------------------

(2216)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2217) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2218)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2219) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2220)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2221) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(2222)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2223) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(2224)
Complex Obligation (AND)

----------------------------------------

(2225)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2226)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2227)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2228) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2229)
Complex Obligation (OR)

----------------------------------------

(2230)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2231) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2232)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2233) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2234)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2235)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2236) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2237)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2238)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2239) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2240)
Complex Obligation (OR)

----------------------------------------

(2241)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2242) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(2243)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2244) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(2245)
Complex Obligation (AND)

----------------------------------------

(2246)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2247)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2248)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2249) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2250)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2251)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2252) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2253)
Complex Obligation (OR)

----------------------------------------

(2254)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2255) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2256)
Complex Obligation (OR)

----------------------------------------

(2257)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2258) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2259)
Complex Obligation (OR)

----------------------------------------

(2260)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2261) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2262)
Complex Obligation (OR)

----------------------------------------

(2263)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2264)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2265)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2266) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2267)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2268) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2269)
Complex Obligation (AND)

----------------------------------------

(2270)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2271) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(2272)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2273)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2274) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(2275)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2276)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2277)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2278) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2279)
Complex Obligation (OR)

----------------------------------------

(2280)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2281)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2282)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2283) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2284)
Complex Obligation (OR)

----------------------------------------

(2285)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2286) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2287)
Complex Obligation (OR)

----------------------------------------

(2288)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2289)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2290)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2291) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2292)
Complex Obligation (OR)

----------------------------------------

(2293)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2294)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2295)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2296) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2297)
Complex Obligation (OR)

----------------------------------------

(2298)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2299)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2300)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2301) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2302)
Complex Obligation (OR)

----------------------------------------

(2303)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2304) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2305)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2306) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2307)
Complex Obligation (AND)

----------------------------------------

(2308)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2309) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(2310)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2311)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2312) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(2313)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2314)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2315)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2316) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2317)
Complex Obligation (OR)

----------------------------------------

(2318)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2319)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2320)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2321) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2322)
Complex Obligation (OR)

----------------------------------------

(2323)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2324)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2325)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2326) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2327)
Complex Obligation (OR)

----------------------------------------

(2328)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2329) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2330)
Complex Obligation (OR)

----------------------------------------

(2331)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2332)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2333)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2334) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2335)
Complex Obligation (OR)

----------------------------------------

(2336)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2337)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2338)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2339) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2340)
Complex Obligation (OR)

----------------------------------------

(2341)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2342)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2343)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2344) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2345)
Complex Obligation (OR)

----------------------------------------

(2346)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2347) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2348)
Complex Obligation (OR)

----------------------------------------

(2349)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2350) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2351)
Complex Obligation (OR)

----------------------------------------

(2352)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2353)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2354)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2355) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2356)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2357) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2358)
Complex Obligation (AND)

----------------------------------------

(2359)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2360) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(2361)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2362)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2363) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(2364)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2365)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2366)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2367) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2368)
Complex Obligation (OR)

----------------------------------------

(2369)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2370)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2371)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2372) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2373)
Complex Obligation (OR)

----------------------------------------

(2374)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2375) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2376)
Complex Obligation (OR)

----------------------------------------

(2377)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2378)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2379)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2380) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2381)
Complex Obligation (OR)

----------------------------------------

(2382)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2383)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2384)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2385) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2386)
Complex Obligation (OR)

----------------------------------------

(2387)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2388)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2389)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2390) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2391)
Complex Obligation (OR)

----------------------------------------

(2392)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2393) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2394)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2395) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2396)
Complex Obligation (AND)

----------------------------------------

(2397)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2398) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(2399)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2400)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2401) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(2402)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2403)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2404)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2405) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2406)
Complex Obligation (OR)

----------------------------------------

(2407)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2408)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2409)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2410) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2411)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2412) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2413)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2414)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2415) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2416)
Complex Obligation (OR)

----------------------------------------

(2417)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2418) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2419)
Complex Obligation (OR)

----------------------------------------

(2420)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2421)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2422)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2423) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2424)
Complex Obligation (OR)

----------------------------------------

(2425)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2426)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2427)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2428) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2429)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2430) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2431)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2432)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2433) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2434)
Complex Obligation (OR)

----------------------------------------

(2435)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2436) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2437)
Complex Obligation (OR)

----------------------------------------

(2438)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2439) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2440)
Complex Obligation (OR)

----------------------------------------

(2441)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2442)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2443)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2444) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2445)
Complex Obligation (OR)

----------------------------------------

(2446)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2447)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2448)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2449) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2450)
Complex Obligation (OR)

----------------------------------------

(2451)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2452)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2453)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2454) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2455)
Complex Obligation (OR)

----------------------------------------

(2456)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2457) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2458)
Complex Obligation (OR)

----------------------------------------

(2459)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2460)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2461)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2462) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2463)
Complex Obligation (OR)

----------------------------------------

(2464)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2465)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2466)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2467) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2468)
Complex Obligation (OR)

----------------------------------------

(2469)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2470)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2471)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2472) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2473)
Complex Obligation (OR)

----------------------------------------

(2474)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2475) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2476)
Complex Obligation (OR)

----------------------------------------

(2477)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2478)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2479)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2480) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2481)
Complex Obligation (OR)

----------------------------------------

(2482)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2483)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2484)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2485) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2486)
Complex Obligation (OR)

----------------------------------------

(2487)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2488)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2489)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2490) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2491)
Complex Obligation (OR)

----------------------------------------

(2492)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2493) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2494)
Complex Obligation (OR)

----------------------------------------

(2495)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2496)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2497)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2498) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2499)
Complex Obligation (OR)

----------------------------------------

(2500)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2501)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2502)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2503) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2504)
Complex Obligation (OR)

----------------------------------------

(2505)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2506)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2507)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2508) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2509)
Complex Obligation (OR)

----------------------------------------

(2510)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2511) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2512)
Complex Obligation (OR)

----------------------------------------

(2513)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2514) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2515)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2516) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2517)
Complex Obligation (AND)

----------------------------------------

(2518)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2519) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(2520)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2521)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2522) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(2523)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2524)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2525)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2526) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2527)
Complex Obligation (OR)

----------------------------------------

(2528)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2529)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2530)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2531) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2532)
Complex Obligation (OR)

----------------------------------------

(2533)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2534)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2535)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2536) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2537)
Complex Obligation (OR)

----------------------------------------

(2538)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2539) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2540)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2541) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2542)
Complex Obligation (AND)

----------------------------------------

(2543)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2544) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, b] > [a_1, c]

Status: C_1: multiset status
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(2545)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b)) -> C0(a0(c))

The TRS R consists of the following rules:

   c -> c
   a0(b) -> c
   a0(b) -> a0(c)
   b -> b
   a0(b) -> a0(a0(c))
   a0(a0(a0(x1))) -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2546)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2547) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b

a(x1)  =  a

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: b > a

Status: b: multiset status
a: multiset status


----------------------------------------

(2548)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b) -> A0(a)
   A0(b) -> A0(c0(b))

The TRS R consists of the following rules:

   c0(a) -> c0(a)
   a -> c0(a)
   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2549)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2550)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2551) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2552)
Complex Obligation (OR)

----------------------------------------

(2553)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2554)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2555)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2556) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2557)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2558) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2559)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2560)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2561) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2562)
Complex Obligation (OR)

----------------------------------------

(2563)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2564) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2565)
Complex Obligation (OR)

----------------------------------------

(2566)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2567)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2568)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2569) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2570)
Complex Obligation (OR)

----------------------------------------

(2571)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2572)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2573)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2574) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2575)
Complex Obligation (OR)

----------------------------------------

(2576)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2577)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2578)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2579) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2580)
Complex Obligation (OR)

----------------------------------------

(2581)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2582) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2583)
Complex Obligation (OR)

----------------------------------------

(2584)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2585)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2586)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2587) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2588)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2589) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2590)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2591)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2592) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2593)
Complex Obligation (OR)

----------------------------------------

(2594)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2595)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2596)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2597) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2598)
Complex Obligation (OR)

----------------------------------------

(2599)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2600) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2601)
Complex Obligation (OR)

----------------------------------------

(2602)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2603) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2604)
Complex Obligation (OR)

----------------------------------------

(2605)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2606) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2607)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2608)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2609) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(2610)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2611) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(2612)
Complex Obligation (AND)

----------------------------------------

(2613)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> c(a(C(x1)))
   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2614)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2615)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2616) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2617)
Complex Obligation (OR)

----------------------------------------

(2618)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2619) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2620)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2621)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2622) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2623)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2624)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2625) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2626)
Complex Obligation (OR)

----------------------------------------

(2627)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2628) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(2629)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2630)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2631)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2632) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2633)
Complex Obligation (OR)

----------------------------------------

(2634)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2635) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2636)
Complex Obligation (OR)

----------------------------------------

(2637)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2638)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2639)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2640) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2641)
Complex Obligation (OR)

----------------------------------------

(2642)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2643)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2644)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2645) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2646)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2647) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2648)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2649)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2650) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2651)
Complex Obligation (OR)

----------------------------------------

(2652)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2653) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2654)
Complex Obligation (OR)

----------------------------------------

(2655)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2656)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2657)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2658) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2659)
Complex Obligation (OR)

----------------------------------------

(2660)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2661)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2662)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2663) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2664)
Complex Obligation (OR)

----------------------------------------

(2665)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2666)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2667)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2668) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2669)
Complex Obligation (OR)

----------------------------------------

(2670)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2671) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2672)
Complex Obligation (OR)

----------------------------------------

(2673)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2674) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(2675)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2676)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2677)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


----------------------------------------

(2678) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2679)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2680) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2681)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2682) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(2683)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2684) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(2685)
Complex Obligation (AND)

----------------------------------------

(2686)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(c0(c0(x1))) -> B0(a0(b0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2687)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(b0(x1))) -> C0(a0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2688)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2689) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2690)
Complex Obligation (OR)

----------------------------------------

(2691)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2692)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2693) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(2694)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2695)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2696) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2697)
Complex Obligation (OR)

----------------------------------------

(2698)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2699) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2700)
Complex Obligation (OR)

----------------------------------------

(2701)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2702) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2703)
Complex Obligation (OR)

----------------------------------------

(2704)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2705) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2706)
Complex Obligation (OR)

----------------------------------------

(2707)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2708)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2709)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2710) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2711)
Complex Obligation (OR)

----------------------------------------

(2712)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2713)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2714)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2715) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2716)
Complex Obligation (OR)

----------------------------------------

(2717)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2718)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2719)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2720) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2721)
Complex Obligation (OR)

----------------------------------------

(2722)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2723) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2724)
Complex Obligation (OR)

----------------------------------------

(2725)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2726)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2727)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2728) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2729)
Complex Obligation (OR)

----------------------------------------

(2730)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2731)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2732)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2733) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2734)
Complex Obligation (OR)

----------------------------------------

(2735)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2736)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2737)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2738) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2739)
Complex Obligation (OR)

----------------------------------------

(2740)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2741) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2742)
Complex Obligation (OR)

----------------------------------------

(2743)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2744)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2745)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2746) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2747)
Complex Obligation (OR)

----------------------------------------

(2748)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2749)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2750)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2751) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2752)
Complex Obligation (OR)

----------------------------------------

(2753)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2754)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2755)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2756) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2757)
Complex Obligation (OR)

----------------------------------------

(2758)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2759) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2760)
Complex Obligation (OR)

----------------------------------------

(2761)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2762)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2763)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2764) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2765)
Complex Obligation (OR)

----------------------------------------

(2766)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2767)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2768)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2769) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2770)
Complex Obligation (OR)

----------------------------------------

(2771)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2772)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2773)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2774) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2775)
Complex Obligation (OR)

----------------------------------------

(2776)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2777) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2778)
Complex Obligation (OR)

----------------------------------------

(2779)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2780) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2781)
Complex Obligation (OR)

----------------------------------------

(2782)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2783)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2784)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2785) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2786)
Complex Obligation (OR)

----------------------------------------

(2787)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2788)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2789)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2790) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2791)
Complex Obligation (OR)

----------------------------------------

(2792)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2793)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2794)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2795) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2796)
Complex Obligation (OR)

----------------------------------------

(2797)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2798) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2799)
Complex Obligation (OR)

----------------------------------------

(2800)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2801)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2802)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2803) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2804)
Complex Obligation (OR)

----------------------------------------

(2805)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2806)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2807)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2808) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2809)
Complex Obligation (OR)

----------------------------------------

(2810)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2811)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2812)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2813) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2814)
Complex Obligation (OR)

----------------------------------------

(2815)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2816) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2817)
Complex Obligation (OR)

----------------------------------------

(2818)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2819)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2820)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2821) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2822)
Complex Obligation (OR)

----------------------------------------

(2823)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2824)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2825)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2826) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2827)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2828) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2829)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2830)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2831) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2832)
Complex Obligation (OR)

----------------------------------------

(2833)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2834) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2835)
Complex Obligation (OR)

----------------------------------------

(2836)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2837)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2838)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2839) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2840)
Complex Obligation (OR)

----------------------------------------

(2841)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2842)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2843)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2844) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2845)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2846) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2847)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2848)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2849) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2850)
Complex Obligation (OR)

----------------------------------------

(2851)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2852) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2853)
Complex Obligation (OR)

----------------------------------------

(2854)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2855) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2856)
Complex Obligation (OR)

----------------------------------------

(2857)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2858)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2859)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2860) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2861)
Complex Obligation (OR)

----------------------------------------

(2862)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2863)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2864)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2865) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2866)
Complex Obligation (OR)

----------------------------------------

(2867)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2868)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2869)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2870) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2871)
Complex Obligation (OR)

----------------------------------------

(2872)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2873) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2874)
Complex Obligation (OR)

----------------------------------------

(2875)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2876)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2877)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2878) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2879)
Complex Obligation (OR)

----------------------------------------

(2880)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2881)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2882)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2883) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2884)
Complex Obligation (OR)

----------------------------------------

(2885)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2886)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2887)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2888) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2889)
Complex Obligation (OR)

----------------------------------------

(2890)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2891) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2892)
Complex Obligation (OR)

----------------------------------------

(2893)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2894)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2895)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2896) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2897)
Complex Obligation (OR)

----------------------------------------

(2898)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2899)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2900)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2901) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2902)
Complex Obligation (OR)

----------------------------------------

(2903)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2904)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2905)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2906) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2907)
Complex Obligation (OR)

----------------------------------------

(2908)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2909) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2910)
Complex Obligation (OR)

----------------------------------------

(2911)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2912)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2913)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2914) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2915)
Complex Obligation (OR)

----------------------------------------

(2916)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(2917)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2918)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2919) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2920)
Complex Obligation (OR)

----------------------------------------

(2921)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2922)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2923)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2924) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2925)
Complex Obligation (OR)

----------------------------------------

(2926)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2927) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2928)
Complex Obligation (OR)

----------------------------------------

(2929)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2930) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2931)
Complex Obligation (OR)

----------------------------------------

(2932)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2933) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2934)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2935) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2936)
Complex Obligation (AND)

----------------------------------------

(2937)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2938)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2939)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2940)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2941) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2942)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2943)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2944) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2945)
Complex Obligation (OR)

----------------------------------------

(2946)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2947) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2948)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2949)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2950)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2951) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2952)
Complex Obligation (OR)

----------------------------------------

(2953)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2954) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2955)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2956)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2957)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2958) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2959)
Complex Obligation (OR)

----------------------------------------

(2960)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2961) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2962)
Complex Obligation (OR)

----------------------------------------

(2963)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2964)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2965)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2966) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2967)
Complex Obligation (OR)

----------------------------------------

(2968)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2969)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(2970)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(2971) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(2972)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(2973) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(2974)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2975)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2976) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2977)
Complex Obligation (OR)

----------------------------------------

(2978)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2979) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2980)
Complex Obligation (OR)

----------------------------------------

(2981)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2982) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2983)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2984) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2985)
Complex Obligation (AND)

----------------------------------------

(2986)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2987)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2988)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2989)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(2990) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2991)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(2992)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2993) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2994)
Complex Obligation (OR)

----------------------------------------

(2995)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


----------------------------------------

(2996) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:

   b(c(c(x1))) -> b(A(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2997)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2998) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2999)
Complex Obligation (AND)

----------------------------------------

(3000)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   c(a(b(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(3001)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(3002)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(a(c(x1)))
   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   b(c(c(x1))) -> b(a(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(3003)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(3004) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(3005)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(3006)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3007) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3008)
Complex Obligation (OR)

----------------------------------------

(3009)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3010)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(3011) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(3012)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(3013)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3014) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3015)
Complex Obligation (OR)

----------------------------------------

(3016)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3017) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3018)
Complex Obligation (OR)

----------------------------------------

(3019)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3020)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3021)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3022) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(3023)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(3024) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(3025)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(3026)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3027) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3028)
Complex Obligation (OR)

----------------------------------------

(3029)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3030)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(3031)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3032) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3033)
Complex Obligation (OR)

----------------------------------------

(3034)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3035) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3036)
Complex Obligation (OR)

----------------------------------------

(3037)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3038) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3039)
Complex Obligation (OR)

----------------------------------------

(3040)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3041)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3042)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3043) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3044)
Complex Obligation (OR)

----------------------------------------

(3045)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3046)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3047)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3048) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3049)
Complex Obligation (OR)

----------------------------------------

(3050)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3051)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3052)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3053) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3054)
Complex Obligation (OR)

----------------------------------------

(3055)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3056) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3057)
Complex Obligation (OR)

----------------------------------------

(3058)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3059) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3060)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(3061)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3062) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(3063)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(3064) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(3065)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(3066)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3067) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3068)
Complex Obligation (OR)

----------------------------------------

(3069)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3070) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3071)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and no relative ADPs.
----------------------------------------

(3072)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(3073) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2
   POL(c(x_1)) = 0

----------------------------------------

(3074)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(3075) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(3076)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(3077)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3078) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(3079)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(3080) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(3081)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(3082)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3083) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3084)
Complex Obligation (OR)

----------------------------------------

(3085)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3086) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3087)
Complex Obligation (OR)

----------------------------------------

(3088)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3089)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3090)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3091) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3092)
Complex Obligation (OR)

----------------------------------------

(3093)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(a(B(x1)))


----------------------------------------

(3094)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(3095)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3096) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3097)
Complex Obligation (OR)

----------------------------------------

(3098)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3099)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))


----------------------------------------

(3100)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3101) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3102)
Complex Obligation (OR)

----------------------------------------

(3103)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3104) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3105)
Complex Obligation (OR)

----------------------------------------

(3106)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3107)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3108)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


----------------------------------------

(3109) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   a(b(b(x1))) -> A(a(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1
   POL(c(x_1)) = 0

----------------------------------------

(3110)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(a(x1))) -> c(a(c(x1)))
   a(b(b(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(c(x1)))


----------------------------------------

(3111) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, C_1, b_1, c_1] > B_1

Status: A_1: multiset status
a_1: multiset status
C_1: multiset status
b_1: multiset status
c_1: multiset status
B_1: multiset status


----------------------------------------

(3112)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> C0(a0(a0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   A0(a0(a0(x1))) -> A0(a0(x1))
   C0(a0(b0(x1))) -> C0(x1)
   C0(a0(b0(x1))) -> C0(a0(c0(x1)))
   A0(b0(b0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> B0(x1)
   B0(c0(c0(x1))) -> A0(b0(x1))
   B0(c0(c0(x1))) -> B0(a0(b0(x1)))
   C0(a0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   c0(a0(b0(x1))) -> c0(a0(c0(x1)))
   a0(b0(a0(x1))) -> c0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(c0(b0(x1)))
   b0(c0(c0(x1))) -> b0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(c0(x1)))
   a0(a0(a0(x1))) -> c0(a0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(3113)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))
   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3114) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(3115)
Complex Obligation (OR)

----------------------------------------

(3116)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   b(c(c(x1))) -> B(A(b(x1)))


----------------------------------------

(3117)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(a(C(x1)))
   b(c(c(x1))) -> B(a(b(x1)))
   c(a(b(x1))) -> c(A(c(x1)))
   a(a(a(x1))) -> C(a(a(x1)))
   a(b(b(x1))) -> a(C(b(x1)))
   a(b(a(x1))) -> c(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> C(a(c(x1)))
   a(b(a(x1))) -> c(a(C(x1)))
   a(b(b(x1))) -> A(c(b(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   b(c(c(x1))) -> b(a(B(x1)))
   a(a(a(x1))) -> c(a(A(x1)))
   c(a(b(x1))) -> c(a(C(x1)))
   b(c(c(x1))) -> b(A(b(x1)))
   a(b(a(x1))) -> C(a(c(x1)))
   a(b(b(x1))) -> a(c(B(x1)))
   a(a(a(x1))) -> c(A(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(A(c(x1)))

