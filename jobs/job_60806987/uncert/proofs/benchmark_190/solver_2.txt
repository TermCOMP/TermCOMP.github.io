YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/40zhx.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPDepGraphProof [EQUIVALENT, 0 ms]
(4) RelADPP
(5) RelADPDerelatifying2Proof [SOUND, 0 ms]
(6) OR
    (7) RelADPP
        (8) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (9) RelADPP
        (10) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (11) OR
            (12) RelADPP
                (13) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (14) RelADPP
                (15) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (16) RelADPP
                (17) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (18) RelADPP
                (19) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                (20) QDP
            (21) RelADPP
                (22) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (23) RelADPP
                (24) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (25) RelADPP
                (26) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (27) RelADPP
                (28) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                (29) QDP
                (30) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                (31) YES
    (32) RelADPP
        (33) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (34) RelADPP
        (35) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (36) OR
            (37) RelADPP
                (38) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (39) RelADPP
                (40) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (41) RelADPP
                (42) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (43) RelADPP
                (44) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                (45) QDP
            (46) RelADPP
                (47) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (48) RelADPP
                (49) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (50) RelADPP
                (51) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (52) RelADPP
                (53) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                (54) QDP
    (55) RelADPP
        (56) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (57) RelADPP
        (58) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (59) OR
            (60) RelADPP
                (61) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (62) RelADPP
                (63) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (64) RelADPP
                (65) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (66) RelADPP
                (67) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                (68) QDP
            (69) RelADPP
                (70) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (71) RelADPP
                (72) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (73) RelADPP
                (74) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (75) RelADPP
                (76) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                (77) QDP


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   b(a(b(x1))) -> b(a(a(a(b(x1)))))

The relative TRS consists of the following S rules:

   a(a(a(x1))) -> b(b(b(b(x1))))


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(A(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(A(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))

and relative ADPs:

   a(a(a(x1))) -> B(B(b(b(x1))))
   a(a(a(x1))) -> B(b(B(b(x1))))
   a(a(a(x1))) -> B(b(b(B(x1))))
   a(a(a(x1))) -> b(B(B(b(x1))))
   a(a(a(x1))) -> b(B(b(B(x1))))
   a(a(a(x1))) -> b(b(B(B(x1))))


----------------------------------------

(3) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(4)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))

and relative ADPs:

   a(a(a(x1))) -> b(B(b(B(x1))))
   a(a(a(x1))) -> b(b(B(B(x1))))
   a(a(a(x1))) -> B(b(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(5) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(6)
Complex Obligation (OR)

----------------------------------------

(7)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   a(a(a(x1))) -> b(B(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(B(B(x1))))
   a(a(a(x1))) -> B(b(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(8) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(9)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(B(B(x1))))
   a(a(a(x1))) -> B(b(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(10) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(11)
Complex Obligation (OR)

----------------------------------------

(12)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   a(a(a(x1))) -> b(b(B(b(x1))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> B(b(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(13) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(14)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> B(b(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(15) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(16)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   a(a(a(x1))) -> B(b(b(b(x1))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(17) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(18)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(19) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(a(a(x1))) -> B(x1)
   B(a(b(x1))) -> B(x1)
   B(a(b(x1))) -> A(a(a(b(x1))))
   B(a(b(x1))) -> B(a(a(a(b(x1)))))

The TRS R consists of the following rules:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(21)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   a(a(a(x1))) -> B(b(b(b(x1))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(B(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(22) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(23)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(B(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(24) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(25)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   a(a(a(x1))) -> b(b(B(b(x1))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(26) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(27)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(28) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(29)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(a(a(x1))) -> B(x1)
   B(a(b(x1))) -> B(x1)
   B(a(b(x1))) -> A(a(a(b(x1))))
   B(a(b(x1))) -> B(a(a(a(b(x1)))))

The TRS R consists of the following rules:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(30) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))
   A(a(a(x1))) -> B(x1)
   B(a(b(x1))) -> B(x1)
   B(a(b(x1))) -> A(a(a(b(x1))))
   B(a(b(x1))) -> B(a(a(a(b(x1)))))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484

Node 463 is start node and node 464 is final node.

Those nodes are connected through the following edges:

* 463 to 465 labelled b_1(0)* 463 to 468 labelled b_1(0), B_1(0)* 463 to 464 labelled B_1(0), B_1(1)* 463 to 469 labelled A_1(0)* 463 to 472 labelled A_1(1)* 463 to 475 labelled B_1(1)* 463 to 471 labelled B_1(1)* 463 to 474 labelled B_1(2)* 464 to 464 labelled #_1(0)* 465 to 466 labelled b_1(0)* 466 to 467 labelled b_1(0)* 467 to 464 labelled b_1(0)* 467 to 475 labelled b_1(1)* 468 to 469 labelled a_1(0)* 468 to 479 labelled b_1(1)* 469 to 470 labelled a_1(0)* 470 to 471 labelled a_1(0)* 471 to 464 labelled b_1(0)* 471 to 475 labelled b_1(1)* 472 to 473 labelled a_1(1)* 473 to 474 labelled a_1(1)* 474 to 464 labelled b_1(1)* 474 to 475 labelled b_1(1)* 475 to 476 labelled a_1(1)* 475 to 482 labelled b_1(2)* 476 to 477 labelled a_1(1)* 477 to 478 labelled a_1(1)* 478 to 464 labelled b_1(1)* 478 to 475 labelled b_1(1)* 479 to 480 labelled b_1(1)* 480 to 481 labelled b_1(1)* 481 to 471 labelled b_1(1)* 482 to 483 labelled b_1(2)* 483 to 484 labelled b_1(2)* 484 to 478 labelled b_1(2)


----------------------------------------

(31)
YES

----------------------------------------

(32)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   a(a(a(x1))) -> b(b(B(b(x1))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(B(b(B(x1))))
   a(a(a(x1))) -> B(b(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(33) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(34)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(B(b(B(x1))))
   a(a(a(x1))) -> B(b(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(35) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(36)
Complex Obligation (OR)

----------------------------------------

(37)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   a(a(a(x1))) -> b(B(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> B(b(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(38) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(39)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> B(b(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(40) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(41)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   a(a(a(x1))) -> B(b(b(b(x1))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(42) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(43)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(44) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(45)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(a(a(x1))) -> B(x1)
   B(a(b(x1))) -> B(x1)
   B(a(b(x1))) -> A(a(a(b(x1))))
   B(a(b(x1))) -> B(a(a(a(b(x1)))))

The TRS R consists of the following rules:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(46)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   a(a(a(x1))) -> B(b(b(b(x1))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(B(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(47) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(48)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(B(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(49) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(50)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   a(a(a(x1))) -> b(B(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(51) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(52)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(53) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(a(a(x1))) -> B(x1)
   B(a(b(x1))) -> B(x1)
   B(a(b(x1))) -> A(a(a(b(x1))))
   B(a(b(x1))) -> B(a(a(a(b(x1)))))

The TRS R consists of the following rules:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(55)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   a(a(a(x1))) -> B(b(b(b(x1))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(B(b(B(x1))))
   a(a(a(x1))) -> b(b(B(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(56) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(57)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(B(b(B(x1))))
   a(a(a(x1))) -> b(b(B(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(58) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(59)
Complex Obligation (OR)

----------------------------------------

(60)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   a(a(a(x1))) -> b(B(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(B(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(61) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(62)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(B(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(63) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(64)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   a(a(a(x1))) -> b(b(B(b(x1))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(65) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(66)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(67) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(a(a(x1))) -> B(x1)
   B(a(b(x1))) -> B(x1)
   B(a(b(x1))) -> A(a(a(b(x1))))
   B(a(b(x1))) -> B(a(a(a(b(x1)))))

The TRS R consists of the following rules:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(69)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   a(a(a(x1))) -> b(b(B(b(x1))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(B(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(70) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(71)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(B(b(B(x1))))
   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(72) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(73)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   a(a(a(x1))) -> b(B(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(74) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(75)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(b(x1))) -> b(A(a(a(b(x1)))))
   b(a(b(x1))) -> B(a(a(a(b(x1)))))
   b(a(b(x1))) -> b(a(a(a(B(x1)))))
   a(a(a(x1))) -> b(b(b(B(x1))))

and relative ADPs:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))


----------------------------------------

(76) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(77)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(a(a(x1))) -> B(x1)
   B(a(b(x1))) -> B(x1)
   B(a(b(x1))) -> A(a(a(b(x1))))
   B(a(b(x1))) -> B(a(a(a(b(x1)))))

The TRS R consists of the following rules:

   a(a(a(x1))) -> b(b(b(b(x1))))
   b(a(b(x1))) -> b(a(a(a(b(x1)))))

Q is empty.
We have to consider all (P,Q,R)-chains.