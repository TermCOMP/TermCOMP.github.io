YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/qmXkE.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPDerelatifying2Proof [SOUND, 9 ms]
(4) OR
    (5) RelADPP
        (6) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (7) OR
            (8) RelADPP
                (9) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (10) OR
                    (11) RelADPP
                        (12) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (13) OR
                            (14) RelADPP
                                (15) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (16) RelADPP
                            (17) RelADPP
                                (18) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (19) RelADPP
                                (20) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (21) AND
                                    (22) RelADPP
                                    (23) RelADPP
                    (24) RelADPP
                        (25) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (26) OR
                            (27) RelADPP
                                (28) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (29) RelADPP
                            (30) RelADPP
                                (31) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (32) RelADPP
                                (33) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (34) AND
                                    (35) RelADPP
                                    (36) RelADPP
                    (37) RelADPP
                        (38) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (39) RelADPP
                        (40) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (41) AND
                            (42) RelADPP
                                (43) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (44) QDP
                            (45) RelADPP
                                (46) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (47) QDP
            (48) RelADPP
                (49) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (50) OR
                    (51) RelADPP
                        (52) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (53) OR
                            (54) RelADPP
                                (55) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (56) RelADPP
                            (57) RelADPP
                                (58) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (59) RelADPP
                                (60) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (61) AND
                                    (62) RelADPP
                                    (63) RelADPP
                    (64) RelADPP
                        (65) RelADPDerelatifying2Proof [SOUND, 2 ms]
                        (66) OR
                            (67) RelADPP
                                (68) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (69) RelADPP
                            (70) RelADPP
                                (71) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (72) RelADPP
                    (73) RelADPP
                        (74) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (75) OR
                            (76) RelADPP
                                (77) RelADPReductionPairProof [EQUIVALENT, 15 ms]
                                (78) RelADPP
                                (79) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (80) AND
                                    (81) RelADPP
                                    (82) RelADPP
                            (83) RelADPP
                                (84) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (85) RelADPP
            (86) RelADPP
                (87) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (88) OR
                    (89) RelADPP
                        (90) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (91) OR
                            (92) RelADPP
                                (93) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (94) RelADPP
                            (95) RelADPP
                                (96) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                (97) RelADPP
                                (98) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (99) AND
                                    (100) RelADPP
                                    (101) RelADPP
                    (102) RelADPP
                        (103) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (104) OR
                            (105) RelADPP
                                (106) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (107) RelADPP
                            (108) RelADPP
                                (109) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (110) RelADPP
                    (111) RelADPP
                        (112) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (113) OR
                            (114) RelADPP
                                (115) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                (116) RelADPP
                                (117) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (118) AND
                                    (119) RelADPP
                                    (120) RelADPP
                            (121) RelADPP
            (122) RelADPP
                (123) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (124) OR
                    (125) RelADPP
                        (126) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (127) RelADPP
                        (128) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (129) AND
                            (130) RelADPP
                                (131) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (132) QDP
                                (133) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (134) YES
                            (135) RelADPP
                                (136) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (137) QDP
                    (138) RelADPP
                        (139) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (140) OR
                            (141) RelADPP
                                (142) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (143) RelADPP
                                (144) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (145) AND
                                    (146) RelADPP
                                    (147) RelADPP
                            (148) RelADPP
                                (149) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (150) RelADPP
                    (151) RelADPP
                        (152) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (153) OR
                            (154) RelADPP
                                (155) RelADPReductionPairProof [EQUIVALENT, 15 ms]
                                (156) RelADPP
                                (157) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (158) AND
                                    (159) RelADPP
                                    (160) RelADPP
                            (161) RelADPP
                                (162) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (163) RelADPP
    (164) RelADPP
        (165) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (166) OR
            (167) RelADPP
                (168) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (169) OR
                    (170) RelADPP
                        (171) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (172) OR
                            (173) RelADPP
                                (174) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (175) RelADPP
                            (176) RelADPP
                                (177) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (178) RelADPP
                    (179) RelADPP
                        (180) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (181) OR
                            (182) RelADPP
                                (183) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (184) RelADPP
                            (185) RelADPP
                                (186) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (187) RelADPP
                                (188) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (189) AND
                                    (190) RelADPP
                                    (191) RelADPP
                    (192) RelADPP
                        (193) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (194) OR
                            (195) RelADPP
                                (196) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (197) RelADPP
                            (198) RelADPP
                                (199) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (200) RelADPP
                                (201) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (202) AND
                                    (203) RelADPP
                                    (204) RelADPP
            (205) RelADPP
                (206) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (207) OR
                    (208) RelADPP
                        (209) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (210) OR
                            (211) RelADPP
                                (212) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (213) RelADPP
                            (214) RelADPP
                    (215) RelADPP
                        (216) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (217) OR
                            (218) RelADPP
                                (219) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (220) RelADPP
                            (221) RelADPP
                    (222) RelADPP
                        (223) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (224) OR
                            (225) RelADPP
                                (226) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (227) RelADPP
                            (228) RelADPP
            (229) RelADPP
                (230) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (231) OR
                    (232) RelADPP
                        (233) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (234) OR
                            (235) RelADPP
                            (236) RelADPP
                                (237) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (238) RelADPP
                                (239) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (240) AND
                                    (241) RelADPP
                                    (242) RelADPP
                    (243) RelADPP
                        (244) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (245) OR
                            (246) RelADPP
                                (247) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (248) RelADPP
                            (249) RelADPP
                    (250) RelADPP
                        (251) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (252) OR
                            (253) RelADPP
                                (254) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (255) RelADPP
                                (256) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (257) AND
                                    (258) RelADPP
                                    (259) RelADPP
                            (260) RelADPP
            (261) RelADPP
                (262) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (263) OR
                    (264) RelADPP
                        (265) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (266) OR
                            (267) RelADPP
                            (268) RelADPP
                                (269) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (270) RelADPP
                                (271) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (272) AND
                                    (273) RelADPP
                                    (274) RelADPP
                    (275) RelADPP
                        (276) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (277) OR
                            (278) RelADPP
                            (279) RelADPP
                    (280) RelADPP
                        (281) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (282) OR
                            (283) RelADPP
                                (284) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (285) RelADPP
                                (286) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (287) AND
                                    (288) RelADPP
                                    (289) RelADPP
                            (290) RelADPP
    (291) RelADPP
        (292) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (293) OR
            (294) RelADPP
                (295) RelADPDerelatifying2Proof [SOUND, 2 ms]
                (296) OR
                    (297) RelADPP
                        (298) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (299) OR
                            (300) RelADPP
                                (301) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (302) RelADPP
                                (303) RelADPCleverAfsProof [SOUND, 27 ms]
                                (304) QDP
                            (305) RelADPP
                                (306) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (307) RelADPP
                                (308) RelADPCleverAfsProof [SOUND, 46 ms]
                                (309) QDP
                                (310) MRRProof [EQUIVALENT, 5 ms]
                                (311) QDP
                    (312) RelADPP
                        (313) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (314) OR
                            (315) RelADPP
                                (316) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (317) RelADPP
                                (318) RelADPCleverAfsProof [SOUND, 39 ms]
                                (319) QDP
                                (320) MRRProof [EQUIVALENT, 6 ms]
                                (321) QDP
                            (322) RelADPP
                                (323) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (324) RelADPP
                                (325) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (326) AND
                                    (327) RelADPP
                                        (328) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (329) QDP
                                    (330) RelADPP
                                        (331) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (332) QDP
                    (333) RelADPP
                        (334) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (335) OR
                            (336) RelADPP
                                (337) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (338) RelADPP
                                (339) RelADPCleverAfsProof [SOUND, 7 ms]
                                (340) QDP
                            (341) RelADPP
                                (342) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (343) RelADPP
                                (344) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (345) AND
                                    (346) RelADPP
                                        (347) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (348) QDP
                                    (349) RelADPP
                                        (350) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (351) QDP
            (352) RelADPP
                (353) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (354) OR
                    (355) RelADPP
                        (356) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (357) OR
                            (358) RelADPP
                                (359) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (360) RelADPP
                                (361) RelADPCleverAfsProof [SOUND, 10 ms]
                                (362) QDP
                                (363) MRRProof [EQUIVALENT, 5 ms]
                                (364) QDP
                            (365) RelADPP
                                (366) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (367) RelADPP
                                (368) RelADPCleverAfsProof [SOUND, 20 ms]
                                (369) QDP
                                (370) MRRProof [EQUIVALENT, 7 ms]
                                (371) QDP
                    (372) RelADPP
                        (373) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (374) OR
                            (375) RelADPP
                                (376) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (377) RelADPP
                                (378) RelADPCleverAfsProof [SOUND, 8 ms]
                                (379) QDP
                            (380) RelADPP
                                (381) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (382) RelADPP
                                (383) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (384) AND
                                    (385) RelADPP
                                        (386) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (387) QDP
                                    (388) RelADPP
                                        (389) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (390) QDP
                    (391) RelADPP
                        (392) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (393) OR
                            (394) RelADPP
                                (395) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (396) RelADPP
                                (397) RelADPCleverAfsProof [SOUND, 18 ms]
                                (398) QDP
                            (399) RelADPP
                                (400) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (401) RelADPP
                                (402) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (403) AND
                                    (404) RelADPP
                                        (405) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (406) QDP
                                    (407) RelADPP
                                        (408) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (409) QDP
            (410) RelADPP
                (411) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (412) OR
                    (413) RelADPP
                        (414) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (415) OR
                            (416) RelADPP
                                (417) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (418) RelADPP
                                (419) RelADPCleverAfsProof [SOUND, 8 ms]
                                (420) QDP
                            (421) RelADPP
                                (422) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (423) RelADPP
                                (424) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (425) AND
                                    (426) RelADPP
                                        (427) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (428) QDP
                                    (429) RelADPP
                                        (430) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (431) QDP
                    (432) RelADPP
                        (433) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (434) OR
                            (435) RelADPP
                                (436) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (437) RelADPP
                                (438) RelADPCleverAfsProof [SOUND, 11 ms]
                                (439) QDP
                            (440) RelADPP
                                (441) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (442) RelADPP
                                (443) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (444) AND
                                    (445) RelADPP
                                        (446) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (447) QDP
                                    (448) RelADPP
                                        (449) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (450) QDP
                    (451) RelADPP
                        (452) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (453) RelADPP
                        (454) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (455) AND
                            (456) RelADPP
                                (457) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (458) QDP
                                (459) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (460) YES
                            (461) RelADPP
                                (462) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (463) QDP
                                (464) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (465) YES
            (466) RelADPP
                (467) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (468) OR
                    (469) RelADPP
                        (470) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (471) OR
                            (472) RelADPP
                                (473) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (474) RelADPP
                                (475) RelADPCleverAfsProof [SOUND, 9 ms]
                                (476) QDP
                            (477) RelADPP
                                (478) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (479) RelADPP
                                (480) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (481) AND
                                    (482) RelADPP
                                        (483) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (484) QDP
                                    (485) RelADPP
                                        (486) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (487) QDP
                    (488) RelADPP
                        (489) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (490) OR
                            (491) RelADPP
                                (492) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (493) RelADPP
                                (494) RelADPCleverAfsProof [SOUND, 21 ms]
                                (495) QDP
                                (496) MRRProof [EQUIVALENT, 5 ms]
                                (497) QDP
                                (498) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (499) AND
                                    (500) QDP
                                    (501) QDP
                            (502) RelADPP
                                (503) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (504) RelADPP
                                (505) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (506) AND
                                    (507) RelADPP
                                        (508) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (509) QDP
                                        (510) RFCMatchBoundsDPProof [EQUIVALENT, 1 ms]
                                        (511) YES
                                    (512) RelADPP
                                        (513) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (514) QDP
                                        (515) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                        (516) YES
                    (517) RelADPP
                        (518) RelADPReductionPairProof [EQUIVALENT, 11 ms]
                        (519) RelADPP
                        (520) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (521) AND
                            (522) RelADPP
                                (523) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (524) QDP
                                (525) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (526) YES
                            (527) RelADPP
                                (528) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (529) QDP
                                (530) RFCMatchBoundsDPProof [EQUIVALENT, 1 ms]
                                (531) YES
    (532) RelADPP
        (533) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (534) OR
            (535) RelADPP
                (536) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (537) OR
                    (538) RelADPP
                        (539) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (540) OR
                            (541) RelADPP
                                (542) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (543) RelADPP
                            (544) RelADPP
                                (545) RelADPReductionPairProof [EQUIVALENT, 15 ms]
                                (546) RelADPP
                                (547) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (548) AND
                                    (549) RelADPP
                                    (550) RelADPP
                    (551) RelADPP
                        (552) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (553) OR
                            (554) RelADPP
                                (555) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (556) RelADPP
                            (557) RelADPP
                                (558) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (559) RelADPP
                                (560) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (561) AND
                                    (562) RelADPP
                                    (563) RelADPP
                    (564) RelADPP
                        (565) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                        (566) RelADPP
                        (567) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (568) AND
                            (569) RelADPP
                                (570) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (571) QDP
                                (572) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (573) YES
                            (574) RelADPP
                                (575) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (576) QDP
                                (577) RFCMatchBoundsDPProof [EQUIVALENT, 1 ms]
                                (578) YES
            (579) RelADPP
                (580) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (581) OR
                    (582) RelADPP
                        (583) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (584) OR
                            (585) RelADPP
                                (586) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (587) RelADPP
                                (588) RelADPCleverAfsProof [SOUND, 8 ms]
                                (589) QDP
                            (590) RelADPP
                                (591) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (592) RelADPP
                                (593) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (594) AND
                                    (595) RelADPP
                                        (596) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (597) QDP
                                    (598) RelADPP
                                        (599) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (600) QDP
                    (601) RelADPP
                        (602) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (603) OR
                            (604) RelADPP
                                (605) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (606) RelADPP
                                (607) RelADPCleverAfsProof [SOUND, 9 ms]
                                (608) QDP
                            (609) RelADPP
                                (610) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (611) RelADPP
                                (612) RelADPCleverAfsProof [SOUND, 12 ms]
                                (613) QDP
                    (614) RelADPP
                        (615) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (616) OR
                            (617) RelADPP
                                (618) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (619) RelADPP
                                (620) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (621) AND
                                    (622) RelADPP
                                        (623) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (624) QDP
                                    (625) RelADPP
                                        (626) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (627) QDP
                                        (628) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                        (629) YES
                            (630) RelADPP
                                (631) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (632) RelADPP
                                (633) RelADPCleverAfsProof [SOUND, 9 ms]
                                (634) QDP
            (635) RelADPP
                (636) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (637) OR
                    (638) RelADPP
                        (639) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (640) OR
                            (641) RelADPP
                                (642) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (643) RelADPP
                            (644) RelADPP
                                (645) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (646) RelADPP
                                (647) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (648) AND
                                    (649) RelADPP
                                        (650) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (651) QDP
                                    (652) RelADPP
                                        (653) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (654) QDP
                    (655) RelADPP
                        (656) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (657) OR
                            (658) RelADPP
                                (659) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (660) RelADPP
                            (661) RelADPP
                                (662) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (663) RelADPP
                    (664) RelADPP
                        (665) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (666) OR
                            (667) RelADPP
                                (668) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                (669) RelADPP
                                (670) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (671) AND
                                    (672) RelADPP
                                    (673) RelADPP
                            (674) RelADPP
                                (675) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (676) RelADPP
            (677) RelADPP
                (678) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (679) OR
                    (680) RelADPP
                        (681) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                        (682) RelADPP
                        (683) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (684) AND
                            (685) RelADPP
                                (686) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (687) QDP
                                (688) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (689) YES
                            (690) RelADPP
                                (691) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (692) QDP
                                (693) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (694) YES
                    (695) RelADPP
                        (696) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (697) OR
                            (698) RelADPP
                                (699) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                (700) RelADPP
                                (701) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (702) AND
                                    (703) RelADPP
                                    (704) RelADPP
                            (705) RelADPP
                                (706) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (707) RelADPP
                    (708) RelADPP
                        (709) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (710) OR
                            (711) RelADPP
                                (712) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (713) RelADPP
                                (714) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (715) AND
                                    (716) RelADPP
                                    (717) RelADPP
                            (718) RelADPP
                                (719) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (720) RelADPP
    (721) RelADPP
        (722) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (723) OR
            (724) RelADPP
                (725) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (726) OR
                    (727) RelADPP
                        (728) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (729) OR
                            (730) RelADPP
                                (731) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (732) RelADPP
                            (733) RelADPP
                                (734) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (735) RelADPP
                    (736) RelADPP
                        (737) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (738) OR
                            (739) RelADPP
                                (740) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (741) RelADPP
                            (742) RelADPP
                                (743) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (744) RelADPP
                                (745) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (746) AND
                                    (747) RelADPP
                                    (748) RelADPP
                    (749) RelADPP
                        (750) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (751) OR
                            (752) RelADPP
                                (753) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (754) RelADPP
                            (755) RelADPP
                                (756) RelADPReductionPairProof [EQUIVALENT, 15 ms]
                                (757) RelADPP
                                (758) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (759) AND
                                    (760) RelADPP
                                    (761) RelADPP
            (762) RelADPP
                (763) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (764) OR
                    (765) RelADPP
                        (766) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (767) OR
                            (768) RelADPP
                                (769) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (770) RelADPP
                            (771) RelADPP
                                (772) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (773) RelADPP
                    (774) RelADPP
                        (775) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (776) OR
                            (777) RelADPP
                                (778) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (779) RelADPP
                            (780) RelADPP
                                (781) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (782) RelADPP
                    (783) RelADPP
                        (784) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (785) OR
                            (786) RelADPP
                                (787) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (788) RelADPP
                            (789) RelADPP
                                (790) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (791) RelADPP
            (792) RelADPP
                (793) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (794) OR
                    (795) RelADPP
                        (796) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (797) OR
                            (798) RelADPP
                                (799) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (800) RelADPP
                                (801) RelADPCleverAfsProof [SOUND, 38 ms]
                                (802) QDP
                            (803) RelADPP
                                (804) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (805) RelADPP
                                (806) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (807) AND
                                    (808) RelADPP
                                        (809) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (810) QDP
                                    (811) RelADPP
                                        (812) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (813) QDP
                    (814) RelADPP
                        (815) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (816) OR
                            (817) RelADPP
                                (818) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (819) RelADPP
                                (820) RelADPCleverAfsProof [SOUND, 13 ms]
                                (821) QDP
                            (822) RelADPP
                                (823) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (824) RelADPP
                                (825) RelADPCleverAfsProof [SOUND, 8 ms]
                                (826) QDP
                    (827) RelADPP
                        (828) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (829) OR
                            (830) RelADPP
                                (831) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (832) RelADPP
                                (833) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (834) AND
                                    (835) RelADPP
                                        (836) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (837) QDP
                                    (838) RelADPP
                                        (839) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (840) QDP
                            (841) RelADPP
                                (842) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (843) RelADPP
                                (844) RelADPCleverAfsProof [SOUND, 10 ms]
                                (845) QDP
                                (846) MRRProof [EQUIVALENT, 6 ms]
                                (847) QDP
                                (848) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (849) AND
                                    (850) QDP
                                    (851) QDP
            (852) RelADPP
                (853) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (854) OR
                    (855) RelADPP
                        (856) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (857) OR
                            (858) RelADPP
                                (859) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (860) RelADPP
                            (861) RelADPP
                                (862) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (863) RelADPP
                                (864) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (865) AND
                                    (866) RelADPP
                                        (867) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (868) QDP
                                    (869) RelADPP
                                        (870) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (871) QDP
                    (872) RelADPP
                        (873) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (874) OR
                            (875) RelADPP
                                (876) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (877) RelADPP
                            (878) RelADPP
                                (879) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (880) RelADPP
                    (881) RelADPP
                        (882) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (883) OR
                            (884) RelADPP
                                (885) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (886) RelADPP
                                (887) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (888) AND
                                    (889) RelADPP
                                        (890) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (891) QDP
                                    (892) RelADPP
                                        (893) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (894) QDP
                            (895) RelADPP
                                (896) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (897) RelADPP


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   c(c(a(x1))) -> b(b(c(x1)))
   a(b(c(x1))) -> a(b(a(x1)))

The relative TRS consists of the following S rules:

   c(b(a(x1))) -> c(c(b(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(c(a(x1))) -> b(b(C(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))

and relative ADPs:

   c(b(a(x1))) -> C(C(b(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> A(C(a(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))


----------------------------------------

(3) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(4)
Complex Obligation (OR)

----------------------------------------

(5)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(6) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(7)
Complex Obligation (OR)

----------------------------------------

(8)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(9) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(10)
Complex Obligation (OR)

----------------------------------------

(11)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(12) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(13)
Complex Obligation (OR)

----------------------------------------

(14)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(15) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(16)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(17)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(18) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(19)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(20) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(21)
Complex Obligation (AND)

----------------------------------------

(22)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(23)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(24)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(25) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(26)
Complex Obligation (OR)

----------------------------------------

(27)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(28) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(29)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(30)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(31) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(32)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(33) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(34)
Complex Obligation (AND)

----------------------------------------

(35)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(36)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(37)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(38) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(39)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(40) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(41)
Complex Obligation (AND)

----------------------------------------

(42)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(43) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(45)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(46) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(47)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(48)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(49) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(50)
Complex Obligation (OR)

----------------------------------------

(51)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(52) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(53)
Complex Obligation (OR)

----------------------------------------

(54)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(55) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(56)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(57)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(58) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(59)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(60) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(61)
Complex Obligation (AND)

----------------------------------------

(62)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(63)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(64)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(65) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(66)
Complex Obligation (OR)

----------------------------------------

(67)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(68) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(69)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(70)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(71) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(72)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(73)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(74) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(75)
Complex Obligation (OR)

----------------------------------------

(76)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(77) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(78)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(79) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(80)
Complex Obligation (AND)

----------------------------------------

(81)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(82)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(83)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(84) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(85)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(86)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(87) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(88)
Complex Obligation (OR)

----------------------------------------

(89)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(90) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(91)
Complex Obligation (OR)

----------------------------------------

(92)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(93) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(94)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(95)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(96) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(97)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(98) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(99)
Complex Obligation (AND)

----------------------------------------

(100)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(101)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(102)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(103) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(104)
Complex Obligation (OR)

----------------------------------------

(105)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(106) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(107)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(108)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(109) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(110)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(111)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(112) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(113)
Complex Obligation (OR)

----------------------------------------

(114)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(115) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(116)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(117) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(118)
Complex Obligation (AND)

----------------------------------------

(119)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(120)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(121)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(122)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(123) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(124)
Complex Obligation (OR)

----------------------------------------

(125)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(126) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(127)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(128) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(129)
Complex Obligation (AND)

----------------------------------------

(130)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(131) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(132)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(133) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 3. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))
   C(b(a(x1))) -> C(c(b(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
20669, 20670, 20671, 20672, 20673, 20674, 20675, 20676, 20677, 20678, 20687, 20688, 20689, 20690, 20691, 20692, 20693, 20694, 20697, 20698, 20705, 20706, 20707, 20708, 20709, 20710

Node 20669 is start node and node 20670 is final node.

Those nodes are connected through the following edges:

* 20669 to 20671 labelled c_1(0), C_1(0)* 20669 to 20673 labelled a_1(0)* 20669 to 20675 labelled b_1(0)* 20669 to 20677 labelled b_1(0), a_1(0)* 20669 to 20697 labelled b_1(1)* 20670 to 20670 labelled #_1(0)* 20671 to 20672 labelled c_1(0)* 20671 to 20691 labelled c_1(1)* 20671 to 20705 labelled b_1(2)* 20672 to 20670 labelled b_1(0)* 20673 to 20674 labelled b_1(0)* 20674 to 20670 labelled a_1(0)* 20674 to 20687 labelled a_1(1)* 20674 to 20689 labelled a_1(1)* 20675 to 20676 labelled b_1(0)* 20676 to 20670 labelled b_1(0), c_1(0)* 20676 to 20691 labelled c_1(1)* 20676 to 20693 labelled b_1(1)* 20676 to 20689 labelled b_1(1)* 20676 to 20705 labelled b_1(2)* 20677 to 20678 labelled c_1(0)* 20678 to 20670 labelled a_1(0)* 20678 to 20687 labelled a_1(1)* 20678 to 20689 labelled a_1(1)* 20687 to 20688 labelled b_1(1)* 20688 to 20670 labelled a_1(1)* 20688 to 20687 labelled a_1(1)* 20688 to 20689 labelled a_1(1)* 20689 to 20690 labelled c_1(1)* 20690 to 20670 labelled a_1(1)* 20690 to 20687 labelled a_1(1)* 20690 to 20689 labelled a_1(1)* 20691 to 20692 labelled c_1(1)* 20691 to 20691 labelled c_1(1)* 20691 to 20705 labelled b_1(2)* 20692 to 20670 labelled b_1(1)* 20693 to 20694 labelled b_1(1)* 20694 to 20670 labelled b_1(1), c_1(1)* 20694 to 20691 labelled c_1(1)* 20694 to 20693 labelled b_1(1)* 20694 to 20689 labelled b_1(1)* 20694 to 20705 labelled b_1(2)* 20697 to 20698 labelled c_1(1)* 20698 to 20692 labelled a_1(1)* 20698 to 20691 labelled a_1(1)* 20698 to 20687 labelled a_1(1)* 20698 to 20689 labelled a_1(1)* 20698 to 20707 labelled a_1(2)* 20705 to 20706 labelled c_1(2)* 20706 to 20692 labelled a_1(2)* 20706 to 20691 labelled a_1(2)* 20706 to 20687 labelled a_1(1)* 20706 to 20689 labelled a_1(1)* 20706 to 20709 labelled a_1(3)* 20707 to 20708 labelled b_1(2)* 20708 to 20706 labelled a_1(2)* 20709 to 20710 labelled b_1(3)* 20710 to 20706 labelled a_1(3)


----------------------------------------

(134)
YES

----------------------------------------

(135)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(136) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(137)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(138)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(139) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(140)
Complex Obligation (OR)

----------------------------------------

(141)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(142) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(143)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(144) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(145)
Complex Obligation (AND)

----------------------------------------

(146)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(147)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(148)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(149) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(150)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(151)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(152) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(153)
Complex Obligation (OR)

----------------------------------------

(154)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(155) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(156)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(157) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(158)
Complex Obligation (AND)

----------------------------------------

(159)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(160)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(161)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(162) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(163)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(164)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(165) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(166)
Complex Obligation (OR)

----------------------------------------

(167)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(168) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(169)
Complex Obligation (OR)

----------------------------------------

(170)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(171) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(172)
Complex Obligation (OR)

----------------------------------------

(173)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(174) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(175)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(176)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(177) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(178)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(179)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(180) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(181)
Complex Obligation (OR)

----------------------------------------

(182)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(183) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(184)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(185)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(186) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(187)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(188) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(189)
Complex Obligation (AND)

----------------------------------------

(190)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(191)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(192)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(193) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(194)
Complex Obligation (OR)

----------------------------------------

(195)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(196) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(197)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(198)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(199) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(200)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(201) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(202)
Complex Obligation (AND)

----------------------------------------

(203)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(204)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(205)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(206) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(207)
Complex Obligation (OR)

----------------------------------------

(208)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(209) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(210)
Complex Obligation (OR)

----------------------------------------

(211)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(212) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(213)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(214)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(215)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(216) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(217)
Complex Obligation (OR)

----------------------------------------

(218)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(219) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(220)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(221)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(222)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(223) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(224)
Complex Obligation (OR)

----------------------------------------

(225)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(226) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(227)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(228)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(229)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(230) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(231)
Complex Obligation (OR)

----------------------------------------

(232)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(233) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(234)
Complex Obligation (OR)

----------------------------------------

(235)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(236)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(237) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(238)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(239) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(240)
Complex Obligation (AND)

----------------------------------------

(241)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(242)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(243)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(244) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(245)
Complex Obligation (OR)

----------------------------------------

(246)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(247) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(248)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(249)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(250)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(251) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(252)
Complex Obligation (OR)

----------------------------------------

(253)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(254) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(255)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(256) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(257)
Complex Obligation (AND)

----------------------------------------

(258)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(259)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(260)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(261)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(262) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(263)
Complex Obligation (OR)

----------------------------------------

(264)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(265) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(266)
Complex Obligation (OR)

----------------------------------------

(267)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(268)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(269) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(270)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(271) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(272)
Complex Obligation (AND)

----------------------------------------

(273)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(274)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(275)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(276) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(277)
Complex Obligation (OR)

----------------------------------------

(278)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(279)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(280)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(281) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(282)
Complex Obligation (OR)

----------------------------------------

(283)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(284) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(285)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(286) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(287)
Complex Obligation (AND)

----------------------------------------

(288)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(289)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(290)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(291)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(292) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(293)
Complex Obligation (OR)

----------------------------------------

(294)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(295) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(296)
Complex Obligation (OR)

----------------------------------------

(297)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(298) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(299)
Complex Obligation (OR)

----------------------------------------

(300)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(301) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(302)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(303) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(304)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(305)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(306) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(307)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(308) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(309)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(310) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(311)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(312)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(313) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(314)
Complex Obligation (OR)

----------------------------------------

(315)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(316) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(317)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(318) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(319)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(320) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(321)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(322)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(323) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(324)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(325) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(326)
Complex Obligation (AND)

----------------------------------------

(327)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(328) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(329)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(330)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(331) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(332)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(333)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(334) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(335)
Complex Obligation (OR)

----------------------------------------

(336)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(337) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(338)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(339) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(340)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(341)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(342) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(343)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(344) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(345)
Complex Obligation (AND)

----------------------------------------

(346)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(347) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(348)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(349)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(350) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(351)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(352)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(353) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(354)
Complex Obligation (OR)

----------------------------------------

(355)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(356) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(357)
Complex Obligation (OR)

----------------------------------------

(358)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(359) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(360)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(361) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(362)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(363) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(364)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(365)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(366) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(367)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(368) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(369)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(370) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(371)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(372)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(373) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(374)
Complex Obligation (OR)

----------------------------------------

(375)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(376) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(377)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(378) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(379)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(380)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(381) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(382)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(383) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(384)
Complex Obligation (AND)

----------------------------------------

(385)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(386) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(387)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(388)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(389) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(390)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(391)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(392) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(393)
Complex Obligation (OR)

----------------------------------------

(394)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(395) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(396)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(397) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(398)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(399)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(400) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(401)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(402) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(403)
Complex Obligation (AND)

----------------------------------------

(404)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(405) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(406)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(407)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(408) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(409)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(410)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(411) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(412)
Complex Obligation (OR)

----------------------------------------

(413)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(414) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(415)
Complex Obligation (OR)

----------------------------------------

(416)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(417) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(418)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(419) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(420)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(421)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(422) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(423)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(424) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(425)
Complex Obligation (AND)

----------------------------------------

(426)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(427) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(428)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(429)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(430) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(431)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(432)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(433) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(434)
Complex Obligation (OR)

----------------------------------------

(435)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(436) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(437)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(438) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(439)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(440)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(441) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(442)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(443) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(444)
Complex Obligation (AND)

----------------------------------------

(445)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(446) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(447)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(448)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(449) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(450)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(451)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(452) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(453)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(454) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(455)
Complex Obligation (AND)

----------------------------------------

(456)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(457) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(458)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(459) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 3. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))
   C(b(a(x1))) -> C(c(b(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
20891, 20892, 20893, 20894, 20895, 20896, 20897, 20898, 20899, 20900, 20901, 20902, 20903, 20904, 20905, 20906, 20907, 20908, 20909, 20910, 20911, 20912, 20913, 20914, 20915, 20916

Node 20891 is start node and node 20892 is final node.

Those nodes are connected through the following edges:

* 20891 to 20893 labelled c_1(0), C_1(0)* 20891 to 20895 labelled a_1(0)* 20891 to 20897 labelled b_1(0)* 20891 to 20899 labelled b_1(0), a_1(0)* 20891 to 20909 labelled b_1(1)* 20892 to 20892 labelled #_1(0)* 20893 to 20894 labelled c_1(0)* 20893 to 20905 labelled c_1(1)* 20893 to 20911 labelled b_1(2)* 20894 to 20892 labelled b_1(0)* 20895 to 20896 labelled b_1(0)* 20896 to 20892 labelled a_1(0)* 20896 to 20901 labelled a_1(1)* 20896 to 20903 labelled a_1(1)* 20897 to 20898 labelled b_1(0)* 20898 to 20892 labelled b_1(0), c_1(0)* 20898 to 20905 labelled c_1(1)* 20898 to 20907 labelled b_1(1)* 20898 to 20903 labelled b_1(1)* 20898 to 20911 labelled b_1(2)* 20899 to 20900 labelled c_1(0)* 20900 to 20892 labelled a_1(0)* 20900 to 20901 labelled a_1(1)* 20900 to 20903 labelled a_1(1)* 20901 to 20902 labelled b_1(1)* 20902 to 20892 labelled a_1(1)* 20902 to 20901 labelled a_1(1)* 20902 to 20903 labelled a_1(1)* 20903 to 20904 labelled c_1(1)* 20904 to 20892 labelled a_1(1)* 20904 to 20901 labelled a_1(1)* 20904 to 20903 labelled a_1(1)* 20905 to 20906 labelled c_1(1)* 20905 to 20905 labelled c_1(1)* 20905 to 20911 labelled b_1(2)* 20906 to 20892 labelled b_1(1)* 20907 to 20908 labelled b_1(1)* 20908 to 20892 labelled b_1(1), c_1(1)* 20908 to 20905 labelled c_1(1)* 20908 to 20907 labelled b_1(1)* 20908 to 20903 labelled b_1(1)* 20908 to 20911 labelled b_1(2)* 20909 to 20910 labelled c_1(1)* 20910 to 20906 labelled a_1(1)* 20910 to 20905 labelled a_1(1)* 20910 to 20901 labelled a_1(1)* 20910 to 20903 labelled a_1(1)* 20910 to 20913 labelled a_1(2)* 20911 to 20912 labelled c_1(2)* 20912 to 20906 labelled a_1(2)* 20912 to 20905 labelled a_1(2)* 20912 to 20901 labelled a_1(1)* 20912 to 20903 labelled a_1(1)* 20912 to 20915 labelled a_1(3)* 20913 to 20914 labelled b_1(2)* 20914 to 20912 labelled a_1(2)* 20915 to 20916 labelled b_1(3)* 20916 to 20912 labelled a_1(3)


----------------------------------------

(460)
YES

----------------------------------------

(461)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(462) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(463)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(464) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 3. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))
   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
20917, 20918, 20919, 20920, 20921, 20922, 20923, 20924, 20925, 20926, 20927, 20928, 20929, 20930, 20931, 20932, 20933, 20934, 20935, 20936, 20937, 20938, 20939, 20940, 20941, 20942

Node 20917 is start node and node 20918 is final node.

Those nodes are connected through the following edges:

* 20917 to 20919 labelled c_1(0)* 20917 to 20921 labelled a_1(0), A_1(0)* 20917 to 20923 labelled b_1(0)* 20917 to 20925 labelled b_1(0), a_1(0), A_1(0)* 20917 to 20935 labelled b_1(1)* 20918 to 20918 labelled #_1(0)* 20919 to 20920 labelled c_1(0)* 20919 to 20931 labelled c_1(1)* 20919 to 20937 labelled b_1(2)* 20920 to 20918 labelled b_1(0)* 20921 to 20922 labelled b_1(0)* 20922 to 20918 labelled a_1(0)* 20922 to 20927 labelled a_1(1)* 20922 to 20929 labelled a_1(1)* 20923 to 20924 labelled b_1(0)* 20924 to 20918 labelled b_1(0), c_1(0)* 20924 to 20931 labelled c_1(1)* 20924 to 20933 labelled b_1(1)* 20924 to 20929 labelled b_1(1)* 20924 to 20937 labelled b_1(2)* 20925 to 20926 labelled c_1(0)* 20926 to 20918 labelled a_1(0)* 20926 to 20927 labelled a_1(1)* 20926 to 20929 labelled a_1(1)* 20927 to 20928 labelled b_1(1)* 20928 to 20918 labelled a_1(1)* 20928 to 20927 labelled a_1(1)* 20928 to 20929 labelled a_1(1)* 20929 to 20930 labelled c_1(1)* 20930 to 20918 labelled a_1(1)* 20930 to 20927 labelled a_1(1)* 20930 to 20929 labelled a_1(1)* 20931 to 20932 labelled c_1(1)* 20931 to 20931 labelled c_1(1)* 20931 to 20937 labelled b_1(2)* 20932 to 20918 labelled b_1(1)* 20933 to 20934 labelled b_1(1)* 20934 to 20918 labelled b_1(1), c_1(1)* 20934 to 20931 labelled c_1(1)* 20934 to 20933 labelled b_1(1)* 20934 to 20929 labelled b_1(1)* 20934 to 20937 labelled b_1(2)* 20935 to 20936 labelled c_1(1)* 20936 to 20932 labelled a_1(1)* 20936 to 20931 labelled a_1(1)* 20936 to 20927 labelled a_1(1)* 20936 to 20929 labelled a_1(1)* 20936 to 20939 labelled a_1(2)* 20937 to 20938 labelled c_1(2)* 20938 to 20932 labelled a_1(2)* 20938 to 20931 labelled a_1(2)* 20938 to 20927 labelled a_1(1)* 20938 to 20929 labelled a_1(1)* 20938 to 20941 labelled a_1(3)* 20939 to 20940 labelled b_1(2)* 20940 to 20938 labelled a_1(2)* 20941 to 20942 labelled b_1(3)* 20942 to 20938 labelled a_1(3)


----------------------------------------

(465)
YES

----------------------------------------

(466)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(467) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(468)
Complex Obligation (OR)

----------------------------------------

(469)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(470) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(471)
Complex Obligation (OR)

----------------------------------------

(472)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(473) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(474)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(475) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(476)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(477)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(478) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(479)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(480) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(481)
Complex Obligation (AND)

----------------------------------------

(482)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(483) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(484)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(485)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(486) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(487)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(488)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(489) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(490)
Complex Obligation (OR)

----------------------------------------

(491)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(492) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(493)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(494) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(495)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(496) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(497)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(498) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs.
----------------------------------------

(499)
Complex Obligation (AND)

----------------------------------------

(500)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(b0(a0(x1))) -> C0(c0(b0(x1)))

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(501)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(502)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(503) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(504)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(505) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(506)
Complex Obligation (AND)

----------------------------------------

(507)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(508) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(509)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(510) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 3. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))
   C(b(a(x1))) -> C(c(b(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
20943, 20944, 20945, 20946, 20947, 20948, 20949, 20950, 20951, 20952, 20953, 20954, 20955, 20956, 20957, 20958, 20959, 20960, 20961, 20962, 20963, 20964, 20965, 20966, 20967, 20968

Node 20943 is start node and node 20944 is final node.

Those nodes are connected through the following edges:

* 20943 to 20945 labelled c_1(0), C_1(0)* 20943 to 20947 labelled a_1(0)* 20943 to 20949 labelled b_1(0)* 20943 to 20951 labelled b_1(0), a_1(0)* 20943 to 20961 labelled b_1(1)* 20944 to 20944 labelled #_1(0)* 20945 to 20946 labelled c_1(0)* 20945 to 20957 labelled c_1(1)* 20945 to 20963 labelled b_1(2)* 20946 to 20944 labelled b_1(0)* 20947 to 20948 labelled b_1(0)* 20948 to 20944 labelled a_1(0)* 20948 to 20953 labelled a_1(1)* 20948 to 20955 labelled a_1(1)* 20949 to 20950 labelled b_1(0)* 20950 to 20944 labelled b_1(0), c_1(0)* 20950 to 20957 labelled c_1(1)* 20950 to 20959 labelled b_1(1)* 20950 to 20955 labelled b_1(1)* 20950 to 20963 labelled b_1(2)* 20951 to 20952 labelled c_1(0)* 20952 to 20944 labelled a_1(0)* 20952 to 20953 labelled a_1(1)* 20952 to 20955 labelled a_1(1)* 20953 to 20954 labelled b_1(1)* 20954 to 20944 labelled a_1(1)* 20954 to 20953 labelled a_1(1)* 20954 to 20955 labelled a_1(1)* 20955 to 20956 labelled c_1(1)* 20956 to 20944 labelled a_1(1)* 20956 to 20953 labelled a_1(1)* 20956 to 20955 labelled a_1(1)* 20957 to 20958 labelled c_1(1)* 20957 to 20957 labelled c_1(1)* 20957 to 20963 labelled b_1(2)* 20958 to 20944 labelled b_1(1)* 20959 to 20960 labelled b_1(1)* 20960 to 20944 labelled b_1(1), c_1(1)* 20960 to 20957 labelled c_1(1)* 20960 to 20959 labelled b_1(1)* 20960 to 20955 labelled b_1(1)* 20960 to 20963 labelled b_1(2)* 20961 to 20962 labelled c_1(1)* 20962 to 20958 labelled a_1(1)* 20962 to 20957 labelled a_1(1)* 20962 to 20953 labelled a_1(1)* 20962 to 20955 labelled a_1(1)* 20962 to 20965 labelled a_1(2)* 20963 to 20964 labelled c_1(2)* 20964 to 20958 labelled a_1(2)* 20964 to 20957 labelled a_1(2)* 20964 to 20953 labelled a_1(1)* 20964 to 20955 labelled a_1(1)* 20964 to 20967 labelled a_1(3)* 20965 to 20966 labelled b_1(2)* 20966 to 20964 labelled a_1(2)* 20967 to 20968 labelled b_1(3)* 20968 to 20964 labelled a_1(3)


----------------------------------------

(511)
YES

----------------------------------------

(512)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(513) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(514)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(515) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 3. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))
   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
20969, 20970, 20971, 20972, 20973, 20974, 20975, 20976, 20977, 20978, 20979, 20980, 20981, 20982, 20983, 20984, 20985, 20986, 20987, 20988, 20989, 20990, 20991, 20992, 20993, 20994

Node 20969 is start node and node 20970 is final node.

Those nodes are connected through the following edges:

* 20969 to 20971 labelled c_1(0)* 20969 to 20973 labelled a_1(0), A_1(0)* 20969 to 20975 labelled b_1(0)* 20969 to 20977 labelled b_1(0), a_1(0), A_1(0)* 20969 to 20987 labelled b_1(1)* 20970 to 20970 labelled #_1(0)* 20971 to 20972 labelled c_1(0)* 20971 to 20983 labelled c_1(1)* 20971 to 20989 labelled b_1(2)* 20972 to 20970 labelled b_1(0)* 20973 to 20974 labelled b_1(0)* 20974 to 20970 labelled a_1(0)* 20974 to 20979 labelled a_1(1)* 20974 to 20981 labelled a_1(1)* 20975 to 20976 labelled b_1(0)* 20976 to 20970 labelled b_1(0), c_1(0)* 20976 to 20983 labelled c_1(1)* 20976 to 20985 labelled b_1(1)* 20976 to 20981 labelled b_1(1)* 20976 to 20989 labelled b_1(2)* 20977 to 20978 labelled c_1(0)* 20978 to 20970 labelled a_1(0)* 20978 to 20979 labelled a_1(1)* 20978 to 20981 labelled a_1(1)* 20979 to 20980 labelled b_1(1)* 20980 to 20970 labelled a_1(1)* 20980 to 20979 labelled a_1(1)* 20980 to 20981 labelled a_1(1)* 20981 to 20982 labelled c_1(1)* 20982 to 20970 labelled a_1(1)* 20982 to 20979 labelled a_1(1)* 20982 to 20981 labelled a_1(1)* 20983 to 20984 labelled c_1(1)* 20983 to 20983 labelled c_1(1)* 20983 to 20989 labelled b_1(2)* 20984 to 20970 labelled b_1(1)* 20985 to 20986 labelled b_1(1)* 20986 to 20970 labelled b_1(1), c_1(1)* 20986 to 20983 labelled c_1(1)* 20986 to 20985 labelled b_1(1)* 20986 to 20981 labelled b_1(1)* 20986 to 20989 labelled b_1(2)* 20987 to 20988 labelled c_1(1)* 20988 to 20984 labelled a_1(1)* 20988 to 20983 labelled a_1(1)* 20988 to 20979 labelled a_1(1)* 20988 to 20981 labelled a_1(1)* 20988 to 20991 labelled a_1(2)* 20989 to 20990 labelled c_1(2)* 20990 to 20984 labelled a_1(2)* 20990 to 20983 labelled a_1(2)* 20990 to 20979 labelled a_1(1)* 20990 to 20981 labelled a_1(1)* 20990 to 20993 labelled a_1(3)* 20991 to 20992 labelled b_1(2)* 20992 to 20990 labelled a_1(2)* 20993 to 20994 labelled b_1(3)* 20994 to 20990 labelled a_1(3)


----------------------------------------

(516)
YES

----------------------------------------

(517)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(518) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(b(a(x1))) -> c(C(b(x1)))
   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(C(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(519)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(520) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(521)
Complex Obligation (AND)

----------------------------------------

(522)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(523) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(524)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(525) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 3. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))
   C(b(a(x1))) -> C(c(b(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
20995, 20996, 20997, 20998, 20999, 21000, 21001, 21002, 21003, 21004, 21005, 21006, 21007, 21008, 21009, 21010, 21011, 21012, 21013, 21014, 21015, 21016, 21017, 21018, 21019, 21020

Node 20995 is start node and node 20996 is final node.

Those nodes are connected through the following edges:

* 20995 to 20997 labelled c_1(0), C_1(0)* 20995 to 20999 labelled a_1(0)* 20995 to 21001 labelled b_1(0)* 20995 to 21003 labelled b_1(0), a_1(0)* 20995 to 21013 labelled b_1(1)* 20996 to 20996 labelled #_1(0)* 20997 to 20998 labelled c_1(0)* 20997 to 21009 labelled c_1(1)* 20997 to 21015 labelled b_1(2)* 20998 to 20996 labelled b_1(0)* 20999 to 21000 labelled b_1(0)* 21000 to 20996 labelled a_1(0)* 21000 to 21005 labelled a_1(1)* 21000 to 21007 labelled a_1(1)* 21001 to 21002 labelled b_1(0)* 21002 to 20996 labelled b_1(0), c_1(0)* 21002 to 21009 labelled c_1(1)* 21002 to 21011 labelled b_1(1)* 21002 to 21007 labelled b_1(1)* 21002 to 21015 labelled b_1(2)* 21003 to 21004 labelled c_1(0)* 21004 to 20996 labelled a_1(0)* 21004 to 21005 labelled a_1(1)* 21004 to 21007 labelled a_1(1)* 21005 to 21006 labelled b_1(1)* 21006 to 20996 labelled a_1(1)* 21006 to 21005 labelled a_1(1)* 21006 to 21007 labelled a_1(1)* 21007 to 21008 labelled c_1(1)* 21008 to 20996 labelled a_1(1)* 21008 to 21005 labelled a_1(1)* 21008 to 21007 labelled a_1(1)* 21009 to 21010 labelled c_1(1)* 21009 to 21009 labelled c_1(1)* 21009 to 21015 labelled b_1(2)* 21010 to 20996 labelled b_1(1)* 21011 to 21012 labelled b_1(1)* 21012 to 20996 labelled b_1(1), c_1(1)* 21012 to 21009 labelled c_1(1)* 21012 to 21011 labelled b_1(1)* 21012 to 21007 labelled b_1(1)* 21012 to 21015 labelled b_1(2)* 21013 to 21014 labelled c_1(1)* 21014 to 21010 labelled a_1(1)* 21014 to 21009 labelled a_1(1)* 21014 to 21005 labelled a_1(1)* 21014 to 21007 labelled a_1(1)* 21014 to 21017 labelled a_1(2)* 21015 to 21016 labelled c_1(2)* 21016 to 21010 labelled a_1(2)* 21016 to 21009 labelled a_1(2)* 21016 to 21005 labelled a_1(1)* 21016 to 21007 labelled a_1(1)* 21016 to 21019 labelled a_1(3)* 21017 to 21018 labelled b_1(2)* 21018 to 21016 labelled a_1(2)* 21019 to 21020 labelled b_1(3)* 21020 to 21016 labelled a_1(3)


----------------------------------------

(526)
YES

----------------------------------------

(527)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(528) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(529)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(530) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 3. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))
   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
20667, 20668, 20679, 20680, 20681, 20682, 20683, 20684, 20685, 20686, 20695, 20696, 20699, 20700, 20701, 20702, 20703, 20704, 20711, 20712, 20713, 20714, 20715, 20716, 20717, 20718

Node 20667 is start node and node 20668 is final node.

Those nodes are connected through the following edges:

* 20667 to 20679 labelled c_1(0)* 20667 to 20681 labelled a_1(0), A_1(0)* 20667 to 20683 labelled b_1(0)* 20667 to 20685 labelled b_1(0), a_1(0), A_1(0)* 20667 to 20711 labelled b_1(1)* 20668 to 20668 labelled #_1(0)* 20679 to 20680 labelled c_1(0)* 20679 to 20701 labelled c_1(1)* 20679 to 20713 labelled b_1(2)* 20680 to 20668 labelled b_1(0)* 20681 to 20682 labelled b_1(0)* 20682 to 20668 labelled a_1(0)* 20682 to 20695 labelled a_1(1)* 20682 to 20699 labelled a_1(1)* 20683 to 20684 labelled b_1(0)* 20684 to 20668 labelled b_1(0), c_1(0)* 20684 to 20701 labelled c_1(1)* 20684 to 20703 labelled b_1(1)* 20684 to 20699 labelled b_1(1)* 20684 to 20713 labelled b_1(2)* 20685 to 20686 labelled c_1(0)* 20686 to 20668 labelled a_1(0)* 20686 to 20695 labelled a_1(1)* 20686 to 20699 labelled a_1(1)* 20695 to 20696 labelled b_1(1)* 20696 to 20668 labelled a_1(1)* 20696 to 20695 labelled a_1(1)* 20696 to 20699 labelled a_1(1)* 20699 to 20700 labelled c_1(1)* 20700 to 20668 labelled a_1(1)* 20700 to 20695 labelled a_1(1)* 20700 to 20699 labelled a_1(1)* 20701 to 20702 labelled c_1(1)* 20701 to 20701 labelled c_1(1)* 20701 to 20713 labelled b_1(2)* 20702 to 20668 labelled b_1(1)* 20703 to 20704 labelled b_1(1)* 20704 to 20668 labelled b_1(1), c_1(1)* 20704 to 20701 labelled c_1(1)* 20704 to 20703 labelled b_1(1)* 20704 to 20699 labelled b_1(1)* 20704 to 20713 labelled b_1(2)* 20711 to 20712 labelled c_1(1)* 20712 to 20702 labelled a_1(1)* 20712 to 20701 labelled a_1(1)* 20712 to 20695 labelled a_1(1)* 20712 to 20699 labelled a_1(1)* 20712 to 20715 labelled a_1(2)* 20713 to 20714 labelled c_1(2)* 20714 to 20702 labelled a_1(2)* 20714 to 20701 labelled a_1(2)* 20714 to 20695 labelled a_1(1)* 20714 to 20699 labelled a_1(1)* 20714 to 20717 labelled a_1(3)* 20715 to 20716 labelled b_1(2)* 20716 to 20714 labelled a_1(2)* 20717 to 20718 labelled b_1(3)* 20718 to 20714 labelled a_1(3)


----------------------------------------

(531)
YES

----------------------------------------

(532)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(533) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(534)
Complex Obligation (OR)

----------------------------------------

(535)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(536) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(537)
Complex Obligation (OR)

----------------------------------------

(538)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(539) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(540)
Complex Obligation (OR)

----------------------------------------

(541)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(542) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(543)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(544)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(545) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(546)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(547) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(548)
Complex Obligation (AND)

----------------------------------------

(549)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(550)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(551)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(552) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(553)
Complex Obligation (OR)

----------------------------------------

(554)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(555) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(556)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(557)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(558) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(559)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(560) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(561)
Complex Obligation (AND)

----------------------------------------

(562)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(563)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(564)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(565) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(566)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(567) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(568)
Complex Obligation (AND)

----------------------------------------

(569)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(570) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(571)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(572) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 3. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))
   C(b(a(x1))) -> C(c(b(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
21021, 21022, 21023, 21024, 21025, 21026, 21027, 21028, 21029, 21030, 21031, 21032, 21033, 21034, 21035, 21036, 21037, 21038, 21039, 21040, 21041, 21042, 21043, 21044, 21045, 21046

Node 21021 is start node and node 21022 is final node.

Those nodes are connected through the following edges:

* 21021 to 21023 labelled c_1(0), C_1(0)* 21021 to 21025 labelled a_1(0)* 21021 to 21027 labelled b_1(0)* 21021 to 21029 labelled b_1(0), a_1(0)* 21021 to 21039 labelled b_1(1)* 21022 to 21022 labelled #_1(0)* 21023 to 21024 labelled c_1(0)* 21023 to 21035 labelled c_1(1)* 21023 to 21041 labelled b_1(2)* 21024 to 21022 labelled b_1(0)* 21025 to 21026 labelled b_1(0)* 21026 to 21022 labelled a_1(0)* 21026 to 21031 labelled a_1(1)* 21026 to 21033 labelled a_1(1)* 21027 to 21028 labelled b_1(0)* 21028 to 21022 labelled b_1(0), c_1(0)* 21028 to 21035 labelled c_1(1)* 21028 to 21037 labelled b_1(1)* 21028 to 21033 labelled b_1(1)* 21028 to 21041 labelled b_1(2)* 21029 to 21030 labelled c_1(0)* 21030 to 21022 labelled a_1(0)* 21030 to 21031 labelled a_1(1)* 21030 to 21033 labelled a_1(1)* 21031 to 21032 labelled b_1(1)* 21032 to 21022 labelled a_1(1)* 21032 to 21031 labelled a_1(1)* 21032 to 21033 labelled a_1(1)* 21033 to 21034 labelled c_1(1)* 21034 to 21022 labelled a_1(1)* 21034 to 21031 labelled a_1(1)* 21034 to 21033 labelled a_1(1)* 21035 to 21036 labelled c_1(1)* 21035 to 21035 labelled c_1(1)* 21035 to 21041 labelled b_1(2)* 21036 to 21022 labelled b_1(1)* 21037 to 21038 labelled b_1(1)* 21038 to 21022 labelled b_1(1), c_1(1)* 21038 to 21035 labelled c_1(1)* 21038 to 21037 labelled b_1(1)* 21038 to 21033 labelled b_1(1)* 21038 to 21041 labelled b_1(2)* 21039 to 21040 labelled c_1(1)* 21040 to 21036 labelled a_1(1)* 21040 to 21035 labelled a_1(1)* 21040 to 21031 labelled a_1(1)* 21040 to 21033 labelled a_1(1)* 21040 to 21043 labelled a_1(2)* 21041 to 21042 labelled c_1(2)* 21042 to 21036 labelled a_1(2)* 21042 to 21035 labelled a_1(2)* 21042 to 21031 labelled a_1(1)* 21042 to 21033 labelled a_1(1)* 21042 to 21045 labelled a_1(3)* 21043 to 21044 labelled b_1(2)* 21044 to 21042 labelled a_1(2)* 21045 to 21046 labelled b_1(3)* 21046 to 21042 labelled a_1(3)


----------------------------------------

(573)
YES

----------------------------------------

(574)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(575) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(576)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(577) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 3. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))
   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
21047, 21048, 21049, 21050, 21051, 21052, 21053, 21054, 21055, 21056, 21057, 21058, 21059, 21060, 21061, 21062, 21063, 21064, 21065, 21066, 21067, 21068, 21652, 21653, 21662, 21666

Node 21047 is start node and node 21048 is final node.

Those nodes are connected through the following edges:

* 21047 to 21049 labelled c_1(0)* 21047 to 21051 labelled a_1(0), A_1(0)* 21047 to 21053 labelled b_1(0)* 21047 to 21055 labelled b_1(0), a_1(0), A_1(0)* 21047 to 21065 labelled b_1(1)* 21048 to 21048 labelled #_1(0)* 21049 to 21050 labelled c_1(0)* 21049 to 21061 labelled c_1(1)* 21049 to 21067 labelled b_1(2)* 21050 to 21048 labelled b_1(0)* 21051 to 21052 labelled b_1(0)* 21052 to 21048 labelled a_1(0)* 21052 to 21057 labelled a_1(1)* 21052 to 21059 labelled a_1(1)* 21053 to 21054 labelled b_1(0)* 21054 to 21048 labelled b_1(0), c_1(0)* 21054 to 21061 labelled c_1(1)* 21054 to 21063 labelled b_1(1)* 21054 to 21059 labelled b_1(1)* 21054 to 21067 labelled b_1(2)* 21055 to 21056 labelled c_1(0)* 21056 to 21048 labelled a_1(0)* 21056 to 21057 labelled a_1(1)* 21056 to 21059 labelled a_1(1)* 21057 to 21058 labelled b_1(1)* 21058 to 21048 labelled a_1(1)* 21058 to 21057 labelled a_1(1)* 21058 to 21059 labelled a_1(1)* 21059 to 21060 labelled c_1(1)* 21060 to 21048 labelled a_1(1)* 21060 to 21057 labelled a_1(1)* 21060 to 21059 labelled a_1(1)* 21061 to 21062 labelled c_1(1)* 21061 to 21061 labelled c_1(1)* 21061 to 21067 labelled b_1(2)* 21062 to 21048 labelled b_1(1)* 21063 to 21064 labelled b_1(1)* 21064 to 21048 labelled b_1(1), c_1(1)* 21064 to 21061 labelled c_1(1)* 21064 to 21063 labelled b_1(1)* 21064 to 21059 labelled b_1(1)* 21064 to 21067 labelled b_1(2)* 21065 to 21066 labelled c_1(1)* 21066 to 21062 labelled a_1(1)* 21066 to 21061 labelled a_1(1)* 21066 to 21057 labelled a_1(1)* 21066 to 21059 labelled a_1(1)* 21066 to 21652 labelled a_1(2)* 21067 to 21068 labelled c_1(2)* 21068 to 21062 labelled a_1(2)* 21068 to 21061 labelled a_1(2)* 21068 to 21057 labelled a_1(1)* 21068 to 21059 labelled a_1(1)* 21068 to 21662 labelled a_1(3)* 21652 to 21653 labelled b_1(2)* 21653 to 21068 labelled a_1(2)* 21662 to 21666 labelled b_1(3)* 21666 to 21068 labelled a_1(3)


----------------------------------------

(578)
YES

----------------------------------------

(579)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(580) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(581)
Complex Obligation (OR)

----------------------------------------

(582)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(583) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(584)
Complex Obligation (OR)

----------------------------------------

(585)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(586) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(587)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(588) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(589)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(590)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(591) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(592)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(593) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(594)
Complex Obligation (AND)

----------------------------------------

(595)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(596) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(597)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(598)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(599) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(600)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(601)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(602) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(603)
Complex Obligation (OR)

----------------------------------------

(604)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(605) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(606)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(607) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(608)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(609)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(610) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(611)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(612) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(613)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(614)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(615) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(616)
Complex Obligation (OR)

----------------------------------------

(617)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(618) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(619)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(620) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(621)
Complex Obligation (AND)

----------------------------------------

(622)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(623) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(624)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(625)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(626) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(627)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(628) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 3. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))
   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
21069, 21070, 21071, 21072, 21073, 21074, 21075, 21076, 21077, 21078, 21079, 21080, 21081, 21082, 21083, 21084, 21085, 21086, 21087, 21088, 21089, 21090, 21091, 21092, 21093, 21094

Node 21069 is start node and node 21070 is final node.

Those nodes are connected through the following edges:

* 21069 to 21071 labelled c_1(0)* 21069 to 21073 labelled a_1(0), A_1(0)* 21069 to 21075 labelled b_1(0)* 21069 to 21077 labelled b_1(0), a_1(0), A_1(0)* 21069 to 21087 labelled b_1(1)* 21070 to 21070 labelled #_1(0)* 21071 to 21072 labelled c_1(0)* 21071 to 21083 labelled c_1(1)* 21071 to 21089 labelled b_1(2)* 21072 to 21070 labelled b_1(0)* 21073 to 21074 labelled b_1(0)* 21074 to 21070 labelled a_1(0)* 21074 to 21079 labelled a_1(1)* 21074 to 21081 labelled a_1(1)* 21075 to 21076 labelled b_1(0)* 21076 to 21070 labelled b_1(0), c_1(0)* 21076 to 21083 labelled c_1(1)* 21076 to 21085 labelled b_1(1)* 21076 to 21081 labelled b_1(1)* 21076 to 21089 labelled b_1(2)* 21077 to 21078 labelled c_1(0)* 21078 to 21070 labelled a_1(0)* 21078 to 21079 labelled a_1(1)* 21078 to 21081 labelled a_1(1)* 21079 to 21080 labelled b_1(1)* 21080 to 21070 labelled a_1(1)* 21080 to 21079 labelled a_1(1)* 21080 to 21081 labelled a_1(1)* 21081 to 21082 labelled c_1(1)* 21082 to 21070 labelled a_1(1)* 21082 to 21079 labelled a_1(1)* 21082 to 21081 labelled a_1(1)* 21083 to 21084 labelled c_1(1)* 21083 to 21083 labelled c_1(1)* 21083 to 21089 labelled b_1(2)* 21084 to 21070 labelled b_1(1)* 21085 to 21086 labelled b_1(1)* 21086 to 21070 labelled b_1(1), c_1(1)* 21086 to 21083 labelled c_1(1)* 21086 to 21085 labelled b_1(1)* 21086 to 21081 labelled b_1(1)* 21086 to 21089 labelled b_1(2)* 21087 to 21088 labelled c_1(1)* 21088 to 21084 labelled a_1(1)* 21088 to 21083 labelled a_1(1)* 21088 to 21079 labelled a_1(1)* 21088 to 21081 labelled a_1(1)* 21088 to 21091 labelled a_1(2)* 21089 to 21090 labelled c_1(2)* 21090 to 21084 labelled a_1(2)* 21090 to 21083 labelled a_1(2)* 21090 to 21079 labelled a_1(1)* 21090 to 21081 labelled a_1(1)* 21090 to 21093 labelled a_1(3)* 21091 to 21092 labelled b_1(2)* 21092 to 21090 labelled a_1(2)* 21093 to 21094 labelled b_1(3)* 21094 to 21090 labelled a_1(3)


----------------------------------------

(629)
YES

----------------------------------------

(630)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(631) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(632)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(633) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(634)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(635)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(636) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(637)
Complex Obligation (OR)

----------------------------------------

(638)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(639) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(640)
Complex Obligation (OR)

----------------------------------------

(641)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(642) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(643)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(644)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(645) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(646)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(647) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(648)
Complex Obligation (AND)

----------------------------------------

(649)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(650) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(651)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(652)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(653) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(654)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(655)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(656) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(657)
Complex Obligation (OR)

----------------------------------------

(658)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(659) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(660)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(661)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(662) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(663)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(664)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(665) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(666)
Complex Obligation (OR)

----------------------------------------

(667)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(668) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(669)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(670) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(671)
Complex Obligation (AND)

----------------------------------------

(672)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(673)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(674)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(675) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(676)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(677)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(678) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(679)
Complex Obligation (OR)

----------------------------------------

(680)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(681) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(682)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(683) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(684)
Complex Obligation (AND)

----------------------------------------

(685)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(686) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(687)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(688) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 3. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))
   C(b(a(x1))) -> C(c(b(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
21106, 21107, 21108, 21109, 21110, 21111, 21112, 21113, 21114, 21115, 21116, 21117, 21118, 21119, 21120, 21121, 21122, 21123, 21124, 21125, 21126, 21127, 21128, 21129, 21130, 21131

Node 21106 is start node and node 21107 is final node.

Those nodes are connected through the following edges:

* 21106 to 21108 labelled c_1(0), C_1(0)* 21106 to 21110 labelled a_1(0)* 21106 to 21112 labelled b_1(0)* 21106 to 21114 labelled b_1(0), a_1(0)* 21106 to 21124 labelled b_1(1)* 21107 to 21107 labelled #_1(0)* 21108 to 21109 labelled c_1(0)* 21108 to 21120 labelled c_1(1)* 21108 to 21126 labelled b_1(2)* 21109 to 21107 labelled b_1(0)* 21110 to 21111 labelled b_1(0)* 21111 to 21107 labelled a_1(0)* 21111 to 21116 labelled a_1(1)* 21111 to 21118 labelled a_1(1)* 21112 to 21113 labelled b_1(0)* 21113 to 21107 labelled b_1(0), c_1(0)* 21113 to 21120 labelled c_1(1)* 21113 to 21122 labelled b_1(1)* 21113 to 21118 labelled b_1(1)* 21113 to 21126 labelled b_1(2)* 21114 to 21115 labelled c_1(0)* 21115 to 21107 labelled a_1(0)* 21115 to 21116 labelled a_1(1)* 21115 to 21118 labelled a_1(1)* 21116 to 21117 labelled b_1(1)* 21117 to 21107 labelled a_1(1)* 21117 to 21116 labelled a_1(1)* 21117 to 21118 labelled a_1(1)* 21118 to 21119 labelled c_1(1)* 21119 to 21107 labelled a_1(1)* 21119 to 21116 labelled a_1(1)* 21119 to 21118 labelled a_1(1)* 21120 to 21121 labelled c_1(1)* 21120 to 21120 labelled c_1(1)* 21120 to 21126 labelled b_1(2)* 21121 to 21107 labelled b_1(1)* 21122 to 21123 labelled b_1(1)* 21123 to 21107 labelled b_1(1), c_1(1)* 21123 to 21120 labelled c_1(1)* 21123 to 21122 labelled b_1(1)* 21123 to 21118 labelled b_1(1)* 21123 to 21126 labelled b_1(2)* 21124 to 21125 labelled c_1(1)* 21125 to 21121 labelled a_1(1)* 21125 to 21120 labelled a_1(1)* 21125 to 21116 labelled a_1(1)* 21125 to 21118 labelled a_1(1)* 21125 to 21128 labelled a_1(2)* 21126 to 21127 labelled c_1(2)* 21127 to 21121 labelled a_1(2)* 21127 to 21120 labelled a_1(2)* 21127 to 21116 labelled a_1(1)* 21127 to 21118 labelled a_1(1)* 21127 to 21130 labelled a_1(3)* 21128 to 21129 labelled b_1(2)* 21129 to 21127 labelled a_1(2)* 21130 to 21131 labelled b_1(3)* 21131 to 21127 labelled a_1(3)


----------------------------------------

(689)
YES

----------------------------------------

(690)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(691) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(692)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(693) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 3. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))
   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
21132, 21133, 21134, 21135, 21136, 21137, 21138, 21139, 21140, 21141, 21142, 21143, 21144, 21145, 21146, 21147, 21148, 21149, 21150, 21151, 21152, 21153, 21154, 21155, 21156, 21157

Node 21132 is start node and node 21133 is final node.

Those nodes are connected through the following edges:

* 21132 to 21134 labelled c_1(0)* 21132 to 21136 labelled a_1(0), A_1(0)* 21132 to 21138 labelled b_1(0)* 21132 to 21140 labelled b_1(0), a_1(0), A_1(0)* 21132 to 21150 labelled b_1(1)* 21133 to 21133 labelled #_1(0)* 21134 to 21135 labelled c_1(0)* 21134 to 21146 labelled c_1(1)* 21134 to 21152 labelled b_1(2)* 21135 to 21133 labelled b_1(0)* 21136 to 21137 labelled b_1(0)* 21137 to 21133 labelled a_1(0)* 21137 to 21142 labelled a_1(1)* 21137 to 21144 labelled a_1(1)* 21138 to 21139 labelled b_1(0)* 21139 to 21133 labelled b_1(0), c_1(0)* 21139 to 21146 labelled c_1(1)* 21139 to 21148 labelled b_1(1)* 21139 to 21144 labelled b_1(1)* 21139 to 21152 labelled b_1(2)* 21140 to 21141 labelled c_1(0)* 21141 to 21133 labelled a_1(0)* 21141 to 21142 labelled a_1(1)* 21141 to 21144 labelled a_1(1)* 21142 to 21143 labelled b_1(1)* 21143 to 21133 labelled a_1(1)* 21143 to 21142 labelled a_1(1)* 21143 to 21144 labelled a_1(1)* 21144 to 21145 labelled c_1(1)* 21145 to 21133 labelled a_1(1)* 21145 to 21142 labelled a_1(1)* 21145 to 21144 labelled a_1(1)* 21146 to 21147 labelled c_1(1)* 21146 to 21146 labelled c_1(1)* 21146 to 21152 labelled b_1(2)* 21147 to 21133 labelled b_1(1)* 21148 to 21149 labelled b_1(1)* 21149 to 21133 labelled b_1(1), c_1(1)* 21149 to 21146 labelled c_1(1)* 21149 to 21148 labelled b_1(1)* 21149 to 21144 labelled b_1(1)* 21149 to 21152 labelled b_1(2)* 21150 to 21151 labelled c_1(1)* 21151 to 21147 labelled a_1(1)* 21151 to 21146 labelled a_1(1)* 21151 to 21142 labelled a_1(1)* 21151 to 21144 labelled a_1(1)* 21151 to 21154 labelled a_1(2)* 21152 to 21153 labelled c_1(2)* 21153 to 21147 labelled a_1(2)* 21153 to 21146 labelled a_1(2)* 21153 to 21142 labelled a_1(1)* 21153 to 21144 labelled a_1(1)* 21153 to 21156 labelled a_1(3)* 21154 to 21155 labelled b_1(2)* 21155 to 21153 labelled a_1(2)* 21156 to 21157 labelled b_1(3)* 21157 to 21153 labelled a_1(3)


----------------------------------------

(694)
YES

----------------------------------------

(695)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(696) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(697)
Complex Obligation (OR)

----------------------------------------

(698)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(699) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(700)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(701) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(702)
Complex Obligation (AND)

----------------------------------------

(703)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(704)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(705)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(706) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(707)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(708)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(709) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(710)
Complex Obligation (OR)

----------------------------------------

(711)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(712) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(713)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(714) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(715)
Complex Obligation (AND)

----------------------------------------

(716)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(717)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(718)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(719) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(720)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(721)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(722) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(723)
Complex Obligation (OR)

----------------------------------------

(724)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(725) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(726)
Complex Obligation (OR)

----------------------------------------

(727)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(728) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(729)
Complex Obligation (OR)

----------------------------------------

(730)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(731) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(732)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(733)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(734) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(735)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(736)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(737) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(738)
Complex Obligation (OR)

----------------------------------------

(739)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(740) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(741)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(742)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(743) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(744)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(745) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(746)
Complex Obligation (AND)

----------------------------------------

(747)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(748)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(749)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(750) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(751)
Complex Obligation (OR)

----------------------------------------

(752)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(753) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(754)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(755)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(756) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(757)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(758) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(759)
Complex Obligation (AND)

----------------------------------------

(760)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(761)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(762)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(763) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(764)
Complex Obligation (OR)

----------------------------------------

(765)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(766) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(767)
Complex Obligation (OR)

----------------------------------------

(768)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(769) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(770)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(771)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(772) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(773)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(774)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(775) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(776)
Complex Obligation (OR)

----------------------------------------

(777)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(778) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(779)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(780)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(781) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(782)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(783)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(784) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(785)
Complex Obligation (OR)

----------------------------------------

(786)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(787) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(788)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(789)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(790) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(791)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(792)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(793) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(794)
Complex Obligation (OR)

----------------------------------------

(795)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(796) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(797)
Complex Obligation (OR)

----------------------------------------

(798)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(799) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(800)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(801) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(802)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(803)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(804) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(805)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(806) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(807)
Complex Obligation (AND)

----------------------------------------

(808)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(809) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(810)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(811)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(812) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(813)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(814)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(815) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(816)
Complex Obligation (OR)

----------------------------------------

(817)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   c(b(a(x1))) -> C(C(b(x1)))


----------------------------------------

(818) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(819)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(820) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(821)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(822)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(823) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(824)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(825) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(826)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(827)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(828) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(829)
Complex Obligation (OR)

----------------------------------------

(830)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(831) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(832)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(833) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(834)
Complex Obligation (AND)

----------------------------------------

(835)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(836) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(837)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(838)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(839) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(840)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(841)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(842) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(843)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(844) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

C(x1)  =  C(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, C_1, a_1]

Status: b_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status


----------------------------------------

(845)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(846) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c0(x1))) -> A0(x1)
   C0(c0(c0(x1))) -> C0(a0(x1))
   C0(c0(a0(x1))) -> C0(x1)
   C0(b0(a0(x1))) -> C0(b0(x1))
   A0(b0(b0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> C0(a0(x1))
   C0(c0(c0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(847)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(c0(a0(x1)))
   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   C0(b0(a0(x1))) -> C0(c0(b0(x1)))

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(848) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs.
----------------------------------------

(849)
Complex Obligation (AND)

----------------------------------------

(850)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(b0(a0(x1))) -> C0(c0(b0(x1)))

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(851)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   c0(b0(a0(x1))) -> c0(c0(b0(x1)))
   a0(b0(c0(x1))) -> a0(b0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(b0(x1)))
   c0(c0(c0(x1))) -> b0(c0(a0(x1)))
   a0(b0(b0(x1))) -> a0(c0(a0(x1)))
   c0(c0(a0(x1))) -> b0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(852)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(853) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(854)
Complex Obligation (OR)

----------------------------------------

(855)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(856) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(857)
Complex Obligation (OR)

----------------------------------------

(858)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(859) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(860)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(861)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(862) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(863)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(864) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(865)
Complex Obligation (AND)

----------------------------------------

(866)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(867) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(868)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(869)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(870) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(871)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(872)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(873) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(874)
Complex Obligation (OR)

----------------------------------------

(875)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))
   a(b(b(x1))) -> A(c(A(x1)))


----------------------------------------

(876) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(877)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(878)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(879) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(880)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(881)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(882) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(883)
Complex Obligation (OR)

----------------------------------------

(884)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(885) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   a(b(b(x1))) -> a(C(a(x1)))

Relative ADPs:

   c(c(c(x1))) -> b(C(A(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(886)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(887) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(888)
Complex Obligation (AND)

----------------------------------------

(889)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(b(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(890) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(891)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(b(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(892)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))

and relative ADPs:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))


----------------------------------------

(893) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(894)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(c(a(x1)))
   A(b(c(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   c(b(a(x1))) -> c(c(b(x1)))
   a(b(c(x1))) -> a(b(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))
   c(c(c(x1))) -> b(c(a(x1)))
   a(b(b(x1))) -> a(c(a(x1)))
   c(c(a(x1))) -> b(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(895)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(C(a(x1)))
   c(c(a(x1))) -> b(b(b(x1)))


----------------------------------------

(896) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(897)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(c(A(x1)))
   c(b(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> A(b(a(x1)))
   a(b(b(x1))) -> A(c(a(x1)))
   a(b(c(x1))) -> a(b(A(x1)))
   c(c(a(x1))) -> b(b(C(x1)))
   c(c(c(x1))) -> b(c(A(x1)))
   a(b(b(x1))) -> a(C(a(x1)))
   c(b(a(x1))) -> C(c(b(x1)))
   c(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   c(c(a(x1))) -> b(b(b(x1)))

