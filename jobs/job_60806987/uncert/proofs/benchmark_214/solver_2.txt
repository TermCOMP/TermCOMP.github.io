YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/3RCgp.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPDerelatifying2Proof [SOUND, 3 ms]
(4) OR
    (5) RelADPP
        (6) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (7) OR
            (8) RelADPP
                (9) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (10) OR
                    (11) RelADPP
                        (12) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (13) RelADPP
                        (14) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (15) AND
                            (16) RelADPP
                                (17) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (18) QDP
                                (19) QDPOrderProof [EQUIVALENT, 5 ms]
                                (20) QDP
                            (21) RelADPP
                                (22) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (23) QDP
                    (24) RelADPP
                        (25) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (26) OR
                            (27) RelADPP
                                (28) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (29) RelADPP
                                (30) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (31) AND
                                    (32) RelADPP
                                        (33) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (34) QDP
                                    (35) RelADPP
                                        (36) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (37) QDP
                            (38) RelADPP
                                (39) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (40) RelADPP
                                (41) RelADPCleverAfsProof [SOUND, 7 ms]
                                (42) QDP
                    (43) RelADPP
                        (44) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (45) OR
                            (46) RelADPP
                                (47) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                (48) RelADPP
                                (49) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (50) AND
                                    (51) RelADPP
                                        (52) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (53) QDP
                                    (54) RelADPP
                                        (55) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (56) QDP
                            (57) RelADPP
                                (58) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (59) RelADPP
                                (60) RelADPCleverAfsProof [SOUND, 8 ms]
                                (61) QDP
            (62) RelADPP
                (63) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (64) OR
                    (65) RelADPP
                        (66) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (67) RelADPP
                        (68) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (69) AND
                            (70) RelADPP
                                (71) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (72) QDP
                            (73) RelADPP
                                (74) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (75) QDP
                    (76) RelADPP
                        (77) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (78) OR
                            (79) RelADPP
                                (80) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (81) RelADPP
                                (82) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (83) AND
                                    (84) RelADPP
                                        (85) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (86) QDP
                                    (87) RelADPP
                                        (88) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (89) QDP
                            (90) RelADPP
                                (91) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (92) RelADPP
                                (93) RelADPCleverAfsProof [SOUND, 16 ms]
                                (94) QDP
                    (95) RelADPP
                        (96) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (97) OR
                            (98) RelADPP
                                (99) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                (100) RelADPP
                                (101) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (102) AND
                                    (103) RelADPP
                                        (104) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (105) QDP
                                    (106) RelADPP
                                        (107) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (108) QDP
                            (109) RelADPP
                                (110) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (111) RelADPP
                                (112) RelADPCleverAfsProof [SOUND, 6 ms]
                                (113) QDP
            (114) RelADPP
                (115) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (116) OR
                    (117) RelADPP
                        (118) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (119) OR
                            (120) RelADPP
                                (121) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (122) RelADPP
                            (123) RelADPP
                    (124) RelADPP
                        (125) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (126) OR
                            (127) RelADPP
                                (128) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (129) RelADPP
                            (130) RelADPP
                    (131) RelADPP
                        (132) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (133) OR
                            (134) RelADPP
                            (135) RelADPP
            (136) RelADPP
                (137) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (138) OR
                    (139) RelADPP
                        (140) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (141) OR
                            (142) RelADPP
                                (143) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (144) RelADPP
                                (145) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (146) AND
                                    (147) RelADPP
                                        (148) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (149) QDP
                                    (150) RelADPP
                                        (151) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (152) QDP
                            (153) RelADPP
                                (154) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (155) RelADPP
                                (156) RelADPCleverAfsProof [SOUND, 9 ms]
                                (157) QDP
                    (158) RelADPP
                        (159) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (160) OR
                            (161) RelADPP
                                (162) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (163) RelADPP
                                (164) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (165) AND
                                    (166) RelADPP
                                        (167) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (168) QDP
                                    (169) RelADPP
                                        (170) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (171) QDP
                            (172) RelADPP
                                (173) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (174) RelADPP
                                (175) RelADPCleverAfsProof [SOUND, 11 ms]
                                (176) QDP
                                (177) MRRProof [EQUIVALENT, 5 ms]
                                (178) QDP
                    (179) RelADPP
                        (180) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (181) OR
                            (182) RelADPP
                                (183) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (184) RelADPP
                                (185) RelADPCleverAfsProof [SOUND, 37 ms]
                                (186) QDP
                            (187) RelADPP
                                (188) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (189) RelADPP
                                (190) RelADPCleverAfsProof [SOUND, 28 ms]
                                (191) QDP
                                (192) MRRProof [EQUIVALENT, 4 ms]
                                (193) QDP
    (194) RelADPP
        (195) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (196) OR
            (197) RelADPP
                (198) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (199) OR
                    (200) RelADPP
                        (201) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (202) RelADPP
                        (203) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (204) AND
                            (205) RelADPP
                                (206) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (207) QDP
                            (208) RelADPP
                                (209) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (210) QDP
                    (211) RelADPP
                        (212) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (213) OR
                            (214) RelADPP
                                (215) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (216) RelADPP
                            (217) RelADPP
                    (218) RelADPP
                        (219) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (220) OR
                            (221) RelADPP
                                (222) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (223) RelADPP
                            (224) RelADPP
            (225) RelADPP
                (226) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (227) OR
                    (228) RelADPP
                        (229) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (230) RelADPP
                        (231) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (232) AND
                            (233) RelADPP
                                (234) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (235) QDP
                            (236) RelADPP
                                (237) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (238) QDP
                    (239) RelADPP
                        (240) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (241) OR
                            (242) RelADPP
                                (243) RelADPReductionPairProof [EQUIVALENT, 15 ms]
                                (244) RelADPP
                            (245) RelADPP
                    (246) RelADPP
                        (247) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (248) OR
                            (249) RelADPP
                                (250) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (251) RelADPP
                                (252) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (253) AND
                                    (254) RelADPP
                                    (255) RelADPP
                            (256) RelADPP
                                (257) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (258) RelADPP
            (259) RelADPP
                (260) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (261) OR
                    (262) RelADPP
                        (263) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (264) OR
                            (265) RelADPP
                                (266) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (267) RelADPP
                                (268) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (269) AND
                                    (270) RelADPP
                                    (271) RelADPP
                            (272) RelADPP
                    (273) RelADPP
                        (274) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (275) OR
                            (276) RelADPP
                                (277) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (278) RelADPP
                            (279) RelADPP
                    (280) RelADPP
                        (281) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (282) OR
                            (283) RelADPP
                            (284) RelADPP
            (285) RelADPP
                (286) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (287) OR
                    (288) RelADPP
                        (289) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (290) OR
                            (291) RelADPP
                                (292) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (293) RelADPP
                            (294) RelADPP
                    (295) RelADPP
                        (296) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (297) OR
                            (298) RelADPP
                                (299) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                (300) RelADPP
                            (301) RelADPP
                    (302) RelADPP
                        (303) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (304) OR
                            (305) RelADPP
                            (306) RelADPP
    (307) RelADPP
        (308) RelADPDerelatifying2Proof [SOUND, 2 ms]
        (309) OR
            (310) RelADPP
                (311) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                (312) RelADPP
                (313) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (314) AND
                    (315) RelADPP
                        (316) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (317) QDP
                    (318) RelADPP
                        (319) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (320) QDP
            (321) RelADPP
                (322) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (323) OR
                    (324) RelADPP
                        (325) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                        (326) RelADPP
                        (327) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (328) AND
                            (329) RelADPP
                                (330) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (331) QDP
                            (332) RelADPP
                                (333) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (334) QDP
                    (335) RelADPP
                        (336) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (337) OR
                            (338) RelADPP
                                (339) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (340) RelADPP
                                (341) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (342) AND
                                    (343) RelADPP
                                        (344) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (345) QDP
                                    (346) RelADPP
                                        (347) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (348) QDP
                            (349) RelADPP
                                (350) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (351) RelADPP
                                (352) RelADPCleverAfsProof [SOUND, 17 ms]
                                (353) QDP
                    (354) RelADPP
                        (355) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (356) OR
                            (357) RelADPP
                                (358) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (359) RelADPP
                                (360) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (361) AND
                                    (362) RelADPP
                                        (363) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (364) QDP
                                    (365) RelADPP
                                        (366) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (367) QDP
                            (368) RelADPP
                                (369) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (370) RelADPP
            (371) RelADPP
                (372) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (373) OR
                    (374) RelADPP
                        (375) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                        (376) RelADPP
                        (377) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (378) AND
                            (379) RelADPP
                                (380) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (381) QDP
                            (382) RelADPP
                                (383) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (384) QDP
                    (385) RelADPP
                        (386) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (387) OR
                            (388) RelADPP
                                (389) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (390) RelADPP
                                (391) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (392) AND
                                    (393) RelADPP
                                    (394) RelADPP
                            (395) RelADPP
                    (396) RelADPP
                        (397) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (398) OR
                            (399) RelADPP
                                (400) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (401) RelADPP
                                (402) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (403) AND
                                    (404) RelADPP
                                    (405) RelADPP
                            (406) RelADPP
            (407) RelADPP
                (408) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (409) OR
                    (410) RelADPP
                        (411) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (412) RelADPP
                        (413) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (414) AND
                            (415) RelADPP
                                (416) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (417) QDP
                            (418) RelADPP
                                (419) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (420) QDP
                    (421) RelADPP
                        (422) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (423) OR
                            (424) RelADPP
                                (425) RelADPReductionPairProof [EQUIVALENT, 15 ms]
                                (426) RelADPP
                                (427) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (428) AND
                                    (429) RelADPP
                                    (430) RelADPP
                            (431) RelADPP
                    (432) RelADPP
                        (433) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (434) OR
                            (435) RelADPP
                                (436) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (437) RelADPP
                                (438) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (439) AND
                                    (440) RelADPP
                                    (441) RelADPP
                            (442) RelADPP
    (443) RelADPP
        (444) RelADPDerelatifying2Proof [SOUND, 5 ms]
        (445) OR
            (446) RelADPP
                (447) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                (448) RelADPP
                (449) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (450) AND
                    (451) RelADPP
                        (452) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (453) QDP
                        (454) QDPOrderProof [EQUIVALENT, 6 ms]
                        (455) QDP
                        (456) PisEmptyProof [EQUIVALENT, 0 ms]
                        (457) YES
                    (458) RelADPP
                        (459) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (460) QDP
                        (461) QDPOrderProof [EQUIVALENT, 11 ms]
                        (462) QDP
                        (463) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (464) TRUE
            (465) RelADPP
                (466) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (467) OR
                    (468) RelADPP
                        (469) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                        (470) RelADPP
                        (471) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (472) AND
                            (473) RelADPP
                                (474) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (475) QDP
                            (476) RelADPP
                                (477) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (478) QDP
                    (479) RelADPP
                        (480) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (481) OR
                            (482) RelADPP
                                (483) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (484) RelADPP
                                (485) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (486) AND
                                    (487) RelADPP
                                        (488) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (489) QDP
                                    (490) RelADPP
                                        (491) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (492) QDP
                            (493) RelADPP
                                (494) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (495) RelADPP
                                (496) RelADPCleverAfsProof [SOUND, 4 ms]
                                (497) QDP
                    (498) RelADPP
                        (499) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (500) OR
                            (501) RelADPP
                                (502) RelADPReductionPairProof [EQUIVALENT, 22 ms]
                                (503) RelADPP
                                (504) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (505) AND
                                    (506) RelADPP
                                        (507) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (508) QDP
                                    (509) RelADPP
                                        (510) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (511) QDP
                            (512) RelADPP
                                (513) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (514) RelADPP
                                (515) RelADPCleverAfsProof [SOUND, 7 ms]
                                (516) QDP
            (517) RelADPP
                (518) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (519) OR
                    (520) RelADPP
                        (521) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                        (522) RelADPP
                        (523) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (524) AND
                            (525) RelADPP
                                (526) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (527) QDP
                            (528) RelADPP
                                (529) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (530) QDP
                    (531) RelADPP
                        (532) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (533) OR
                            (534) RelADPP
                                (535) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (536) RelADPP
                                (537) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (538) AND
                                    (539) RelADPP
                                    (540) RelADPP
                            (541) RelADPP
                    (542) RelADPP
                        (543) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (544) OR
                            (545) RelADPP
                                (546) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (547) RelADPP
                                (548) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (549) AND
                                    (550) RelADPP
                                    (551) RelADPP
                            (552) RelADPP
            (553) RelADPP
                (554) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (555) OR
                    (556) RelADPP
                        (557) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                        (558) RelADPP
                        (559) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (560) AND
                            (561) RelADPP
                                (562) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (563) QDP
                            (564) RelADPP
                                (565) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (566) QDP
                    (567) RelADPP
                        (568) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (569) OR
                            (570) RelADPP
                                (571) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (572) RelADPP
                                (573) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (574) AND
                                    (575) RelADPP
                                    (576) RelADPP
                            (577) RelADPP
                    (578) RelADPP
                        (579) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (580) OR
                            (581) RelADPP
                                (582) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (583) RelADPP
                                (584) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (585) AND
                                    (586) RelADPP
                                    (587) RelADPP
                            (588) RelADPP
    (589) RelADPP
        (590) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (591) OR
            (592) RelADPP
                (593) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (594) OR
                    (595) RelADPP
                        (596) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                        (597) RelADPP
                        (598) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (599) AND
                            (600) RelADPP
                                (601) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (602) QDP
                            (603) RelADPP
                                (604) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (605) QDP
                    (606) RelADPP
                        (607) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (608) OR
                            (609) RelADPP
                                (610) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (611) RelADPP
                                (612) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (613) AND
                                    (614) RelADPP
                                    (615) RelADPP
                            (616) RelADPP
                                (617) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (618) RelADPP
                    (619) RelADPP
                        (620) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (621) OR
                            (622) RelADPP
                                (623) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (624) RelADPP
                                (625) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (626) AND
                                    (627) RelADPP
                                    (628) RelADPP
                            (629) RelADPP
            (630) RelADPP
                (631) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (632) OR
                    (633) RelADPP
                        (634) RelADPReductionPairProof [EQUIVALENT, 15 ms]
                        (635) RelADPP
                        (636) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (637) AND
                            (638) RelADPP
                                (639) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (640) QDP
                            (641) RelADPP
                                (642) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (643) QDP
                    (644) RelADPP
                        (645) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (646) OR
                            (647) RelADPP
                                (648) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (649) RelADPP
                                (650) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (651) AND
                                    (652) RelADPP
                                    (653) RelADPP
                            (654) RelADPP
                    (655) RelADPP
                        (656) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (657) OR
                            (658) RelADPP
                                (659) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (660) RelADPP
                                (661) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (662) AND
                                    (663) RelADPP
                                    (664) RelADPP
                            (665) RelADPP
            (666) RelADPP
                (667) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (668) OR
                    (669) RelADPP
                        (670) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (671) OR
                            (672) RelADPP
                                (673) RelADPReductionPairProof [EQUIVALENT, 15 ms]
                                (674) RelADPP
                                (675) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (676) AND
                                    (677) RelADPP
                                    (678) RelADPP
                            (679) RelADPP
                    (680) RelADPP
                        (681) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (682) OR
                            (683) RelADPP
                                (684) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (685) RelADPP
                                (686) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (687) AND
                                    (688) RelADPP
                                    (689) RelADPP
                            (690) RelADPP
                    (691) RelADPP
                        (692) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (693) OR
                            (694) RelADPP
                                (695) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (696) RelADPP
                                (697) RelADPCleverAfsProof [SOUND, 7 ms]
                                (698) QDP
                            (699) RelADPP
                                (700) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (701) RelADPP
            (702) RelADPP
                (703) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (704) OR
                    (705) RelADPP
                        (706) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (707) OR
                            (708) RelADPP
                                (709) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (710) RelADPP
                                (711) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (712) AND
                                    (713) RelADPP
                                    (714) RelADPP
                            (715) RelADPP
                    (716) RelADPP
                        (717) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (718) OR
                            (719) RelADPP
                                (720) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (721) RelADPP
                                (722) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (723) AND
                                    (724) RelADPP
                                    (725) RelADPP
                            (726) RelADPP
                    (727) RelADPP
                        (728) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (729) OR
                            (730) RelADPP
                            (731) RelADPP


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(a(c(x1))) -> b(c(a(x1)))

The relative TRS consists of the following S rules:

   b(b(b(x1))) -> c(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(a(c(x1))) -> b(c(A(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))
   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(3) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(4)
Complex Obligation (OR)

----------------------------------------

(5)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(6) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(7)
Complex Obligation (OR)

----------------------------------------

(8)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(9) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(10)
Complex Obligation (OR)

----------------------------------------

(11)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(12) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(13)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(14) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(15)
Complex Obligation (AND)

----------------------------------------

(16)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(17) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A(c(a(x1))) -> A(b(b(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( b_1(x_1) ) = max{0, -2}
POL( c_1(x_1) ) = max{0, x_1 - 1}
POL( a_1(x_1) ) = 2
POL( A_1(x_1) ) = x_1 + 1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(20)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(21)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(22) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(23)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(24)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(25) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(26)
Complex Obligation (OR)

----------------------------------------

(27)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(28) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(29)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(30) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(31)
Complex Obligation (AND)

----------------------------------------

(32)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(33) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(34)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(35)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(36) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(37)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(38)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(39) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(40)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(41) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

A(x1)  =  A(x1)

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, A_1, c_1, a_1]

Status: b_1: [1]
A_1: [1]
c_1: [1]
a_1: [1]


----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))
   B0(c0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(43)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(44) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(45)
Complex Obligation (OR)

----------------------------------------

(46)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(47) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(48)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(49) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(50)
Complex Obligation (AND)

----------------------------------------

(51)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(52) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(53)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(54)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(55) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(57)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(58) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(59)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(60) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

A(x1)  =  A(x1)

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, A_1, c_1, a_1]

Status: b_1: [1]
A_1: [1]
c_1: [1]
a_1: [1]


----------------------------------------

(61)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))
   B0(c0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(62)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(63) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(64)
Complex Obligation (OR)

----------------------------------------

(65)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(66) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(67)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(68) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(69)
Complex Obligation (AND)

----------------------------------------

(70)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(71) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(73)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(74) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(75)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(76)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(77) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(78)
Complex Obligation (OR)

----------------------------------------

(79)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(80) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(81)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(82) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(83)
Complex Obligation (AND)

----------------------------------------

(84)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(85) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(86)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(87)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(88) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(89)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(90)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(91) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(92)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(93) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

A(x1)  =  A(x1)

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, A_1, c_1, a_1]

Status: b_1: [1]
A_1: [1]
c_1: [1]
a_1: [1]


----------------------------------------

(94)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))
   B0(c0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(95)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(96) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(97)
Complex Obligation (OR)

----------------------------------------

(98)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(99) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(100)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(101) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(102)
Complex Obligation (AND)

----------------------------------------

(103)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(104) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(105)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(106)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(107) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(108)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(109)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(110) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(111)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(112) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

A(x1)  =  A(x1)

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, A_1, c_1, a_1]

Status: b_1: [1]
A_1: [1]
c_1: [1]
a_1: [1]


----------------------------------------

(113)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))
   B0(c0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(114)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(115) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(116)
Complex Obligation (OR)

----------------------------------------

(117)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(118) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(119)
Complex Obligation (OR)

----------------------------------------

(120)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(121) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(122)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(123)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(124)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(125) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(126)
Complex Obligation (OR)

----------------------------------------

(127)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(128) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(129)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(130)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(131)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(132) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(133)
Complex Obligation (OR)

----------------------------------------

(134)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(135)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(136)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(137) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(138)
Complex Obligation (OR)

----------------------------------------

(139)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(140) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(141)
Complex Obligation (OR)

----------------------------------------

(142)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(143) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(144)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(145) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(146)
Complex Obligation (AND)

----------------------------------------

(147)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(148) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(149)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(150)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(151) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(152)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(153)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(154) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(155)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(156) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

A(x1)  =  A(x1)

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, A_1, c_1, a_1]

Status: b_1: [1]
A_1: [1]
c_1: [1]
a_1: [1]


----------------------------------------

(157)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))
   B0(c0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(158)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(159) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(160)
Complex Obligation (OR)

----------------------------------------

(161)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(162) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(163)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(164) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(165)
Complex Obligation (AND)

----------------------------------------

(166)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(167) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(168)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(169)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(170) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(171)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(172)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(173) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(174)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(175) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

A(x1)  =  A(x1)

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, A_1, c_1, a_1]

Status: b_1: [1]
A_1: [1]
c_1: [1]
a_1: [1]


----------------------------------------

(176)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))
   B0(c0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(177) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   B0(c0(b0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(B0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(178)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(179)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(180) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(181)
Complex Obligation (OR)

----------------------------------------

(182)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(183) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(184)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(185) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

A(x1)  =  A(x1)

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, A_1, c_1, a_1]

Status: b_1: [1]
A_1: [1]
c_1: [1]
a_1: [1]


----------------------------------------

(186)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))
   B0(c0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(187)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(188) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(189)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(190) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

A(x1)  =  A(x1)

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, A_1, c_1, a_1]

Status: b_1: [1]
A_1: [1]
c_1: [1]
a_1: [1]


----------------------------------------

(191)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))
   B0(c0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(192) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   B0(c0(b0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(B0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(193)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(194)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(195) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(196)
Complex Obligation (OR)

----------------------------------------

(197)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(198) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(199)
Complex Obligation (OR)

----------------------------------------

(200)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(201) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(202)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(203) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(204)
Complex Obligation (AND)

----------------------------------------

(205)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(206) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(207)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(208)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(209) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(210)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(211)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(212) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(213)
Complex Obligation (OR)

----------------------------------------

(214)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(215) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(216)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(217)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(218)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(219) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(220)
Complex Obligation (OR)

----------------------------------------

(221)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(222) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(223)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(224)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(225)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(226) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(227)
Complex Obligation (OR)

----------------------------------------

(228)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(229) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(230)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(231) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(232)
Complex Obligation (AND)

----------------------------------------

(233)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(234) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(235)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(236)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(237) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(238)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(239)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(240) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(241)
Complex Obligation (OR)

----------------------------------------

(242)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(243) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(244)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(245)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(246)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(247) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(248)
Complex Obligation (OR)

----------------------------------------

(249)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(250) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(251)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(252) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(253)
Complex Obligation (AND)

----------------------------------------

(254)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(255)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(256)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(257) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(258)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and no relative ADPs.
----------------------------------------

(259)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(260) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(261)
Complex Obligation (OR)

----------------------------------------

(262)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(263) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(264)
Complex Obligation (OR)

----------------------------------------

(265)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(266) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(267)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(268) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(269)
Complex Obligation (AND)

----------------------------------------

(270)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(271)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(272)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(273)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(274) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(275)
Complex Obligation (OR)

----------------------------------------

(276)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(277) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(278)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(279)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(280)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(281) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(282)
Complex Obligation (OR)

----------------------------------------

(283)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(284)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(285)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(286) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(287)
Complex Obligation (OR)

----------------------------------------

(288)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(289) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(290)
Complex Obligation (OR)

----------------------------------------

(291)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(292) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(293)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(294)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(295)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(296) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(297)
Complex Obligation (OR)

----------------------------------------

(298)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(299) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(300)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(301)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(302)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(303) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(304)
Complex Obligation (OR)

----------------------------------------

(305)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(306)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(307)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(308) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(309)
Complex Obligation (OR)

----------------------------------------

(310)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(311) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(312)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(313) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(314)
Complex Obligation (AND)

----------------------------------------

(315)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(316) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(317)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(318)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(319) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(320)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(321)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(322) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(323)
Complex Obligation (OR)

----------------------------------------

(324)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(325) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(326)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(327) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(328)
Complex Obligation (AND)

----------------------------------------

(329)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(330) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(331)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(332)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(333) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(334)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(335)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(336) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(337)
Complex Obligation (OR)

----------------------------------------

(338)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(339) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(340)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(341) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(342)
Complex Obligation (AND)

----------------------------------------

(343)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(344) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(345)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(346)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(347) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(348)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(349)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(350) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(351)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(352) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

A(x1)  =  A(x1)

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, A_1, c_1, a_1]

Status: b_1: [1]
A_1: [1]
c_1: [1]
a_1: [1]


----------------------------------------

(353)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))
   B0(c0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(354)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(355) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(356)
Complex Obligation (OR)

----------------------------------------

(357)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(358) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(359)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(360) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(361)
Complex Obligation (AND)

----------------------------------------

(362)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(363) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(364)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(365)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(366) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(367)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(368)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(369) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(370)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(371)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(372) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(373)
Complex Obligation (OR)

----------------------------------------

(374)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(375) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(376)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(377) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(378)
Complex Obligation (AND)

----------------------------------------

(379)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(380) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(381)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(382)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(383) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(384)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(385)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(386) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(387)
Complex Obligation (OR)

----------------------------------------

(388)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(389) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(390)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(391) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(392)
Complex Obligation (AND)

----------------------------------------

(393)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(394)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(395)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(396)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(397) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(398)
Complex Obligation (OR)

----------------------------------------

(399)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(400) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(401)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(402) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(403)
Complex Obligation (AND)

----------------------------------------

(404)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(405)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(406)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(407)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(408) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(409)
Complex Obligation (OR)

----------------------------------------

(410)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(411) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(412)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(413) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(414)
Complex Obligation (AND)

----------------------------------------

(415)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(416) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(417)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(418)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(419) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(420)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(421)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(422) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(423)
Complex Obligation (OR)

----------------------------------------

(424)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(425) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(426)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(427) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(428)
Complex Obligation (AND)

----------------------------------------

(429)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(430)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(431)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(432)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(433) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(434)
Complex Obligation (OR)

----------------------------------------

(435)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(436) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(437)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(438) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(439)
Complex Obligation (AND)

----------------------------------------

(440)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(441)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(442)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(443)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(444) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(445)
Complex Obligation (OR)

----------------------------------------

(446)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(447) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(448)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(449) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(450)
Complex Obligation (AND)

----------------------------------------

(451)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(452) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(453)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(454) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A(c(a(x1))) -> A(b(b(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( b_1(x_1) ) = max{0, -2}
POL( c_1(x_1) ) = max{0, x_1 - 1}
POL( a_1(x_1) ) = 2
POL( A_1(x_1) ) = x_1 + 1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(455)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(456) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(457)
YES

----------------------------------------

(458)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(459) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(460)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(461) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   B(c(b(x1))) -> B(a(c(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( b_1(x_1) ) = 2
POL( c_1(x_1) ) = max{0, x_1 - 1}
POL( a_1(x_1) ) = max{0, -2}
POL( B_1(x_1) ) = max{0, 2x_1 - 1}

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(462)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(463) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(464)
TRUE

----------------------------------------

(465)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(466) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(467)
Complex Obligation (OR)

----------------------------------------

(468)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(469) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(470)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(471) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(472)
Complex Obligation (AND)

----------------------------------------

(473)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(474) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(475)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(476)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(477) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(478)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(479)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(480) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(481)
Complex Obligation (OR)

----------------------------------------

(482)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(483) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(484)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(485) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(486)
Complex Obligation (AND)

----------------------------------------

(487)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(488) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(489)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(490)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(491) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(492)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(493)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(494) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(495)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(496) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

A(x1)  =  A(x1)

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, A_1, c_1, a_1]

Status: b_1: [1]
A_1: [1]
c_1: [1]
a_1: [1]


----------------------------------------

(497)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))
   B0(c0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(498)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(499) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(500)
Complex Obligation (OR)

----------------------------------------

(501)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(502) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(503)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(504) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(505)
Complex Obligation (AND)

----------------------------------------

(506)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(507) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(508)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(509)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(510) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(511)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(512)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(513) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(514)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(515) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

A(x1)  =  A(x1)

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, A_1, c_1, a_1]

Status: b_1: [1]
A_1: [1]
c_1: [1]
a_1: [1]


----------------------------------------

(516)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))
   B0(c0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(517)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(518) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(519)
Complex Obligation (OR)

----------------------------------------

(520)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(521) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(522)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(523) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(524)
Complex Obligation (AND)

----------------------------------------

(525)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(526) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(527)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(528)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(529) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(530)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(531)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(532) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(533)
Complex Obligation (OR)

----------------------------------------

(534)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


----------------------------------------

(535) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> a(B(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(536)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(537) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(538)
Complex Obligation (AND)

----------------------------------------

(539)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(540)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(541)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(542)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(543) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(544)
Complex Obligation (OR)

----------------------------------------

(545)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(546) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(547)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(548) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(549)
Complex Obligation (AND)

----------------------------------------

(550)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(551)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(552)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(553)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(554) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(555)
Complex Obligation (OR)

----------------------------------------

(556)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(557) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(558)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(559) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(560)
Complex Obligation (AND)

----------------------------------------

(561)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(562) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(563)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(564)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(565) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(566)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(567)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(568) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(569)
Complex Obligation (OR)

----------------------------------------

(570)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(571) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(572)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(573) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(574)
Complex Obligation (AND)

----------------------------------------

(575)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(576)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(577)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(578)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(579) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(580)
Complex Obligation (OR)

----------------------------------------

(581)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(582) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(583)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(584) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(585)
Complex Obligation (AND)

----------------------------------------

(586)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(587)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(588)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(589)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(590) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(591)
Complex Obligation (OR)

----------------------------------------

(592)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(593) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(594)
Complex Obligation (OR)

----------------------------------------

(595)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(596) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(597)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(598) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(599)
Complex Obligation (AND)

----------------------------------------

(600)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(601) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(602)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(603)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(604) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(605)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(606)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(607) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(608)
Complex Obligation (OR)

----------------------------------------

(609)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(610) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(611)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(612) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(613)
Complex Obligation (AND)

----------------------------------------

(614)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(615)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(616)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(617) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(618)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(619)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(620) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(621)
Complex Obligation (OR)

----------------------------------------

(622)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(623) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(624)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(625) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(626)
Complex Obligation (AND)

----------------------------------------

(627)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(628)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(629)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(630)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(631) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(632)
Complex Obligation (OR)

----------------------------------------

(633)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(634) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(635)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(636) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(637)
Complex Obligation (AND)

----------------------------------------

(638)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(639) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(640)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(a(x1))) -> A(b(b(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(641)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(642) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(643)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(a(c(x1))) -> B(c(a(x1)))
   B(c(b(x1))) -> B(a(c(x1)))

The TRS R consists of the following rules:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(644)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(645) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(646)
Complex Obligation (OR)

----------------------------------------

(647)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(648) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(649)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(650) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(651)
Complex Obligation (AND)

----------------------------------------

(652)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(653)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(654)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(655)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(656) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(657)
Complex Obligation (OR)

----------------------------------------

(658)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(659) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(660)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(661) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(662)
Complex Obligation (AND)

----------------------------------------

(663)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(664)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(665)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(666)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(667) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(668)
Complex Obligation (OR)

----------------------------------------

(669)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(670) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(671)
Complex Obligation (OR)

----------------------------------------

(672)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(673) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(674)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(675) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(676)
Complex Obligation (AND)

----------------------------------------

(677)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(678)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(679)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(680)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(681) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(682)
Complex Obligation (OR)

----------------------------------------

(683)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


----------------------------------------

(684) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(685)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(686) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(687)
Complex Obligation (AND)

----------------------------------------

(688)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(689)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(690)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(691)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(692) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(693)
Complex Obligation (OR)

----------------------------------------

(694)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(695) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(696)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(697) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

A(x1)  =  A(x1)

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, A_1, c_1, a_1]

Status: b_1: [1]
A_1: [1]
c_1: [1]
a_1: [1]


----------------------------------------

(698)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(b0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> B0(x1)
   B0(a0(c0(x1))) -> A0(x1)
   B0(a0(c0(x1))) -> B0(c0(a0(x1)))
   B0(c0(b0(x1))) -> B0(a0(c0(x1)))
   A0(c0(a0(x1))) -> B0(x1)
   A0(c0(a0(x1))) -> B0(b0(x1))
   A0(c0(a0(x1))) -> A0(b0(b0(x1)))
   B0(c0(b0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   b0(c0(b0(x1))) -> b0(a0(c0(x1)))
   b0(b0(b0(x1))) -> c0(c0(a0(x1)))
   b0(a0(c0(x1))) -> b0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(c0(a0(x1))) -> a0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(699)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(700) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(701)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   b(b(b(x1))) -> c(c(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and no relative ADPs.
----------------------------------------

(702)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(703) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(704)
Complex Obligation (OR)

----------------------------------------

(705)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(706) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(707)
Complex Obligation (OR)

----------------------------------------

(708)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(709) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(710)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(711) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(712)
Complex Obligation (AND)

----------------------------------------

(713)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(714)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(715)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(716)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(717) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(718)
Complex Obligation (OR)

----------------------------------------

(719)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


----------------------------------------

(720) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

Relative ADPs:

   b(b(b(x1))) -> c(c(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(721)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(722) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(723)
Complex Obligation (AND)

----------------------------------------

(724)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> A(b(b(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(725)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> B(c(a(x1)))
   b(c(b(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(c(b(x1))) -> b(a(c(x1)))
   b(b(b(x1))) -> c(c(a(x1)))
   b(a(c(x1))) -> b(c(a(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(a(x1))) -> a(b(b(x1)))


----------------------------------------

(726)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))


----------------------------------------

(727)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))
   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(728) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(729)
Complex Obligation (OR)

----------------------------------------

(730)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(B(b(x1)))


----------------------------------------

(731)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> a(B(b(x1)))
   b(a(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> a(b(B(x1)))
   b(c(b(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> A(b(b(x1)))
   b(c(b(x1))) -> b(A(c(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(b(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> A(b(B(x1)))

