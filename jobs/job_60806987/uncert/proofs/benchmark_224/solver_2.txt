YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/k7Llc.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPDepGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) RelADPP
        (6) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (7) OR
            (8) RelADPP
                (9) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (10) RelADPP
                (11) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (12) OR
                    (13) RelADPP
                        (14) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (15) OR
                            (16) RelADPP
                                (17) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (18) RelADPP
                                (19) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (20) RelADPP
                                (21) RelADPCleverAfsProof [SOUND, 11 ms]
                                (22) QDP
                                (23) MRRProof [EQUIVALENT, 3 ms]
                                (24) QDP
                                (25) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (26) QDP
                                (27) TransformationProof [EQUIVALENT, 0 ms]
                                (28) QDP
                                (29) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (30) QDP
                            (31) RelADPP
                                (32) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (33) RelADPP
                                (34) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (35) RelADPP
                                (36) RelADPCleverAfsProof [SOUND, 29 ms]
                                (37) QDP
                                (38) MRRProof [EQUIVALENT, 4 ms]
                                (39) QDP
                                (40) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (41) QDP
                                (42) TransformationProof [EQUIVALENT, 0 ms]
                                (43) QDP
                                (44) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (45) QDP
                    (46) RelADPP
                        (47) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (48) OR
                            (49) RelADPP
                                (50) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (51) RelADPP
                                (52) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (53) RelADPP
                                (54) RelADPCleverAfsProof [SOUND, 31 ms]
                                (55) QDP
                                (56) MRRProof [EQUIVALENT, 5 ms]
                                (57) QDP
                                (58) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (59) QDP
                                (60) TransformationProof [EQUIVALENT, 0 ms]
                                (61) QDP
                                (62) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (63) QDP
                            (64) RelADPP
                                (65) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (66) RelADPP
                                (67) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (68) RelADPP
                                (69) RelADPCleverAfsProof [SOUND, 30 ms]
                                (70) QDP
                                (71) MRRProof [EQUIVALENT, 2 ms]
                                (72) QDP
                                (73) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (74) QDP
                                (75) TransformationProof [EQUIVALENT, 0 ms]
                                (76) QDP
                                (77) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (78) QDP
                    (79) RelADPP
                        (80) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (81) RelADPP
                        (82) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (83) OR
                            (84) RelADPP
                                (85) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (86) RelADPP
                                (87) RelADPCleverAfsProof [SOUND, 43 ms]
                                (88) QDP
                                (89) MRRProof [EQUIVALENT, 3 ms]
                                (90) QDP
                                (91) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (92) QDP
                                (93) TransformationProof [EQUIVALENT, 0 ms]
                                (94) QDP
                                (95) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (96) QDP
                            (97) RelADPP
                                (98) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (99) RelADPP
                                (100) RelADPCleverAfsProof [SOUND, 33 ms]
                                (101) QDP
                                (102) MRRProof [EQUIVALENT, 3 ms]
                                (103) QDP
                                (104) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (105) QDP
                                (106) TransformationProof [EQUIVALENT, 0 ms]
                                (107) QDP
                                (108) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (109) QDP
            (110) RelADPP
                (111) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (112) OR
                    (113) RelADPP
                        (114) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (115) RelADPP
                        (116) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (117) OR
                            (118) RelADPP
                                (119) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (120) RelADPP
                                (121) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (122) RelADPP
                                (123) RelADPCleverAfsProof [SOUND, 27 ms]
                                (124) QDP
                                (125) MRRProof [EQUIVALENT, 2 ms]
                                (126) QDP
                                (127) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (128) QDP
                                (129) TransformationProof [EQUIVALENT, 0 ms]
                                (130) QDP
                                (131) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (132) QDP
                            (133) RelADPP
                                (134) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (135) RelADPP
                                (136) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (137) RelADPP
                                (138) RelADPCleverAfsProof [SOUND, 42 ms]
                                (139) QDP
                                (140) MRRProof [EQUIVALENT, 3 ms]
                                (141) QDP
                                (142) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (143) QDP
                                (144) TransformationProof [EQUIVALENT, 0 ms]
                                (145) QDP
                                (146) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (147) QDP
                    (148) RelADPP
                        (149) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (150) OR
                            (151) RelADPP
                                (152) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (153) RelADPP
                                (154) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (155) RelADPP
                                (156) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (157) RelADPP
                                (158) RelADPCleverAfsProof [SOUND, 20 ms]
                                (159) QDP
                                (160) MRRProof [EQUIVALENT, 4 ms]
                                (161) QDP
                                (162) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (163) QDP
                                (164) TransformationProof [EQUIVALENT, 0 ms]
                                (165) QDP
                                (166) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (167) QDP
                            (168) RelADPP
                                (169) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (170) AND
                                    (171) RelADPP
                                        (172) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (173) RelADPP
                                        (174) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (175) RelADPP
                                        (176) RelADPCleverAfsProof [SOUND, 41 ms]
                                        (177) QDP
                                        (178) MRRProof [EQUIVALENT, 4 ms]
                                        (179) QDP
                                        (180) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (181) QDP
                                        (182) TransformationProof [EQUIVALENT, 0 ms]
                                        (183) QDP
                                        (184) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (185) QDP
                                    (186) RelADPP
                                        (187) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (188) RelADPP
                                        (189) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (190) TRUE
                                    (191) RelADPP
                                        (192) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (193) RelADPP
                                        (194) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (195) TRUE
                                    (196) RelADPP
                                        (197) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                        (198) RelADPP
                                        (199) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (200) YES
                                    (201) RelADPP
                                        (202) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (203) RelADPP
                                        (204) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (205) YES
                                    (206) RelADPP
                                        (207) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (208) RelADPP
                                        (209) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (210) YES
                                    (211) RelADPP
                                        (212) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (213) RelADPP
                                        (214) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (215) YES
                                    (216) RelADPP
                                        (217) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                                        (218) RelADPP
                                        (219) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (220) YES
                                    (221) RelADPP
                                        (222) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (223) RelADPP
                                        (224) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (225) YES
                    (226) RelADPP
                        (227) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (228) AND
                            (229) RelADPP
                                (230) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (231) OR
                                    (232) RelADPP
                                        (233) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (234) RelADPP
                                        (235) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (236) RelADPP
                                        (237) RelADPCleverAfsProof [SOUND, 18 ms]
                                        (238) QDP
                                        (239) MRRProof [EQUIVALENT, 2 ms]
                                        (240) QDP
                                        (241) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (242) QDP
                                        (243) TransformationProof [EQUIVALENT, 0 ms]
                                        (244) QDP
                                        (245) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (246) QDP
                                    (247) RelADPP
                                        (248) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (249) RelADPP
                                        (250) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (251) RelADPP
                                        (252) RelADPCleverAfsProof [SOUND, 38 ms]
                                        (253) QDP
                                        (254) MRRProof [EQUIVALENT, 3 ms]
                                        (255) QDP
                                        (256) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (257) QDP
                                        (258) TransformationProof [EQUIVALENT, 0 ms]
                                        (259) QDP
                                        (260) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (261) QDP
                            (262) RelADPP
                                (263) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (264) RelADPP
                                (265) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (266) TRUE
                            (267) RelADPP
                                (268) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (269) OR
                                    (270) RelADPP
                                        (271) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (272) RelADPP
                                        (273) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (274) RelADPP
                                        (275) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (276) RelADPP
                                        (277) RelADPCleverAfsProof [SOUND, 25 ms]
                                        (278) QDP
                                        (279) MRRProof [EQUIVALENT, 2 ms]
                                        (280) QDP
                                        (281) QDPOrderProof [EQUIVALENT, 6 ms]
                                        (282) QDP
                                        (283) PisEmptyProof [EQUIVALENT, 0 ms]
                                        (284) YES
                                    (285) RelADPP
                                        (286) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (287) AND
                                            (288) RelADPP
                                                (289) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (290) RelADPP
                                                (291) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (292) RelADPP
                                                (293) RelADPCleverAfsProof [SOUND, 6 ms]
                                                (294) QDP
                                                (295) MRRProof [EQUIVALENT, 3 ms]
                                                (296) QDP
                                                (297) QDPOrderProof [EQUIVALENT, 1 ms]
                                                (298) QDP
                                                (299) PisEmptyProof [EQUIVALENT, 0 ms]
                                                (300) YES
                                            (301) RelADPP
                                                (302) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                                (303) RelADPP
                                                (304) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                                (305) YES
                                            (306) RelADPP
                                                (307) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                                (308) RelADPP
                                                (309) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                                (310) YES
                            (311) RelADPP
                                (312) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (313) RelADPP
                                (314) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (315) YES
                            (316) RelADPP
                                (317) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (318) RelADPP
                                (319) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (320) YES
                            (321) RelADPP
                                (322) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                (323) RelADPP
                                (324) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (325) TRUE
                            (326) RelADPP
                                (327) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (328) RelADPP
                                (329) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (330) YES
                            (331) RelADPP
                                (332) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (333) RelADPP
                                (334) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (335) YES
                            (336) RelADPP
                                (337) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (338) RelADPP
                                (339) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (340) TRUE
                            (341) RelADPP
                                (342) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (343) RelADPP
                                (344) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (345) YES
                            (346) RelADPP
                                (347) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (348) RelADPP
                                (349) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (350) RelADPP
                                (351) RelADPCleverAfsProof [SOUND, 15 ms]
                                (352) QDP
                                (353) MRRProof [EQUIVALENT, 3 ms]
                                (354) QDP
                                (355) PisEmptyProof [EQUIVALENT, 0 ms]
                                (356) YES
                            (357) RelADPP
                                (358) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (359) RelADPP
                                (360) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (361) YES
                            (362) RelADPP
                                (363) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (364) RelADPP
                                (365) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (366) YES
                            (367) RelADPP
                                (368) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (369) RelADPP
                                (370) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (371) TRUE
            (372) RelADPP
                (373) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (374) OR
                    (375) RelADPP
                        (376) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (377) RelADPP
                        (378) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (379) OR
                            (380) RelADPP
                                (381) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (382) RelADPP
                                (383) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (384) RelADPP
                                (385) RelADPCleverAfsProof [SOUND, 21 ms]
                                (386) QDP
                                (387) MRRProof [EQUIVALENT, 3 ms]
                                (388) QDP
                                (389) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (390) QDP
                                (391) TransformationProof [EQUIVALENT, 0 ms]
                                (392) QDP
                                (393) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (394) QDP
                            (395) RelADPP
                                (396) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (397) RelADPP
                                (398) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (399) RelADPP
                                (400) RelADPCleverAfsProof [SOUND, 11 ms]
                                (401) QDP
                                (402) MRRProof [EQUIVALENT, 4 ms]
                                (403) QDP
                                (404) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (405) QDP
                                (406) TransformationProof [EQUIVALENT, 0 ms]
                                (407) QDP
                                (408) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (409) QDP
                    (410) RelADPP
                        (411) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (412) OR
                            (413) RelADPP
                                (414) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (415) RelADPP
                                (416) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (417) RelADPP
                                (418) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (419) RelADPP
                                (420) RelADPCleverAfsProof [SOUND, 15 ms]
                                (421) QDP
                                (422) MRRProof [EQUIVALENT, 4 ms]
                                (423) QDP
                                (424) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (425) QDP
                                (426) TransformationProof [EQUIVALENT, 0 ms]
                                (427) QDP
                                (428) DependencyGraphProof [EQUIVALENT, 0 ms]
                                (429) QDP
                                (430) QDPOrderProof [EQUIVALENT, 5 ms]
                                (431) QDP
                                (432) PisEmptyProof [EQUIVALENT, 0 ms]
                                (433) YES
                            (434) RelADPP
                                (435) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (436) AND
                                    (437) RelADPP
                                        (438) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (439) RelADPP
                                        (440) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (441) RelADPP
                                        (442) RelADPCleverAfsProof [SOUND, 9 ms]
                                        (443) QDP
                                        (444) MRRProof [EQUIVALENT, 2 ms]
                                        (445) QDP
                                        (446) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (447) QDP
                                        (448) TransformationProof [EQUIVALENT, 0 ms]
                                        (449) QDP
                                        (450) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (451) QDP
                                        (452) QDPOrderProof [EQUIVALENT, 5 ms]
                                        (453) QDP
                                    (454) RelADPP
                                        (455) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (456) RelADPP
                                        (457) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (458) YES
                                    (459) RelADPP
                                        (460) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (461) RelADPP
                                        (462) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (463) TRUE
                                    (464) RelADPP
                                        (465) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (466) RelADPP
                                        (467) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (468) TRUE
                                    (469) RelADPP
                                        (470) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (471) RelADPP
                                        (472) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (473) YES
                                    (474) RelADPP
                                        (475) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (476) RelADPP
                                        (477) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (478) YES
                                    (479) RelADPP
                                        (480) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (481) RelADPP
                                        (482) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (483) YES
                                    (484) RelADPP
                                        (485) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (486) RelADPP
                                        (487) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (488) YES
                                    (489) RelADPP
                                        (490) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (491) RelADPP
                                        (492) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (493) YES
                    (494) RelADPP
                        (495) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (496) AND
                            (497) RelADPP
                                (498) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (499) OR
                                    (500) RelADPP
                                        (501) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (502) RelADPP
                                        (503) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (504) RelADPP
                                        (505) RelADPCleverAfsProof [SOUND, 19 ms]
                                        (506) QDP
                                        (507) MRRProof [EQUIVALENT, 2 ms]
                                        (508) QDP
                                        (509) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (510) QDP
                                        (511) TransformationProof [EQUIVALENT, 0 ms]
                                        (512) QDP
                                        (513) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (514) QDP
                                    (515) RelADPP
                                        (516) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (517) RelADPP
                                        (518) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (519) RelADPP
                                        (520) RelADPCleverAfsProof [SOUND, 27 ms]
                                        (521) QDP
                                        (522) MRRProof [EQUIVALENT, 3 ms]
                                        (523) QDP
                                        (524) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (525) QDP
                                        (526) TransformationProof [EQUIVALENT, 0 ms]
                                        (527) QDP
                                        (528) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (529) QDP
                            (530) RelADPP
                                (531) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (532) RelADPP
                                (533) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (534) TRUE
                            (535) RelADPP
                                (536) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (537) RelADPP
                                (538) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (539) YES
                            (540) RelADPP
                                (541) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (542) RelADPP
                                (543) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (544) TRUE
                            (545) RelADPP
                                (546) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (547) RelADPP
                                (548) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (549) YES
                            (550) RelADPP
                                (551) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (552) RelADPP
                                (553) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (554) YES
                            (555) RelADPP
                                (556) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (557) RelADPP
                                (558) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (559) YES
                            (560) RelADPP
                                (561) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (562) RelADPP
                                (563) RelADPCleverAfsProof [SOUND, 5 ms]
                                (564) QDP
                                (565) MRRProof [EQUIVALENT, 2 ms]
                                (566) QDP
                                (567) PisEmptyProof [EQUIVALENT, 0 ms]
                                (568) YES
                            (569) RelADPP
                                (570) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (571) RelADPP
                                (572) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (573) YES
                            (574) RelADPP
                                (575) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                (576) RelADPP
                                (577) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (578) YES
                            (579) RelADPP
                                (580) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                (581) RelADPP
                                (582) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (583) TRUE
                            (584) RelADPP
                                (585) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (586) RelADPP
                                (587) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (588) YES
                            (589) RelADPP
                                (590) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (591) RelADPP
                                (592) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (593) YES
                            (594) RelADPP
                                (595) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (596) RelADPP
                                (597) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (598) YES
            (599) RelADPP
                (600) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (601) AND
                    (602) RelADPP
                        (603) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (604) OR
                            (605) RelADPP
                                (606) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (607) RelADPP
                                (608) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (609) OR
                                    (610) RelADPP
                                        (611) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (612) RelADPP
                                        (613) RelADPCleverAfsProof [SOUND, 37 ms]
                                        (614) QDP
                                        (615) MRRProof [EQUIVALENT, 6 ms]
                                        (616) QDP
                                        (617) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (618) QDP
                                        (619) TransformationProof [EQUIVALENT, 0 ms]
                                        (620) QDP
                                        (621) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (622) QDP
                                    (623) RelADPP
                                        (624) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (625) RelADPP
                                        (626) RelADPCleverAfsProof [SOUND, 18 ms]
                                        (627) QDP
                                        (628) MRRProof [EQUIVALENT, 2 ms]
                                        (629) QDP
                                        (630) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (631) QDP
                                        (632) TransformationProof [EQUIVALENT, 0 ms]
                                        (633) QDP
                                        (634) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (635) QDP
                            (636) RelADPP
                                (637) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (638) OR
                                    (639) RelADPP
                                        (640) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (641) RelADPP
                                        (642) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (643) RelADPP
                                        (644) RelADPCleverAfsProof [SOUND, 18 ms]
                                        (645) QDP
                                        (646) MRRProof [EQUIVALENT, 2 ms]
                                        (647) QDP
                                        (648) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (649) QDP
                                        (650) TransformationProof [EQUIVALENT, 0 ms]
                                        (651) QDP
                                        (652) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (653) QDP
                                    (654) RelADPP
                                        (655) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (656) RelADPP
                                        (657) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (658) RelADPP
                                        (659) RelADPCleverAfsProof [SOUND, 9 ms]
                                        (660) QDP
                                        (661) MRRProof [EQUIVALENT, 2 ms]
                                        (662) QDP
                                        (663) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (664) QDP
                                        (665) TransformationProof [EQUIVALENT, 0 ms]
                                        (666) QDP
                                        (667) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (668) QDP
                            (669) RelADPP
                                (670) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (671) OR
                                    (672) RelADPP
                                        (673) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (674) RelADPP
                                        (675) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (676) RelADPP
                                        (677) RelADPCleverAfsProof [SOUND, 17 ms]
                                        (678) QDP
                                        (679) MRRProof [EQUIVALENT, 3 ms]
                                        (680) QDP
                                        (681) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (682) QDP
                                        (683) TransformationProof [EQUIVALENT, 0 ms]
                                        (684) QDP
                                        (685) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (686) QDP
                                    (687) RelADPP
                                        (688) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (689) RelADPP
                                        (690) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (691) RelADPP
                                        (692) RelADPCleverAfsProof [SOUND, 30 ms]
                                        (693) QDP
                                        (694) MRRProof [EQUIVALENT, 2 ms]
                                        (695) QDP
                                        (696) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (697) QDP
                                        (698) TransformationProof [EQUIVALENT, 0 ms]
                                        (699) QDP
                                        (700) DependencyGraphProof [EQUIVALENT, 0 ms]
                                        (701) QDP
                    (702) RelADPP
                        (703) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (704) RelADPP
                        (705) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (706) YES
                    (707) RelADPP
                        (708) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (709) RelADPP
                        (710) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (711) YES
                    (712) RelADPP
                        (713) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                        (714) RelADPP
                        (715) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (716) YES
                    (717) RelADPP
                        (718) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (719) RelADPP
                        (720) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (721) TRUE
                    (722) RelADPP
                        (723) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                        (724) RelADPP
                        (725) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (726) YES
                    (727) RelADPP
                        (728) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (729) RelADPP
                        (730) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (731) YES
                    (732) RelADPP
                        (733) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                        (734) RelADPP
                        (735) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (736) TRUE
                    (737) RelADPP
                        (738) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (739) RelADPP
                        (740) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (741) YES
                    (742) RelADPP
                        (743) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (744) RelADPP
                        (745) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (746) YES
                    (747) RelADPP
                        (748) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                        (749) RelADPP
                        (750) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (751) TRUE
                    (752) RelADPP
                        (753) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (754) RelADPP
                        (755) RelADPCleverAfsProof [SOUND, 7 ms]
                        (756) QDP
                        (757) MRRProof [EQUIVALENT, 1 ms]
                        (758) QDP
                        (759) PisEmptyProof [EQUIVALENT, 0 ms]
                        (760) YES
                    (761) RelADPP
                        (762) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (763) RelADPP
                        (764) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (765) TRUE
                    (766) RelADPP
                        (767) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (768) RelADPP
                        (769) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (770) RelADPP
                        (771) RelADPCleverAfsProof [SOUND, 7 ms]
                        (772) QDP
                        (773) MRRProof [EQUIVALENT, 2 ms]
                        (774) QDP
                        (775) PisEmptyProof [EQUIVALENT, 0 ms]
                        (776) YES
                    (777) RelADPP
                        (778) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (779) OR
                            (780) RelADPP
                                (781) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (782) RelADPP
                                (783) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (784) RelADPP
                                (785) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (786) RelADPP
                                (787) RelADPCleverAfsProof [SOUND, 16 ms]
                                (788) QDP
                                (789) MRRProof [EQUIVALENT, 3 ms]
                                (790) QDP
                                (791) QDPOrderProof [EQUIVALENT, 5 ms]
                                (792) QDP
                                (793) PisEmptyProof [EQUIVALENT, 0 ms]
                                (794) YES
                            (795) RelADPP
                                (796) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (797) AND
                                    (798) RelADPP
                                        (799) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (800) RelADPP
                                        (801) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (802) RelADPP
                                        (803) RelADPCleverAfsProof [SOUND, 32 ms]
                                        (804) QDP
                                        (805) MRRProof [EQUIVALENT, 3 ms]
                                        (806) QDP
                                        (807) QDPOrderProof [EQUIVALENT, 6 ms]
                                        (808) QDP
                                        (809) PisEmptyProof [EQUIVALENT, 0 ms]
                                        (810) YES
                                    (811) RelADPP
                                        (812) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (813) RelADPP
                                        (814) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (815) YES
                                    (816) RelADPP
                                        (817) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (818) RelADPP
                                        (819) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (820) YES
                    (821) RelADPP
                        (822) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                        (823) RelADPP
                        (824) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (825) TRUE
                    (826) RelADPP
                        (827) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                        (828) RelADPP
                        (829) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (830) YES
                    (831) RelADPP
                        (832) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (833) RelADPP
                        (834) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (835) YES
                    (836) RelADPP
                        (837) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (838) RelADPP
                        (839) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (840) YES
    (841) RelADPP
        (842) RelADPReductionPairProof [EQUIVALENT, 18 ms]
        (843) RelADPP
        (844) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (845) TRUE
    (846) RelADPP
        (847) RelADPReductionPairProof [EQUIVALENT, 16 ms]
        (848) RelADPP
        (849) RelADPReductionPairProof [EQUIVALENT, 4 ms]
        (850) RelADPP
        (851) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (852) TRUE
    (853) RelADPP
        (854) RelADPReductionPairProof [EQUIVALENT, 23 ms]
        (855) RelADPP
        (856) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (857) YES
    (858) RelADPP
        (859) RelADPReductionPairProof [EQUIVALENT, 17 ms]
        (860) RelADPP
        (861) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (862) TRUE
    (863) RelADPP
        (864) RelADPReductionPairProof [EQUIVALENT, 32 ms]
        (865) RelADPP
        (866) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (867) YES
    (868) RelADPP
        (869) RelADPReductionPairProof [EQUIVALENT, 16 ms]
        (870) RelADPP
        (871) RelADPCleverAfsProof [SOUND, 14 ms]
        (872) QDP
        (873) MRRProof [EQUIVALENT, 3 ms]
        (874) QDP
        (875) PisEmptyProof [EQUIVALENT, 0 ms]
        (876) YES
    (877) RelADPP
        (878) RelADPReductionPairProof [EQUIVALENT, 22 ms]
        (879) RelADPP
        (880) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (881) RelADPP
        (882) RelADPCleverAfsProof [SOUND, 10 ms]
        (883) QDP
        (884) MRRProof [EQUIVALENT, 7 ms]
        (885) QDP
        (886) PisEmptyProof [EQUIVALENT, 0 ms]
        (887) YES
    (888) RelADPP
        (889) RelADPReductionPairProof [EQUIVALENT, 41 ms]
        (890) RelADPP
        (891) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (892) YES
    (893) RelADPP
        (894) RelADPReductionPairProof [EQUIVALENT, 19 ms]
        (895) RelADPP
        (896) RelADPReductionPairProof [EQUIVALENT, 4 ms]
        (897) RelADPP
        (898) RelADPCleverAfsProof [SOUND, 9 ms]
        (899) QDP
        (900) MRRProof [EQUIVALENT, 2 ms]
        (901) QDP
        (902) PisEmptyProof [EQUIVALENT, 0 ms]
        (903) YES
    (904) RelADPP
        (905) RelADPReductionPairProof [EQUIVALENT, 23 ms]
        (906) RelADPP
        (907) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (908) RelADPP
        (909) RelADPCleverAfsProof [SOUND, 10 ms]
        (910) QDP
        (911) MRRProof [EQUIVALENT, 4 ms]
        (912) QDP
        (913) PisEmptyProof [EQUIVALENT, 0 ms]
        (914) YES
    (915) RelADPP
        (916) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (917) OR
            (918) RelADPP
                (919) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (920) RelADPP
                (921) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (922) RelADPP
                (923) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (924) RelADPP
                (925) RelADPCleverAfsProof [SOUND, 3 ms]
                (926) QDP
                (927) MRRProof [EQUIVALENT, 2 ms]
                (928) QDP
                (929) QDPOrderProof [EQUIVALENT, 12 ms]
                (930) QDP
                (931) PisEmptyProof [EQUIVALENT, 0 ms]
                (932) YES
            (933) RelADPP
                (934) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (935) AND
                    (936) RelADPP
                        (937) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (938) RelADPP
                        (939) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (940) RelADPP
                        (941) RelADPCleverAfsProof [SOUND, 27 ms]
                        (942) QDP
                        (943) MRRProof [EQUIVALENT, 2 ms]
                        (944) QDP
                        (945) QDPOrderProof [EQUIVALENT, 5 ms]
                        (946) QDP
                        (947) PisEmptyProof [EQUIVALENT, 0 ms]
                        (948) YES
                    (949) RelADPP
                        (950) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (951) RelADPP
                        (952) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (953) YES
                    (954) RelADPP
                        (955) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                        (956) RelADPP
                        (957) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (958) YES
    (959) RelADPP
        (960) RelADPReductionPairProof [EQUIVALENT, 16 ms]
        (961) RelADPP
        (962) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (963) TRUE
    (964) RelADPP
        (965) RelADPReductionPairProof [EQUIVALENT, 16 ms]
        (966) RelADPP
        (967) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (968) YES
    (969) RelADPP
        (970) RelADPReductionPairProof [EQUIVALENT, 19 ms]
        (971) RelADPP
        (972) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (973) YES
    (974) RelADPP
        (975) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (976) OR
            (977) RelADPP
                (978) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (979) RelADPP
                (980) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                (981) RelADPP
                (982) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (983) RelADPP
                (984) RelADPCleverAfsProof [SOUND, 0 ms]
                (985) QDP
                (986) MRRProof [EQUIVALENT, 2 ms]
                (987) QDP
                (988) PisEmptyProof [EQUIVALENT, 0 ms]
                (989) YES
            (990) RelADPP
                (991) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (992) AND
                    (993) RelADPP
                        (994) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (995) RelADPP
                        (996) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (997) YES
                    (998) RelADPP
                        (999) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (1000) RelADPP
                        (1001) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1002) TRUE
                    (1003) RelADPP
                        (1004) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (1005) RelADPP
                        (1006) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1007) YES
    (1008) RelADPP
        (1009) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (1010) OR
            (1011) RelADPP
                (1012) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (1013) RelADPP
                (1014) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1015) OR
                    (1016) RelADPP
                        (1017) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1018) RelADPP
                        (1019) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1020) RelADPP
                        (1021) RelADPCleverAfsProof [SOUND, 19 ms]
                        (1022) QDP
                        (1023) MRRProof [EQUIVALENT, 3 ms]
                        (1024) QDP
                        (1025) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (1026) TRUE
                    (1027) RelADPP
                        (1028) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1029) RelADPP
                        (1030) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                        (1031) RelADPP
                        (1032) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1033) YES
            (1034) RelADPP
                (1035) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1036) OR
                    (1037) RelADPP
                        (1038) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1039) RelADPP
                        (1040) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1041) RelADPP
                        (1042) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1043) RelADPP
                        (1044) RelADPCleverAfsProof [SOUND, 16 ms]
                        (1045) QDP
                        (1046) MRRProof [EQUIVALENT, 3 ms]
                        (1047) QDP
                        (1048) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (1049) TRUE
                    (1050) RelADPP
                        (1051) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1052) AND
                            (1053) RelADPP
                                (1054) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (1055) RelADPP
                                (1056) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (1057) YES
                            (1058) RelADPP
                                (1059) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1060) RelADPP
                                (1061) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1062) TRUE
                            (1063) RelADPP
                                (1064) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (1065) RelADPP
                                (1066) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (1067) YES
                            (1068) RelADPP
                                (1069) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1070) RelADPP
                                (1071) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (1072) YES
                            (1073) RelADPP
                                (1074) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1075) RelADPP
                                (1076) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (1077) YES
            (1078) RelADPP
                (1079) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (1080) AND
                    (1081) RelADPP
                        (1082) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                        (1083) RelADPP
                        (1084) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1085) YES
                    (1086) RelADPP
                        (1087) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                        (1088) RelADPP
                        (1089) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1090) YES
                    (1091) RelADPP
                        (1092) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (1093) RelADPP
                        (1094) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1095) TRUE
                    (1096) RelADPP
                        (1097) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                        (1098) RelADPP
                        (1099) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1100) TRUE
                    (1101) RelADPP
                        (1102) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                        (1103) RelADPP
                        (1104) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1105) YES
                    (1106) RelADPP
                        (1107) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (1108) RelADPP
                        (1109) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1110) YES
    (1111) RelADPP
        (1112) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (1113) OR
            (1114) RelADPP
                (1115) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (1116) RelADPP
                (1117) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                (1118) RelADPP
                (1119) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                (1120) RelADPP
                (1121) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (1122) TRUE
            (1123) RelADPP
                (1124) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1125) OR
                    (1126) RelADPP
                        (1127) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1128) RelADPP
                        (1129) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                        (1130) RelADPP
                        (1131) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1132) RelADPP
                        (1133) RelADPCleverAfsProof [SOUND, 0 ms]
                        (1134) QDP
                        (1135) MRRProof [EQUIVALENT, 2 ms]
                        (1136) QDP
                        (1137) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (1138) TRUE
                    (1139) RelADPP
                        (1140) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1141) AND
                            (1142) RelADPP
                                (1143) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1144) RelADPP
                                (1145) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (1146) YES
                            (1147) RelADPP
                                (1148) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (1149) RelADPP
                                (1150) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (1151) YES
                            (1152) RelADPP
                                (1153) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (1154) RelADPP
                                (1155) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (1156) YES
                            (1157) RelADPP
                                (1158) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (1159) RelADPP
                                (1160) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1161) TRUE
                            (1162) RelADPP
                                (1163) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                (1164) RelADPP
                                (1165) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (1166) YES
            (1167) RelADPP
                (1168) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (1169) AND
                    (1170) RelADPP
                        (1171) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                        (1172) RelADPP
                        (1173) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1174) YES
                    (1175) RelADPP
                        (1176) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (1177) RelADPP
                        (1178) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1179) TRUE
                    (1180) RelADPP
                        (1181) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (1182) RelADPP
                        (1183) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1184) YES
                    (1185) RelADPP
                        (1186) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                        (1187) RelADPP
                        (1188) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1189) YES
                    (1190) RelADPP
                        (1191) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                        (1192) RelADPP
                        (1193) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1194) YES
                    (1195) RelADPP
                        (1196) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (1197) RelADPP
                        (1198) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1199) YES
    (1200) RelADPP
        (1201) RelADPReductionPairProof [EQUIVALENT, 19 ms]
        (1202) RelADPP
        (1203) RelADPReductionPairProof [EQUIVALENT, 4 ms]
        (1204) RelADPP
        (1205) RelADPCleverAfsProof [SOUND, 18 ms]
        (1206) QDP
        (1207) MRRProof [EQUIVALENT, 3 ms]
        (1208) QDP
        (1209) PisEmptyProof [EQUIVALENT, 0 ms]
        (1210) YES
    (1211) RelADPP
        (1212) RelADPReductionPairProof [EQUIVALENT, 22 ms]
        (1213) RelADPP
        (1214) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (1215) YES
    (1216) RelADPP
        (1217) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (1218) OR
            (1219) RelADPP
                (1220) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (1221) RelADPP
                (1222) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1223) OR
                    (1224) RelADPP
                        (1225) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1226) RelADPP
                        (1227) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1228) RelADPP
                        (1229) RelADPCleverAfsProof [SOUND, 20 ms]
                        (1230) QDP
                        (1231) MRRProof [EQUIVALENT, 4 ms]
                        (1232) QDP
                        (1233) QDPOrderProof [EQUIVALENT, 9 ms]
                        (1234) QDP
                        (1235) PisEmptyProof [EQUIVALENT, 0 ms]
                        (1236) YES
                    (1237) RelADPP
                        (1238) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1239) RelADPP
                        (1240) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1241) RelADPP
                        (1242) RelADPCleverAfsProof [SOUND, 19 ms]
                        (1243) QDP
                        (1244) MRRProof [EQUIVALENT, 3 ms]
                        (1245) QDP
                        (1246) QDPOrderProof [EQUIVALENT, 5 ms]
                        (1247) QDP
                        (1248) PisEmptyProof [EQUIVALENT, 0 ms]
                        (1249) YES
            (1250) RelADPP
                (1251) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1252) OR
                    (1253) RelADPP
                        (1254) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1255) RelADPP
                        (1256) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1257) RelADPP
                        (1258) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1259) RelADPP
                        (1260) RelADPCleverAfsProof [SOUND, 26 ms]
                        (1261) QDP
                        (1262) MRRProof [EQUIVALENT, 3 ms]
                        (1263) QDP
                        (1264) QDPOrderProof [EQUIVALENT, 9 ms]
                        (1265) QDP
                        (1266) PisEmptyProof [EQUIVALENT, 0 ms]
                        (1267) YES
                    (1268) RelADPP
                        (1269) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1270) AND
                            (1271) RelADPP
                                (1272) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1273) RelADPP
                                (1274) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1275) RelADPP
                                (1276) RelADPCleverAfsProof [SOUND, 13 ms]
                                (1277) QDP
                                (1278) MRRProof [EQUIVALENT, 4 ms]
                                (1279) QDP
                                (1280) QDPOrderProof [EQUIVALENT, 5 ms]
                                (1281) QDP
                                (1282) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1283) YES
                            (1284) RelADPP
                                (1285) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (1286) RelADPP
                                (1287) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (1288) YES
                            (1289) RelADPP
                                (1290) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (1291) RelADPP
                                (1292) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (1293) YES
                            (1294) RelADPP
                                (1295) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1296) RelADPP
                                (1297) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1298) TRUE
                            (1299) RelADPP
                                (1300) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (1301) RelADPP
                                (1302) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (1303) YES
            (1304) RelADPP
                (1305) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (1306) AND
                    (1307) RelADPP
                        (1308) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1309) OR
                            (1310) RelADPP
                                (1311) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1312) RelADPP
                                (1313) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1314) RelADPP
                                (1315) RelADPCleverAfsProof [SOUND, 29 ms]
                                (1316) QDP
                                (1317) MRRProof [EQUIVALENT, 3 ms]
                                (1318) QDP
                                (1319) QDPOrderProof [EQUIVALENT, 4 ms]
                                (1320) QDP
                                (1321) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1322) YES
                            (1323) RelADPP
                                (1324) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1325) RelADPP
                                (1326) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1327) RelADPP
                                (1328) RelADPCleverAfsProof [SOUND, 13 ms]
                                (1329) QDP
                                (1330) MRRProof [EQUIVALENT, 3 ms]
                                (1331) QDP
                                (1332) QDPOrderProof [EQUIVALENT, 6 ms]
                                (1333) QDP
                                (1334) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1335) YES
                    (1336) RelADPP
                        (1337) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1338) OR
                            (1339) RelADPP
                                (1340) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1341) RelADPP
                                (1342) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1343) RelADPP
                                (1344) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1345) RelADPP
                                (1346) RelADPCleverAfsProof [SOUND, 8 ms]
                                (1347) QDP
                                (1348) MRRProof [EQUIVALENT, 7 ms]
                                (1349) QDP
                                (1350) QDPOrderProof [EQUIVALENT, 4 ms]
                                (1351) QDP
                                (1352) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1353) YES
                            (1354) RelADPP
                                (1355) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1356) AND
                                    (1357) RelADPP
                                        (1358) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1359) RelADPP
                                        (1360) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1361) RelADPP
                                        (1362) RelADPCleverAfsProof [SOUND, 6 ms]
                                        (1363) QDP
                                        (1364) MRRProof [EQUIVALENT, 3 ms]
                                        (1365) QDP
                                        (1366) QDPOrderProof [EQUIVALENT, 5 ms]
                                        (1367) QDP
                                        (1368) PisEmptyProof [EQUIVALENT, 0 ms]
                                        (1369) YES
                                    (1370) RelADPP
                                        (1371) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1372) RelADPP
                                        (1373) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1374) YES
                                    (1375) RelADPP
                                        (1376) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1377) RelADPP
                                        (1378) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1379) YES
                    (1380) RelADPP
                        (1381) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (1382) RelADPP
                        (1383) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1384) TRUE
                    (1385) RelADPP
                        (1386) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (1387) RelADPP
                        (1388) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1389) YES
                    (1390) RelADPP
                        (1391) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                        (1392) RelADPP
                        (1393) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1394) TRUE
                    (1395) RelADPP
                        (1396) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                        (1397) RelADPP
                        (1398) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (1399) YES
    (1400) RelADPP
        (1401) RelADPReductionPairProof [EQUIVALENT, 14 ms]
        (1402) RelADPP
        (1403) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (1404) TRUE
    (1405) RelADPP
        (1406) RelADPReductionPairProof [EQUIVALENT, 18 ms]
        (1407) RelADPP
        (1408) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (1409) TRUE
    (1410) RelADPP
        (1411) RelADPReductionPairProof [EQUIVALENT, 19 ms]
        (1412) RelADPP
        (1413) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (1414) YES


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))

The relative TRS consists of the following S rules:

   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   c(a(a(x1))) -> a(c(A(x1)))
   a(c(c(x1))) -> A(c(b(x1)))
   a(c(c(x1))) -> a(C(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(a(b(x1))) -> C(A(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(b(b(x1))) -> A(b(C(x1)))


----------------------------------------

(3) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  23 Lassos,
Result: This relative DT problem is equivalent to 24 subproblems.

----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))


----------------------------------------

(6) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(7)
Complex Obligation (OR)

----------------------------------------

(8)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))


----------------------------------------

(9) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(10)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(11) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(12)
Complex Obligation (OR)

----------------------------------------

(13)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(14) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(15)
Complex Obligation (OR)

----------------------------------------

(16)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(17) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(18)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(19) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(20)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(21) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(22)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(23) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(24)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(25) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(27) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(29) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(31)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(32) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(33)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(34) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(35)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(36) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(37)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(38) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(39)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(40) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(41)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(42) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(43)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(44) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(45)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(46)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(47) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(48)
Complex Obligation (OR)

----------------------------------------

(49)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(50) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(51)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(52) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(53)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(54) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(55)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(56) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(57)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(58) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(59)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(60) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(61)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(62) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(63)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(64)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(65) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(66)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(67) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(68)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(69) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(71) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(73) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(74)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(75) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(76)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(77) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(78)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(79)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(80) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(81)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(82) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(83)
Complex Obligation (OR)

----------------------------------------

(84)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(85) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(86)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(87) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(88)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(89) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(90)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(91) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(92)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(93) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(94)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(95) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(96)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(97)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(98) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(99)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(100) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(101)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(102) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(103)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(104) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(105)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(106) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(107)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(108) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(109)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(110)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))


----------------------------------------

(111) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(112)
Complex Obligation (OR)

----------------------------------------

(113)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))


----------------------------------------

(114) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(115)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(116) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(117)
Complex Obligation (OR)

----------------------------------------

(118)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(119) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(120)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(121) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(122)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(123) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(124)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(125) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(126)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(127) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(128)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(129) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(130)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(131) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(132)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(133)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(134) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(135)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(136) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(137)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(138) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(139)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(140) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(141)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(142) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(143)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(144) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(145)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(146) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(147)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(148)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(b(b(x1))) -> A(b(C(x1)))


----------------------------------------

(149) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(150)
Complex Obligation (OR)

----------------------------------------

(151)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))


----------------------------------------

(152) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(153)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(154) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(155)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(156) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(157)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(158) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(159)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(160) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(161)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(162) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(163)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(164) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(165)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(166) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(167)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(168)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))


----------------------------------------

(169) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  8 Lassos,
Result: This relative DT problem is equivalent to 9 subproblems.

----------------------------------------

(170)
Complex Obligation (AND)

----------------------------------------

(171)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(172) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(173)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(174) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(175)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(176) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(177)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(178) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(179)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(180) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(181)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(182) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(183)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(184) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(185)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(186)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(187) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(188)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(189) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(190)
TRUE

----------------------------------------

(191)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(192) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(193)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(194) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(195)
TRUE

----------------------------------------

(196)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(197) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(b(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(198)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(199) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(200)
YES

----------------------------------------

(201)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(202) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(203)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(204) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(205)
YES

----------------------------------------

(206)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(207) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(208)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(209) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(210)
YES

----------------------------------------

(211)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(212) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(213)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(214) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(215)
YES

----------------------------------------

(216)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(217) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(218)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(219) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(220)
YES

----------------------------------------

(221)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(b(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(222) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(b(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(223)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(224) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(225)
YES

----------------------------------------

(226)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))


----------------------------------------

(227) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  13 Lassos,
Result: This relative DT problem is equivalent to 14 subproblems.

----------------------------------------

(228)
Complex Obligation (AND)

----------------------------------------

(229)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(230) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(231)
Complex Obligation (OR)

----------------------------------------

(232)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(233) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(234)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(235) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(236)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(237) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(238)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(239) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(240)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(241) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(242)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(243) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(244)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(245) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(246)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(247)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(248) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(249)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(250) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(251)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(252) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(253)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(254) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(255)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(256) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(257)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(258) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(259)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(260) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(261)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(262)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(263) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(264)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(265) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(266)
TRUE

----------------------------------------

(267)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(268) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(269)
Complex Obligation (OR)

----------------------------------------

(270)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(271) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(272)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(273) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(274)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(275) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(276)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(277) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1, b_1] > [A_1, C_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(278)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(279) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(280)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(281) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(282)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(283) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(284)
YES

----------------------------------------

(285)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(286) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(287)
Complex Obligation (AND)

----------------------------------------

(288)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(289) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(290)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(291) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(292)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(293) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1, b_1] > [A_1, C_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(294)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(295) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(296)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(297) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(298)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(299) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(300)
YES

----------------------------------------

(301)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(302) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(303)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(304) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(305)
YES

----------------------------------------

(306)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(307) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(308)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(309) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(310)
YES

----------------------------------------

(311)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(312) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(b(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(313)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(314) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(315)
YES

----------------------------------------

(316)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(317) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(318)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(319) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(320)
YES

----------------------------------------

(321)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(322) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(323)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(324) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(325)
TRUE

----------------------------------------

(326)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(327) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(328)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(329) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(330)
YES

----------------------------------------

(331)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(332) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(333)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(334) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(335)
YES

----------------------------------------

(336)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(337) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(338)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(339) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(340)
TRUE

----------------------------------------

(341)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(342) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(C(x_1)) = 3 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(343)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(344) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(345)
YES

----------------------------------------

(346)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(347) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

Relative ADPs:

   a(c(c(x1))) -> C(A(b(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(348)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(349) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(350)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(351) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [C_1, a_1, c_1, b_1]

Status: C_1: [1]
a_1: multiset status
c_1: multiset status
b_1: multiset status


----------------------------------------

(352)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(353) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(354)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(355) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(356)
YES

----------------------------------------

(357)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(b(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(358) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(b(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(359)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(360) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(361)
YES

----------------------------------------

(362)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(363) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(364)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(365) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(366)
YES

----------------------------------------

(367)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(368) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(369)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(370) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(371)
TRUE

----------------------------------------

(372)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))


----------------------------------------

(373) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(374)
Complex Obligation (OR)

----------------------------------------

(375)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))


----------------------------------------

(376) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(377)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(378) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(379)
Complex Obligation (OR)

----------------------------------------

(380)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(381) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(382)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(383) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(384)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(385) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(386)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(387) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(388)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(389) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(390)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(391) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(392)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(393) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(394)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(395)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(396) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(397)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(398) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(399)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(400) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(401)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(402) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(403)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(404) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(405)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(406) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(407)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(408) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(409)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(410)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(b(b(x1))) -> A(b(C(x1)))


----------------------------------------

(411) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(412)
Complex Obligation (OR)

----------------------------------------

(413)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))


----------------------------------------

(414) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(415)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(416) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(417)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))


----------------------------------------

(418) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(419)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(420) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(421)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(422) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(423)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(424) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(425)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(426) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(427)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(428) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(429)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(430) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(431)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(432) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(433)
YES

----------------------------------------

(434)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))


----------------------------------------

(435) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  8 Lassos,
Result: This relative DT problem is equivalent to 9 subproblems.

----------------------------------------

(436)
Complex Obligation (AND)

----------------------------------------

(437)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(438) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(439)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(440) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(441)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(442) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(443)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(444) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(445)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(446) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(447)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(448) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(449)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(450) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(451)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(452) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(453)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(454)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(455) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(456)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(457) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(458)
YES

----------------------------------------

(459)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(460) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(461)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(462) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(463)
TRUE

----------------------------------------

(464)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(465) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(466)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(467) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(468)
TRUE

----------------------------------------

(469)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(470) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(471)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(472) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(473)
YES

----------------------------------------

(474)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(475) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(b(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(476)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(477) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(478)
YES

----------------------------------------

(479)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(480) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(481)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(482) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(483)
YES

----------------------------------------

(484)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(485) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(486)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(487) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(488)
YES

----------------------------------------

(489)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(b(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(490) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(b(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(491)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(492) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(493)
YES

----------------------------------------

(494)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))


----------------------------------------

(495) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  13 Lassos,
Result: This relative DT problem is equivalent to 14 subproblems.

----------------------------------------

(496)
Complex Obligation (AND)

----------------------------------------

(497)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(498) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(499)
Complex Obligation (OR)

----------------------------------------

(500)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(501) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(502)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(503) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(504)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(505) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(506)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(507) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(508)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(509) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(510)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(511) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(512)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(513) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(514)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(515)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(516) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(517)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(518) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(519)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(520) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(521)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(522) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(523)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(524) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(525)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(526) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(527)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(528) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(529)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(530)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(531) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> C(b(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 0

----------------------------------------

(532)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(533) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(534)
TRUE

----------------------------------------

(535)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(536) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(537)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(538) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(539)
YES

----------------------------------------

(540)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(541) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(542)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(543) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(544)
TRUE

----------------------------------------

(545)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(546) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(547)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(548) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(549)
YES

----------------------------------------

(550)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(551) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 0

----------------------------------------

(552)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(553) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(554)
YES

----------------------------------------

(555)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(556) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(557)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(558) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(559)
YES

----------------------------------------

(560)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(561) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(562)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(563) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [C_1, a_1, c_1, b_1]

Status: C_1: [1]
a_1: multiset status
c_1: multiset status
b_1: multiset status


----------------------------------------

(564)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(565) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(566)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(567) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(568)
YES

----------------------------------------

(569)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(570) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(571)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(572) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(573)
YES

----------------------------------------

(574)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(575) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 0

----------------------------------------

(576)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(577) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(578)
YES

----------------------------------------

(579)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(580) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(581)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(582) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(583)
TRUE

----------------------------------------

(584)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(585) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 0

----------------------------------------

(586)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(587) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(588)
YES

----------------------------------------

(589)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(590) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(591)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(592) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(593)
YES

----------------------------------------

(594)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(595) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(596)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(597) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(598)
YES

----------------------------------------

(599)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))


----------------------------------------

(600) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  18 Lassos,
Result: This relative DT problem is equivalent to 19 subproblems.

----------------------------------------

(601)
Complex Obligation (AND)

----------------------------------------

(602)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(603) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(604)
Complex Obligation (OR)

----------------------------------------

(605)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(606) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(607)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(608) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(609)
Complex Obligation (OR)

----------------------------------------

(610)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(611) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(612)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(613) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(614)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(615) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(616)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(617) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(618)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(619) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(620)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(621) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(622)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(623)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(624) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(625)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(626) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(627)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(628) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(629)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(630) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(631)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(632) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(633)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(634) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(635)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(636)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(637) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(638)
Complex Obligation (OR)

----------------------------------------

(639)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(640) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(641)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(642) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(643)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(644) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(645)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(646) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(647)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(648) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(649)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(650) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(651)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(652) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(653)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(654)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(655) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(656)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(657) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(658)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(659) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(660)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(661) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(662)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(663) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(664)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(665) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(666)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(667) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(668)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(669)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(670) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(671)
Complex Obligation (OR)

----------------------------------------

(672)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(673) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(674)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(675) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(676)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(677) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(678)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(679) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(680)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(681) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(682)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(683) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(684)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(685) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(686)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(687)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(688) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(689)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(690) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(691)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> A(a(b(x1)))
   c(a(a(x1))) -> a(C(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(A(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(692) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, c_1, C_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(693)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(694) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(b0(b0(x1))) -> A0(b0(x1))
   A0(a0(b0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))
   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(695)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> A0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(696) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(697)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(698) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule A0(a0(b0(x1))) -> C0(a0(b0(x1))) at position [0] we obtained the following new rules [LPAR04]:

   (A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0)))))
   (A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))),A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0)))))


----------------------------------------

(699)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(b0(b0(x0)))) -> C0(a0(a0(b0(x0))))
   A0(a0(b0(b0(x0)))) -> C0(a0(b0(c0(x0))))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(700) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(701)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(702)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(703) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(704)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(705) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(706)
YES

----------------------------------------

(707)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(708) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(709)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(710) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(711)
YES

----------------------------------------

(712)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(713) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 0

----------------------------------------

(714)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(715) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(716)
YES

----------------------------------------

(717)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(718) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(719)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(720) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(721)
TRUE

----------------------------------------

(722)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(723) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(724)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(725) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(726)
YES

----------------------------------------

(727)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(728) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(729)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(730) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(731)
YES

----------------------------------------

(732)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(733) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(734)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(735) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(736)
TRUE

----------------------------------------

(737)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(738) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 0

----------------------------------------

(739)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(740) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(741)
YES

----------------------------------------

(742)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(743) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 0

----------------------------------------

(744)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(745) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(746)
YES

----------------------------------------

(747)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(748) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> C(b(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 0

----------------------------------------

(749)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(750) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(751)
TRUE

----------------------------------------

(752)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(753) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(754)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(755) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [C_1, a_1, c_1, b_1]

Status: C_1: [1]
a_1: multiset status
c_1: multiset status
b_1: multiset status


----------------------------------------

(756)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(757) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(758)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(759) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(760)
YES

----------------------------------------

(761)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(762) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(763)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(764) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(765)
TRUE

----------------------------------------

(766)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(767) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

Relative ADPs:

   a(c(c(x1))) -> C(A(b(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(768)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(769) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(770)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(771) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [C_1, a_1, c_1, b_1]

Status: C_1: [1]
a_1: multiset status
c_1: multiset status
b_1: multiset status


----------------------------------------

(772)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(773) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(774)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(775) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(776)
YES

----------------------------------------

(777)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(778) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(779)
Complex Obligation (OR)

----------------------------------------

(780)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(781) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(782)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(783) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(784)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(785) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(786)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(787) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1, b_1] > [A_1, C_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(788)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(789) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(790)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(791) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(792)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(793) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(794)
YES

----------------------------------------

(795)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(796) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(797)
Complex Obligation (AND)

----------------------------------------

(798)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(799) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(800)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(801) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(802)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(803) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1, b_1] > [A_1, C_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(804)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(805) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(806)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(807) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(808)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(809) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(810)
YES

----------------------------------------

(811)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(812) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(813)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(814) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(815)
YES

----------------------------------------

(816)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(817) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(818)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(819) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(820)
YES

----------------------------------------

(821)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(822) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(823)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(824) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(825)
TRUE

----------------------------------------

(826)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(827) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(828)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(829) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(830)
YES

----------------------------------------

(831)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(832) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(833)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(834) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(835)
YES

----------------------------------------

(836)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(837) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(C(x_1)) = 3 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(838)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(839) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(840)
YES

----------------------------------------

(841)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(842) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(843)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(844) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(845)
TRUE

----------------------------------------

(846)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(847) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 0

----------------------------------------

(848)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(849) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> C(b(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 0

----------------------------------------

(850)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(851) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(852)
TRUE

----------------------------------------

(853)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(854) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 0

----------------------------------------

(855)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(856) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(857)
YES

----------------------------------------

(858)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(859) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(860)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(861) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(862)
TRUE

----------------------------------------

(863)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> a(C(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(864) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(C(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(865)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(866) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(867)
YES

----------------------------------------

(868)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(869) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(870)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(871) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [C_1, a_1, c_1, b_1]

Status: C_1: [1]
a_1: multiset status
c_1: multiset status
b_1: multiset status


----------------------------------------

(872)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(873) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(874)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(875) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(876)
YES

----------------------------------------

(877)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(878) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

Relative ADPs:

   a(c(c(x1))) -> C(A(b(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(879)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(880) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(881)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(882) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [C_1, a_1, c_1, b_1]

Status: C_1: [1]
a_1: multiset status
c_1: multiset status
b_1: multiset status


----------------------------------------

(883)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(884) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(885)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(886) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(887)
YES

----------------------------------------

(888)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(889) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 0

----------------------------------------

(890)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(891) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(892)
YES

----------------------------------------

(893)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(894) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 0

----------------------------------------

(895)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(896) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(897)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(898) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [C_1, a_1, c_1, b_1]

Status: C_1: [1]
a_1: multiset status
c_1: multiset status
b_1: multiset status


----------------------------------------

(899)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(900) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(901)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(902) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(903)
YES

----------------------------------------

(904)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(905) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(b(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(906)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(907) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(908)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(909) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [C_1, a_1, c_1, b_1]

Status: C_1: [1]
a_1: multiset status
c_1: multiset status
b_1: multiset status


----------------------------------------

(910)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(911) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(912)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(913) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(914)
YES

----------------------------------------

(915)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(916) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(917)
Complex Obligation (OR)

----------------------------------------

(918)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(919) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(920)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(921) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(922)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(923) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(924)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(925) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1, b_1] > [A_1, C_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(926)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(927) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(928)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(929) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(930)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(931) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(932)
YES

----------------------------------------

(933)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(934) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(935)
Complex Obligation (AND)

----------------------------------------

(936)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(937) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(938)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(939) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(940)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(941) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1, b_1] > [A_1, C_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(942)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(943) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(944)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(945) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(946)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(947) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(948)
YES

----------------------------------------

(949)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(950) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(951)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(952) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(953)
YES

----------------------------------------

(954)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(955) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(956)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(957) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(958)
YES

----------------------------------------

(959)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(960) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> C(b(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 0

----------------------------------------

(961)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(962) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(963)
TRUE

----------------------------------------

(964)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(965) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(966)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(967) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(968)
YES

----------------------------------------

(969)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(970) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(C(x_1)) = 3 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(971)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(972) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(973)
YES

----------------------------------------

(974)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(975) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(976)
Complex Obligation (OR)

----------------------------------------

(977)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(978) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(979)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(980) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 0

----------------------------------------

(981)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(982) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(983)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(984) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: trivial

Status: a_1: multiset status


----------------------------------------

(985)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(986) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(987)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(988) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(989)
YES

----------------------------------------

(990)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(991) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(992)
Complex Obligation (AND)

----------------------------------------

(993)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(994) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(995)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(996) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(997)
YES

----------------------------------------

(998)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(999) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(1000)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1001) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(1002)
TRUE

----------------------------------------

(1003)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1004) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(1005)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1006) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1007)
YES

----------------------------------------

(1008)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1009) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1010)
Complex Obligation (OR)

----------------------------------------

(1011)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1012) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1013)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1014) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1015)
Complex Obligation (OR)

----------------------------------------

(1016)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1017) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1018)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1019) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1020)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1021) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, C_1] > [c_1, a_1, b_1]

Status: A_1: [1]
c_1: multiset status
C_1: [1]
a_1: multiset status
b_1: multiset status


----------------------------------------

(1022)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1023) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1024)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1025) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(1026)
TRUE

----------------------------------------

(1027)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1028) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1029)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1030) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(1031)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1032) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1033)
YES

----------------------------------------

(1034)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1035) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1036)
Complex Obligation (OR)

----------------------------------------

(1037)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1038) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1039)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1040) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1041)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1042) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1043)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1044) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, C_1] > [c_1, a_1, b_1]

Status: A_1: [1]
c_1: multiset status
C_1: [1]
a_1: multiset status
b_1: multiset status


----------------------------------------

(1045)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1046) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1047)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1048) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(1049)
TRUE

----------------------------------------

(1050)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1051) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  4 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(1052)
Complex Obligation (AND)

----------------------------------------

(1053)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1054) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1055)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1056) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1057)
YES

----------------------------------------

(1058)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1059) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(1060)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1061) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(1062)
TRUE

----------------------------------------

(1063)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1064) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(1065)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1066) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1067)
YES

----------------------------------------

(1068)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1069) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(1070)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1071) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1072)
YES

----------------------------------------

(1073)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1074) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(1075)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1076) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1077)
YES

----------------------------------------

(1078)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1079) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  5 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(1080)
Complex Obligation (AND)

----------------------------------------

(1081)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1082) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 2 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(1083)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1084) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1085)
YES

----------------------------------------

(1086)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1087) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(C(x_1)) = 3 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1088)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1089) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1090)
YES

----------------------------------------

(1091)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1092) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(1093)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1094) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(1095)
TRUE

----------------------------------------

(1096)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1097) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1098)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1099) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(1100)
TRUE

----------------------------------------

(1101)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1102) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(1103)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1104) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1105)
YES

----------------------------------------

(1106)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1107) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(1108)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1109) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1110)
YES

----------------------------------------

(1111)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1112) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1113)
Complex Obligation (OR)

----------------------------------------

(1114)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1115) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1116)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1117) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(a(b(x1))) -> C(A(b(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 0

----------------------------------------

(1118)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1119) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1120)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1121) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(1122)
TRUE

----------------------------------------

(1123)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1124) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1125)
Complex Obligation (OR)

----------------------------------------

(1126)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1127) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1128)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1129) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 2 + 3*x_1
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 0

----------------------------------------

(1130)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1131) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1132)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(b(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1133) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, a_1, b_1, C_1, c_1]

Status: A_1: multiset status
a_1: multiset status
b_1: multiset status
C_1: multiset status
c_1: multiset status


----------------------------------------

(1134)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(b0(x1))) -> C0(a0(b0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1135) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(1136)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(b0(x1))) -> C0(a0(b0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1137) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(1138)
TRUE

----------------------------------------

(1139)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1140) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  4 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(1141)
Complex Obligation (AND)

----------------------------------------

(1142)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1143) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(b(x1))) -> C(a(b(x1)))
   a(a(b(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1144)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1145) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1146)
YES

----------------------------------------

(1147)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(b(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1148) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(b(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(1149)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1150) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1151)
YES

----------------------------------------

(1152)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1153) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(1154)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1155) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1156)
YES

----------------------------------------

(1157)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1158) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(1159)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1160) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(1161)
TRUE

----------------------------------------

(1162)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1163) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(b(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(1164)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1165) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1166)
YES

----------------------------------------

(1167)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1168) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  5 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(1169)
Complex Obligation (AND)

----------------------------------------

(1170)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1171) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))
   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1172)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1173) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1174)
YES

----------------------------------------

(1175)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1176) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(1177)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1178) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(1179)
TRUE

----------------------------------------

(1180)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1181) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 0

----------------------------------------

(1182)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1183) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1184)
YES

----------------------------------------

(1185)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1186) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(1187)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1188) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1189)
YES

----------------------------------------

(1190)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1191) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(1192)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1193) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1194)
YES

----------------------------------------

(1195)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1196) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(1197)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1198) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1199)
YES

----------------------------------------

(1200)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1201) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> C(b(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 0

----------------------------------------

(1202)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1203) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(1204)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(C(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1205) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [C_1, a_1, c_1, b_1]

Status: C_1: [1]
a_1: multiset status
c_1: multiset status
b_1: multiset status


----------------------------------------

(1206)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(a0(x1))) -> C0(a0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1207) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   C0(a0(a0(x1))) -> C0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1208)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1209) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1210)
YES

----------------------------------------

(1211)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1212) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(a(x1))) -> a(c(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(1213)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1214) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1215)
YES

----------------------------------------

(1216)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1217) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1218)
Complex Obligation (OR)

----------------------------------------

(1219)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1220) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1221)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1222) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1223)
Complex Obligation (OR)

----------------------------------------

(1224)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1225) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1226)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1227) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1228)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1229) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, C_1] > [c_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(1230)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> A0(b0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1231) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1232)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1233) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(1234)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1235) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1236)
YES

----------------------------------------

(1237)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1238) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1239)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1240) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1241)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1242) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, C_1] > [c_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(1243)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> A0(b0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1244) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1245)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1246) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(1247)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1248) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1249)
YES

----------------------------------------

(1250)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1251) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1252)
Complex Obligation (OR)

----------------------------------------

(1253)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1254) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1255)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> A(b(C(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1256) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1257)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1258) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1259)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1260) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, C_1] > [c_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(1261)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> A0(b0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1262) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1263)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1264) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(1265)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1266) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1267)
YES

----------------------------------------

(1268)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1269) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  4 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(1270)
Complex Obligation (AND)

----------------------------------------

(1271)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1272) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1273)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1274) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1275)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1276) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, C_1] > [c_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(1277)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> A0(b0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1278) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1279)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1280) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(1281)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1282) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1283)
YES

----------------------------------------

(1284)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1285) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(1286)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1287) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1288)
YES

----------------------------------------

(1289)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1290) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(1291)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1292) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1293)
YES

----------------------------------------

(1294)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1295) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(1296)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1297) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(1298)
TRUE

----------------------------------------

(1299)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1300) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(1301)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1302) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1303)
YES

----------------------------------------

(1304)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))


----------------------------------------

(1305) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  5 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(1306)
Complex Obligation (AND)

----------------------------------------

(1307)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1308) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1309)
Complex Obligation (OR)

----------------------------------------

(1310)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1311) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1312)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1313) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1314)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1315) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, C_1] > [c_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(1316)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> A0(b0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1317) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1318)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1319) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(1320)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1321) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1322)
YES

----------------------------------------

(1323)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1324) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1325)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1326) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1327)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(b(b(x1))) -> a(b(C(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1328) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [A_1, C_1] > [c_1, a_1, b_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(1329)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
   A0(c0(c0(x1))) -> A0(b0(x1))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1330) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> C0(x1)
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(c0(x1))) -> A0(b0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1331)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1332) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(1333)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1334) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1335)
YES

----------------------------------------

(1336)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1337) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1338)
Complex Obligation (OR)

----------------------------------------

(1339)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1340) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1341)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1342) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1343)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1344) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1345)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1346) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1, b_1] > [A_1, C_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(1347)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1348) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1349)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1350) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(1351)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1352) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1353)
YES

----------------------------------------

(1354)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1355) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1356)
Complex Obligation (AND)

----------------------------------------

(1357)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1358) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1359)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))
   a(a(a(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1360) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(1361)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))
   a(c(c(x1))) -> C(a(b(x1)))
   a(a(a(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1362) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1, b_1] > [A_1, C_1]

Status: A_1: multiset status
c_1: multiset status
C_1: multiset status
a_1: multiset status
b_1: multiset status


----------------------------------------

(1363)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   A0(a0(a0(x1))) -> A0(x1)
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1364) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 1 + x_1
   POL(C0(x_1)) = 1 + x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1365)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1366) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(c0(c0(x1))) -> C0(a0(b0(x1)))
   C0(a0(a0(x1))) -> A0(c0(a0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(A0(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(c0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(C0(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(a0(x_1)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(b0(x_1)) =  	[[0], [1]] 	 +  	[[0, 1], [0, 1]] 	* 	x_1
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))


----------------------------------------

(1367)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(c0(x1))) -> a0(c0(b0(x1)))
   a0(a0(b0(x1))) -> c0(a0(b0(x1)))
   c0(a0(a0(x1))) -> a0(c0(a0(x1)))
   a0(c0(c0(x1))) -> c0(a0(b0(x1)))
   a0(b0(b0(x1))) -> a0(a0(b0(x1)))
   a0(a0(a0(x1))) -> c0(b0(a0(x1)))
   a0(b0(b0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1368) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1369)
YES

----------------------------------------

(1370)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1371) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> C(a(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(1372)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1373) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1374)
YES

----------------------------------------

(1375)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1376) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> c(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(1377)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1378) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1379)
YES

----------------------------------------

(1380)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1381) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(1382)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1383) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(1384)
TRUE

----------------------------------------

(1385)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1386) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(1387)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1388) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1389)
YES

----------------------------------------

(1390)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1391) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1392)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(c(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1393) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(1394)
TRUE

----------------------------------------

(1395)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1396) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(C(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(1397)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(c(c(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1398) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1399)
YES

----------------------------------------

(1400)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(c(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1401) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(1402)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(c(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1403) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(1404)
TRUE

----------------------------------------

(1405)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1406) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> C(A(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> C(b(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 0

----------------------------------------

(1407)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> A(c(a(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1408) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(1409)
TRUE

----------------------------------------

(1410)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1411) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   a(a(a(x1))) -> C(b(A(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(1412)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(c(x1))) -> a(c(b(x1)))
   a(a(b(x1))) -> c(a(b(x1)))
   c(a(a(x1))) -> a(c(a(x1)))
   a(c(c(x1))) -> c(a(b(x1)))
   a(b(b(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> c(b(a(x1)))
   a(b(b(x1))) -> a(b(c(x1)))


----------------------------------------

(1413) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1414)
YES
