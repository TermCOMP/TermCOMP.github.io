YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/ZuMDy.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRS S Cleaner [EQUIVALENT, 0 ms]
(2) RelTRS
(3) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(4) RelADPP
(5) RelADPDepGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) RelADPP
        (8) RelADPRuleRemovalProof [EQUIVALENT, 5 ms]
        (9) RelADPP
        (10) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (11) AND
            (12) RelADPP
                (13) RelADPCleverAfsProof [SOUND, 0 ms]
                (14) QDP
                (15) MRRProof [EQUIVALENT, 0 ms]
                (16) QDP
                (17) PisEmptyProof [EQUIVALENT, 0 ms]
                (18) YES
            (19) RelADPP
                (20) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (21) OR
                    (22) RelADPP
                        (23) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (24) AND
                            (25) RelADPP
                                (26) RelADPCleverAfsProof [SOUND, 2 ms]
                                (27) QDP
                                (28) MRRProof [EQUIVALENT, 0 ms]
                                (29) QDP
                                (30) PisEmptyProof [EQUIVALENT, 0 ms]
                                (31) YES
                            (32) RelADPP
                                (33) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (34) RelADPP
                                (35) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (36) RelADPP
                                (37) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (38) RelADPP
                                (39) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (40) QDP
                                (41) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (42) YES
                            (43) RelADPP
                                (44) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (45) RelADPP
                                (46) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (47) RelADPP
                                (48) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (49) RelADPP
                                (50) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (51) QDP
                                (52) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (53) YES
                            (54) RelADPP
                                (55) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (56) RelADPP
                                (57) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (58) YES
                            (59) RelADPP
                                (60) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (61) RelADPP
                                (62) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                (63) YES
                    (64) RelADPP
                        (65) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (66) AND
                            (67) RelADPP
                                (68) RelADPCleverAfsProof [SOUND, 1 ms]
                                (69) QDP
                                (70) MRRProof [EQUIVALENT, 0 ms]
                                (71) QDP
                                (72) PisEmptyProof [EQUIVALENT, 0 ms]
                                (73) YES
                            (74) RelADPP
                                (75) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (76) OR
                                    (77) RelADPP
                                        (78) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (79) RelADPP
                                        (80) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (81) RelADPP
                                        (82) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (83) RelADPP
                                        (84) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (85) QDP
                                    (86) RelADPP
                                        (87) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (88) AND
                                            (89) RelADPP
                                                (90) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (91) RelADPP
                                                (92) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (93) QDP
                                            (94) RelADPP
                                                (95) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (96) RelADPP
                                                (97) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (98) RelADPP
                                                (99) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (100) QDP
                                            (101) RelADPP
                                                (102) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (103) RelADPP
                                                (104) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (105) QDP
                                            (106) RelADPP
                                                (107) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (108) RelADPP
                                                (109) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (110) QDP
                            (111) RelADPP
                                (112) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (113) OR
                                    (114) RelADPP
                                        (115) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (116) AND
                                            (117) RelADPP
                                                (118) RelADPCleverAfsProof [SOUND, 1 ms]
                                                (119) QDP
                                                (120) MRRProof [EQUIVALENT, 2 ms]
                                                (121) QDP
                                                (122) PisEmptyProof [EQUIVALENT, 0 ms]
                                                (123) YES
                                            (124) RelADPP
                                                (125) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                                (126) RelADPP
                                                (127) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (128) RelADPP
                                                (129) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (130) RelADPP
                                                (131) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                                (132) QDP
                                            (133) RelADPP
                                                (134) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                                (135) RelADPP
                                                (136) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                                (137) YES
                                            (138) RelADPP
                                                (139) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                                (140) RelADPP
                                                (141) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                                (142) YES
                                            (143) RelADPP
                                                (144) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (145) RelADPP
                                                (146) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (147) RelADPP
                                                (148) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                                (149) QDP
                                    (150) RelADPP
                                        (151) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (152) AND
                                            (153) RelADPP
                                                (154) RelADPCleverAfsProof [SOUND, 1 ms]
                                                (155) QDP
                                                (156) MRRProof [EQUIVALENT, 2 ms]
                                                (157) QDP
                                                (158) PisEmptyProof [EQUIVALENT, 0 ms]
                                                (159) YES
                                            (160) RelADPP
                                                (161) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (162) RelADPP
                                                (163) RelADPCleverAfsProof [SOUND, 2 ms]
                                                (164) QDP
                                            (165) RelADPP
                                                (166) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (167) RelADPP
                                                (168) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (169) AND
                                                    (170) RelADPP
                                                        (171) RelADPCleverAfsProof [SOUND, 0 ms]
                                                        (172) QDP
                                                    (173) RelADPP
                                                        (174) RelADPCleverAfsProof [SOUND, 0 ms]
                                                        (175) QDP
                                            (176) RelADPP
                                                (177) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (178) RelADPP
                                                (179) RelADPCleverAfsProof [SOUND, 0 ms]
                                                (180) QDP
                                            (181) RelADPP
                                                (182) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (183) RelADPP
                                                (184) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (185) RelADPP
                                                (186) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (187) QDP
                            (188) RelADPP
                                (189) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (190) OR
                                    (191) RelADPP
                                        (192) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (193) RelADPP
                                        (194) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (195) RelADPP
                                        (196) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (197) RelADPP
                                        (198) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (199) QDP
                                    (200) RelADPP
                                        (201) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (202) AND
                                            (203) RelADPP
                                                (204) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (205) RelADPP
                                                (206) RelADPCleverAfsProof [SOUND, 4 ms]
                                                (207) QDP
                                            (208) RelADPP
                                                (209) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (210) RelADPP
                                                (211) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (212) QDP
                                            (213) RelADPP
                                                (214) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (215) RelADPP
                                                (216) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (217) RelADPP
                                                (218) RelADPCleverAfsProof [SOUND, 2 ms]
                                                (219) QDP
                                            (220) RelADPP
                                                (221) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (222) RelADPP
                                                (223) RelADPCleverAfsProof [SOUND, 0 ms]
                                                (224) QDP
                            (225) RelADPP
                                (226) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (227) OR
                                    (228) RelADPP
                                        (229) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (230) AND
                                            (231) RelADPP
                                                (232) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                                (233) RelADPP
                                                (234) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (235) RelADPP
                                                (236) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (237) RelADPP
                                                (238) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                                (239) QDP
                                            (240) RelADPP
                                                (241) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                                (242) RelADPP
                                                (243) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                                (244) YES
                                            (245) RelADPP
                                                (246) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (247) RelADPP
                                                (248) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (249) RelADPP
                                                (250) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                                (251) QDP
                                            (252) RelADPP
                                                (253) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                                (254) RelADPP
                                                (255) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                                (256) YES
                                    (257) RelADPP
                                        (258) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (259) AND
                                            (260) RelADPP
                                                (261) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (262) RelADPP
                                                (263) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (264) QDP
                                            (265) RelADPP
                                                (266) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (267) RelADPP
                                                (268) RelADPCleverAfsProof [SOUND, 4 ms]
                                                (269) QDP
                                            (270) RelADPP
                                                (271) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (272) RelADPP
                                                (273) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (274) RelADPP
                    (275) RelADPP
                        (276) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (277) AND
                            (278) RelADPP
                                (279) RelADPCleverAfsProof [SOUND, 2 ms]
                                (280) QDP
                                (281) MRRProof [EQUIVALENT, 0 ms]
                                (282) QDP
                                (283) PisEmptyProof [EQUIVALENT, 0 ms]
                                (284) YES
                            (285) RelADPP
                                (286) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (287) OR
                                    (288) RelADPP
                                        (289) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (290) RelADPP
                                        (291) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (292) QDP
                                    (293) RelADPP
                                        (294) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (295) AND
                                            (296) RelADPP
                                                (297) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (298) RelADPP
                                                (299) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (300) QDP
                                            (301) RelADPP
                                                (302) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (303) RelADPP
                                                (304) RelADPCleverAfsProof [SOUND, 2 ms]
                                                (305) QDP
                                            (306) RelADPP
                                                (307) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (308) RelADPP
                                                (309) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (310) QDP
                                            (311) RelADPP
                                                (312) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (313) RelADPP
                                                (314) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (315) RelADPP
                                                (316) RelADPCleverAfsProof [SOUND, 0 ms]
                                                (317) QDP
                            (318) RelADPP
                                (319) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (320) OR
                                    (321) RelADPP
                                        (322) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (323) AND
                                            (324) RelADPP
                                                (325) RelADPCleverAfsProof [SOUND, 2 ms]
                                                (326) QDP
                                                (327) MRRProof [EQUIVALENT, 1 ms]
                                                (328) QDP
                                                (329) PisEmptyProof [EQUIVALENT, 0 ms]
                                                (330) YES
                                            (331) RelADPP
                                                (332) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                                (333) RelADPP
                                                (334) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                                (335) QDP
                                            (336) RelADPP
                                                (337) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                                (338) RelADPP
                                                (339) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                                (340) QDP
                                            (341) RelADPP
                                                (342) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                                (343) RelADPP
                                                (344) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                                (345) YES
                                            (346) RelADPP
                                                (347) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                                (348) RelADPP
                                                (349) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                                (350) YES
                                    (351) RelADPP
                                        (352) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (353) AND
                                            (354) RelADPP
                                                (355) RelADPCleverAfsProof [SOUND, 1 ms]
                                                (356) QDP
                                                (357) MRRProof [EQUIVALENT, 1 ms]
                                                (358) QDP
                                                (359) PisEmptyProof [EQUIVALENT, 0 ms]
                                                (360) YES
                                            (361) RelADPP
                                                (362) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (363) RelADPP
                                                (364) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (365) QDP
                                            (366) RelADPP
                                                (367) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (368) RelADPP
                                                (369) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (370) AND
                                                    (371) RelADPP
                                                        (372) RelADPCleverAfsProof [SOUND, 1 ms]
                                                        (373) QDP
                                                    (374) RelADPP
                                                        (375) RelADPCleverAfsProof [SOUND, 0 ms]
                                                        (376) QDP
                                            (377) RelADPP
                                                (378) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (379) RelADPP
                                                (380) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (381) QDP
                                            (382) RelADPP
                                                (383) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (384) RelADPP
                                                (385) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (386) RelADPP
                                                (387) RelADPCleverAfsProof [SOUND, 0 ms]
                                                (388) QDP
                            (389) RelADPP
                                (390) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (391) OR
                                    (392) RelADPP
                                        (393) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (394) RelADPP
                                        (395) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (396) QDP
                                    (397) RelADPP
                                        (398) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (399) AND
                                            (400) RelADPP
                                                (401) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (402) RelADPP
                                                (403) RelADPCleverAfsProof [SOUND, 2 ms]
                                                (404) QDP
                                            (405) RelADPP
                                                (406) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (407) RelADPP
                                                (408) RelADPCleverAfsProof [SOUND, 4 ms]
                                                (409) QDP
                                            (410) RelADPP
                                                (411) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (412) RelADPP
                                                (413) RelADPCleverAfsProof [SOUND, 4 ms]
                                                (414) QDP
                                            (415) RelADPP
                                                (416) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (417) RelADPP
                                                (418) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (419) RelADPP
                                                (420) RelADPCleverAfsProof [SOUND, 0 ms]
                                                (421) QDP
                            (422) RelADPP
                                (423) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (424) OR
                                    (425) RelADPP
                                        (426) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (427) AND
                                            (428) RelADPP
                                                (429) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                                (430) RelADPP
                                                (431) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                                (432) QDP
                                            (433) RelADPP
                                                (434) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                                (435) RelADPP
                                                (436) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                                (437) YES
                                            (438) RelADPP
                                                (439) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                                (440) RelADPP
                                                (441) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                                (442) QDP
                                            (443) RelADPP
                                                (444) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                                (445) RelADPP
                                                (446) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                                (447) YES
                                    (448) RelADPP
                                        (449) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (450) AND
                                            (451) RelADPP
                                                (452) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (453) RelADPP
                                                (454) RelADPCleverAfsProof [SOUND, 4 ms]
                                                (455) QDP
                                            (456) RelADPP
                                                (457) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (458) RelADPP
                                                (459) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (460) QDP
                                            (461) RelADPP
                                                (462) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                                (463) RelADPP
                                                (464) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                                (465) RelADPP
                                                (466) RelADPCleverAfsProof [SOUND, 2 ms]
                                                (467) QDP
            (468) RelADPP
                (469) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                (470) RelADPP
                (471) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                (472) YES
    (473) RelADPP
        (474) RelADPRuleRemovalProof [EQUIVALENT, 6 ms]
        (475) RelADPP
        (476) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (477) OR
            (478) RelADPP
                (479) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (480) AND
                    (481) RelADPP
                        (482) RelADPCleverAfsProof [SOUND, 1 ms]
                        (483) QDP
                        (484) MRRProof [EQUIVALENT, 3 ms]
                        (485) QDP
                        (486) PisEmptyProof [EQUIVALENT, 0 ms]
                        (487) YES
                    (488) RelADPP
                        (489) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                        (490) RelADPP
                        (491) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (492) RelADPP
                        (493) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (494) RelADPP
                        (495) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (496) QDP
                        (497) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (498) YES
                    (499) RelADPP
                        (500) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                        (501) RelADPP
                        (502) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (503) RelADPP
                        (504) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (505) RelADPP
                        (506) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (507) QDP
                        (508) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (509) YES
                    (510) RelADPP
                        (511) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                        (512) RelADPP
                        (513) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (514) YES
                    (515) RelADPP
                        (516) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                        (517) RelADPP
                        (518) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (519) YES
            (520) RelADPP
                (521) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (522) AND
                    (523) RelADPP
                        (524) RelADPCleverAfsProof [SOUND, 3 ms]
                        (525) QDP
                        (526) MRRProof [EQUIVALENT, 2 ms]
                        (527) QDP
                        (528) PisEmptyProof [EQUIVALENT, 0 ms]
                        (529) YES
                    (530) RelADPP
                        (531) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (532) OR
                            (533) RelADPP
                                (534) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (535) RelADPP
                                (536) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (537) RelADPP
                                (538) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (539) RelADPP
                                (540) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (541) QDP
                            (542) RelADPP
                                (543) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (544) AND
                                    (545) RelADPP
                                        (546) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (547) RelADPP
                                        (548) RelADPCleverAfsProof [SOUND, 3 ms]
                                        (549) QDP
                                        (550) MRRProof [EQUIVALENT, 0 ms]
                                        (551) QDP
                                    (552) RelADPP
                                        (553) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (554) RelADPP
                                        (555) RelADPCleverAfsProof [SOUND, 3 ms]
                                        (556) QDP
                                    (557) RelADPP
                                        (558) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (559) RelADPP
                                        (560) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (561) QDP
                                        (562) MRRProof [EQUIVALENT, 0 ms]
                                        (563) QDP
                                    (564) RelADPP
                                        (565) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (566) RelADPP
                                        (567) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (568) RelADPP
                                        (569) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (570) QDP
                                        (571) MRRProof [EQUIVALENT, 0 ms]
                                        (572) QDP
                    (573) RelADPP
                        (574) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (575) OR
                            (576) RelADPP
                                (577) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                (578) RelADPP
                                (579) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (580) RelADPP
                                (581) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (582) RelADPP
                                (583) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (584) QDP
                            (585) RelADPP
                                (586) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (587) AND
                                    (588) RelADPP
                                        (589) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (590) RelADPP
                                        (591) RelADPCleverAfsProof [SOUND, 8 ms]
                                        (592) QDP
                                    (593) RelADPP
                                        (594) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (595) RelADPP
                                        (596) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (597) RelADPP
                                        (598) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (599) QDP
                                        (600) MRRProof [EQUIVALENT, 0 ms]
                                        (601) QDP
                                    (602) RelADPP
                                        (603) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (604) RelADPP
                                        (605) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (606) QDP
                                        (607) MRRProof [EQUIVALENT, 1 ms]
                                        (608) QDP
                                    (609) RelADPP
                                        (610) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (611) RelADPP
                                        (612) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (613) QDP
                                        (614) MRRProof [EQUIVALENT, 0 ms]
                                        (615) QDP
                    (616) RelADPP
                        (617) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (618) OR
                            (619) RelADPP
                                (620) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (621) AND
                                    (622) RelADPP
                                        (623) RelADPCleverAfsProof [SOUND, 1 ms]
                                        (624) QDP
                                        (625) MRRProof [EQUIVALENT, 2 ms]
                                        (626) QDP
                                        (627) PisEmptyProof [EQUIVALENT, 0 ms]
                                        (628) YES
                                    (629) RelADPP
                                        (630) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (631) RelADPP
                                        (632) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (633) RelADPP
                                        (634) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (635) RelADPP
                                        (636) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (637) QDP
                                    (638) RelADPP
                                        (639) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (640) RelADPP
                                        (641) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (642) RelADPP
                                        (643) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (644) QDP
                                    (645) RelADPP
                                        (646) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                        (647) RelADPP
                                        (648) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (649) YES
                                    (650) RelADPP
                                        (651) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (652) RelADPP
                                        (653) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (654) YES
                            (655) RelADPP
                                (656) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (657) AND
                                    (658) RelADPP
                                        (659) RelADPCleverAfsProof [SOUND, 1 ms]
                                        (660) QDP
                                        (661) MRRProof [EQUIVALENT, 4 ms]
                                        (662) QDP
                                        (663) PisEmptyProof [EQUIVALENT, 0 ms]
                                        (664) YES
                                    (665) RelADPP
                                        (666) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (667) RelADPP
                                        (668) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (669) QDP
                                        (670) MRRProof [EQUIVALENT, 0 ms]
                                        (671) QDP
                                    (672) RelADPP
                                        (673) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (674) RelADPP
                                        (675) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (676) QDP
                                        (677) MRRProof [EQUIVALENT, 0 ms]
                                        (678) QDP
                                    (679) RelADPP
                                        (680) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (681) RelADPP
                                        (682) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (683) AND
                                            (684) RelADPP
                                                (685) RelADPCleverAfsProof [SOUND, 1 ms]
                                                (686) QDP
                                            (687) RelADPP
                                                (688) RelADPCleverAfsProof [SOUND, 3 ms]
                                                (689) QDP
                                    (690) RelADPP
                                        (691) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (692) RelADPP
                                        (693) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (694) RelADPP
                                        (695) RelADPCleverAfsProof [SOUND, 3 ms]
                                        (696) QDP
                                        (697) MRRProof [EQUIVALENT, 0 ms]
                                        (698) QDP
                    (699) RelADPP
                        (700) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (701) OR
                            (702) RelADPP
                                (703) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (704) AND
                                    (705) RelADPP
                                        (706) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (707) RelADPP
                                        (708) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (709) RelADPP
                                        (710) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (711) RelADPP
                                        (712) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (713) QDP
                                    (714) RelADPP
                                        (715) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (716) RelADPP
                                        (717) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (718) RelADPP
                                        (719) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (720) QDP
                                    (721) RelADPP
                                        (722) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (723) RelADPP
                                        (724) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (725) YES
                                    (726) RelADPP
                                        (727) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (728) RelADPP
                                        (729) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (730) YES
                            (731) RelADPP
                                (732) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (733) AND
                                    (734) RelADPP
                                        (735) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (736) RelADPP
                                        (737) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (738) QDP
                                        (739) MRRProof [EQUIVALENT, 0 ms]
                                        (740) QDP
                                    (741) RelADPP
                                        (742) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (743) RelADPP
                                        (744) RelADPCleverAfsProof [SOUND, 1 ms]
                                        (745) QDP
                                    (746) RelADPP
                                        (747) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (748) RelADPP
                                        (749) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (750) RelADPP
                                        (751) RelADPCleverAfsProof [SOUND, 2 ms]
                                        (752) QDP
            (753) RelADPP
                (754) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (755) AND
                    (756) RelADPP
                        (757) RelADPCleverAfsProof [SOUND, 2 ms]
                        (758) QDP
                        (759) MRRProof [EQUIVALENT, 2 ms]
                        (760) QDP
                        (761) PisEmptyProof [EQUIVALENT, 0 ms]
                        (762) YES
                    (763) RelADPP
                        (764) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (765) OR
                            (766) RelADPP
                                (767) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (768) RelADPP
                                (769) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (770) QDP
                                (771) RFCMatchBoundsDPProof [EQUIVALENT, 2 ms]
                                (772) YES
                            (773) RelADPP
                                (774) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (775) AND
                                    (776) RelADPP
                                        (777) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (778) RelADPP
                                        (779) RelADPCleverAfsProof [SOUND, 16 ms]
                                        (780) QDP
                                        (781) MRRProof [EQUIVALENT, 0 ms]
                                        (782) QDP
                                    (783) RelADPP
                                        (784) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (785) RelADPP
                                        (786) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (787) RelADPP
                                        (788) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (789) QDP
                                        (790) MRRProof [EQUIVALENT, 0 ms]
                                        (791) QDP
                                    (792) RelADPP
                                        (793) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (794) RelADPP
                                        (795) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (796) QDP
                                        (797) MRRProof [EQUIVALENT, 0 ms]
                                        (798) QDP
                                    (799) RelADPP
                                        (800) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (801) RelADPP
                                        (802) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (803) QDP
                                        (804) MRRProof [EQUIVALENT, 2 ms]
                                        (805) QDP
                                        (806) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                        (807) YES
                    (808) RelADPP
                        (809) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (810) OR
                            (811) RelADPP
                                (812) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (813) RelADPP
                                (814) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (815) QDP
                                (816) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (817) YES
                            (818) RelADPP
                                (819) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (820) AND
                                    (821) RelADPP
                                        (822) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (823) RelADPP
                                        (824) RelADPCleverAfsProof [SOUND, 2 ms]
                                        (825) QDP
                                    (826) RelADPP
                                        (827) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (828) RelADPP
                                        (829) RelADPCleverAfsProof [SOUND, 1 ms]
                                        (830) QDP
                                    (831) RelADPP
                                        (832) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (833) RelADPP
                                        (834) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (835) QDP
                                        (836) MRRProof [EQUIVALENT, 0 ms]
                                        (837) QDP
                                    (838) RelADPP
                                        (839) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (840) RelADPP
                                        (841) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (842) RelADPP
                                        (843) RelADPCleverAfsProof [SOUND, 3 ms]
                                        (844) QDP
                    (845) RelADPP
                        (846) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (847) OR
                            (848) RelADPP
                                (849) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (850) AND
                                    (851) RelADPP
                                        (852) RelADPCleverAfsProof [SOUND, 1 ms]
                                        (853) QDP
                                        (854) MRRProof [EQUIVALENT, 7 ms]
                                        (855) QDP
                                        (856) PisEmptyProof [EQUIVALENT, 0 ms]
                                        (857) YES
                                    (858) RelADPP
                                        (859) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                        (860) RelADPP
                                        (861) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (862) QDP
                                    (863) RelADPP
                                        (864) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                        (865) RelADPP
                                        (866) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (867) YES
                                    (868) RelADPP
                                        (869) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (870) RelADPP
                                        (871) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (872) YES
                                    (873) RelADPP
                                        (874) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (875) RelADPP
                                        (876) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (877) QDP
                                        (878) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                        (879) YES
                            (880) RelADPP
                                (881) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (882) AND
                                    (883) RelADPP
                                        (884) RelADPCleverAfsProof [SOUND, 1 ms]
                                        (885) QDP
                                        (886) MRRProof [EQUIVALENT, 2 ms]
                                        (887) QDP
                                        (888) PisEmptyProof [EQUIVALENT, 0 ms]
                                        (889) YES
                                    (890) RelADPP
                                        (891) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (892) RelADPP
                                        (893) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (894) QDP
                                    (895) RelADPP
                                        (896) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (897) RelADPP
                                        (898) RelADPCleverAfsProof [SOUND, 3 ms]
                                        (899) QDP
                                        (900) MRRProof [EQUIVALENT, 0 ms]
                                        (901) QDP
                                    (902) RelADPP
                                        (903) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (904) RelADPP
                                        (905) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (906) AND
                                            (907) RelADPP
                                                (908) RelADPCleverAfsProof [SOUND, 2 ms]
                                                (909) QDP
                                                (910) MRRProof [EQUIVALENT, 0 ms]
                                                (911) QDP
                                                (912) PisEmptyProof [EQUIVALENT, 0 ms]
                                                (913) YES
                                            (914) RelADPP
                                                (915) RelADPCleverAfsProof [SOUND, 4 ms]
                                                (916) QDP
                                                (917) MRRProof [EQUIVALENT, 0 ms]
                                                (918) QDP
                                    (919) RelADPP
                                        (920) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (921) RelADPP
                                        (922) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (923) RelADPP
                                        (924) RelADPCleverAfsProof [SOUND, 3 ms]
                                        (925) QDP
                    (926) RelADPP
                        (927) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (928) OR
                            (929) RelADPP
                                (930) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (931) AND
                                    (932) RelADPP
                                        (933) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (934) RelADPP
                                        (935) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (936) QDP
                                    (937) RelADPP
                                        (938) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (939) RelADPP
                                        (940) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (941) YES
                                    (942) RelADPP
                                        (943) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (944) RelADPP
                                        (945) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (946) QDP
                                        (947) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                        (948) YES
                                    (949) RelADPP
                                        (950) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                                        (951) RelADPP
                                        (952) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (953) YES
                            (954) RelADPP
                                (955) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (956) AND
                                    (957) RelADPP
                                        (958) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (959) RelADPP
                                        (960) RelADPCleverAfsProof [SOUND, 1 ms]
                                        (961) QDP
                                    (962) RelADPP
                                        (963) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (964) RelADPP
                                        (965) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (966) RelADPP
                                        (967) RelADPCleverAfsProof [SOUND, 3 ms]
                                        (968) QDP
                                    (969) RelADPP
                                        (970) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (971) RelADPP
                                        (972) RelADPCleverAfsProof [SOUND, 3 ms]
                                        (973) QDP
    (974) RelADPP
        (975) RelADPRuleRemovalProof [EQUIVALENT, 5 ms]
        (976) RelADPP
        (977) RelADPReductionPairProof [EQUIVALENT, 4 ms]
        (978) RelADPP
        (979) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (980) YES
    (981) RelADPP
        (982) RelADPRuleRemovalProof [EQUIVALENT, 9 ms]
        (983) RelADPP
        (984) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (985) YES
    (986) RelADPP
        (987) RelADPRuleRemovalProof [EQUIVALENT, 5 ms]
        (988) RelADPP
        (989) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (990) YES
    (991) RelADPP
        (992) RelADPRuleRemovalProof [EQUIVALENT, 6 ms]
        (993) RelADPP
        (994) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (995) YES


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   b(a(c(x1))) -> c(c(a(x1)))

The relative TRS consists of the following S rules:

   a(b(b(x1))) -> a(b(b(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> a(c(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(1) RelTRS S Cleaner (EQUIVALENT)
We have deleted all rules from S that have the shape t -> t:

   a(b(b(x1))) -> a(b(b(x1)))


----------------------------------------

(2)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   b(a(c(x1))) -> c(c(a(x1)))

The relative TRS consists of the following S rules:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> a(c(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(3) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(4)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> B(a(c(x1)))
   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   b(a(c(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))
   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(c(a(x1))) -> A(c(c(x1)))
   b(c(c(x1))) -> c(B(c(x1)))


----------------------------------------

(5) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  5 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))
   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   b(a(c(x1))) -> c(c(A(x1)))
   a(c(a(x1))) -> B(a(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   a(c(a(x1))) -> a(c(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(8) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   a(b(b(x1))) -> A(a(c(x1)))
   a(b(b(x1))) -> a(A(c(x1)))
   b(a(c(x1))) -> c(c(A(x1)))

   a(c(a(x1))) -> a(c(c(x1)))

c:

   a(c(a(x1))) -> b(A(c(x1)))
   a(c(a(x1))) -> B(a(c(x1)))

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(9)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(c(a(x1))) -> B(a(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(10) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(11)
Complex Obligation (AND)

----------------------------------------

(12)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(13) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(15) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(16)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(17) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(18)
YES

----------------------------------------

(19)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(20) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(21)
Complex Obligation (OR)

----------------------------------------

(22)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(23) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(24)
Complex Obligation (AND)

----------------------------------------

(25)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(26) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(27)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(28) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(29)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(30) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(31)
YES

----------------------------------------

(32)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(33) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = x_1

----------------------------------------

(34)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(35) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(36)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(37) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(38)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(39) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(41) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))
   A(b(b(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
5321, 5322, 5323, 5324, 5325, 5326, 5327, 5328, 5329, 5330, 5331, 5332, 5333, 5334, 5335, 5336, 5337, 5338

Node 5321 is start node and node 5322 is final node.

Those nodes are connected through the following edges:

* 5321 to 5323 labelled b_1(0)* 5321 to 5325 labelled a_1(0), A_1(0)* 5321 to 5327 labelled c_1(0)* 5321 to 5335 labelled a_1(1), A_1(1)* 5322 to 5322 labelled #_1(0)* 5323 to 5324 labelled a_1(0)* 5323 to 5329 labelled b_1(1)* 5324 to 5322 labelled c_1(0)* 5325 to 5326 labelled b_1(0)* 5326 to 5322 labelled a_1(0)* 5326 to 5329 labelled b_1(1)* 5326 to 5331 labelled a_1(1)* 5326 to 5337 labelled a_1(2)* 5327 to 5328 labelled b_1(0)* 5327 to 5333 labelled c_1(1)* 5328 to 5322 labelled c_1(0)* 5329 to 5330 labelled a_1(1)* 5329 to 5329 labelled b_1(1)* 5330 to 5322 labelled c_1(1)* 5331 to 5332 labelled b_1(1)* 5332 to 5322 labelled a_1(1)* 5332 to 5329 labelled b_1(1)* 5332 to 5331 labelled a_1(1)* 5332 to 5337 labelled a_1(2)* 5333 to 5334 labelled b_1(1)* 5333 to 5333 labelled c_1(1)* 5334 to 5322 labelled c_1(1)* 5335 to 5336 labelled b_1(1)* 5336 to 5329 labelled a_1(1)* 5336 to 5337 labelled a_1(2)* 5337 to 5338 labelled b_1(2)* 5338 to 5329 labelled a_1(2)* 5338 to 5337 labelled a_1(2)


----------------------------------------

(42)
YES

----------------------------------------

(43)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(44) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(45)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(46) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(47)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(48) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(49)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(50) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(51)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(52) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))
   A(b(b(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
5284, 5285, 5286, 5287, 5288, 5289, 5290, 5291, 5293, 5294, 5295, 5296, 5297, 5298, 5299, 5300, 5301, 5302

Node 5284 is start node and node 5285 is final node.

Those nodes are connected through the following edges:

* 5284 to 5286 labelled b_1(0)* 5284 to 5288 labelled a_1(0), A_1(0)* 5284 to 5290 labelled c_1(0)* 5284 to 5299 labelled a_1(1), A_1(1)* 5285 to 5285 labelled #_1(0)* 5286 to 5287 labelled a_1(0)* 5286 to 5293 labelled b_1(1)* 5287 to 5285 labelled c_1(0)* 5288 to 5289 labelled b_1(0)* 5289 to 5285 labelled a_1(0)* 5289 to 5293 labelled b_1(1)* 5289 to 5295 labelled a_1(1)* 5289 to 5301 labelled a_1(2)* 5290 to 5291 labelled b_1(0)* 5290 to 5297 labelled c_1(1)* 5291 to 5285 labelled c_1(0)* 5293 to 5294 labelled a_1(1)* 5293 to 5293 labelled b_1(1)* 5294 to 5285 labelled c_1(1)* 5295 to 5296 labelled b_1(1)* 5296 to 5285 labelled a_1(1)* 5296 to 5293 labelled b_1(1)* 5296 to 5295 labelled a_1(1)* 5296 to 5301 labelled a_1(2)* 5297 to 5298 labelled b_1(1)* 5297 to 5297 labelled c_1(1)* 5298 to 5285 labelled c_1(1)* 5299 to 5300 labelled b_1(1)* 5300 to 5293 labelled a_1(1)* 5300 to 5301 labelled a_1(2)* 5301 to 5302 labelled b_1(2)* 5302 to 5293 labelled a_1(2)* 5302 to 5301 labelled a_1(2)


----------------------------------------

(53)
YES

----------------------------------------

(54)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(55) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = x_1

----------------------------------------

(56)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(57) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(58)
YES

----------------------------------------

(59)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(60) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(61)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(62) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(63)
YES

----------------------------------------

(64)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(65) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(66)
Complex Obligation (AND)

----------------------------------------

(67)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(68) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(69)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(70) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(71)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(72) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(73)
YES

----------------------------------------

(74)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(75) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(76)
Complex Obligation (OR)

----------------------------------------

(77)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(78) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(79)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(80) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(81)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(82) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(83)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(84) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(85)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(86)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(87) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(88)
Complex Obligation (AND)

----------------------------------------

(89)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(90) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(91)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(92) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(93)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(94)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(95) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(96)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(97) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(98)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(99) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(100)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(101)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(102) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(103)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(104) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(105)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(106)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(107) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(108)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(109) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(110)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(111)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(112) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(113)
Complex Obligation (OR)

----------------------------------------

(114)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(115) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(116)
Complex Obligation (AND)

----------------------------------------

(117)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(118) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(119)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(120) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(121)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(122) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(123)
YES

----------------------------------------

(124)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(125) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(126)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(127) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(128)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(129) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(130)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(131) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(132)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(133)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(134) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(135)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(136) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(137)
YES

----------------------------------------

(138)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(139) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = x_1

----------------------------------------

(140)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(141) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(142)
YES

----------------------------------------

(143)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(144) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(145)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(146) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(147)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(148) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(149)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(150)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(151) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(152)
Complex Obligation (AND)

----------------------------------------

(153)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(154) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(155)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(156) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(157)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(158) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(159)
YES

----------------------------------------

(160)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(161) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(162)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(163) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(164)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(165)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(166) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(167)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(168) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(169)
Complex Obligation (AND)

----------------------------------------

(170)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(171) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(172)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(173)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(174) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(175)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(176)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(177) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(178)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(179) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(180)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(181)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(182) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(183)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(184) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(185)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(186) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(187)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(188)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(189) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(190)
Complex Obligation (OR)

----------------------------------------

(191)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(192) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(193)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(194) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(195)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(196) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(197)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(198) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(199)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(200)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(201) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(202)
Complex Obligation (AND)

----------------------------------------

(203)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(204) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(205)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(206) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(207)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(208)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(209) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(210)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(211) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(212)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(213)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(214) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(215)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(216) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(217)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(218) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(219)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(220)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(221) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(222)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(223) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(224)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(225)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(226) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(227)
Complex Obligation (OR)

----------------------------------------

(228)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(229) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(230)
Complex Obligation (AND)

----------------------------------------

(231)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(232) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(233)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(234) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(235)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(236) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(237)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(238) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(239)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(240)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(241) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2
   POL(B(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(242)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(243) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(244)
YES

----------------------------------------

(245)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(246) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(247)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(248) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(249)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(250) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(251)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(252)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(253) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = x_1

----------------------------------------

(254)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(255) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(256)
YES

----------------------------------------

(257)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(258) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(259)
Complex Obligation (AND)

----------------------------------------

(260)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(261) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(262)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(263) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(264)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(265)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(266) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(267)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(268) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(269)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(270)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(271) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(272)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(273) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(274)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(275)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(276) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(277)
Complex Obligation (AND)

----------------------------------------

(278)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(279) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(280)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(281) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(282)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(283) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(284)
YES

----------------------------------------

(285)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(286) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(287)
Complex Obligation (OR)

----------------------------------------

(288)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(289) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(290)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(291) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(292)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(293)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(294) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(295)
Complex Obligation (AND)

----------------------------------------

(296)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(297) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(298)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(299) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(300)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(301)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(302) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(303)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(304) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(305)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(306)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(307) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(308)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(309) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(310)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(311)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(312) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(313)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(314) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(315)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(316) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(317)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(318)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(319) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(320)
Complex Obligation (OR)

----------------------------------------

(321)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(322) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(323)
Complex Obligation (AND)

----------------------------------------

(324)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(325) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(326)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(327) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(328)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(329) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(330)
YES

----------------------------------------

(331)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(332) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(333)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(334) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(335)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(336)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(337) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(338)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(339) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(340)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(341)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(342) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(343)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(344) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(345)
YES

----------------------------------------

(346)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(347) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(348)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(349) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(350)
YES

----------------------------------------

(351)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(352) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(353)
Complex Obligation (AND)

----------------------------------------

(354)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(355) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(356)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(357) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(358)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(359) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(360)
YES

----------------------------------------

(361)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(362) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(363)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(364) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(365)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(366)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(367) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(368)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(369) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(370)
Complex Obligation (AND)

----------------------------------------

(371)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(372) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(373)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(374)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(375) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(376)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(377)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(378) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(379)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(380) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(381)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(382)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(383) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(384)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(385) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(386)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(387) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(388)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(389)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(390) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(391)
Complex Obligation (OR)

----------------------------------------

(392)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(393) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(394)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(395) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(396)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(397)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(398) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(399)
Complex Obligation (AND)

----------------------------------------

(400)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(401) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(402)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(403) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(404)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(405)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(406) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(407)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(408) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(409)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(410)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(411) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(412)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(413) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(414)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(415)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(416) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(417)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(418) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(419)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(420) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(421)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(422)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(423) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(424)
Complex Obligation (OR)

----------------------------------------

(425)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(426) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(427)
Complex Obligation (AND)

----------------------------------------

(428)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(429) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(430)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(431) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(432)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(433)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(434) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(435)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(436) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(437)
YES

----------------------------------------

(438)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(439) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(440)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(441) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(442)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(443)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(444) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(445)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(446) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(447)
YES

----------------------------------------

(448)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(449) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(450)
Complex Obligation (AND)

----------------------------------------

(451)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(452) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(453)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(454) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(455)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(456)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(457) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(458)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(459) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(460)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(461)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(462) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(463)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(464) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(465)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(466) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(467)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(468)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> B(a(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(469) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(a(x1))) -> B(a(c(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 2

----------------------------------------

(470)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(471) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(472)
YES

----------------------------------------

(473)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   b(a(c(x1))) -> c(c(a(x1)))
   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   a(c(a(x1))) -> a(c(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(474) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(a(c(x1))) -> c(c(a(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(c(a(x1))) -> a(c(c(x1)))

c:

   a(c(a(x1))) -> b(A(c(x1)))

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(475)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(476) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(477)
Complex Obligation (OR)

----------------------------------------

(478)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(479) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(480)
Complex Obligation (AND)

----------------------------------------

(481)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(482) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(483)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(484) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(485)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(486) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(487)
YES

----------------------------------------

(488)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(489) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = x_1

----------------------------------------

(490)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(491) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(492)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(493) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(494)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(495) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(496)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(497) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))
   A(b(b(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
5360, 5361, 5362, 5363, 5364, 5365, 5366, 5367, 5368, 5369, 5370, 5371, 5372, 5373, 5374, 5375, 5376, 5377

Node 5360 is start node and node 5361 is final node.

Those nodes are connected through the following edges:

* 5360 to 5362 labelled b_1(0)* 5360 to 5364 labelled a_1(0), A_1(0)* 5360 to 5366 labelled c_1(0)* 5360 to 5374 labelled a_1(1), A_1(1)* 5361 to 5361 labelled #_1(0)* 5362 to 5363 labelled a_1(0)* 5362 to 5368 labelled b_1(1)* 5363 to 5361 labelled c_1(0)* 5364 to 5365 labelled b_1(0)* 5365 to 5361 labelled a_1(0)* 5365 to 5368 labelled b_1(1)* 5365 to 5370 labelled a_1(1)* 5365 to 5376 labelled a_1(2)* 5366 to 5367 labelled b_1(0)* 5366 to 5372 labelled c_1(1)* 5367 to 5361 labelled c_1(0)* 5368 to 5369 labelled a_1(1)* 5368 to 5368 labelled b_1(1)* 5369 to 5361 labelled c_1(1)* 5370 to 5371 labelled b_1(1)* 5371 to 5361 labelled a_1(1)* 5371 to 5368 labelled b_1(1)* 5371 to 5370 labelled a_1(1)* 5371 to 5376 labelled a_1(2)* 5372 to 5373 labelled b_1(1)* 5372 to 5372 labelled c_1(1)* 5373 to 5361 labelled c_1(1)* 5374 to 5375 labelled b_1(1)* 5375 to 5368 labelled a_1(1)* 5375 to 5376 labelled a_1(2)* 5376 to 5377 labelled b_1(2)* 5377 to 5368 labelled a_1(2)* 5377 to 5376 labelled a_1(2)


----------------------------------------

(498)
YES

----------------------------------------

(499)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(500) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(501)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(502) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(503)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(504) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(505)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(506) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(507)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(508) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))
   A(b(b(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4095, 4096, 4097, 4098, 4099, 4100, 4107, 4108, 4134, 4135

Node 4083 is start node and node 4084 is final node.

Those nodes are connected through the following edges:

* 4083 to 4085 labelled b_1(0)* 4083 to 4087 labelled a_1(0), A_1(0)* 4083 to 4089 labelled c_1(0)* 4083 to 4107 labelled a_1(1), A_1(1)* 4084 to 4084 labelled #_1(0)* 4085 to 4086 labelled a_1(0)* 4085 to 4095 labelled b_1(1)* 4086 to 4084 labelled c_1(0)* 4087 to 4088 labelled b_1(0)* 4088 to 4084 labelled a_1(0)* 4088 to 4095 labelled b_1(1)* 4088 to 4097 labelled a_1(1)* 4088 to 4134 labelled a_1(2)* 4089 to 4090 labelled b_1(0)* 4089 to 4099 labelled c_1(1)* 4090 to 4084 labelled c_1(0)* 4095 to 4096 labelled a_1(1)* 4095 to 4095 labelled b_1(1)* 4096 to 4084 labelled c_1(1)* 4097 to 4098 labelled b_1(1)* 4098 to 4084 labelled a_1(1)* 4098 to 4095 labelled b_1(1)* 4098 to 4097 labelled a_1(1)* 4098 to 4134 labelled a_1(2)* 4099 to 4100 labelled b_1(1)* 4099 to 4099 labelled c_1(1)* 4100 to 4084 labelled c_1(1)* 4107 to 4108 labelled b_1(1)* 4108 to 4095 labelled a_1(1)* 4108 to 4134 labelled a_1(2)* 4134 to 4135 labelled b_1(2)* 4135 to 4095 labelled a_1(2)* 4135 to 4134 labelled a_1(2)


----------------------------------------

(509)
YES

----------------------------------------

(510)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(511) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = x_1

----------------------------------------

(512)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(513) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(514)
YES

----------------------------------------

(515)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(516) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(517)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(518) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(519)
YES

----------------------------------------

(520)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(521) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(522)
Complex Obligation (AND)

----------------------------------------

(523)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(524) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(525)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(526) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(527)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(528) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(529)
YES

----------------------------------------

(530)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(531) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(532)
Complex Obligation (OR)

----------------------------------------

(533)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(534) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(535)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(536) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(537)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(538) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(539)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(540) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(541)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(542)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(543) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(544)
Complex Obligation (AND)

----------------------------------------

(545)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(546) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(547)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(548) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(549)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(550) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(551)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(552)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(553) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(554)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(555) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(556)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(557)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(558) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(559)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(560) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(561)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(562) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(563)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(564)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(565) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(566)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(567) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(568)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(569) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(570)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(571) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(572)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(573)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(574) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(575)
Complex Obligation (OR)

----------------------------------------

(576)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(577) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(578)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(579) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(580)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(581) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(582)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(583) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(584)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(585)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(586) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(587)
Complex Obligation (AND)

----------------------------------------

(588)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(589) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(590)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(591) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(592)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(593)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(594) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(595)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(596) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(597)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(598) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(599)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(600) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(601)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(602)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(603) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(604)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(605) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(606)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(607) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(608)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(609)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(610) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(611)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(612) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(613)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(614) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(615)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(616)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(617) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(618)
Complex Obligation (OR)

----------------------------------------

(619)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(620) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(621)
Complex Obligation (AND)

----------------------------------------

(622)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(623) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(624)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(625) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(626)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(627) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(628)
YES

----------------------------------------

(629)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(630) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(631)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(632) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(633)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(634) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(635)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(636) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(637)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(638)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(639) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(640)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(641) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(642)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(643) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(644)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(645)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(646) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(647)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(648) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(649)
YES

----------------------------------------

(650)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(651) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = x_1

----------------------------------------

(652)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(653) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(654)
YES

----------------------------------------

(655)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(656) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(657)
Complex Obligation (AND)

----------------------------------------

(658)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(659) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(660)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(661) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(662)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(663) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(664)
YES

----------------------------------------

(665)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(666) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(667)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(668) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(669)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(670) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(671)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(672)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(673) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(674)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(675) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(676)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(677) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(678)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(679)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(680) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(681)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(682) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(683)
Complex Obligation (AND)

----------------------------------------

(684)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(685) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(686)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(687)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(688) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(689)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(690)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(691) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(692)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(693) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(694)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(695) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(696)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(697) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(698)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(699)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(700) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(701)
Complex Obligation (OR)

----------------------------------------

(702)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(703) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(704)
Complex Obligation (AND)

----------------------------------------

(705)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(706) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(707)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(708) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(709)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(710) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(711)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(712) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(713)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(714)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(715) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(716)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(717) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(718)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(719) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(720)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(721)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(722) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = x_1

----------------------------------------

(723)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(724) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(725)
YES

----------------------------------------

(726)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(727) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2
   POL(B(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(728)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(729) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(730)
YES

----------------------------------------

(731)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(732) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(733)
Complex Obligation (AND)

----------------------------------------

(734)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(735) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(736)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(737) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(738)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(739) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(740)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(741)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(742) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(743)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(744) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(745)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(746)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(747) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(748)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(749) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(750)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(751) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(752)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(753)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(754) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(755)
Complex Obligation (AND)

----------------------------------------

(756)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(757) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(758)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(759) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(760)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(761) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(762)
YES

----------------------------------------

(763)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(764) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(765)
Complex Obligation (OR)

----------------------------------------

(766)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(767) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(768)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(769) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(770)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(771) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))
   A(b(b(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617

Node 3600 is start node and node 3601 is final node.

Those nodes are connected through the following edges:

* 3600 to 3602 labelled b_1(0)* 3600 to 3604 labelled a_1(0), A_1(0)* 3600 to 3606 labelled c_1(0)* 3600 to 3614 labelled a_1(1), A_1(1)* 3601 to 3601 labelled #_1(0)* 3602 to 3603 labelled a_1(0)* 3602 to 3608 labelled b_1(1)* 3603 to 3601 labelled c_1(0)* 3604 to 3605 labelled b_1(0)* 3605 to 3601 labelled a_1(0)* 3605 to 3608 labelled b_1(1)* 3605 to 3610 labelled a_1(1)* 3605 to 3616 labelled a_1(2)* 3606 to 3607 labelled b_1(0)* 3606 to 3612 labelled c_1(1)* 3607 to 3601 labelled c_1(0)* 3608 to 3609 labelled a_1(1)* 3608 to 3608 labelled b_1(1)* 3609 to 3601 labelled c_1(1)* 3610 to 3611 labelled b_1(1)* 3611 to 3601 labelled a_1(1)* 3611 to 3608 labelled b_1(1)* 3611 to 3610 labelled a_1(1)* 3611 to 3616 labelled a_1(2)* 3612 to 3613 labelled b_1(1)* 3612 to 3612 labelled c_1(1)* 3613 to 3601 labelled c_1(1)* 3614 to 3615 labelled b_1(1)* 3615 to 3608 labelled a_1(1)* 3615 to 3616 labelled a_1(2)* 3616 to 3617 labelled b_1(2)* 3617 to 3608 labelled a_1(2)* 3617 to 3616 labelled a_1(2)


----------------------------------------

(772)
YES

----------------------------------------

(773)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(774) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(775)
Complex Obligation (AND)

----------------------------------------

(776)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(777) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(778)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(779) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(780)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(781) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(782)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(783)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(784) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(785)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(786) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(787)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(788) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(789)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(790) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(791)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(792)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(793) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(794)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(795) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(796)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(797) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(798)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(799)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(800) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(801)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(802) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(803)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(804) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(805)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(806) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))
   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
5172, 5173, 5174, 5175, 5176, 5177, 5178, 5179, 5180, 5181, 5182, 5183, 5184, 5185, 5196, 5197, 5198, 5199

Node 5172 is start node and node 5173 is final node.

Those nodes are connected through the following edges:

* 5172 to 5174 labelled b0_1(0)* 5172 to 5176 labelled a0_1(0), A0_1(0)* 5172 to 5178 labelled c0_1(0)* 5172 to 5196 labelled a0_1(1), A0_1(1)* 5173 to 5173 labelled #_1(0)* 5174 to 5175 labelled a0_1(0)* 5174 to 5180 labelled b0_1(1)* 5175 to 5173 labelled c0_1(0)* 5176 to 5177 labelled b0_1(0)* 5177 to 5173 labelled a0_1(0)* 5177 to 5180 labelled b0_1(1)* 5177 to 5182 labelled a0_1(1)* 5177 to 5198 labelled a0_1(2)* 5178 to 5179 labelled b0_1(0)* 5178 to 5184 labelled c0_1(1)* 5179 to 5173 labelled c0_1(0)* 5180 to 5181 labelled a0_1(1)* 5180 to 5180 labelled b0_1(1)* 5181 to 5173 labelled c0_1(1)* 5182 to 5183 labelled b0_1(1)* 5183 to 5173 labelled a0_1(1)* 5183 to 5180 labelled b0_1(1)* 5183 to 5182 labelled a0_1(1)* 5183 to 5198 labelled a0_1(2)* 5184 to 5185 labelled b0_1(1)* 5184 to 5184 labelled c0_1(1)* 5185 to 5173 labelled c0_1(1)* 5196 to 5197 labelled b0_1(1)* 5197 to 5180 labelled a0_1(1)* 5197 to 5198 labelled a0_1(2)* 5198 to 5199 labelled b0_1(2)* 5199 to 5180 labelled a0_1(2)* 5199 to 5198 labelled a0_1(2)


----------------------------------------

(807)
YES

----------------------------------------

(808)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(809) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(810)
Complex Obligation (OR)

----------------------------------------

(811)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(812) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(813)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(814) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(815)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(816) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))
   A(b(b(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
5248, 5249, 5250, 5251, 5252, 5253, 5254, 5255, 5256, 5257, 5258, 5259, 5260, 5261, 5265, 5266, 5267, 5268

Node 5248 is start node and node 5249 is final node.

Those nodes are connected through the following edges:

* 5248 to 5250 labelled b_1(0)* 5248 to 5252 labelled a_1(0), A_1(0)* 5248 to 5254 labelled c_1(0)* 5248 to 5265 labelled a_1(1), A_1(1)* 5249 to 5249 labelled #_1(0)* 5250 to 5251 labelled a_1(0)* 5250 to 5256 labelled b_1(1)* 5251 to 5249 labelled c_1(0)* 5252 to 5253 labelled b_1(0)* 5253 to 5249 labelled a_1(0)* 5253 to 5256 labelled b_1(1)* 5253 to 5258 labelled a_1(1)* 5253 to 5267 labelled a_1(2)* 5254 to 5255 labelled b_1(0)* 5254 to 5260 labelled c_1(1)* 5255 to 5249 labelled c_1(0)* 5256 to 5257 labelled a_1(1)* 5256 to 5256 labelled b_1(1)* 5257 to 5249 labelled c_1(1)* 5258 to 5259 labelled b_1(1)* 5259 to 5249 labelled a_1(1)* 5259 to 5256 labelled b_1(1)* 5259 to 5258 labelled a_1(1)* 5259 to 5267 labelled a_1(2)* 5260 to 5261 labelled b_1(1)* 5260 to 5260 labelled c_1(1)* 5261 to 5249 labelled c_1(1)* 5265 to 5266 labelled b_1(1)* 5266 to 5256 labelled a_1(1)* 5266 to 5267 labelled a_1(2)* 5267 to 5268 labelled b_1(2)* 5268 to 5256 labelled a_1(2)* 5268 to 5267 labelled a_1(2)


----------------------------------------

(817)
YES

----------------------------------------

(818)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(819) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(820)
Complex Obligation (AND)

----------------------------------------

(821)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(822) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(823)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(824) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(825)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(826)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(827) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(828)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(829) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(830)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(831)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(832) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(833)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(834) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(835)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(836) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(837)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(838)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(839) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(840)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(841) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(842)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(843) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(844)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(845)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(846) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(847)
Complex Obligation (OR)

----------------------------------------

(848)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(849) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(850)
Complex Obligation (AND)

----------------------------------------

(851)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(852) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(853)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(854) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(855)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(856) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(857)
YES

----------------------------------------

(858)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(859) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(860)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(861) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(862)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(863)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(864) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(865)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(866) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(867)
YES

----------------------------------------

(868)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(869) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(870)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(871) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(872)
YES

----------------------------------------

(873)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(874) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(875)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(876) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(877)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(878) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))
   A(b(b(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
5378, 5379, 5380, 5381, 5382, 5383, 5384, 5385, 5386, 5387, 5388, 5389, 5390, 5391, 5392, 5393, 5394, 5395

Node 5378 is start node and node 5379 is final node.

Those nodes are connected through the following edges:

* 5378 to 5380 labelled b_1(0)* 5378 to 5382 labelled a_1(0), A_1(0)* 5378 to 5384 labelled c_1(0)* 5378 to 5392 labelled a_1(1), A_1(1)* 5379 to 5379 labelled #_1(0)* 5380 to 5381 labelled a_1(0)* 5380 to 5386 labelled b_1(1)* 5381 to 5379 labelled c_1(0)* 5382 to 5383 labelled b_1(0)* 5383 to 5379 labelled a_1(0)* 5383 to 5386 labelled b_1(1)* 5383 to 5388 labelled a_1(1)* 5383 to 5394 labelled a_1(2)* 5384 to 5385 labelled b_1(0)* 5384 to 5390 labelled c_1(1)* 5385 to 5379 labelled c_1(0)* 5386 to 5387 labelled a_1(1)* 5386 to 5386 labelled b_1(1)* 5387 to 5379 labelled c_1(1)* 5388 to 5389 labelled b_1(1)* 5389 to 5379 labelled a_1(1)* 5389 to 5386 labelled b_1(1)* 5389 to 5388 labelled a_1(1)* 5389 to 5394 labelled a_1(2)* 5390 to 5391 labelled b_1(1)* 5390 to 5390 labelled c_1(1)* 5391 to 5379 labelled c_1(1)* 5392 to 5393 labelled b_1(1)* 5393 to 5386 labelled a_1(1)* 5393 to 5394 labelled a_1(2)* 5394 to 5395 labelled b_1(2)* 5395 to 5386 labelled a_1(2)* 5395 to 5394 labelled a_1(2)


----------------------------------------

(879)
YES

----------------------------------------

(880)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(881) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(882)
Complex Obligation (AND)

----------------------------------------

(883)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(884) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(885)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(886) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(887)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(888) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(889)
YES

----------------------------------------

(890)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(891) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(892)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(893) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(894)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(895)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(896) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(897)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(898) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(899)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(900) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(901)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(902)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(903) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(904)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(905) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(906)
Complex Obligation (AND)

----------------------------------------

(907)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> b(A(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(908) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(909)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(910) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(911)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(912) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(913)
YES

----------------------------------------

(914)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(915) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(916)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(917) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(b0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = x_1


----------------------------------------

(918)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(919)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(920) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(921)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(922) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(923)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(924) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(925)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(926)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(927) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(928)
Complex Obligation (OR)

----------------------------------------

(929)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(930) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(931)
Complex Obligation (AND)

----------------------------------------

(932)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(933) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(934)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(935) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(936)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(937)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(938) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(939)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(940) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(941)
YES

----------------------------------------

(942)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(943) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(944)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(945) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(946)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(b(b(x1))) -> A(b(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(947) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))
   A(b(b(x1))) -> A(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
5303, 5304, 5305, 5306, 5307, 5308, 5309, 5310, 5311, 5312, 5313, 5314, 5315, 5316, 5317, 5318, 5319, 5320

Node 5303 is start node and node 5304 is final node.

Those nodes are connected through the following edges:

* 5303 to 5305 labelled b_1(0)* 5303 to 5307 labelled a_1(0), A_1(0)* 5303 to 5309 labelled c_1(0)* 5303 to 5317 labelled a_1(1), A_1(1)* 5304 to 5304 labelled #_1(0)* 5305 to 5306 labelled a_1(0)* 5305 to 5311 labelled b_1(1)* 5306 to 5304 labelled c_1(0)* 5307 to 5308 labelled b_1(0)* 5308 to 5304 labelled a_1(0)* 5308 to 5311 labelled b_1(1)* 5308 to 5313 labelled a_1(1)* 5308 to 5319 labelled a_1(2)* 5309 to 5310 labelled b_1(0)* 5309 to 5315 labelled c_1(1)* 5310 to 5304 labelled c_1(0)* 5311 to 5312 labelled a_1(1)* 5311 to 5311 labelled b_1(1)* 5312 to 5304 labelled c_1(1)* 5313 to 5314 labelled b_1(1)* 5314 to 5304 labelled a_1(1)* 5314 to 5311 labelled b_1(1)* 5314 to 5313 labelled a_1(1)* 5314 to 5319 labelled a_1(2)* 5315 to 5316 labelled b_1(1)* 5315 to 5315 labelled c_1(1)* 5316 to 5304 labelled c_1(1)* 5317 to 5318 labelled b_1(1)* 5318 to 5311 labelled a_1(1)* 5318 to 5319 labelled a_1(2)* 5319 to 5320 labelled b_1(2)* 5320 to 5311 labelled a_1(2)* 5320 to 5319 labelled a_1(2)


----------------------------------------

(948)
YES

----------------------------------------

(949)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(950) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

Relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(951)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(952) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(953)
YES

----------------------------------------

(954)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(955) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(956)
Complex Obligation (AND)

----------------------------------------

(957)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(958) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(959)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(960) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(961)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(962)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(963) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(964)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(B(a(x1)))
   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(965) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(966)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(967) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(968)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(969)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(970) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(971)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(b(A(x1)))
   a(b(b(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(b(x1))) -> a(b(a(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(972) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

a(x1)  =  a(x1)

c(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [A_1, b_1, a_1]

Status: A_1: multiset status
b_1: [1]
a_1: [1]


----------------------------------------

(973)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(b0(x1))) -> A0(b0(a0(x1)))
   A0(b0(b0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> b0(a0(c0(x1)))
   a0(b0(b0(x1))) -> a0(b0(a0(x1)))
   b0(c0(c0(x1))) -> c0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(974)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> B(a(c(x1)))

and relative ADPs:

   b(a(c(x1))) -> c(c(a(x1)))
   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   a(c(a(x1))) -> a(c(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(975) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(a(c(x1))) -> c(c(a(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(c(a(x1))) -> a(c(c(x1)))

c:

   a(c(a(x1))) -> B(a(c(x1)))

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(976)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> B(a(c(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(977) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(a(x1))) -> B(a(c(x1)))

Relative ADPs:

   a(c(a(x1))) -> b(a(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 2

----------------------------------------

(978)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(979) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(980)
YES

----------------------------------------

(981)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> A(a(c(x1)))

and relative ADPs:

   b(a(c(x1))) -> c(c(a(x1)))
   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   a(c(a(x1))) -> a(c(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(982) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   a(b(b(x1))) -> A(a(c(x1)))

   b(a(c(x1))) -> c(c(a(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(c(a(x1))) -> a(c(c(x1)))

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(983)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(984) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(985)
YES

----------------------------------------

(986)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(b(x1))) -> a(A(c(x1)))

and relative ADPs:

   b(a(c(x1))) -> c(c(a(x1)))
   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   a(c(a(x1))) -> a(c(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(987) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   a(b(b(x1))) -> a(A(c(x1)))

   b(a(c(x1))) -> c(c(a(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(c(a(x1))) -> a(c(c(x1)))

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(988)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(989) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(990)
YES

----------------------------------------

(991)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(c(x1))) -> c(c(A(x1)))

and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   a(c(a(x1))) -> a(c(c(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(992) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(a(c(x1))) -> c(c(A(x1)))

   a(b(b(x1))) -> a(a(c(x1)))
   a(c(a(x1))) -> a(c(c(x1)))

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = x_1

----------------------------------------

(993)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(b(x1))) -> A(b(A(x1)))
   a(c(a(x1))) -> b(a(c(x1)))
   a(b(b(x1))) -> a(B(A(x1)))
   a(b(b(x1))) -> A(B(a(x1)))
   b(c(c(x1))) -> c(b(c(x1)))


----------------------------------------

(994) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(995)
YES
