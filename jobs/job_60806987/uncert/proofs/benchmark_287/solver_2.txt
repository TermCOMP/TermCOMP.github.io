YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/pSYiH.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPDerelatifying2Proof [SOUND, 0 ms]
(4) OR
    (5) RelADPP
        (6) RelADPDerelatifying2Proof [SOUND, 12 ms]
        (7) OR
            (8) RelADPP
                (9) RelADPDerelatifying2Proof [SOUND, 5 ms]
                (10) OR
                    (11) RelADPP
                        (12) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (13) OR
                            (14) RelADPP
                                (15) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (16) OR
                                    (17) RelADPP
                                    (18) RelADPP
                            (19) RelADPP
                                (20) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (21) OR
                                    (22) RelADPP
                                    (23) RelADPP
                            (24) RelADPP
                                (25) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (26) RelADPP
                                (27) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (28) AND
                                    (29) RelADPP
                                    (30) RelADPP
                                    (31) RelADPP
                    (32) RelADPP
                        (33) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (34) OR
                            (35) RelADPP
                                (36) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (37) OR
                                    (38) RelADPP
                                    (39) RelADPP
                            (40) RelADPP
                                (41) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (42) OR
                                    (43) RelADPP
                                    (44) RelADPP
                            (45) RelADPP
                                (46) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (47) RelADPP
                                (48) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (49) AND
                                    (50) RelADPP
                                    (51) RelADPP
                                    (52) RelADPP
                    (53) RelADPP
                        (54) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (55) OR
                            (56) RelADPP
                                (57) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (58) OR
                                    (59) RelADPP
                                    (60) RelADPP
                            (61) RelADPP
                                (62) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (63) OR
                                    (64) RelADPP
                                    (65) RelADPP
                            (66) RelADPP
                                (67) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (68) RelADPP
                                (69) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (70) AND
                                    (71) RelADPP
                                    (72) RelADPP
                                    (73) RelADPP
                    (74) RelADPP
                        (75) RelADPReductionPairProof [EQUIVALENT, 29 ms]
                        (76) RelADPP
                        (77) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (78) AND
                            (79) RelADPP
                                (80) RelADPCleverAfsProof [SOUND, 6 ms]
                                (81) QDP
                                (82) MRRProof [EQUIVALENT, 1 ms]
                                (83) QDP
                            (84) RelADPP
                                (85) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (86) QDP
                            (87) RelADPP
                                (88) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (89) QDP
            (90) RelADPP
                (91) RelADPDerelatifying2Proof [SOUND, 6 ms]
                (92) OR
                    (93) RelADPP
                        (94) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (95) OR
                            (96) RelADPP
                                (97) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (98) OR
                                    (99) RelADPP
                                    (100) RelADPP
                            (101) RelADPP
                                (102) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (103) OR
                                    (104) RelADPP
                                    (105) RelADPP
                            (106) RelADPP
                                (107) RelADPReductionPairProof [EQUIVALENT, 20 ms]
                                (108) RelADPP
                                (109) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (110) AND
                                    (111) RelADPP
                                    (112) RelADPP
                                    (113) RelADPP
                    (114) RelADPP
                        (115) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (116) OR
                            (117) RelADPP
                                (118) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (119) OR
                                    (120) RelADPP
                                    (121) RelADPP
                            (122) RelADPP
                                (123) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (124) OR
                                    (125) RelADPP
                                    (126) RelADPP
                            (127) RelADPP
                                (128) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (129) RelADPP
                                (130) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (131) AND
                                    (132) RelADPP
                                    (133) RelADPP
                                    (134) RelADPP
                    (135) RelADPP
                        (136) RelADPDerelatifying2Proof [SOUND, 2 ms]
                        (137) OR
                            (138) RelADPP
                                (139) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (140) OR
                                    (141) RelADPP
                                    (142) RelADPP
                            (143) RelADPP
                                (144) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (145) OR
                                    (146) RelADPP
                                    (147) RelADPP
                            (148) RelADPP
                                (149) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (150) RelADPP
                                (151) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (152) AND
                                    (153) RelADPP
                                    (154) RelADPP
                                    (155) RelADPP
                    (156) RelADPP
                        (157) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                        (158) RelADPP
                        (159) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (160) AND
                            (161) RelADPP
                                (162) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (163) QDP
                            (164) RelADPP
                                (165) RelADPCleverAfsProof [SOUND, 16 ms]
                                (166) QDP
                                (167) MRRProof [EQUIVALENT, 1 ms]
                                (168) QDP
                            (169) RelADPP
                                (170) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (171) QDP
            (172) RelADPP
                (173) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (174) OR
                    (175) RelADPP
                        (176) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (177) OR
                            (178) RelADPP
                                (179) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (180) OR
                                    (181) RelADPP
                                    (182) RelADPP
                                        (183) RelADPReductionPairProof [EQUIVALENT, 21 ms]
                                        (184) RelADPP
                            (185) RelADPP
                                (186) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (187) OR
                                    (188) RelADPP
                                    (189) RelADPP
                                        (190) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (191) RelADPP
                            (192) RelADPP
                                (193) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (194) RelADPP
                                (195) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (196) AND
                                    (197) RelADPP
                                        (198) RelADPCleverAfsProof [SOUND, 25 ms]
                                        (199) QDP
                                    (200) RelADPP
                                    (201) RelADPP
                    (202) RelADPP
                        (203) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (204) OR
                            (205) RelADPP
                                (206) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (207) OR
                                    (208) RelADPP
                                    (209) RelADPP
                                        (210) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                        (211) RelADPP
                            (212) RelADPP
                                (213) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (214) OR
                                    (215) RelADPP
                                    (216) RelADPP
                                        (217) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                        (218) RelADPP
                            (219) RelADPP
                                (220) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                (221) RelADPP
                                (222) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (223) AND
                                    (224) RelADPP
                                        (225) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (226) QDP
                                    (227) RelADPP
                                        (228) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (229) QDP
                                        (230) MRRProof [EQUIVALENT, 1 ms]
                                        (231) QDP
                                    (232) RelADPP
                                        (233) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (234) QDP
                    (235) RelADPP
                        (236) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (237) OR
                            (238) RelADPP
                                (239) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (240) OR
                                    (241) RelADPP
                                    (242) RelADPP
                                        (243) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                        (244) RelADPP
                            (245) RelADPP
                                (246) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (247) OR
                                    (248) RelADPP
                                    (249) RelADPP
                                        (250) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                        (251) RelADPP
                            (252) RelADPP
                                (253) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (254) RelADPP
                                (255) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (256) AND
                                    (257) RelADPP
                                    (258) RelADPP
                                    (259) RelADPP
                                        (260) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (261) RelADPP
                                        (262) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (263) YES
                                    (264) RelADPP
                                        (265) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (266) RelADPP
                                    (267) RelADPP
                                        (268) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (269) RelADPP
                                    (270) RelADPP
                                        (271) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (272) RelADPP
                                        (273) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (274) YES
                    (275) RelADPP
                        (276) RelADPReductionPairProof [EQUIVALENT, 14 ms]
                        (277) RelADPP
                        (278) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (279) AND
                            (280) RelADPP
                                (281) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (282) QDP
                            (283) RelADPP
                                (284) RelADPCleverAfsProof [SOUND, 8 ms]
                                (285) QDP
                                (286) MRRProof [EQUIVALENT, 1 ms]
                                (287) QDP
                                (288) PisEmptyProof [EQUIVALENT, 0 ms]
                                (289) YES
                            (290) RelADPP
                                (291) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (292) QDP
                                (293) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (294) YES
            (295) RelADPP
                (296) RelADPDerelatifying2Proof [SOUND, 4 ms]
                (297) OR
                    (298) RelADPP
                        (299) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (300) OR
                            (301) RelADPP
                                (302) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (303) OR
                                    (304) RelADPP
                                    (305) RelADPP
                            (306) RelADPP
                                (307) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (308) OR
                                    (309) RelADPP
                                    (310) RelADPP
                            (311) RelADPP
                                (312) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (313) RelADPP
                                (314) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (315) AND
                                    (316) RelADPP
                                    (317) RelADPP
                                    (318) RelADPP
                    (319) RelADPP
                        (320) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (321) OR
                            (322) RelADPP
                                (323) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (324) OR
                                    (325) RelADPP
                                    (326) RelADPP
                            (327) RelADPP
                                (328) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (329) OR
                                    (330) RelADPP
                                    (331) RelADPP
                            (332) RelADPP
                                (333) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (334) RelADPP
                                (335) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (336) AND
                                    (337) RelADPP
                                    (338) RelADPP
                                    (339) RelADPP
                    (340) RelADPP
                        (341) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (342) OR
                            (343) RelADPP
                                (344) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (345) OR
                                    (346) RelADPP
                                    (347) RelADPP
                            (348) RelADPP
                                (349) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (350) OR
                                    (351) RelADPP
                                    (352) RelADPP
                            (353) RelADPP
                                (354) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                                (355) RelADPP
                                (356) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (357) AND
                                    (358) RelADPP
                                    (359) RelADPP
                                    (360) RelADPP
                                    (361) RelADPP
                                    (362) RelADPP
                                    (363) RelADPP
                    (364) RelADPP
                        (365) RelADPReductionPairProof [EQUIVALENT, 22 ms]
                        (366) RelADPP
                        (367) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (368) AND
                            (369) RelADPP
                                (370) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (371) QDP
                            (372) RelADPP
                                (373) RelADPCleverAfsProof [SOUND, 5 ms]
                                (374) QDP
                                (375) MRRProof [EQUIVALENT, 1 ms]
                                (376) QDP
                            (377) RelADPP
                                (378) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (379) QDP
            (380) RelADPP
                (381) RelADPReductionPairProof [EQUIVALENT, 12 ms]
                (382) RelADPP
                (383) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (384) AND
                    (385) RelADPP
                        (386) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (387) QDP
                        (388) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (389) YES
                    (390) RelADPP
                        (391) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (392) RelADPP
                        (393) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (394) YES
                    (395) RelADPP
                        (396) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (397) QDP
                        (398) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (399) YES
                    (400) RelADPP
                        (401) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                        (402) RelADPP
                        (403) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (404) QDP
                    (405) RelADPP
                        (406) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                        (407) RelADPP
                        (408) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (409) YES
                    (410) RelADPP
                        (411) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (412) RelADPP
                        (413) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (414) QDP
    (415) RelADPP
        (416) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (417) OR
            (418) RelADPP
                (419) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (420) OR
                    (421) RelADPP
                        (422) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (423) OR
                            (424) RelADPP
                                (425) RelADPReductionPairProof [EQUIVALENT, 20 ms]
                                (426) RelADPP
                                (427) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (428) AND
                                    (429) RelADPP
                                        (430) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (431) QDP
                                    (432) RelADPP
                                        (433) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (434) QDP
                                        (435) MRRProof [EQUIVALENT, 1 ms]
                                        (436) QDP
                                    (437) RelADPP
                                        (438) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (439) QDP
                            (440) RelADPP
                                (441) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (442) OR
                                    (443) RelADPP
                                        (444) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                        (445) RelADPP
                                        (446) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (447) AND
                                            (448) RelADPP
                                            (449) RelADPP
                                            (450) RelADPP
                                    (451) RelADPP
                            (452) RelADPP
                                (453) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (454) OR
                                    (455) RelADPP
                                        (456) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (457) RelADPP
                                        (458) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (459) AND
                                            (460) RelADPP
                                            (461) RelADPP
                                            (462) RelADPP
                                    (463) RelADPP
                    (464) RelADPP
                        (465) RelADPReductionPairProof [EQUIVALENT, 21 ms]
                        (466) RelADPP
                        (467) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (468) AND
                            (469) RelADPP
                                (470) RelADPCleverAfsProof [SOUND, 6 ms]
                                (471) QDP
                                (472) MRRProof [EQUIVALENT, 1 ms]
                                (473) QDP
                                (474) PisEmptyProof [EQUIVALENT, 0 ms]
                                (475) YES
                            (476) RelADPP
                                (477) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (478) QDP
                            (479) RelADPP
                                (480) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (481) QDP
                    (482) RelADPP
                        (483) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (484) OR
                            (485) RelADPP
                                (486) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (487) OR
                                    (488) RelADPP
                                        (489) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (490) RelADPP
                                        (491) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (492) AND
                                            (493) RelADPP
                                            (494) RelADPP
                                            (495) RelADPP
                                    (496) RelADPP
                            (497) RelADPP
                                (498) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                (499) RelADPP
                                (500) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (501) AND
                                    (502) RelADPP
                                        (503) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (504) QDP
                                        (505) MRRProof [EQUIVALENT, 1 ms]
                                        (506) QDP
                                    (507) RelADPP
                                        (508) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (509) QDP
                                    (510) RelADPP
                                        (511) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (512) QDP
                            (513) RelADPP
                                (514) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (515) OR
                                    (516) RelADPP
                                    (517) RelADPP
                                        (518) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                        (519) RelADPP
                                        (520) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (521) AND
                                            (522) RelADPP
                                            (523) RelADPP
                                            (524) RelADPP
                    (525) RelADPP
                        (526) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (527) OR
                            (528) RelADPP
                                (529) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (530) OR
                                    (531) RelADPP
                                        (532) RelADPReductionPairProof [EQUIVALENT, 12 ms]
                                        (533) RelADPP
                                        (534) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (535) AND
                                            (536) RelADPP
                                            (537) RelADPP
                                            (538) RelADPP
                                    (539) RelADPP
                            (540) RelADPP
                                (541) RelADPReductionPairProof [EQUIVALENT, 20 ms]
                                (542) RelADPP
                                (543) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (544) AND
                                    (545) RelADPP
                                        (546) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (547) QDP
                                    (548) RelADPP
                                        (549) RelADPCleverAfsProof [SOUND, 2 ms]
                                        (550) QDP
                                        (551) MRRProof [EQUIVALENT, 2 ms]
                                        (552) QDP
                                    (553) RelADPP
                                        (554) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (555) QDP
                            (556) RelADPP
                                (557) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (558) OR
                                    (559) RelADPP
                                    (560) RelADPP
                                        (561) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (562) RelADPP
                                        (563) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (564) AND
                                            (565) RelADPP
                                            (566) RelADPP
                                            (567) RelADPP
            (568) RelADPP
                (569) RelADPDerelatifying2Proof [SOUND, 4 ms]
                (570) OR
                    (571) RelADPP
                        (572) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (573) OR
                            (574) RelADPP
                                (575) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (576) RelADPP
                                (577) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (578) AND
                                    (579) RelADPP
                                    (580) RelADPP
                                    (581) RelADPP
                            (582) RelADPP
                                (583) RelADPDerelatifying2Proof [SOUND, 4 ms]
                                (584) OR
                                    (585) RelADPP
                                    (586) RelADPP
                            (587) RelADPP
                                (588) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (589) OR
                                    (590) RelADPP
                                    (591) RelADPP
                    (592) RelADPP
                        (593) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                        (594) RelADPP
                        (595) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (596) AND
                            (597) RelADPP
                                (598) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (599) QDP
                            (600) RelADPP
                                (601) RelADPCleverAfsProof [SOUND, 6 ms]
                                (602) QDP
                                (603) MRRProof [EQUIVALENT, 1 ms]
                                (604) QDP
                            (605) RelADPP
                                (606) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (607) QDP
                    (608) RelADPP
                        (609) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (610) OR
                            (611) RelADPP
                                (612) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (613) OR
                                    (614) RelADPP
                                    (615) RelADPP
                            (616) RelADPP
                                (617) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (618) RelADPP
                                (619) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (620) AND
                                    (621) RelADPP
                                    (622) RelADPP
                                    (623) RelADPP
                            (624) RelADPP
                                (625) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (626) OR
                                    (627) RelADPP
                                    (628) RelADPP
                    (629) RelADPP
                        (630) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (631) OR
                            (632) RelADPP
                                (633) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (634) OR
                                    (635) RelADPP
                                    (636) RelADPP
                            (637) RelADPP
                                (638) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (639) RelADPP
                                (640) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (641) AND
                                    (642) RelADPP
                                    (643) RelADPP
                                    (644) RelADPP
                            (645) RelADPP
                                (646) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (647) OR
                                    (648) RelADPP
                                    (649) RelADPP
            (650) RelADPP
                (651) RelADPReductionPairProof [EQUIVALENT, 25 ms]
                (652) RelADPP
                (653) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (654) AND
                    (655) RelADPP
                        (656) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (657) QDP
                        (658) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (659) YES
                    (660) RelADPP
                        (661) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                        (662) RelADPP
                        (663) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (664) YES
                    (665) RelADPP
                        (666) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (667) QDP
                        (668) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (669) YES
                    (670) RelADPP
                        (671) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                        (672) RelADPP
                        (673) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (674) YES
                    (675) RelADPP
                        (676) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (677) RelADPP
                        (678) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (679) QDP
                        (680) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (681) YES
                    (682) RelADPP
                        (683) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                        (684) RelADPP
                        (685) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (686) QDP
                        (687) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (688) YES
            (689) RelADPP
                (690) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (691) OR
                    (692) RelADPP
                        (693) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (694) OR
                            (695) RelADPP
                                (696) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (697) OR
                                    (698) RelADPP
                                    (699) RelADPP
                            (700) RelADPP
                                (701) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (702) RelADPP
                                (703) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (704) AND
                                    (705) RelADPP
                                    (706) RelADPP
                                    (707) RelADPP
                            (708) RelADPP
                                (709) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (710) OR
                                    (711) RelADPP
                                    (712) RelADPP
                    (713) RelADPP
                        (714) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (715) OR
                            (716) RelADPP
                                (717) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (718) OR
                                    (719) RelADPP
                                    (720) RelADPP
                            (721) RelADPP
                                (722) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (723) RelADPP
                                (724) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (725) AND
                                    (726) RelADPP
                                    (727) RelADPP
                                    (728) RelADPP
                            (729) RelADPP
                                (730) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (731) OR
                                    (732) RelADPP
                                    (733) RelADPP
                    (734) RelADPP
                        (735) RelADPReductionPairProof [EQUIVALENT, 22 ms]
                        (736) RelADPP
                        (737) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (738) AND
                            (739) RelADPP
                                (740) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (741) QDP
                            (742) RelADPP
                                (743) RelADPCleverAfsProof [SOUND, 5 ms]
                                (744) QDP
                                (745) MRRProof [EQUIVALENT, 1 ms]
                                (746) QDP
                            (747) RelADPP
                                (748) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (749) QDP
                    (750) RelADPP
                        (751) RelADPDerelatifying2Proof [SOUND, 2 ms]
                        (752) OR
                            (753) RelADPP
                                (754) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (755) OR
                                    (756) RelADPP
                                    (757) RelADPP
                                        (758) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                        (759) RelADPP
                            (760) RelADPP
                                (761) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (762) OR
                                    (763) RelADPP
                                    (764) RelADPP
                                        (765) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (766) RelADPP
                            (767) RelADPP
                                (768) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                (769) RelADPP
                                (770) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (771) AND
                                    (772) RelADPP
                                        (773) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (774) QDP
                                    (775) RelADPP
                                        (776) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (777) QDP
                                    (778) RelADPP
                                        (779) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (780) RelADPP
                                        (781) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (782) YES
                                    (783) RelADPP
                                        (784) RelADPReductionPairProof [EQUIVALENT, 15 ms]
                                        (785) RelADPP
                                    (786) RelADPP
                                        (787) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (788) RelADPP
                                    (789) RelADPP
                                        (790) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (791) RelADPP
                                        (792) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (793) YES
            (794) RelADPP
                (795) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (796) OR
                    (797) RelADPP
                        (798) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (799) OR
                            (800) RelADPP
                                (801) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (802) OR
                                    (803) RelADPP
                                        (804) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (805) RelADPP
                                    (806) RelADPP
                            (807) RelADPP
                                (808) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                (809) RelADPP
                                (810) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (811) AND
                                    (812) RelADPP
                                        (813) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (814) QDP
                                    (815) RelADPP
                                        (816) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (817) QDP
                                        (818) MRRProof [EQUIVALENT, 1 ms]
                                        (819) QDP
                                    (820) RelADPP
                                        (821) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (822) QDP
                            (823) RelADPP
                                (824) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (825) OR
                                    (826) RelADPP
                                    (827) RelADPP
                                        (828) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                        (829) RelADPP
                                        (830) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (831) AND
                                            (832) RelADPP
                                            (833) RelADPP
                                            (834) RelADPP
                    (835) RelADPP
                        (836) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (837) OR
                            (838) RelADPP
                                (839) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (840) OR
                                    (841) RelADPP
                                        (842) RelADPReductionPairProof [EQUIVALENT, 12 ms]
                                        (843) RelADPP
                                    (844) RelADPP
                            (845) RelADPP
                                (846) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (847) RelADPP
                                (848) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (849) AND
                                    (850) RelADPP
                                        (851) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (852) QDP
                                    (853) RelADPP
                                        (854) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (855) QDP
                                        (856) MRRProof [EQUIVALENT, 1 ms]
                                        (857) QDP
                                    (858) RelADPP
                                        (859) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (860) QDP
                            (861) RelADPP
                                (862) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (863) OR
                                    (864) RelADPP
                                    (865) RelADPP
                                        (866) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                        (867) RelADPP
                                        (868) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (869) AND
                                            (870) RelADPP
                                            (871) RelADPP
                                            (872) RelADPP
                    (873) RelADPP
                        (874) RelADPReductionPairProof [EQUIVALENT, 22 ms]
                        (875) RelADPP
                        (876) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (877) AND
                            (878) RelADPP
                                (879) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (880) QDP
                            (881) RelADPP
                                (882) RelADPCleverAfsProof [SOUND, 26 ms]
                                (883) QDP
                                (884) MRRProof [EQUIVALENT, 1 ms]
                                (885) QDP
                            (886) RelADPP
                                (887) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (888) QDP
                    (889) RelADPP
                        (890) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (891) OR
                            (892) RelADPP
                                (893) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (894) OR
                                    (895) RelADPP
                                    (896) RelADPP
                                        (897) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (898) RelADPP
                            (899) RelADPP
                                (900) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (901) OR
                                    (902) RelADPP
                                    (903) RelADPP
                            (904) RelADPP
                                (905) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (906) RelADPP
                                (907) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (908) AND
                                    (909) RelADPP
                                    (910) RelADPP
                                    (911) RelADPP
                                        (912) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (913) RelADPP
                                    (914) RelADPP
                                        (915) RelADPReductionPairProof [EQUIVALENT, 14 ms]
                                        (916) RelADPP
                                    (917) RelADPP
                                        (918) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (919) RelADPP
                                    (920) RelADPP
                                        (921) RelADPReductionPairProof [EQUIVALENT, 15 ms]
                                        (922) RelADPP
    (923) RelADPP
        (924) RelADPDerelatifying2Proof [SOUND, 8 ms]
        (925) OR
            (926) RelADPP
                (927) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (928) OR
                    (929) RelADPP
                        (930) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (931) OR
                            (932) RelADPP
                                (933) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (934) OR
                                    (935) RelADPP
                                    (936) RelADPP
                            (937) RelADPP
                                (938) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (939) OR
                                    (940) RelADPP
                                    (941) RelADPP
                            (942) RelADPP
                                (943) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (944) RelADPP
                                (945) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (946) AND
                                    (947) RelADPP
                                    (948) RelADPP
                                        (949) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (950) QDP
                                    (951) RelADPP
                    (952) RelADPP
                        (953) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (954) OR
                            (955) RelADPP
                                (956) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (957) OR
                                    (958) RelADPP
                                    (959) RelADPP
                            (960) RelADPP
                                (961) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (962) OR
                                    (963) RelADPP
                                    (964) RelADPP
                            (965) RelADPP
                                (966) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (967) OR
                                    (968) RelADPP
                                    (969) RelADPP
                    (970) RelADPP
                        (971) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (972) OR
                            (973) RelADPP
                                (974) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (975) OR
                                    (976) RelADPP
                                    (977) RelADPP
                            (978) RelADPP
                                (979) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (980) OR
                                    (981) RelADPP
                                    (982) RelADPP
                            (983) RelADPP
                                (984) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (985) OR
                                    (986) RelADPP
                                    (987) RelADPP
                    (988) RelADPP
                        (989) RelADPDerelatifying2Proof [SOUND, 2 ms]
                        (990) OR
                            (991) RelADPP
                                (992) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (993) RelADPP
                                (994) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (995) AND
                                    (996) RelADPP
                                    (997) RelADPP
                                        (998) RelADPCleverAfsProof [SOUND, 16 ms]
                                        (999) QDP
                                    (1000) RelADPP
                            (1001) RelADPP
                                (1002) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1003) OR
                                    (1004) RelADPP
                                    (1005) RelADPP
                            (1006) RelADPP
                                (1007) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1008) OR
                                    (1009) RelADPP
                                    (1010) RelADPP
            (1011) RelADPP
                (1012) RelADPDerelatifying2Proof [SOUND, 2 ms]
                (1013) OR
                    (1014) RelADPP
                        (1015) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (1016) OR
                            (1017) RelADPP
                                (1018) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1019) OR
                                    (1020) RelADPP
                                    (1021) RelADPP
                            (1022) RelADPP
                                (1023) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (1024) OR
                                    (1025) RelADPP
                                    (1026) RelADPP
                            (1027) RelADPP
                                (1028) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1029) RelADPP
                                (1030) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1031) AND
                                    (1032) RelADPP
                                    (1033) RelADPP
                                        (1034) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (1035) QDP
                                    (1036) RelADPP
                    (1037) RelADPP
                        (1038) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1039) OR
                            (1040) RelADPP
                                (1041) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1042) OR
                                    (1043) RelADPP
                                    (1044) RelADPP
                                        (1045) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                        (1046) RelADPP
                            (1047) RelADPP
                                (1048) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1049) OR
                                    (1050) RelADPP
                                    (1051) RelADPP
                            (1052) RelADPP
                                (1053) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1054) RelADPP
                                (1055) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1056) AND
                                    (1057) RelADPP
                                        (1058) RelADPCleverAfsProof [SOUND, 26 ms]
                                        (1059) QDP
                                    (1060) RelADPP
                                    (1061) RelADPP
                    (1062) RelADPP
                        (1063) RelADPDerelatifying2Proof [SOUND, 5 ms]
                        (1064) OR
                            (1065) RelADPP
                                (1066) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1067) OR
                                    (1068) RelADPP
                                    (1069) RelADPP
                            (1070) RelADPP
                                (1071) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (1072) OR
                                    (1073) RelADPP
                                    (1074) RelADPP
                            (1075) RelADPP
                                (1076) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (1077) RelADPP
                                (1078) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1079) AND
                                    (1080) RelADPP
                                    (1081) RelADPP
                                        (1082) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (1083) QDP
                                    (1084) RelADPP
                    (1085) RelADPP
                        (1086) RelADPReductionPairProof [EQUIVALENT, 20 ms]
                        (1087) RelADPP
                        (1088) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1089) AND
                            (1090) RelADPP
                                (1091) RelADPCleverAfsProof [SOUND, 15 ms]
                                (1092) QDP
                                (1093) MRRProof [EQUIVALENT, 2 ms]
                                (1094) QDP
                            (1095) RelADPP
                                (1096) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (1097) QDP
                            (1098) RelADPP
                                (1099) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (1100) QDP
            (1101) RelADPP
                (1102) RelADPDerelatifying2Proof [SOUND, 4 ms]
                (1103) OR
                    (1104) RelADPP
                        (1105) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1106) OR
                            (1107) RelADPP
                                (1108) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1109) OR
                                    (1110) RelADPP
                                    (1111) RelADPP
                                        (1112) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                        (1113) RelADPP
                            (1114) RelADPP
                                (1115) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1116) OR
                                    (1117) RelADPP
                                    (1118) RelADPP
                            (1119) RelADPP
                                (1120) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1121) OR
                                    (1122) RelADPP
                                        (1123) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                        (1124) RelADPP
                                    (1125) RelADPP
                    (1126) RelADPP
                        (1127) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1128) OR
                            (1129) RelADPP
                                (1130) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1131) OR
                                    (1132) RelADPP
                                    (1133) RelADPP
                            (1134) RelADPP
                                (1135) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1136) OR
                                    (1137) RelADPP
                                    (1138) RelADPP
                            (1139) RelADPP
                                (1140) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1141) RelADPP
                                (1142) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1143) AND
                                    (1144) RelADPP
                                        (1145) RelADPCleverAfsProof [SOUND, 16 ms]
                                        (1146) QDP
                                    (1147) RelADPP
                                    (1148) RelADPP
                    (1149) RelADPP
                        (1150) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (1151) OR
                            (1152) RelADPP
                                (1153) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1154) OR
                                    (1155) RelADPP
                                    (1156) RelADPP
                            (1157) RelADPP
                                (1158) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (1159) OR
                                    (1160) RelADPP
                                    (1161) RelADPP
                            (1162) RelADPP
                                (1163) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1164) OR
                                    (1165) RelADPP
                                    (1166) RelADPP
                    (1167) RelADPP
                        (1168) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1169) OR
                            (1170) RelADPP
                                (1171) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1172) OR
                                    (1173) RelADPP
                                    (1174) RelADPP
                            (1175) RelADPP
                                (1176) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1177) RelADPP
                                (1178) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1179) AND
                                    (1180) RelADPP
                                        (1181) RelADPCleverAfsProof [SOUND, 16 ms]
                                        (1182) QDP
                                    (1183) RelADPP
                                    (1184) RelADPP
                            (1185) RelADPP
                                (1186) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (1187) OR
                                    (1188) RelADPP
                                    (1189) RelADPP
            (1190) RelADPP
                (1191) RelADPDerelatifying2Proof [SOUND, 3 ms]
                (1192) OR
                    (1193) RelADPP
                        (1194) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (1195) OR
                            (1196) RelADPP
                                (1197) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1198) OR
                                    (1199) RelADPP
                                    (1200) RelADPP
                            (1201) RelADPP
                                (1202) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1203) OR
                                    (1204) RelADPP
                                    (1205) RelADPP
                            (1206) RelADPP
                                (1207) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (1208) OR
                                    (1209) RelADPP
                                    (1210) RelADPP
                    (1211) RelADPP
                        (1212) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1213) OR
                            (1214) RelADPP
                                (1215) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1216) OR
                                    (1217) RelADPP
                                    (1218) RelADPP
                            (1219) RelADPP
                                (1220) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1221) OR
                                    (1222) RelADPP
                                    (1223) RelADPP
                            (1224) RelADPP
                                (1225) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1226) RelADPP
                                (1227) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1228) AND
                                    (1229) RelADPP
                                    (1230) RelADPP
                                        (1231) RelADPCleverAfsProof [SOUND, 26 ms]
                                        (1232) QDP
                                    (1233) RelADPP
                    (1234) RelADPP
                        (1235) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (1236) OR
                            (1237) RelADPP
                                (1238) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1239) OR
                                    (1240) RelADPP
                                    (1241) RelADPP
                            (1242) RelADPP
                                (1243) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1244) OR
                                    (1245) RelADPP
                                    (1246) RelADPP
                            (1247) RelADPP
                                (1248) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (1249) OR
                                    (1250) RelADPP
                                    (1251) RelADPP
                    (1252) RelADPP
                        (1253) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1254) OR
                            (1255) RelADPP
                                (1256) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1257) OR
                                    (1258) RelADPP
                                    (1259) RelADPP
                            (1260) RelADPP
                                (1261) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (1262) RelADPP
                                (1263) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1264) AND
                                    (1265) RelADPP
                                    (1266) RelADPP
                                        (1267) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (1268) QDP
                                    (1269) RelADPP
                            (1270) RelADPP
                                (1271) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1272) OR
                                    (1273) RelADPP
                                    (1274) RelADPP
            (1275) RelADPP
                (1276) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1277) OR
                    (1278) RelADPP
                        (1279) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (1280) OR
                            (1281) RelADPP
                                (1282) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (1283) RelADPP
                                (1284) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1285) AND
                                    (1286) RelADPP
                                    (1287) RelADPP
                                        (1288) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (1289) QDP
                                    (1290) RelADPP
                            (1291) RelADPP
                                (1292) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1293) OR
                                    (1294) RelADPP
                                    (1295) RelADPP
                            (1296) RelADPP
                                (1297) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1298) OR
                                    (1299) RelADPP
                                    (1300) RelADPP
                    (1301) RelADPP
                        (1302) RelADPReductionPairProof [EQUIVALENT, 12 ms]
                        (1303) RelADPP
                        (1304) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1305) AND
                            (1306) RelADPP
                                (1307) RelADPCleverAfsProof [SOUND, 26 ms]
                                (1308) QDP
                                (1309) MRRProof [EQUIVALENT, 1 ms]
                                (1310) QDP
                            (1311) RelADPP
                                (1312) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (1313) QDP
                            (1314) RelADPP
                                (1315) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (1316) QDP
                    (1317) RelADPP
                        (1318) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1319) OR
                            (1320) RelADPP
                                (1321) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1322) OR
                                    (1323) RelADPP
                                    (1324) RelADPP
                            (1325) RelADPP
                                (1326) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1327) RelADPP
                                (1328) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1329) AND
                                    (1330) RelADPP
                                        (1331) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (1332) QDP
                                    (1333) RelADPP
                                    (1334) RelADPP
                            (1335) RelADPP
                                (1336) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1337) OR
                                    (1338) RelADPP
                                    (1339) RelADPP
                    (1340) RelADPP
                        (1341) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1342) OR
                            (1343) RelADPP
                                (1344) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (1345) OR
                                    (1346) RelADPP
                                    (1347) RelADPP
                            (1348) RelADPP
                                (1349) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (1350) RelADPP
                                (1351) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1352) AND
                                    (1353) RelADPP
                                    (1354) RelADPP
                                        (1355) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (1356) QDP
                                    (1357) RelADPP
                            (1358) RelADPP
                                (1359) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1360) OR
                                    (1361) RelADPP
                                    (1362) RelADPP
    (1363) RelADPP
        (1364) RelADPDerelatifying2Proof [SOUND, 10 ms]
        (1365) OR
            (1366) RelADPP
                (1367) RelADPDerelatifying2Proof [SOUND, 4 ms]
                (1368) OR
                    (1369) RelADPP
                        (1370) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1371) OR
                            (1372) RelADPP
                                (1373) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1374) OR
                                    (1375) RelADPP
                                    (1376) RelADPP
                            (1377) RelADPP
                                (1378) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1379) OR
                                    (1380) RelADPP
                                    (1381) RelADPP
                            (1382) RelADPP
                                (1383) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1384) OR
                                    (1385) RelADPP
                                    (1386) RelADPP
                    (1387) RelADPP
                        (1388) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1389) OR
                            (1390) RelADPP
                                (1391) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1392) OR
                                    (1393) RelADPP
                                    (1394) RelADPP
                            (1395) RelADPP
                                (1396) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1397) OR
                                    (1398) RelADPP
                                    (1399) RelADPP
                            (1400) RelADPP
                                (1401) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (1402) RelADPP
                                (1403) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1404) AND
                                    (1405) RelADPP
                                    (1406) RelADPP
                                        (1407) RelADPCleverAfsProof [SOUND, 20 ms]
                                        (1408) QDP
                                    (1409) RelADPP
                    (1410) RelADPP
                        (1411) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1412) OR
                            (1413) RelADPP
                                (1414) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1415) OR
                                    (1416) RelADPP
                                    (1417) RelADPP
                            (1418) RelADPP
                                (1419) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1420) OR
                                    (1421) RelADPP
                                    (1422) RelADPP
                            (1423) RelADPP
                                (1424) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1425) OR
                                    (1426) RelADPP
                                    (1427) RelADPP
                    (1428) RelADPP
                        (1429) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (1430) OR
                            (1431) RelADPP
                                (1432) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1433) OR
                                    (1434) RelADPP
                                    (1435) RelADPP
                            (1436) RelADPP
                                (1437) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (1438) RelADPP
                                (1439) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1440) AND
                                    (1441) RelADPP
                                    (1442) RelADPP
                                        (1443) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (1444) QDP
                                    (1445) RelADPP
                            (1446) RelADPP
                                (1447) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1448) OR
                                    (1449) RelADPP
                                    (1450) RelADPP
            (1451) RelADPP
                (1452) RelADPDerelatifying2Proof [SOUND, 4 ms]
                (1453) OR
                    (1454) RelADPP
                        (1455) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1456) OR
                            (1457) RelADPP
                                (1458) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1459) OR
                                    (1460) RelADPP
                                    (1461) RelADPP
                            (1462) RelADPP
                                (1463) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1464) OR
                                    (1465) RelADPP
                                    (1466) RelADPP
                            (1467) RelADPP
                                (1468) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1469) OR
                                    (1470) RelADPP
                                    (1471) RelADPP
                    (1472) RelADPP
                        (1473) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1474) OR
                            (1475) RelADPP
                                (1476) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (1477) OR
                                    (1478) RelADPP
                                    (1479) RelADPP
                            (1480) RelADPP
                                (1481) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1482) OR
                                    (1483) RelADPP
                                    (1484) RelADPP
                            (1485) RelADPP
                                (1486) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (1487) RelADPP
                                (1488) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1489) AND
                                    (1490) RelADPP
                                    (1491) RelADPP
                                        (1492) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (1493) QDP
                                    (1494) RelADPP
                    (1495) RelADPP
                        (1496) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1497) OR
                            (1498) RelADPP
                                (1499) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1500) OR
                                    (1501) RelADPP
                                    (1502) RelADPP
                            (1503) RelADPP
                                (1504) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1505) OR
                                    (1506) RelADPP
                                    (1507) RelADPP
                            (1508) RelADPP
                                (1509) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1510) OR
                                    (1511) RelADPP
                                    (1512) RelADPP
                    (1513) RelADPP
                        (1514) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1515) OR
                            (1516) RelADPP
                                (1517) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (1518) OR
                                    (1519) RelADPP
                                    (1520) RelADPP
                            (1521) RelADPP
                                (1522) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1523) RelADPP
                                (1524) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1525) AND
                                    (1526) RelADPP
                                    (1527) RelADPP
                                        (1528) RelADPCleverAfsProof [SOUND, 16 ms]
                                        (1529) QDP
                                    (1530) RelADPP
                            (1531) RelADPP
                                (1532) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1533) OR
                                    (1534) RelADPP
                                    (1535) RelADPP
            (1536) RelADPP
                (1537) RelADPDerelatifying2Proof [SOUND, 4 ms]
                (1538) OR
                    (1539) RelADPP
                        (1540) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1541) OR
                            (1542) RelADPP
                                (1543) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (1544) OR
                                    (1545) RelADPP
                                    (1546) RelADPP
                            (1547) RelADPP
                                (1548) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1549) OR
                                    (1550) RelADPP
                                    (1551) RelADPP
                            (1552) RelADPP
                                (1553) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (1554) RelADPP
                                (1555) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1556) AND
                                    (1557) RelADPP
                                    (1558) RelADPP
                                        (1559) RelADPCleverAfsProof [SOUND, 27 ms]
                                        (1560) QDP
                                    (1561) RelADPP
                    (1562) RelADPP
                        (1563) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1564) OR
                            (1565) RelADPP
                                (1566) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1567) OR
                                    (1568) RelADPP
                                    (1569) RelADPP
                            (1570) RelADPP
                                (1571) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1572) OR
                                    (1573) RelADPP
                                    (1574) RelADPP
                            (1575) RelADPP
                                (1576) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1577) RelADPP
                                (1578) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1579) AND
                                    (1580) RelADPP
                                    (1581) RelADPP
                                        (1582) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (1583) QDP
                                    (1584) RelADPP
                    (1585) RelADPP
                        (1586) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1587) OR
                            (1588) RelADPP
                                (1589) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1590) OR
                                    (1591) RelADPP
                                    (1592) RelADPP
                            (1593) RelADPP
                                (1594) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1595) OR
                                    (1596) RelADPP
                                    (1597) RelADPP
                            (1598) RelADPP
                                (1599) RelADPReductionPairProof [EQUIVALENT, 25 ms]
                                (1600) RelADPP
                                (1601) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1602) AND
                                    (1603) RelADPP
                                    (1604) RelADPP
                                    (1605) RelADPP
                                    (1606) RelADPP
                                    (1607) RelADPP
                                    (1608) RelADPP
                    (1609) RelADPP
                        (1610) RelADPReductionPairProof [EQUIVALENT, 15 ms]
                        (1611) RelADPP
                        (1612) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1613) AND
                            (1614) RelADPP
                                (1615) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (1616) QDP
                            (1617) RelADPP
                                (1618) RelADPCleverAfsProof [SOUND, 26 ms]
                                (1619) QDP
                                (1620) MRRProof [EQUIVALENT, 1 ms]
                                (1621) QDP
                            (1622) RelADPP
                                (1623) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (1624) QDP
            (1625) RelADPP
                (1626) RelADPDerelatifying2Proof [SOUND, 5 ms]
                (1627) OR
                    (1628) RelADPP
                        (1629) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1630) OR
                            (1631) RelADPP
                                (1632) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1633) OR
                                    (1634) RelADPP
                                    (1635) RelADPP
                            (1636) RelADPP
                                (1637) RelADPDerelatifying2Proof [SOUND, 3 ms]
                                (1638) OR
                                    (1639) RelADPP
                                    (1640) RelADPP
                            (1641) RelADPP
                                (1642) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1643) OR
                                    (1644) RelADPP
                                    (1645) RelADPP
                    (1646) RelADPP
                        (1647) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (1648) OR
                            (1649) RelADPP
                                (1650) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1651) OR
                                    (1652) RelADPP
                                    (1653) RelADPP
                            (1654) RelADPP
                                (1655) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1656) OR
                                    (1657) RelADPP
                                    (1658) RelADPP
                            (1659) RelADPP
                                (1660) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1661) OR
                                    (1662) RelADPP
                                    (1663) RelADPP
                    (1664) RelADPP
                        (1665) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1666) OR
                            (1667) RelADPP
                                (1668) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1669) OR
                                    (1670) RelADPP
                                    (1671) RelADPP
                            (1672) RelADPP
                                (1673) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1674) OR
                                    (1675) RelADPP
                                    (1676) RelADPP
                            (1677) RelADPP
                                (1678) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (1679) RelADPP
                                (1680) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1681) AND
                                    (1682) RelADPP
                                    (1683) RelADPP
                                    (1684) RelADPP
                                    (1685) RelADPP
                                    (1686) RelADPP
                                    (1687) RelADPP
                    (1688) RelADPP
                        (1689) RelADPDerelatifying2Proof [SOUND, 3 ms]
                        (1690) OR
                            (1691) RelADPP
                                (1692) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (1693) OR
                                    (1694) RelADPP
                                    (1695) RelADPP
                            (1696) RelADPP
                                (1697) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1698) OR
                                    (1699) RelADPP
                                    (1700) RelADPP
                            (1701) RelADPP
                                (1702) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (1703) RelADPP
                                (1704) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1705) AND
                                    (1706) RelADPP
                                    (1707) RelADPP
                                    (1708) RelADPP
                                    (1709) RelADPP
                                    (1710) RelADPP
                                    (1711) RelADPP
            (1712) RelADPP
                (1713) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1714) OR
                    (1715) RelADPP
                        (1716) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1717) OR
                            (1718) RelADPP
                                (1719) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1720) OR
                                    (1721) RelADPP
                                    (1722) RelADPP
                            (1723) RelADPP
                                (1724) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (1725) RelADPP
                                (1726) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1727) AND
                                    (1728) RelADPP
                                    (1729) RelADPP
                                        (1730) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (1731) QDP
                                    (1732) RelADPP
                            (1733) RelADPP
                                (1734) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1735) OR
                                    (1736) RelADPP
                                    (1737) RelADPP
                    (1738) RelADPP
                        (1739) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (1740) OR
                            (1741) RelADPP
                                (1742) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1743) OR
                                    (1744) RelADPP
                                    (1745) RelADPP
                            (1746) RelADPP
                                (1747) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1748) RelADPP
                                (1749) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1750) AND
                                    (1751) RelADPP
                                    (1752) RelADPP
                                        (1753) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (1754) QDP
                                    (1755) RelADPP
                            (1756) RelADPP
                                (1757) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1758) OR
                                    (1759) RelADPP
                                    (1760) RelADPP
                    (1761) RelADPP
                        (1762) RelADPReductionPairProof [EQUIVALENT, 11 ms]
                        (1763) RelADPP
                        (1764) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1765) AND
                            (1766) RelADPP
                                (1767) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (1768) QDP
                            (1769) RelADPP
                                (1770) RelADPCleverAfsProof [SOUND, 16 ms]
                                (1771) QDP
                                (1772) MRRProof [EQUIVALENT, 1 ms]
                                (1773) QDP
                            (1774) RelADPP
                                (1775) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (1776) QDP
                    (1777) RelADPP
                        (1778) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1779) OR
                            (1780) RelADPP
                                (1781) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1782) OR
                                    (1783) RelADPP
                                    (1784) RelADPP
                            (1785) RelADPP
                                (1786) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1787) OR
                                    (1788) RelADPP
                                    (1789) RelADPP
                            (1790) RelADPP
                                (1791) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (1792) RelADPP
                                (1793) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1794) AND
                                    (1795) RelADPP
                                    (1796) RelADPP
                                    (1797) RelADPP
                                    (1798) RelADPP
                                    (1799) RelADPP
                                    (1800) RelADPP
    (1801) RelADPP
        (1802) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (1803) OR
            (1804) RelADPP
                (1805) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1806) OR
                    (1807) RelADPP
                        (1808) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (1809) OR
                            (1810) RelADPP
                                (1811) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1812) OR
                                    (1813) RelADPP
                                    (1814) RelADPP
                            (1815) RelADPP
                                (1816) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1817) OR
                                    (1818) RelADPP
                                    (1819) RelADPP
                            (1820) RelADPP
                                (1821) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1822) RelADPP
                                (1823) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1824) AND
                                    (1825) RelADPP
                                    (1826) RelADPP
                                    (1827) RelADPP
                    (1828) RelADPP
                        (1829) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (1830) OR
                            (1831) RelADPP
                                (1832) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (1833) OR
                                    (1834) RelADPP
                                    (1835) RelADPP
                            (1836) RelADPP
                                (1837) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1838) OR
                                    (1839) RelADPP
                                    (1840) RelADPP
                            (1841) RelADPP
                                (1842) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1843) OR
                                    (1844) RelADPP
                                    (1845) RelADPP
                    (1846) RelADPP
                        (1847) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (1848) OR
                            (1849) RelADPP
                                (1850) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1851) OR
                                    (1852) RelADPP
                                    (1853) RelADPP
                            (1854) RelADPP
                                (1855) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1856) OR
                                    (1857) RelADPP
                                    (1858) RelADPP
                            (1859) RelADPP
                                (1860) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1861) OR
                                    (1862) RelADPP
                                    (1863) RelADPP
                    (1864) RelADPP
                        (1865) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1866) OR
                            (1867) RelADPP
                                (1868) RelADPReductionPairProof [EQUIVALENT, 27 ms]
                                (1869) RelADPP
                                (1870) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1871) AND
                                    (1872) RelADPP
                                    (1873) RelADPP
                                        (1874) RelADPCleverAfsProof [SOUND, 25 ms]
                                        (1875) QDP
                                    (1876) RelADPP
                            (1877) RelADPP
                                (1878) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1879) OR
                                    (1880) RelADPP
                                    (1881) RelADPP
                            (1882) RelADPP
                                (1883) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1884) OR
                                    (1885) RelADPP
                                    (1886) RelADPP
            (1887) RelADPP
                (1888) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1889) OR
                    (1890) RelADPP
                        (1891) RelADPDerelatifying2Proof [SOUND, 5 ms]
                        (1892) OR
                            (1893) RelADPP
                                (1894) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1895) OR
                                    (1896) RelADPP
                                    (1897) RelADPP
                            (1898) RelADPP
                                (1899) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1900) OR
                                    (1901) RelADPP
                                    (1902) RelADPP
                            (1903) RelADPP
                                (1904) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (1905) RelADPP
                                (1906) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1907) AND
                                    (1908) RelADPP
                                    (1909) RelADPP
                                        (1910) RelADPCleverAfsProof [SOUND, 25 ms]
                                        (1911) QDP
                                    (1912) RelADPP
                    (1913) RelADPP
                        (1914) RelADPDerelatifying2Proof [SOUND, 5 ms]
                        (1915) OR
                            (1916) RelADPP
                                (1917) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1918) OR
                                    (1919) RelADPP
                                    (1920) RelADPP
                            (1921) RelADPP
                                (1922) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1923) OR
                                    (1924) RelADPP
                                    (1925) RelADPP
                            (1926) RelADPP
                                (1927) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (1928) RelADPP
                                (1929) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1930) AND
                                    (1931) RelADPP
                                    (1932) RelADPP
                                        (1933) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (1934) QDP
                                    (1935) RelADPP
                    (1936) RelADPP
                        (1937) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1938) OR
                            (1939) RelADPP
                                (1940) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1941) OR
                                    (1942) RelADPP
                                    (1943) RelADPP
                            (1944) RelADPP
                                (1945) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1946) OR
                                    (1947) RelADPP
                                    (1948) RelADPP
                            (1949) RelADPP
                                (1950) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (1951) RelADPP
                                (1952) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1953) AND
                                    (1954) RelADPP
                                    (1955) RelADPP
                                        (1956) RelADPCleverAfsProof [SOUND, 24 ms]
                                        (1957) QDP
                                    (1958) RelADPP
                    (1959) RelADPP
                        (1960) RelADPReductionPairProof [EQUIVALENT, 11 ms]
                        (1961) RelADPP
                        (1962) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (1963) AND
                            (1964) RelADPP
                                (1965) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (1966) QDP
                            (1967) RelADPP
                                (1968) RelADPCleverAfsProof [SOUND, 5 ms]
                                (1969) QDP
                                (1970) MRRProof [EQUIVALENT, 1 ms]
                                (1971) QDP
                            (1972) RelADPP
                                (1973) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (1974) QDP
            (1975) RelADPP
                (1976) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1977) OR
                    (1978) RelADPP
                        (1979) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (1980) OR
                            (1981) RelADPP
                                (1982) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1983) OR
                                    (1984) RelADPP
                                    (1985) RelADPP
                            (1986) RelADPP
                                (1987) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1988) OR
                                    (1989) RelADPP
                                    (1990) RelADPP
                            (1991) RelADPP
                                (1992) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1993) OR
                                    (1994) RelADPP
                                    (1995) RelADPP
                    (1996) RelADPP
                        (1997) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1998) OR
                            (1999) RelADPP
                                (2000) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2001) OR
                                    (2002) RelADPP
                                    (2003) RelADPP
                            (2004) RelADPP
                                (2005) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2006) OR
                                    (2007) RelADPP
                                    (2008) RelADPP
                            (2009) RelADPP
                                (2010) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (2011) RelADPP
                                (2012) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2013) AND
                                    (2014) RelADPP
                                    (2015) RelADPP
                                        (2016) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (2017) QDP
                                    (2018) RelADPP
                    (2019) RelADPP
                        (2020) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2021) OR
                            (2022) RelADPP
                                (2023) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2024) OR
                                    (2025) RelADPP
                                    (2026) RelADPP
                            (2027) RelADPP
                                (2028) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2029) OR
                                    (2030) RelADPP
                                    (2031) RelADPP
                            (2032) RelADPP
                                (2033) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2034) OR
                                    (2035) RelADPP
                                    (2036) RelADPP
                    (2037) RelADPP
                        (2038) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2039) OR
                            (2040) RelADPP
                                (2041) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2042) OR
                                    (2043) RelADPP
                                    (2044) RelADPP
                            (2045) RelADPP
                                (2046) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                (2047) RelADPP
                                (2048) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2049) AND
                                    (2050) RelADPP
                                    (2051) RelADPP
                                        (2052) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (2053) QDP
                                    (2054) RelADPP
                            (2055) RelADPP
                                (2056) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2057) OR
                                    (2058) RelADPP
                                    (2059) RelADPP
            (2060) RelADPP
                (2061) RelADPDerelatifying2Proof [SOUND, 4 ms]
                (2062) OR
                    (2063) RelADPP
                        (2064) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (2065) OR
                            (2066) RelADPP
                                (2067) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2068) OR
                                    (2069) RelADPP
                                    (2070) RelADPP
                            (2071) RelADPP
                                (2072) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2073) OR
                                    (2074) RelADPP
                                    (2075) RelADPP
                            (2076) RelADPP
                                (2077) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2078) OR
                                    (2079) RelADPP
                                    (2080) RelADPP
                    (2081) RelADPP
                        (2082) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2083) OR
                            (2084) RelADPP
                                (2085) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2086) OR
                                    (2087) RelADPP
                                    (2088) RelADPP
                            (2089) RelADPP
                                (2090) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2091) OR
                                    (2092) RelADPP
                                    (2093) RelADPP
                            (2094) RelADPP
                                (2095) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (2096) RelADPP
                                (2097) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2098) AND
                                    (2099) RelADPP
                                    (2100) RelADPP
                                        (2101) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (2102) QDP
                                    (2103) RelADPP
                    (2104) RelADPP
                        (2105) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2106) OR
                            (2107) RelADPP
                            (2108) RelADPP
                            (2109) RelADPP
                    (2110) RelADPP
                        (2111) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2112) OR
                            (2113) RelADPP
                                (2114) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2115) OR
                                    (2116) RelADPP
                                    (2117) RelADPP
                            (2118) RelADPP
                                (2119) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                (2120) RelADPP
                                (2121) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2122) AND
                                    (2123) RelADPP
                                    (2124) RelADPP
                                        (2125) RelADPCleverAfsProof [SOUND, 7 ms]
                                        (2126) QDP
                                    (2127) RelADPP
                            (2128) RelADPP
                                (2129) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2130) OR
                                    (2131) RelADPP
                                    (2132) RelADPP
            (2133) RelADPP
                (2134) RelADPDerelatifying2Proof [SOUND, 4 ms]
                (2135) OR
                    (2136) RelADPP
                        (2137) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (2138) OR
                            (2139) RelADPP
                                (2140) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                                (2141) RelADPP
                                (2142) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2143) AND
                                    (2144) RelADPP
                                    (2145) RelADPP
                                        (2146) RelADPCleverAfsProof [SOUND, 24 ms]
                                        (2147) QDP
                                    (2148) RelADPP
                            (2149) RelADPP
                                (2150) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2151) OR
                                    (2152) RelADPP
                                    (2153) RelADPP
                            (2154) RelADPP
                                (2155) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2156) OR
                                    (2157) RelADPP
                                    (2158) RelADPP
                    (2159) RelADPP
                        (2160) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                        (2161) RelADPP
                        (2162) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (2163) AND
                            (2164) RelADPP
                                (2165) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (2166) QDP
                            (2167) RelADPP
                                (2168) RelADPCleverAfsProof [SOUND, 5 ms]
                                (2169) QDP
                                (2170) MRRProof [EQUIVALENT, 1 ms]
                                (2171) QDP
                            (2172) RelADPP
                                (2173) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (2174) QDP
                    (2175) RelADPP
                        (2176) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (2177) OR
                            (2178) RelADPP
                                (2179) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2180) OR
                                    (2181) RelADPP
                                    (2182) RelADPP
                            (2183) RelADPP
                                (2184) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                                (2185) RelADPP
                                (2186) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2187) AND
                                    (2188) RelADPP
                                    (2189) RelADPP
                                        (2190) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (2191) QDP
                                    (2192) RelADPP
                            (2193) RelADPP
                                (2194) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2195) OR
                                    (2196) RelADPP
                                    (2197) RelADPP
                    (2198) RelADPP
                        (2199) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2200) OR
                            (2201) RelADPP
                                (2202) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2203) OR
                                    (2204) RelADPP
                                    (2205) RelADPP
                            (2206) RelADPP
                                (2207) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                                (2208) RelADPP
                                (2209) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2210) AND
                                    (2211) RelADPP
                                    (2212) RelADPP
                                    (2213) RelADPP
                            (2214) RelADPP
                                (2215) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2216) OR
                                    (2217) RelADPP
                                    (2218) RelADPP
    (2219) RelADPP
        (2220) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (2221) OR
            (2222) RelADPP
                (2223) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (2224) OR
                    (2225) RelADPP
                        (2226) RelADPDerelatifying2Proof [SOUND, 12 ms]
                        (2227) OR
                            (2228) RelADPP
                                (2229) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2230) OR
                                    (2231) RelADPP
                                    (2232) RelADPP
                                        (2233) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (2234) RelADPP
                            (2235) RelADPP
                                (2236) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2237) OR
                                    (2238) RelADPP
                                    (2239) RelADPP
                            (2240) RelADPP
                                (2241) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2242) OR
                                    (2243) RelADPP
                                        (2244) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (2245) RelADPP
                                    (2246) RelADPP
                    (2247) RelADPP
                        (2248) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2249) OR
                            (2250) RelADPP
                                (2251) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2252) OR
                                    (2253) RelADPP
                                    (2254) RelADPP
                                        (2255) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (2256) RelADPP
                            (2257) RelADPP
                                (2258) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2259) OR
                                    (2260) RelADPP
                                    (2261) RelADPP
                                        (2262) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                        (2263) RelADPP
                            (2264) RelADPP
                                (2265) RelADPReductionPairProof [EQUIVALENT, 12 ms]
                                (2266) RelADPP
                                (2267) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2268) AND
                                    (2269) RelADPP
                                        (2270) RelADPCleverAfsProof [SOUND, 0 ms]
                                        (2271) QDP
                                        (2272) MRRProof [EQUIVALENT, 1 ms]
                                        (2273) QDP
                                    (2274) RelADPP
                                    (2275) RelADPP
                    (2276) RelADPP
                        (2277) RelADPDerelatifying2Proof [SOUND, 8 ms]
                        (2278) OR
                            (2279) RelADPP
                                (2280) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2281) OR
                                    (2282) RelADPP
                                    (2283) RelADPP
                            (2284) RelADPP
                                (2285) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2286) OR
                                    (2287) RelADPP
                                    (2288) RelADPP
                                        (2289) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                        (2290) RelADPP
                                        (2291) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2292) AND
                                            (2293) RelADPP
                                            (2294) RelADPP
                                            (2295) RelADPP
                            (2296) RelADPP
                                (2297) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2298) OR
                                    (2299) RelADPP
                                    (2300) RelADPP
                                        (2301) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                        (2302) RelADPP
                                        (2303) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2304) AND
                                            (2305) RelADPP
                                            (2306) RelADPP
                                            (2307) RelADPP
                    (2308) RelADPP
                        (2309) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2310) OR
                            (2311) RelADPP
                                (2312) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2313) OR
                                    (2314) RelADPP
                                        (2315) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (2316) RelADPP
                                    (2317) RelADPP
                            (2318) RelADPP
                                (2319) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                (2320) RelADPP
                                (2321) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2322) AND
                                    (2323) RelADPP
                                        (2324) RelADPCleverAfsProof [SOUND, 7 ms]
                                        (2325) QDP
                                    (2326) RelADPP
                                    (2327) RelADPP
                            (2328) RelADPP
                                (2329) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2330) OR
                                    (2331) RelADPP
                                    (2332) RelADPP
                                        (2333) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (2334) RelADPP
            (2335) RelADPP
                (2336) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (2337) OR
                    (2338) RelADPP
                        (2339) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2340) OR
                            (2341) RelADPP
                                (2342) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2343) OR
                                    (2344) RelADPP
                                    (2345) RelADPP
                                        (2346) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (2347) RelADPP
                            (2348) RelADPP
                                (2349) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2350) OR
                                    (2351) RelADPP
                                    (2352) RelADPP
                            (2353) RelADPP
                                (2354) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2355) OR
                                    (2356) RelADPP
                                        (2357) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                        (2358) RelADPP
                                        (2359) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2360) AND
                                            (2361) RelADPP
                                            (2362) RelADPP
                                            (2363) RelADPP
                                    (2364) RelADPP
                    (2365) RelADPP
                        (2366) RelADPDerelatifying2Proof [SOUND, 8 ms]
                        (2367) OR
                            (2368) RelADPP
                                (2369) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2370) OR
                                    (2371) RelADPP
                                    (2372) RelADPP
                                        (2373) RelADPReductionPairProof [EQUIVALENT, 22 ms]
                                        (2374) RelADPP
                            (2375) RelADPP
                                (2376) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2377) OR
                                    (2378) RelADPP
                                    (2379) RelADPP
                                        (2380) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                        (2381) RelADPP
                            (2382) RelADPP
                                (2383) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                                (2384) RelADPP
                                (2385) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2386) AND
                                    (2387) RelADPP
                                        (2388) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (2389) QDP
                                    (2390) RelADPP
                                        (2391) RelADPCleverAfsProof [SOUND, 0 ms]
                                        (2392) QDP
                                        (2393) MRRProof [EQUIVALENT, 1 ms]
                                        (2394) QDP
                                    (2395) RelADPP
                                        (2396) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (2397) QDP
                    (2398) RelADPP
                        (2399) RelADPDerelatifying2Proof [SOUND, 7 ms]
                        (2400) OR
                            (2401) RelADPP
                                (2402) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2403) OR
                                    (2404) RelADPP
                                    (2405) RelADPP
                            (2406) RelADPP
                                (2407) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2408) OR
                                    (2409) RelADPP
                                    (2410) RelADPP
                                        (2411) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                        (2412) RelADPP
                                        (2413) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2414) AND
                                            (2415) RelADPP
                                            (2416) RelADPP
                                            (2417) RelADPP
                            (2418) RelADPP
                                (2419) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2420) OR
                                    (2421) RelADPP
                                    (2422) RelADPP
                                        (2423) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                        (2424) RelADPP
                                        (2425) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2426) AND
                                            (2427) RelADPP
                                            (2428) RelADPP
                                            (2429) RelADPP
                    (2430) RelADPP
                        (2431) RelADPDerelatifying2Proof [SOUND, 9 ms]
                        (2432) OR
                            (2433) RelADPP
                                (2434) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2435) OR
                                    (2436) RelADPP
                                        (2437) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                        (2438) RelADPP
                                    (2439) RelADPP
                            (2440) RelADPP
                                (2441) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                (2442) RelADPP
                                (2443) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2444) AND
                                    (2445) RelADPP
                                        (2446) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (2447) QDP
                                    (2448) RelADPP
                                        (2449) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (2450) QDP
                                        (2451) MRRProof [EQUIVALENT, 1 ms]
                                        (2452) QDP
                                    (2453) RelADPP
                                        (2454) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (2455) QDP
                            (2456) RelADPP
                                (2457) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2458) OR
                                    (2459) RelADPP
                                    (2460) RelADPP
                                        (2461) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                        (2462) RelADPP
            (2463) RelADPP
                (2464) RelADPDerelatifying2Proof [SOUND, 6 ms]
                (2465) OR
                    (2466) RelADPP
                        (2467) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2468) OR
                            (2469) RelADPP
                                (2470) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2471) OR
                                    (2472) RelADPP
                                    (2473) RelADPP
                            (2474) RelADPP
                                (2475) RelADPDerelatifying2Proof [SOUND, 1 ms]
                                (2476) OR
                                    (2477) RelADPP
                                    (2478) RelADPP
                            (2479) RelADPP
                                (2480) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (2481) RelADPP
                                (2482) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2483) AND
                                    (2484) RelADPP
                                    (2485) RelADPP
                                    (2486) RelADPP
                    (2487) RelADPP
                        (2488) RelADPDerelatifying2Proof [SOUND, 6 ms]
                        (2489) OR
                            (2490) RelADPP
                                (2491) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2492) OR
                                    (2493) RelADPP
                                    (2494) RelADPP
                            (2495) RelADPP
                                (2496) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2497) OR
                                    (2498) RelADPP
                                    (2499) RelADPP
                            (2500) RelADPP
                                (2501) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (2502) RelADPP
                                (2503) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2504) AND
                                    (2505) RelADPP
                                    (2506) RelADPP
                                    (2507) RelADPP
                    (2508) RelADPP
                        (2509) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (2510) OR
                            (2511) RelADPP
                                (2512) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (2513) OR
                                    (2514) RelADPP
                                    (2515) RelADPP
                            (2516) RelADPP
                                (2517) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2518) OR
                                    (2519) RelADPP
                                    (2520) RelADPP
                            (2521) RelADPP
                                (2522) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (2523) RelADPP
                                (2524) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2525) AND
                                    (2526) RelADPP
                                    (2527) RelADPP
                                    (2528) RelADPP
                                    (2529) RelADPP
                                    (2530) RelADPP
                                    (2531) RelADPP
                    (2532) RelADPP
                        (2533) RelADPReductionPairProof [EQUIVALENT, 21 ms]
                        (2534) RelADPP
                        (2535) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (2536) AND
                            (2537) RelADPP
                                (2538) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (2539) QDP
                            (2540) RelADPP
                                (2541) RelADPCleverAfsProof [SOUND, 4 ms]
                                (2542) QDP
                                (2543) MRRProof [EQUIVALENT, 1 ms]
                                (2544) QDP
                            (2545) RelADPP
                                (2546) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (2547) QDP
            (2548) RelADPP
                (2549) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (2550) OR
                    (2551) RelADPP
                        (2552) RelADPDerelatifying2Proof [SOUND, 11 ms]
                        (2553) OR
                            (2554) RelADPP
                                (2555) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2556) OR
                                    (2557) RelADPP
                                    (2558) RelADPP
                            (2559) RelADPP
                                (2560) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2561) OR
                                    (2562) RelADPP
                                    (2563) RelADPP
                                        (2564) RelADPReductionPairProof [EQUIVALENT, 19 ms]
                                        (2565) RelADPP
                            (2566) RelADPP
                                (2567) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2568) OR
                                    (2569) RelADPP
                                    (2570) RelADPP
                                        (2571) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                        (2572) RelADPP
                    (2573) RelADPP
                        (2574) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2575) OR
                            (2576) RelADPP
                                (2577) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2578) OR
                                    (2579) RelADPP
                                    (2580) RelADPP
                            (2581) RelADPP
                                (2582) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2583) OR
                                    (2584) RelADPP
                                    (2585) RelADPP
                                        (2586) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                        (2587) RelADPP
                                        (2588) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2589) AND
                                            (2590) RelADPP
                                            (2591) RelADPP
                                            (2592) RelADPP
                            (2593) RelADPP
                                (2594) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2595) OR
                                    (2596) RelADPP
                                    (2597) RelADPP
                                        (2598) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (2599) RelADPP
                                        (2600) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2601) AND
                                            (2602) RelADPP
                                            (2603) RelADPP
                                            (2604) RelADPP
                    (2605) RelADPP
                        (2606) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2607) OR
                            (2608) RelADPP
                                (2609) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2610) OR
                                    (2611) RelADPP
                                    (2612) RelADPP
                                        (2613) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                        (2614) RelADPP
                            (2615) RelADPP
                                (2616) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2617) OR
                                    (2618) RelADPP
                                    (2619) RelADPP
                                        (2620) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                        (2621) RelADPP
                            (2622) RelADPP
                                (2623) RelADPReductionPairProof [EQUIVALENT, 20 ms]
                                (2624) RelADPP
                                (2625) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2626) AND
                                    (2627) RelADPP
                                    (2628) RelADPP
                                    (2629) RelADPP
                                        (2630) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (2631) RelADPP
                                        (2632) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (2633) YES
                                    (2634) RelADPP
                                        (2635) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (2636) RelADPP
                                        (2637) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (2638) YES
                                    (2639) RelADPP
                                        (2640) RelADPReductionPairProof [EQUIVALENT, 14 ms]
                                        (2641) RelADPP
                                    (2642) RelADPP
                                        (2643) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (2644) RelADPP
                    (2645) RelADPP
                        (2646) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (2647) OR
                            (2648) RelADPP
                                (2649) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2650) OR
                                    (2651) RelADPP
                                    (2652) RelADPP
                                        (2653) RelADPReductionPairProof [EQUIVALENT, 11 ms]
                                        (2654) RelADPP
                            (2655) RelADPP
                                (2656) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2657) OR
                                    (2658) RelADPP
                                    (2659) RelADPP
                                        (2660) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (2661) RelADPP
                            (2662) RelADPP
                                (2663) RelADPReductionPairProof [EQUIVALENT, 17 ms]
                                (2664) RelADPP
                                (2665) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2666) AND
                                    (2667) RelADPP
                                    (2668) RelADPP
                                        (2669) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (2670) QDP
                                    (2671) RelADPP
                                        (2672) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (2673) RelADPP
                                        (2674) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (2675) YES
                                    (2676) RelADPP
                                        (2677) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (2678) RelADPP
                                        (2679) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (2680) YES
                                    (2681) RelADPP
                                        (2682) RelADPReductionPairProof [EQUIVALENT, 14 ms]
                                        (2683) RelADPP
                                    (2684) RelADPP
                                        (2685) RelADPReductionPairProof [EQUIVALENT, 14 ms]
                                        (2686) RelADPP
            (2687) RelADPP
                (2688) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (2689) OR
                    (2690) RelADPP
                        (2691) RelADPDerelatifying2Proof [SOUND, 7 ms]
                        (2692) OR
                            (2693) RelADPP
                                (2694) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2695) OR
                                    (2696) RelADPP
                                        (2697) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (2698) RelADPP
                                        (2699) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2700) AND
                                            (2701) RelADPP
                                            (2702) RelADPP
                                            (2703) RelADPP
                                    (2704) RelADPP
                            (2705) RelADPP
                                (2706) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (2707) RelADPP
                                (2708) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2709) AND
                                    (2710) RelADPP
                                        (2711) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (2712) QDP
                                        (2713) MRRProof [EQUIVALENT, 1 ms]
                                        (2714) QDP
                                    (2715) RelADPP
                                        (2716) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (2717) QDP
                                    (2718) RelADPP
                                        (2719) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (2720) QDP
                            (2721) RelADPP
                                (2722) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2723) OR
                                    (2724) RelADPP
                                    (2725) RelADPP
                                        (2726) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (2727) RelADPP
                    (2728) RelADPP
                        (2729) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (2730) OR
                            (2731) RelADPP
                                (2732) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2733) OR
                                    (2734) RelADPP
                                        (2735) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (2736) RelADPP
                                        (2737) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2738) AND
                                            (2739) RelADPP
                                            (2740) RelADPP
                                            (2741) RelADPP
                                    (2742) RelADPP
                            (2743) RelADPP
                                (2744) RelADPReductionPairProof [EQUIVALENT, 9 ms]
                                (2745) RelADPP
                                (2746) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2747) AND
                                    (2748) RelADPP
                                        (2749) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (2750) QDP
                                    (2751) RelADPP
                                        (2752) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (2753) QDP
                                        (2754) MRRProof [EQUIVALENT, 1 ms]
                                        (2755) QDP
                                    (2756) RelADPP
                                        (2757) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                        (2758) QDP
                            (2759) RelADPP
                                (2760) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2761) OR
                                    (2762) RelADPP
                                    (2763) RelADPP
                                        (2764) RelADPReductionPairProof [EQUIVALENT, 16 ms]
                                        (2765) RelADPP
                                        (2766) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (2767) AND
                                            (2768) RelADPP
                                            (2769) RelADPP
                                            (2770) RelADPP
                    (2771) RelADPP
                        (2772) RelADPReductionPairProof [EQUIVALENT, 26 ms]
                        (2773) RelADPP
                        (2774) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (2775) AND
                            (2776) RelADPP
                                (2777) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (2778) QDP
                                (2779) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (2780) YES
                            (2781) RelADPP
                                (2782) RelADPCleverAfsProof [SOUND, 16 ms]
                                (2783) QDP
                                (2784) MRRProof [EQUIVALENT, 7 ms]
                                (2785) QDP
                                (2786) PisEmptyProof [EQUIVALENT, 0 ms]
                                (2787) YES
                            (2788) RelADPP
                                (2789) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (2790) QDP
                    (2791) RelADPP
                        (2792) RelADPDerelatifying2Proof [SOUND, 4 ms]
                        (2793) OR
                            (2794) RelADPP
                                (2795) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2796) OR
                                    (2797) RelADPP
                                    (2798) RelADPP
                                        (2799) RelADPReductionPairProof [EQUIVALENT, 18 ms]
                                        (2800) RelADPP
                            (2801) RelADPP
                                (2802) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (2803) OR
                                    (2804) RelADPP
                                    (2805) RelADPP
                                        (2806) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                                        (2807) RelADPP
                            (2808) RelADPP
                                (2809) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                                (2810) RelADPP
                                (2811) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (2812) AND
                                    (2813) RelADPP
                                    (2814) RelADPP
                                    (2815) RelADPP
                                        (2816) RelADPReductionPairProof [EQUIVALENT, 14 ms]
                                        (2817) RelADPP
                                        (2818) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (2819) YES
                                    (2820) RelADPP
                                        (2821) RelADPReductionPairProof [EQUIVALENT, 14 ms]
                                        (2822) RelADPP
                                    (2823) RelADPP
                                        (2824) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (2825) RelADPP
                                        (2826) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (2827) YES
                                    (2828) RelADPP
                                        (2829) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (2830) RelADPP


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   c(a(a(x1))) -> c(c(b(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))

The relative TRS consists of the following S rules:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(a(x1))) -> a(b(a(x1)))


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(b(a(x1))) -> b(b(C(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   b(c(b(x1))) -> a(a(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(3) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 6 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(4)
Complex Obligation (OR)

----------------------------------------

(5)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(6) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(7)
Complex Obligation (OR)

----------------------------------------

(8)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(9) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(10)
Complex Obligation (OR)

----------------------------------------

(11)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(12) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(13)
Complex Obligation (OR)

----------------------------------------

(14)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(15) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(16)
Complex Obligation (OR)

----------------------------------------

(17)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(18)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(19)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(20) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(21)
Complex Obligation (OR)

----------------------------------------

(22)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(23)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(24)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(25) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(26)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(27) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(28)
Complex Obligation (AND)

----------------------------------------

(29)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(30)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(31)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(32)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(33) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(34)
Complex Obligation (OR)

----------------------------------------

(35)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(36) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(37)
Complex Obligation (OR)

----------------------------------------

(38)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(39)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(40)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(41) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(42)
Complex Obligation (OR)

----------------------------------------

(43)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(44)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(45)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(46) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(47)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(48) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(49)
Complex Obligation (AND)

----------------------------------------

(50)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(51)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(52)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(53)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(54) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(55)
Complex Obligation (OR)

----------------------------------------

(56)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(57) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(58)
Complex Obligation (OR)

----------------------------------------

(59)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(60)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(61)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(62) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(63)
Complex Obligation (OR)

----------------------------------------

(64)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(65)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(66)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(67) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(68)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(69) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(70)
Complex Obligation (AND)

----------------------------------------

(71)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(72)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(73)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(74)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(75) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(76)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(77) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(78)
Complex Obligation (AND)

----------------------------------------

(79)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(80) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(81)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(82) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(83)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(84)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(85) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(86)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(87)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(88) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(89)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(90)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(91) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(92)
Complex Obligation (OR)

----------------------------------------

(93)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(94) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(95)
Complex Obligation (OR)

----------------------------------------

(96)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(97) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(98)
Complex Obligation (OR)

----------------------------------------

(99)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(100)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(101)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(102) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(103)
Complex Obligation (OR)

----------------------------------------

(104)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(105)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(106)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(107) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(108)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(109) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(110)
Complex Obligation (AND)

----------------------------------------

(111)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(112)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(113)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(114)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(115) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(116)
Complex Obligation (OR)

----------------------------------------

(117)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(118) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(119)
Complex Obligation (OR)

----------------------------------------

(120)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(121)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(122)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(123) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(124)
Complex Obligation (OR)

----------------------------------------

(125)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(126)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(127)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(128) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(129)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(130) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(131)
Complex Obligation (AND)

----------------------------------------

(132)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(133)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(134)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(135)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(136) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(137)
Complex Obligation (OR)

----------------------------------------

(138)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(139) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(140)
Complex Obligation (OR)

----------------------------------------

(141)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(142)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(143)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(144) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(145)
Complex Obligation (OR)

----------------------------------------

(146)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(147)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(148)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(149) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(150)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(151) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(152)
Complex Obligation (AND)

----------------------------------------

(153)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(154)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(155)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(156)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(157) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(158)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(159) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(160)
Complex Obligation (AND)

----------------------------------------

(161)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(162) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(163)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(164)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(165) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(166)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(167) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(168)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(169)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(170) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(171)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(172)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(173) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(174)
Complex Obligation (OR)

----------------------------------------

(175)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(176) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(177)
Complex Obligation (OR)

----------------------------------------

(178)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(179) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(180)
Complex Obligation (OR)

----------------------------------------

(181)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(182)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(183) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(184)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(185)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(186) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(187)
Complex Obligation (OR)

----------------------------------------

(188)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(189)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(190) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(191)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(192)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(193) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(194)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(195) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(196)
Complex Obligation (AND)

----------------------------------------

(197)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(198) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(199)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(200)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(201)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(202)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(203) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(204)
Complex Obligation (OR)

----------------------------------------

(205)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(206) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(207)
Complex Obligation (OR)

----------------------------------------

(208)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(209)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(210) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(211)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(212)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(213) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(214)
Complex Obligation (OR)

----------------------------------------

(215)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(216)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(217) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(218)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(219)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(220) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(221)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(222) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(223)
Complex Obligation (AND)

----------------------------------------

(224)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(225) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(226)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(227)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(228) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(229)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(230) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(231)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(232)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(233) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(234)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(235)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(236) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(237)
Complex Obligation (OR)

----------------------------------------

(238)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(239) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(240)
Complex Obligation (OR)

----------------------------------------

(241)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(242)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(243) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(244)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(245)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(246) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(247)
Complex Obligation (OR)

----------------------------------------

(248)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(249)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(250) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(251)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(252)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(253) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(254)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(255) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(256)
Complex Obligation (AND)

----------------------------------------

(257)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(258)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(259)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(260) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(261)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(262) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(263)
YES

----------------------------------------

(264)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(265) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(266)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(267)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(268) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(269)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(270)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(271) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(272)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(273) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(274)
YES

----------------------------------------

(275)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(276) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(B(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 1 + 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(277)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(278) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(279)
Complex Obligation (AND)

----------------------------------------

(280)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(281) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(282)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(283)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(284) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(285)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(286) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(287)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(288) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(289)
YES

----------------------------------------

(290)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(291) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(292)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(293) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))
   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
88248, 88249, 88250, 88251, 88252, 88253, 88254, 88255, 88256, 88257, 88258, 88259, 88260, 88261, 88262, 88263, 88264, 88265, 88266, 88267, 88268, 88269, 88270, 88271, 88272, 88273, 88274, 88275, 88276, 88277, 88278, 88279, 88280, 88281, 88282, 88283

Node 88248 is start node and node 88249 is final node.

Those nodes are connected through the following edges:

* 88248 to 88250 labelled c_1(0), a_1(0), C_1(0)* 88248 to 88252 labelled a_1(0)* 88248 to 88254 labelled b_1(0)* 88248 to 88256 labelled c_1(0), C_1(0)* 88248 to 88266 labelled b_1(1)* 88248 to 88272 labelled c_1(1), C_1(1)* 88248 to 88274 labelled b_1(2)* 88249 to 88249 labelled #_1(0)* 88250 to 88251 labelled b_1(0)* 88251 to 88249 labelled a_1(0)* 88251 to 88258 labelled a_1(1)* 88252 to 88253 labelled a_1(0)* 88253 to 88249 labelled c_1(0), a_1(0)* 88253 to 88260 labelled c_1(1), a_1(1)* 88253 to 88262 labelled c_1(1)* 88253 to 88258 labelled a_1(1)* 88253 to 88282 labelled c_1(2)* 88254 to 88255 labelled b_1(0)* 88254 to 88264 labelled a_1(1)* 88255 to 88249 labelled c_1(0)* 88255 to 88260 labelled c_1(1), a_1(1)* 88255 to 88262 labelled c_1(1)* 88255 to 88282 labelled c_1(2)* 88256 to 88257 labelled c_1(0)* 88256 to 88268 labelled a_1(1)* 88256 to 88270 labelled c_1(1)* 88257 to 88249 labelled b_1(0)* 88257 to 88264 labelled a_1(1)* 88257 to 88266 labelled b_1(1)* 88257 to 88274 labelled b_1(2)* 88258 to 88259 labelled a_1(1)* 88259 to 88249 labelled c_1(1)* 88259 to 88260 labelled c_1(1), a_1(1)* 88259 to 88262 labelled c_1(1)* 88259 to 88282 labelled c_1(2)* 88260 to 88261 labelled b_1(1)* 88261 to 88249 labelled a_1(1)* 88261 to 88258 labelled a_1(1)* 88262 to 88263 labelled c_1(1)* 88262 to 88278 labelled a_1(2)* 88262 to 88280 labelled c_1(2)* 88263 to 88249 labelled b_1(1)* 88263 to 88264 labelled a_1(1)* 88263 to 88266 labelled b_1(1)* 88263 to 88274 labelled b_1(2)* 88264 to 88265 labelled a_1(1)* 88265 to 88249 labelled a_1(1)* 88265 to 88258 labelled a_1(1)* 88265 to 88261 labelled a_1(1)* 88265 to 88283 labelled a_1(1)* 88266 to 88267 labelled b_1(1)* 88266 to 88264 labelled a_1(1)* 88266 to 88276 labelled a_1(2)* 88267 to 88249 labelled c_1(1)* 88267 to 88260 labelled c_1(1), a_1(1)* 88267 to 88262 labelled c_1(1)* 88267 to 88282 labelled c_1(2)* 88268 to 88269 labelled b_1(1)* 88269 to 88265 labelled a_1(1)* 88270 to 88271 labelled c_1(1)* 88271 to 88265 labelled b_1(1)* 88272 to 88273 labelled b_1(1)* 88273 to 88269 labelled a_1(1)* 88274 to 88275 labelled b_1(2)* 88274 to 88276 labelled a_1(2)* 88275 to 88260 labelled c_1(2)* 88276 to 88277 labelled a_1(2)* 88277 to 88261 labelled a_1(2)* 88277 to 88283 labelled a_1(2)* 88278 to 88279 labelled b_1(2)* 88279 to 88265 labelled a_1(2)* 88280 to 88281 labelled c_1(2)* 88281 to 88265 labelled b_1(2)* 88282 to 88283 labelled b_1(2)* 88283 to 88279 labelled a_1(2)


----------------------------------------

(294)
YES

----------------------------------------

(295)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(296) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(297)
Complex Obligation (OR)

----------------------------------------

(298)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(299) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(300)
Complex Obligation (OR)

----------------------------------------

(301)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(302) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(303)
Complex Obligation (OR)

----------------------------------------

(304)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(305)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(306)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(307) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(308)
Complex Obligation (OR)

----------------------------------------

(309)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(310)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(311)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(312) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(313)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(314) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(315)
Complex Obligation (AND)

----------------------------------------

(316)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(317)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(318)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(319)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(320) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(321)
Complex Obligation (OR)

----------------------------------------

(322)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(323) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(324)
Complex Obligation (OR)

----------------------------------------

(325)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(326)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(327)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(328) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(329)
Complex Obligation (OR)

----------------------------------------

(330)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(331)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(332)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(333) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(334)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(335) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(336)
Complex Obligation (AND)

----------------------------------------

(337)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(338)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(339)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(340)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(341) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(342)
Complex Obligation (OR)

----------------------------------------

(343)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(344) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(345)
Complex Obligation (OR)

----------------------------------------

(346)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(347)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(348)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(349) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(350)
Complex Obligation (OR)

----------------------------------------

(351)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(352)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(353)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(354) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(355)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(356) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(357)
Complex Obligation (AND)

----------------------------------------

(358)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(359)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(360)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(361)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(362)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(363)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(364)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(365) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = 1 + 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(366)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(367) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(368)
Complex Obligation (AND)

----------------------------------------

(369)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(370) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(371)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(372)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(373) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(374)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(375) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(376)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(377)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(378) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(379)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(380)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(381) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(382)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(383) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(384)
Complex Obligation (AND)

----------------------------------------

(385)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(386) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(387)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(388) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))
   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
65474, 65475, 65476, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65503, 65504, 65505, 65506, 65507, 65508, 65509, 65510, 65511, 65512, 65523, 65524, 65525, 65526, 65527, 65528, 65529, 65530, 65531, 65532, 65533, 65534, 65535, 65536, 65537, 65538

Node 65474 is start node and node 65475 is final node.

Those nodes are connected through the following edges:

* 65474 to 65476 labelled c_1(0), a_1(0), C_1(0)* 65474 to 65478 labelled a_1(0)* 65474 to 65480 labelled b_1(0)* 65474 to 65482 labelled c_1(0), C_1(0)* 65474 to 65511 labelled b_1(1)* 65474 to 65527 labelled c_1(1), C_1(1)* 65474 to 65529 labelled b_1(2)* 65475 to 65475 labelled #_1(0)* 65476 to 65477 labelled b_1(0)* 65477 to 65475 labelled a_1(0)* 65477 to 65503 labelled a_1(1)* 65478 to 65479 labelled a_1(0)* 65479 to 65475 labelled c_1(0), a_1(0)* 65479 to 65505 labelled c_1(1), a_1(1)* 65479 to 65507 labelled c_1(1)* 65479 to 65503 labelled a_1(1)* 65479 to 65537 labelled c_1(2)* 65480 to 65481 labelled b_1(0)* 65480 to 65509 labelled a_1(1)* 65481 to 65475 labelled c_1(0)* 65481 to 65505 labelled c_1(1), a_1(1)* 65481 to 65507 labelled c_1(1)* 65481 to 65537 labelled c_1(2)* 65482 to 65483 labelled c_1(0)* 65482 to 65523 labelled a_1(1)* 65482 to 65525 labelled c_1(1)* 65483 to 65475 labelled b_1(0)* 65483 to 65509 labelled a_1(1)* 65483 to 65511 labelled b_1(1)* 65483 to 65529 labelled b_1(2)* 65503 to 65504 labelled a_1(1)* 65504 to 65475 labelled c_1(1)* 65504 to 65505 labelled c_1(1), a_1(1)* 65504 to 65507 labelled c_1(1)* 65504 to 65537 labelled c_1(2)* 65505 to 65506 labelled b_1(1)* 65506 to 65475 labelled a_1(1)* 65506 to 65503 labelled a_1(1)* 65507 to 65508 labelled c_1(1)* 65507 to 65533 labelled a_1(2)* 65507 to 65535 labelled c_1(2)* 65508 to 65475 labelled b_1(1)* 65508 to 65509 labelled a_1(1)* 65508 to 65511 labelled b_1(1)* 65508 to 65529 labelled b_1(2)* 65509 to 65510 labelled a_1(1)* 65510 to 65475 labelled a_1(1)* 65510 to 65503 labelled a_1(1)* 65510 to 65506 labelled a_1(1)* 65510 to 65538 labelled a_1(1)* 65511 to 65512 labelled b_1(1)* 65511 to 65509 labelled a_1(1)* 65511 to 65531 labelled a_1(2)* 65512 to 65475 labelled c_1(1)* 65512 to 65505 labelled c_1(1), a_1(1)* 65512 to 65507 labelled c_1(1)* 65512 to 65537 labelled c_1(2)* 65523 to 65524 labelled b_1(1)* 65524 to 65510 labelled a_1(1)* 65525 to 65526 labelled c_1(1)* 65526 to 65510 labelled b_1(1)* 65527 to 65528 labelled b_1(1)* 65528 to 65524 labelled a_1(1)* 65529 to 65530 labelled b_1(2)* 65529 to 65531 labelled a_1(2)* 65530 to 65505 labelled c_1(2)* 65531 to 65532 labelled a_1(2)* 65532 to 65506 labelled a_1(2)* 65532 to 65538 labelled a_1(2)* 65533 to 65534 labelled b_1(2)* 65534 to 65510 labelled a_1(2)* 65535 to 65536 labelled c_1(2)* 65536 to 65510 labelled b_1(2)* 65537 to 65538 labelled b_1(2)* 65538 to 65534 labelled a_1(2)


----------------------------------------

(389)
YES

----------------------------------------

(390)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(391) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(392)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(393) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(394)
YES

----------------------------------------

(395)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(396) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(397)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(398) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))
   B(b(a(x1))) -> B(b(c(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
65513, 65514, 65515, 65516, 65517, 65518, 65519, 65520, 65521, 65522, 66401, 66402, 66403, 66404, 66405, 66406, 66407, 66408, 66409, 66410, 66411, 66412, 66413, 66414, 66415, 66416, 66417, 66418, 66419, 66420, 66421, 66422, 66423, 66424, 66425, 66426

Node 65513 is start node and node 65514 is final node.

Those nodes are connected through the following edges:

* 65513 to 65515 labelled c_1(0), a_1(0)* 65513 to 65517 labelled a_1(0)* 65513 to 65519 labelled b_1(0), B_1(0)* 65513 to 65521 labelled c_1(0)* 65513 to 66409 labelled b_1(1), B_1(1)* 65513 to 66415 labelled c_1(1)* 65513 to 66417 labelled b_1(2), B_1(2)* 65514 to 65514 labelled #_1(0)* 65515 to 65516 labelled b_1(0)* 65516 to 65514 labelled a_1(0)* 65516 to 66401 labelled a_1(1)* 65517 to 65518 labelled a_1(0)* 65518 to 65514 labelled c_1(0), a_1(0)* 65518 to 66403 labelled c_1(1), a_1(1)* 65518 to 66405 labelled c_1(1)* 65518 to 66401 labelled a_1(1)* 65518 to 66425 labelled c_1(2)* 65519 to 65520 labelled b_1(0)* 65519 to 66407 labelled a_1(1)* 65520 to 65514 labelled c_1(0)* 65520 to 66403 labelled c_1(1), a_1(1)* 65520 to 66405 labelled c_1(1)* 65520 to 66425 labelled c_1(2)* 65521 to 65522 labelled c_1(0)* 65521 to 66411 labelled a_1(1)* 65521 to 66413 labelled c_1(1)* 65522 to 65514 labelled b_1(0)* 65522 to 66407 labelled a_1(1)* 65522 to 66409 labelled b_1(1)* 65522 to 66417 labelled b_1(2)* 66401 to 66402 labelled a_1(1)* 66402 to 65514 labelled c_1(1)* 66402 to 66403 labelled c_1(1), a_1(1)* 66402 to 66405 labelled c_1(1)* 66402 to 66425 labelled c_1(2)* 66403 to 66404 labelled b_1(1)* 66404 to 65514 labelled a_1(1)* 66404 to 66401 labelled a_1(1)* 66405 to 66406 labelled c_1(1)* 66405 to 66421 labelled a_1(2)* 66405 to 66423 labelled c_1(2)* 66406 to 65514 labelled b_1(1)* 66406 to 66407 labelled a_1(1)* 66406 to 66409 labelled b_1(1)* 66406 to 66417 labelled b_1(2)* 66407 to 66408 labelled a_1(1)* 66408 to 65514 labelled a_1(1)* 66408 to 66401 labelled a_1(1)* 66408 to 66404 labelled a_1(1)* 66408 to 66426 labelled a_1(1)* 66409 to 66410 labelled b_1(1)* 66409 to 66407 labelled a_1(1)* 66409 to 66419 labelled a_1(2)* 66410 to 65514 labelled c_1(1)* 66410 to 66403 labelled c_1(1), a_1(1)* 66410 to 66405 labelled c_1(1)* 66410 to 66425 labelled c_1(2)* 66411 to 66412 labelled b_1(1)* 66412 to 66408 labelled a_1(1)* 66413 to 66414 labelled c_1(1)* 66414 to 66408 labelled b_1(1)* 66415 to 66416 labelled b_1(1)* 66416 to 66412 labelled a_1(1)* 66417 to 66418 labelled b_1(2)* 66417 to 66419 labelled a_1(2)* 66418 to 66403 labelled c_1(2)* 66419 to 66420 labelled a_1(2)* 66420 to 66404 labelled a_1(2)* 66420 to 66426 labelled a_1(2)* 66421 to 66422 labelled b_1(2)* 66422 to 66408 labelled a_1(2)* 66423 to 66424 labelled c_1(2)* 66424 to 66408 labelled b_1(2)* 66425 to 66426 labelled b_1(2)* 66426 to 66422 labelled a_1(2)


----------------------------------------

(399)
YES

----------------------------------------

(400)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(401) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(402)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(403) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(404)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(405)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(406) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(407)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(408) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(409)
YES

----------------------------------------

(410)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(411) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(412)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(413) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(414)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(415)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(416) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(417)
Complex Obligation (OR)

----------------------------------------

(418)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(419) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(420)
Complex Obligation (OR)

----------------------------------------

(421)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(422) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(423)
Complex Obligation (OR)

----------------------------------------

(424)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(425) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(426)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(427) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(428)
Complex Obligation (AND)

----------------------------------------

(429)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(430) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(431)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(432)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(433) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(434)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(435) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(436)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(437)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(438) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(439)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(440)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(441) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(442)
Complex Obligation (OR)

----------------------------------------

(443)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(444) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(445)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(446) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(447)
Complex Obligation (AND)

----------------------------------------

(448)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(449)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(450)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(451)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(452)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(453) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(454)
Complex Obligation (OR)

----------------------------------------

(455)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(456) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(457)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(458) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(459)
Complex Obligation (AND)

----------------------------------------

(460)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(461)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(462)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(463)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(464)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(465) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(466)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(467) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(468)
Complex Obligation (AND)

----------------------------------------

(469)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(470) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(471)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(472) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(473)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(474) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(475)
YES

----------------------------------------

(476)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(477) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(478)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(479)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(480) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(481)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(482)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(483) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(484)
Complex Obligation (OR)

----------------------------------------

(485)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(486) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(487)
Complex Obligation (OR)

----------------------------------------

(488)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(489) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(490)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(491) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(492)
Complex Obligation (AND)

----------------------------------------

(493)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(494)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(495)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(496)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(497)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(498) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(499)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(500) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(501)
Complex Obligation (AND)

----------------------------------------

(502)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(503) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(504)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(505) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(506)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(507)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(508) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(509)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(510)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(511) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(512)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(513)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(514) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(515)
Complex Obligation (OR)

----------------------------------------

(516)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(517)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(518) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(519)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(520) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(521)
Complex Obligation (AND)

----------------------------------------

(522)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(523)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(524)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(525)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(526) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(527)
Complex Obligation (OR)

----------------------------------------

(528)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(529) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(530)
Complex Obligation (OR)

----------------------------------------

(531)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(532) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(533)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(534) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(535)
Complex Obligation (AND)

----------------------------------------

(536)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(537)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(538)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(539)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(540)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(541) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(542)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(543) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(544)
Complex Obligation (AND)

----------------------------------------

(545)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(546) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(547)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(548)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(549) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(550)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(551) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(552)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(553)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(554) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(555)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(556)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(557) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(558)
Complex Obligation (OR)

----------------------------------------

(559)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(560)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(561) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(562)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(563) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(564)
Complex Obligation (AND)

----------------------------------------

(565)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(566)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(567)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(568)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(569) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(570)
Complex Obligation (OR)

----------------------------------------

(571)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(572) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(573)
Complex Obligation (OR)

----------------------------------------

(574)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(575) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(576)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(577) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(578)
Complex Obligation (AND)

----------------------------------------

(579)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(580)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(581)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(582)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(583) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(584)
Complex Obligation (OR)

----------------------------------------

(585)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(586)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(587)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(588) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(589)
Complex Obligation (OR)

----------------------------------------

(590)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(591)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(592)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(593) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(594)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(595) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(596)
Complex Obligation (AND)

----------------------------------------

(597)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(598) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(599)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(600)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(601) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(602)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(603) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(604)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(605)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(606) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(607)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(608)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(609) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(610)
Complex Obligation (OR)

----------------------------------------

(611)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(612) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(613)
Complex Obligation (OR)

----------------------------------------

(614)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(615)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(616)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(617) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(618)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(619) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(620)
Complex Obligation (AND)

----------------------------------------

(621)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(622)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(623)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(624)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(625) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(626)
Complex Obligation (OR)

----------------------------------------

(627)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(628)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(629)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(630) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(631)
Complex Obligation (OR)

----------------------------------------

(632)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(633) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(634)
Complex Obligation (OR)

----------------------------------------

(635)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(636)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(637)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(638) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(639)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(640) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(641)
Complex Obligation (AND)

----------------------------------------

(642)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(643)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(644)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(645)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(646) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(647)
Complex Obligation (OR)

----------------------------------------

(648)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(649)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(650)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(651) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(652)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(653) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(654)
Complex Obligation (AND)

----------------------------------------

(655)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(656) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(657)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(658) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))
   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
64520, 64521, 64524, 64525, 64526, 64527, 64528, 64529, 64530, 64531, 64532, 64533, 64534, 64535, 64536, 64537, 64538, 64539, 64540, 64541, 64542, 64543, 64544, 64545, 64580, 64581, 64582, 64583, 64584, 64585, 64586, 64587, 64588, 64589, 64590, 64591

Node 64520 is start node and node 64521 is final node.

Those nodes are connected through the following edges:

* 64520 to 64524 labelled c_1(0), a_1(0), C_1(0)* 64520 to 64526 labelled a_1(0)* 64520 to 64528 labelled b_1(0)* 64520 to 64530 labelled c_1(0), C_1(0)* 64520 to 64540 labelled b_1(1)* 64520 to 64580 labelled c_1(1), C_1(1)* 64520 to 64582 labelled b_1(2)* 64521 to 64521 labelled #_1(0)* 64524 to 64525 labelled b_1(0)* 64525 to 64521 labelled a_1(0)* 64525 to 64532 labelled a_1(1)* 64526 to 64527 labelled a_1(0)* 64527 to 64521 labelled c_1(0), a_1(0)* 64527 to 64534 labelled c_1(1), a_1(1)* 64527 to 64536 labelled c_1(1)* 64527 to 64532 labelled a_1(1)* 64527 to 64590 labelled c_1(2)* 64528 to 64529 labelled b_1(0)* 64528 to 64538 labelled a_1(1)* 64529 to 64521 labelled c_1(0)* 64529 to 64534 labelled c_1(1), a_1(1)* 64529 to 64536 labelled c_1(1)* 64529 to 64590 labelled c_1(2)* 64530 to 64531 labelled c_1(0)* 64530 to 64542 labelled a_1(1)* 64530 to 64544 labelled c_1(1)* 64531 to 64521 labelled b_1(0)* 64531 to 64538 labelled a_1(1)* 64531 to 64540 labelled b_1(1)* 64531 to 64582 labelled b_1(2)* 64532 to 64533 labelled a_1(1)* 64533 to 64521 labelled c_1(1)* 64533 to 64534 labelled c_1(1), a_1(1)* 64533 to 64536 labelled c_1(1)* 64533 to 64590 labelled c_1(2)* 64534 to 64535 labelled b_1(1)* 64535 to 64521 labelled a_1(1)* 64535 to 64532 labelled a_1(1)* 64536 to 64537 labelled c_1(1)* 64536 to 64586 labelled a_1(2)* 64536 to 64588 labelled c_1(2)* 64537 to 64521 labelled b_1(1)* 64537 to 64538 labelled a_1(1)* 64537 to 64540 labelled b_1(1)* 64537 to 64582 labelled b_1(2)* 64538 to 64539 labelled a_1(1)* 64539 to 64521 labelled a_1(1)* 64539 to 64532 labelled a_1(1)* 64539 to 64535 labelled a_1(1)* 64539 to 64591 labelled a_1(1)* 64540 to 64541 labelled b_1(1)* 64540 to 64538 labelled a_1(1)* 64540 to 64584 labelled a_1(2)* 64541 to 64521 labelled c_1(1)* 64541 to 64534 labelled c_1(1), a_1(1)* 64541 to 64536 labelled c_1(1)* 64541 to 64590 labelled c_1(2)* 64542 to 64543 labelled b_1(1)* 64543 to 64539 labelled a_1(1)* 64544 to 64545 labelled c_1(1)* 64545 to 64539 labelled b_1(1)* 64580 to 64581 labelled b_1(1)* 64581 to 64543 labelled a_1(1)* 64582 to 64583 labelled b_1(2)* 64582 to 64584 labelled a_1(2)* 64583 to 64534 labelled c_1(2)* 64584 to 64585 labelled a_1(2)* 64585 to 64535 labelled a_1(2)* 64585 to 64591 labelled a_1(2)* 64586 to 64587 labelled b_1(2)* 64587 to 64539 labelled a_1(2)* 64588 to 64589 labelled c_1(2)* 64589 to 64539 labelled b_1(2)* 64590 to 64591 labelled b_1(2)* 64591 to 64587 labelled a_1(2)


----------------------------------------

(659)
YES

----------------------------------------

(660)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(661) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(662)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(663) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(664)
YES

----------------------------------------

(665)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(666) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(667)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(668) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))
   B(b(a(x1))) -> B(b(c(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
64522, 64523, 64546, 64547, 64548, 64549, 64550, 64551, 64552, 64553, 64554, 64555, 64556, 64557, 64558, 64559, 64560, 64561, 64562, 64563, 64564, 64565, 64566, 64567, 64568, 64569, 64570, 64571, 64572, 64573, 64574, 64575, 64576, 64577, 64578, 64579

Node 64522 is start node and node 64523 is final node.

Those nodes are connected through the following edges:

* 64522 to 64546 labelled c_1(0), a_1(0)* 64522 to 64548 labelled a_1(0)* 64522 to 64550 labelled b_1(0), B_1(0)* 64522 to 64552 labelled c_1(0)* 64522 to 64562 labelled b_1(1), B_1(1)* 64522 to 64568 labelled c_1(1)* 64522 to 64570 labelled b_1(2), B_1(2)* 64523 to 64523 labelled #_1(0)* 64546 to 64547 labelled b_1(0)* 64547 to 64523 labelled a_1(0)* 64547 to 64554 labelled a_1(1)* 64548 to 64549 labelled a_1(0)* 64549 to 64523 labelled c_1(0), a_1(0)* 64549 to 64556 labelled c_1(1), a_1(1)* 64549 to 64558 labelled c_1(1)* 64549 to 64554 labelled a_1(1)* 64549 to 64578 labelled c_1(2)* 64550 to 64551 labelled b_1(0)* 64550 to 64560 labelled a_1(1)* 64551 to 64523 labelled c_1(0)* 64551 to 64556 labelled c_1(1), a_1(1)* 64551 to 64558 labelled c_1(1)* 64551 to 64578 labelled c_1(2)* 64552 to 64553 labelled c_1(0)* 64552 to 64564 labelled a_1(1)* 64552 to 64566 labelled c_1(1)* 64553 to 64523 labelled b_1(0)* 64553 to 64560 labelled a_1(1)* 64553 to 64562 labelled b_1(1)* 64553 to 64570 labelled b_1(2)* 64554 to 64555 labelled a_1(1)* 64555 to 64523 labelled c_1(1)* 64555 to 64556 labelled c_1(1), a_1(1)* 64555 to 64558 labelled c_1(1)* 64555 to 64578 labelled c_1(2)* 64556 to 64557 labelled b_1(1)* 64557 to 64523 labelled a_1(1)* 64557 to 64554 labelled a_1(1)* 64558 to 64559 labelled c_1(1)* 64558 to 64574 labelled a_1(2)* 64558 to 64576 labelled c_1(2)* 64559 to 64523 labelled b_1(1)* 64559 to 64560 labelled a_1(1)* 64559 to 64562 labelled b_1(1)* 64559 to 64570 labelled b_1(2)* 64560 to 64561 labelled a_1(1)* 64561 to 64523 labelled a_1(1)* 64561 to 64554 labelled a_1(1)* 64561 to 64557 labelled a_1(1)* 64561 to 64579 labelled a_1(1)* 64562 to 64563 labelled b_1(1)* 64562 to 64560 labelled a_1(1)* 64562 to 64572 labelled a_1(2)* 64563 to 64523 labelled c_1(1)* 64563 to 64556 labelled c_1(1), a_1(1)* 64563 to 64558 labelled c_1(1)* 64563 to 64578 labelled c_1(2)* 64564 to 64565 labelled b_1(1)* 64565 to 64561 labelled a_1(1)* 64566 to 64567 labelled c_1(1)* 64567 to 64561 labelled b_1(1)* 64568 to 64569 labelled b_1(1)* 64569 to 64565 labelled a_1(1)* 64570 to 64571 labelled b_1(2)* 64570 to 64572 labelled a_1(2)* 64571 to 64556 labelled c_1(2)* 64572 to 64573 labelled a_1(2)* 64573 to 64557 labelled a_1(2)* 64573 to 64579 labelled a_1(2)* 64574 to 64575 labelled b_1(2)* 64575 to 64561 labelled a_1(2)* 64576 to 64577 labelled c_1(2)* 64577 to 64561 labelled b_1(2)* 64578 to 64579 labelled b_1(2)* 64579 to 64575 labelled a_1(2)


----------------------------------------

(669)
YES

----------------------------------------

(670)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(671) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(672)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(673) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(674)
YES

----------------------------------------

(675)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(676) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(677)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(678) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(679)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(680) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))
   C(a(b(x1))) -> C(b(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
90329, 90330, 90331, 90334, 90335, 90336, 90337, 90338, 90339, 90340, 90341, 90342, 90343, 90344, 90345, 90346, 90347, 90348, 90349, 90350, 90351, 90352, 90353, 90354, 90355, 90356, 90357, 90358, 90359, 90360, 90361, 90362, 90363, 90364, 90365, 90366

Node 90329 is start node and node 90330 is final node.

Those nodes are connected through the following edges:

* 90329 to 90331 labelled c_1(0), a_1(0), C_1(0)* 90329 to 90335 labelled a_1(0)* 90329 to 90337 labelled b_1(0)* 90329 to 90339 labelled c_1(0)* 90329 to 90349 labelled b_1(1)* 90329 to 90355 labelled c_1(1)* 90329 to 90357 labelled b_1(2)* 90330 to 90330 labelled #_1(0)* 90331 to 90334 labelled b_1(0)* 90334 to 90330 labelled a_1(0)* 90334 to 90341 labelled a_1(1)* 90335 to 90336 labelled a_1(0)* 90336 to 90330 labelled c_1(0), a_1(0)* 90336 to 90343 labelled c_1(1), a_1(1)* 90336 to 90345 labelled c_1(1)* 90336 to 90341 labelled a_1(1)* 90336 to 90365 labelled c_1(2)* 90337 to 90338 labelled b_1(0)* 90337 to 90347 labelled a_1(1)* 90338 to 90330 labelled c_1(0)* 90338 to 90343 labelled c_1(1), a_1(1)* 90338 to 90345 labelled c_1(1)* 90338 to 90365 labelled c_1(2)* 90339 to 90340 labelled c_1(0)* 90339 to 90351 labelled a_1(1)* 90339 to 90353 labelled c_1(1)* 90340 to 90330 labelled b_1(0)* 90340 to 90347 labelled a_1(1)* 90340 to 90349 labelled b_1(1)* 90340 to 90357 labelled b_1(2)* 90341 to 90342 labelled a_1(1)* 90342 to 90330 labelled c_1(1)* 90342 to 90343 labelled c_1(1), a_1(1)* 90342 to 90345 labelled c_1(1)* 90342 to 90365 labelled c_1(2)* 90343 to 90344 labelled b_1(1)* 90344 to 90330 labelled a_1(1)* 90344 to 90341 labelled a_1(1)* 90345 to 90346 labelled c_1(1)* 90345 to 90361 labelled a_1(2)* 90345 to 90363 labelled c_1(2)* 90346 to 90330 labelled b_1(1)* 90346 to 90347 labelled a_1(1)* 90346 to 90349 labelled b_1(1)* 90346 to 90357 labelled b_1(2)* 90347 to 90348 labelled a_1(1)* 90348 to 90330 labelled a_1(1)* 90348 to 90341 labelled a_1(1)* 90348 to 90344 labelled a_1(1)* 90348 to 90366 labelled a_1(1)* 90349 to 90350 labelled b_1(1)* 90349 to 90347 labelled a_1(1)* 90349 to 90359 labelled a_1(2)* 90350 to 90330 labelled c_1(1)* 90350 to 90343 labelled c_1(1), a_1(1)* 90350 to 90345 labelled c_1(1)* 90350 to 90365 labelled c_1(2)* 90351 to 90352 labelled b_1(1)* 90352 to 90348 labelled a_1(1)* 90353 to 90354 labelled c_1(1)* 90354 to 90348 labelled b_1(1)* 90355 to 90356 labelled b_1(1)* 90356 to 90352 labelled a_1(1)* 90357 to 90358 labelled b_1(2)* 90357 to 90359 labelled a_1(2)* 90358 to 90343 labelled c_1(2)* 90359 to 90360 labelled a_1(2)* 90360 to 90344 labelled a_1(2)* 90360 to 90366 labelled a_1(2)* 90361 to 90362 labelled b_1(2)* 90362 to 90348 labelled a_1(2)* 90363 to 90364 labelled c_1(2)* 90364 to 90348 labelled b_1(2)* 90365 to 90366 labelled b_1(2)* 90366 to 90362 labelled a_1(2)


----------------------------------------

(681)
YES

----------------------------------------

(682)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(683) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(684)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(685) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(686)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(687) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
90332, 90333, 90367, 90368, 90369, 90370, 90371, 90372, 90373, 90374, 90375, 90376, 90377, 90378, 90379, 90380, 90381, 90382, 90383, 90384, 90385, 90386, 90387, 90388, 90389, 90390, 90391, 90392, 90393, 90394, 90395, 90396, 90397, 90398, 90399, 90400

Node 90332 is start node and node 90333 is final node.

Those nodes are connected through the following edges:

* 90332 to 90367 labelled c_1(0), a_1(0)* 90332 to 90369 labelled a_1(0)* 90332 to 90371 labelled b_1(0)* 90332 to 90373 labelled c_1(0), C_1(0)* 90332 to 90383 labelled b_1(1)* 90332 to 90389 labelled c_1(1)* 90332 to 90391 labelled b_1(2)* 90333 to 90333 labelled #_1(0)* 90367 to 90368 labelled b_1(0)* 90368 to 90333 labelled a_1(0)* 90368 to 90375 labelled a_1(1)* 90369 to 90370 labelled a_1(0)* 90370 to 90333 labelled c_1(0), a_1(0)* 90370 to 90377 labelled c_1(1), a_1(1)* 90370 to 90379 labelled c_1(1)* 90370 to 90375 labelled a_1(1)* 90370 to 90399 labelled c_1(2)* 90371 to 90372 labelled b_1(0)* 90371 to 90381 labelled a_1(1)* 90372 to 90333 labelled c_1(0)* 90372 to 90377 labelled c_1(1), a_1(1)* 90372 to 90379 labelled c_1(1)* 90372 to 90399 labelled c_1(2)* 90373 to 90374 labelled c_1(0)* 90373 to 90385 labelled a_1(1)* 90373 to 90387 labelled c_1(1)* 90374 to 90333 labelled b_1(0)* 90374 to 90381 labelled a_1(1)* 90374 to 90383 labelled b_1(1)* 90374 to 90391 labelled b_1(2)* 90375 to 90376 labelled a_1(1)* 90376 to 90333 labelled c_1(1)* 90376 to 90377 labelled c_1(1), a_1(1)* 90376 to 90379 labelled c_1(1)* 90376 to 90399 labelled c_1(2)* 90377 to 90378 labelled b_1(1)* 90378 to 90333 labelled a_1(1)* 90378 to 90375 labelled a_1(1)* 90379 to 90380 labelled c_1(1)* 90379 to 90395 labelled a_1(2)* 90379 to 90397 labelled c_1(2)* 90380 to 90333 labelled b_1(1)* 90380 to 90381 labelled a_1(1)* 90380 to 90383 labelled b_1(1)* 90380 to 90391 labelled b_1(2)* 90381 to 90382 labelled a_1(1)* 90382 to 90333 labelled a_1(1)* 90382 to 90375 labelled a_1(1)* 90382 to 90378 labelled a_1(1)* 90382 to 90400 labelled a_1(1)* 90383 to 90384 labelled b_1(1)* 90383 to 90381 labelled a_1(1)* 90383 to 90393 labelled a_1(2)* 90384 to 90333 labelled c_1(1)* 90384 to 90377 labelled c_1(1), a_1(1)* 90384 to 90379 labelled c_1(1)* 90384 to 90399 labelled c_1(2)* 90385 to 90386 labelled b_1(1)* 90386 to 90382 labelled a_1(1)* 90387 to 90388 labelled c_1(1)* 90388 to 90382 labelled b_1(1)* 90389 to 90390 labelled b_1(1)* 90390 to 90386 labelled a_1(1)* 90391 to 90392 labelled b_1(2)* 90391 to 90393 labelled a_1(2)* 90392 to 90377 labelled c_1(2)* 90393 to 90394 labelled a_1(2)* 90394 to 90378 labelled a_1(2)* 90394 to 90400 labelled a_1(2)* 90395 to 90396 labelled b_1(2)* 90396 to 90382 labelled a_1(2)* 90397 to 90398 labelled c_1(2)* 90398 to 90382 labelled b_1(2)* 90399 to 90400 labelled b_1(2)* 90400 to 90396 labelled a_1(2)


----------------------------------------

(688)
YES

----------------------------------------

(689)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(690) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(691)
Complex Obligation (OR)

----------------------------------------

(692)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(693) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(694)
Complex Obligation (OR)

----------------------------------------

(695)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(696) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(697)
Complex Obligation (OR)

----------------------------------------

(698)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(699)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(700)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(701) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(702)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(703) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(704)
Complex Obligation (AND)

----------------------------------------

(705)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(706)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(707)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(708)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(709) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(710)
Complex Obligation (OR)

----------------------------------------

(711)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(712)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(713)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(714) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(715)
Complex Obligation (OR)

----------------------------------------

(716)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(717) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(718)
Complex Obligation (OR)

----------------------------------------

(719)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(720)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(721)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(722) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(723)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(724) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(725)
Complex Obligation (AND)

----------------------------------------

(726)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(727)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(728)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(729)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(730) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(731)
Complex Obligation (OR)

----------------------------------------

(732)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(733)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(734)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(735) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(B(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 1 + 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(736)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(737) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(738)
Complex Obligation (AND)

----------------------------------------

(739)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(740) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(741)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(742)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(743) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(744)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(745) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(746)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(747)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(748) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(749)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(750)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(751) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(752)
Complex Obligation (OR)

----------------------------------------

(753)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(754) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(755)
Complex Obligation (OR)

----------------------------------------

(756)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(757)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(758) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(759)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(760)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(761) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(762)
Complex Obligation (OR)

----------------------------------------

(763)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(764)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(765) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(766)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(767)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(768) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(769)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(770) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(771)
Complex Obligation (AND)

----------------------------------------

(772)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(773) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(774)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(775)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(776) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(777)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(778)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(779) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(780)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(781) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(782)
YES

----------------------------------------

(783)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(784) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(785)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(786)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(787) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(788)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(789)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(790) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(791)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(792) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(793)
YES

----------------------------------------

(794)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(795) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(796)
Complex Obligation (OR)

----------------------------------------

(797)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(798) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(799)
Complex Obligation (OR)

----------------------------------------

(800)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(801) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(802)
Complex Obligation (OR)

----------------------------------------

(803)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(804) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(805)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(806)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(807)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(808) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(809)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(810) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(811)
Complex Obligation (AND)

----------------------------------------

(812)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(813) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(814)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(815)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(816) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(817)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(818) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(819)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(820)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(821) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(822)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(823)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(824) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(825)
Complex Obligation (OR)

----------------------------------------

(826)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(827)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(828) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(829)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(830) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(831)
Complex Obligation (AND)

----------------------------------------

(832)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(833)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(834)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(835)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(836) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(837)
Complex Obligation (OR)

----------------------------------------

(838)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(839) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(840)
Complex Obligation (OR)

----------------------------------------

(841)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(842) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(843)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(844)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(845)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(846) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(847)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(848) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(849)
Complex Obligation (AND)

----------------------------------------

(850)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(851) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(852)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(853)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(854) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(855)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(856) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(857)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(858)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(859) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(860)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(861)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(862) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(863)
Complex Obligation (OR)

----------------------------------------

(864)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(865)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(866) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(867)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(868) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(869)
Complex Obligation (AND)

----------------------------------------

(870)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(871)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(872)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(873)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(874) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = 1 + 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(875)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(876) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(877)
Complex Obligation (AND)

----------------------------------------

(878)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(879) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(880)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(881)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(882) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(883)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(884) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(885)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(886)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(887) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(888)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(889)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(890) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(891)
Complex Obligation (OR)

----------------------------------------

(892)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(893) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(894)
Complex Obligation (OR)

----------------------------------------

(895)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(896)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(897) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(898)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(899)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(900) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(901)
Complex Obligation (OR)

----------------------------------------

(902)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(903)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(904)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(905) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(906)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(907) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(908)
Complex Obligation (AND)

----------------------------------------

(909)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(910)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(911)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(912) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(913)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(914)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(915) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(916)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(917)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(918) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(919)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(920)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(921) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(922)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(923)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(924) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(925)
Complex Obligation (OR)

----------------------------------------

(926)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(927) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(928)
Complex Obligation (OR)

----------------------------------------

(929)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(930) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(931)
Complex Obligation (OR)

----------------------------------------

(932)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(933) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(934)
Complex Obligation (OR)

----------------------------------------

(935)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(936)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(937)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(938) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(939)
Complex Obligation (OR)

----------------------------------------

(940)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(941)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(942)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(943) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(944)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(945) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(946)
Complex Obligation (AND)

----------------------------------------

(947)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(948)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(949) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(950)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(951)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(952)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(953) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(954)
Complex Obligation (OR)

----------------------------------------

(955)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(956) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(957)
Complex Obligation (OR)

----------------------------------------

(958)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(959)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(960)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(961) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(962)
Complex Obligation (OR)

----------------------------------------

(963)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(964)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(965)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(966) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(967)
Complex Obligation (OR)

----------------------------------------

(968)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(969)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(970)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(971) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(972)
Complex Obligation (OR)

----------------------------------------

(973)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(974) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(975)
Complex Obligation (OR)

----------------------------------------

(976)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(977)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(978)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(979) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(980)
Complex Obligation (OR)

----------------------------------------

(981)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(982)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(983)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(984) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(985)
Complex Obligation (OR)

----------------------------------------

(986)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(987)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(988)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(989) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(990)
Complex Obligation (OR)

----------------------------------------

(991)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(992) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(993)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(994) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(995)
Complex Obligation (AND)

----------------------------------------

(996)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(997)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(998) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(999)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1000)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1001)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1002) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1003)
Complex Obligation (OR)

----------------------------------------

(1004)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1005)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1006)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1007) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1008)
Complex Obligation (OR)

----------------------------------------

(1009)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1010)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1011)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1012) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1013)
Complex Obligation (OR)

----------------------------------------

(1014)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1015) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1016)
Complex Obligation (OR)

----------------------------------------

(1017)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1018) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1019)
Complex Obligation (OR)

----------------------------------------

(1020)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1021)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1022)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1023) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1024)
Complex Obligation (OR)

----------------------------------------

(1025)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1026)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1027)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1028) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(1029)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1030) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1031)
Complex Obligation (AND)

----------------------------------------

(1032)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1033)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1034) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1035)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1036)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1037)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1038) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1039)
Complex Obligation (OR)

----------------------------------------

(1040)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1041) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1042)
Complex Obligation (OR)

----------------------------------------

(1043)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1044)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1045) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(1046)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1047)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1048) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1049)
Complex Obligation (OR)

----------------------------------------

(1050)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1051)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1052)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1053) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(1054)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1055) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1056)
Complex Obligation (AND)

----------------------------------------

(1057)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1058) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1059)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1060)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1061)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1062)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1063) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1064)
Complex Obligation (OR)

----------------------------------------

(1065)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1066) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1067)
Complex Obligation (OR)

----------------------------------------

(1068)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1069)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1070)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1071) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1072)
Complex Obligation (OR)

----------------------------------------

(1073)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1074)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1075)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1076) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1077)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1078) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1079)
Complex Obligation (AND)

----------------------------------------

(1080)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1081)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1082) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1083)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1084)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1085)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1086) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(1087)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1088) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1089)
Complex Obligation (AND)

----------------------------------------

(1090)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1091) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1092)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1093) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(1094)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1095)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1096) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1097)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1098)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1099) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1100)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1101)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1102) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1103)
Complex Obligation (OR)

----------------------------------------

(1104)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1105) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1106)
Complex Obligation (OR)

----------------------------------------

(1107)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1108) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1109)
Complex Obligation (OR)

----------------------------------------

(1110)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1111)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1112) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(1113)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1114)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1115) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1116)
Complex Obligation (OR)

----------------------------------------

(1117)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1118)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1119)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1120) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1121)
Complex Obligation (OR)

----------------------------------------

(1122)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1123) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(1124)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1125)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1126)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1127) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1128)
Complex Obligation (OR)

----------------------------------------

(1129)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1130) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1131)
Complex Obligation (OR)

----------------------------------------

(1132)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1133)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1134)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1135) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1136)
Complex Obligation (OR)

----------------------------------------

(1137)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1138)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1139)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1140) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(1141)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1142) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1143)
Complex Obligation (AND)

----------------------------------------

(1144)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1145) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1146)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1147)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1148)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1149)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1150) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1151)
Complex Obligation (OR)

----------------------------------------

(1152)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1153) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1154)
Complex Obligation (OR)

----------------------------------------

(1155)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1156)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1157)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1158) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1159)
Complex Obligation (OR)

----------------------------------------

(1160)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1161)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1162)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1163) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1164)
Complex Obligation (OR)

----------------------------------------

(1165)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1166)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1167)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1168) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1169)
Complex Obligation (OR)

----------------------------------------

(1170)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1171) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1172)
Complex Obligation (OR)

----------------------------------------

(1173)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1174)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1175)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1176) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(1177)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1178) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1179)
Complex Obligation (AND)

----------------------------------------

(1180)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1181) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1182)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1183)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1184)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1185)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1186) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1187)
Complex Obligation (OR)

----------------------------------------

(1188)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1189)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1190)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1191) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1192)
Complex Obligation (OR)

----------------------------------------

(1193)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1194) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1195)
Complex Obligation (OR)

----------------------------------------

(1196)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1197) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1198)
Complex Obligation (OR)

----------------------------------------

(1199)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1200)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1201)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1202) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1203)
Complex Obligation (OR)

----------------------------------------

(1204)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1205)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1206)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1207) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1208)
Complex Obligation (OR)

----------------------------------------

(1209)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1210)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1211)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1212) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1213)
Complex Obligation (OR)

----------------------------------------

(1214)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1215) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1216)
Complex Obligation (OR)

----------------------------------------

(1217)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1218)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1219)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1220) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1221)
Complex Obligation (OR)

----------------------------------------

(1222)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1223)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1224)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1225) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1226)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1227) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1228)
Complex Obligation (AND)

----------------------------------------

(1229)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1230)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1231) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1232)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1233)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1234)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1235) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1236)
Complex Obligation (OR)

----------------------------------------

(1237)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1238) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1239)
Complex Obligation (OR)

----------------------------------------

(1240)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1241)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1242)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1243) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1244)
Complex Obligation (OR)

----------------------------------------

(1245)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1246)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1247)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1248) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1249)
Complex Obligation (OR)

----------------------------------------

(1250)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1251)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1252)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1253) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1254)
Complex Obligation (OR)

----------------------------------------

(1255)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1256) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1257)
Complex Obligation (OR)

----------------------------------------

(1258)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1259)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1260)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1261) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1262)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1263) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1264)
Complex Obligation (AND)

----------------------------------------

(1265)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1266)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1267) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1268)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1269)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1270)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1271) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1272)
Complex Obligation (OR)

----------------------------------------

(1273)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1274)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1275)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1276) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1277)
Complex Obligation (OR)

----------------------------------------

(1278)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1279) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1280)
Complex Obligation (OR)

----------------------------------------

(1281)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1282) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(1283)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1284) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1285)
Complex Obligation (AND)

----------------------------------------

(1286)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1287)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1288) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1289)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1290)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1291)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1292) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1293)
Complex Obligation (OR)

----------------------------------------

(1294)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1295)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1296)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1297) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1298)
Complex Obligation (OR)

----------------------------------------

(1299)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1300)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1301)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1302) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(1303)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1304) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1305)
Complex Obligation (AND)

----------------------------------------

(1306)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1307) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1308)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1309) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(1310)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1311)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1312) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1313)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1314)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1315) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1316)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1317)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1318) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1319)
Complex Obligation (OR)

----------------------------------------

(1320)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1321) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1322)
Complex Obligation (OR)

----------------------------------------

(1323)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1324)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1325)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1326) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(1327)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1328) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1329)
Complex Obligation (AND)

----------------------------------------

(1330)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1331) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1332)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1333)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1334)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1335)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1336) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1337)
Complex Obligation (OR)

----------------------------------------

(1338)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1339)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1340)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1341) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1342)
Complex Obligation (OR)

----------------------------------------

(1343)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1344) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1345)
Complex Obligation (OR)

----------------------------------------

(1346)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1347)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1348)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1349) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1350)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1351) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1352)
Complex Obligation (AND)

----------------------------------------

(1353)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1354)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1355) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1356)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1357)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1358)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1359) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1360)
Complex Obligation (OR)

----------------------------------------

(1361)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1362)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1363)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1364) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1365)
Complex Obligation (OR)

----------------------------------------

(1366)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1367) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1368)
Complex Obligation (OR)

----------------------------------------

(1369)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1370) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1371)
Complex Obligation (OR)

----------------------------------------

(1372)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1373) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1374)
Complex Obligation (OR)

----------------------------------------

(1375)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1376)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1377)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1378) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1379)
Complex Obligation (OR)

----------------------------------------

(1380)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1381)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1382)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1383) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1384)
Complex Obligation (OR)

----------------------------------------

(1385)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1386)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1387)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1388) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1389)
Complex Obligation (OR)

----------------------------------------

(1390)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1391) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1392)
Complex Obligation (OR)

----------------------------------------

(1393)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1394)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1395)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1396) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1397)
Complex Obligation (OR)

----------------------------------------

(1398)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1399)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1400)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1401) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1402)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1403) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1404)
Complex Obligation (AND)

----------------------------------------

(1405)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1406)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1407) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1408)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1409)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1410)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1411) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1412)
Complex Obligation (OR)

----------------------------------------

(1413)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1414) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1415)
Complex Obligation (OR)

----------------------------------------

(1416)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1417)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1418)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1419) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1420)
Complex Obligation (OR)

----------------------------------------

(1421)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1422)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1423)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1424) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1425)
Complex Obligation (OR)

----------------------------------------

(1426)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1427)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1428)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1429) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1430)
Complex Obligation (OR)

----------------------------------------

(1431)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1432) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1433)
Complex Obligation (OR)

----------------------------------------

(1434)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1435)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1436)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1437) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1438)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1439) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1440)
Complex Obligation (AND)

----------------------------------------

(1441)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1442)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1443) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1444)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1445)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1446)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1447) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1448)
Complex Obligation (OR)

----------------------------------------

(1449)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1450)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1451)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1452) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1453)
Complex Obligation (OR)

----------------------------------------

(1454)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1455) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1456)
Complex Obligation (OR)

----------------------------------------

(1457)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1458) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1459)
Complex Obligation (OR)

----------------------------------------

(1460)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1461)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1462)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1463) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1464)
Complex Obligation (OR)

----------------------------------------

(1465)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1466)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1467)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1468) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1469)
Complex Obligation (OR)

----------------------------------------

(1470)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1471)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1472)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1473) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1474)
Complex Obligation (OR)

----------------------------------------

(1475)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1476) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1477)
Complex Obligation (OR)

----------------------------------------

(1478)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1479)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1480)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1481) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1482)
Complex Obligation (OR)

----------------------------------------

(1483)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1484)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1485)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1486) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1487)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1488) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1489)
Complex Obligation (AND)

----------------------------------------

(1490)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1491)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1492) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1493)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1494)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1495)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1496) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1497)
Complex Obligation (OR)

----------------------------------------

(1498)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1499) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1500)
Complex Obligation (OR)

----------------------------------------

(1501)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1502)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1503)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1504) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1505)
Complex Obligation (OR)

----------------------------------------

(1506)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1507)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1508)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1509) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1510)
Complex Obligation (OR)

----------------------------------------

(1511)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1512)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1513)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1514) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1515)
Complex Obligation (OR)

----------------------------------------

(1516)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1517) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1518)
Complex Obligation (OR)

----------------------------------------

(1519)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1520)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1521)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1522) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1523)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1524) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1525)
Complex Obligation (AND)

----------------------------------------

(1526)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1527)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1528) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1529)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1530)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1531)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1532) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1533)
Complex Obligation (OR)

----------------------------------------

(1534)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1535)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1536)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1537) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1538)
Complex Obligation (OR)

----------------------------------------

(1539)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1540) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1541)
Complex Obligation (OR)

----------------------------------------

(1542)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1543) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1544)
Complex Obligation (OR)

----------------------------------------

(1545)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1546)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1547)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1548) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1549)
Complex Obligation (OR)

----------------------------------------

(1550)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1551)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1552)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1553) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1554)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1555) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1556)
Complex Obligation (AND)

----------------------------------------

(1557)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1558)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1559) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1560)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1561)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1562)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1563) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1564)
Complex Obligation (OR)

----------------------------------------

(1565)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1566) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1567)
Complex Obligation (OR)

----------------------------------------

(1568)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1569)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1570)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1571) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1572)
Complex Obligation (OR)

----------------------------------------

(1573)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1574)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1575)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1576) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1577)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1578) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1579)
Complex Obligation (AND)

----------------------------------------

(1580)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1581)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1582) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1583)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1584)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1585)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1586) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1587)
Complex Obligation (OR)

----------------------------------------

(1588)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1589) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1590)
Complex Obligation (OR)

----------------------------------------

(1591)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1592)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1593)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1594) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1595)
Complex Obligation (OR)

----------------------------------------

(1596)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1597)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1598)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1599) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1600)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1601) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(1602)
Complex Obligation (AND)

----------------------------------------

(1603)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1604)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1605)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1606)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1607)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1608)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1609)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1610) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = 1 + 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(1611)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1612) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1613)
Complex Obligation (AND)

----------------------------------------

(1614)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1615) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1616)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1617)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1618) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1619)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1620) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(1621)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1622)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1623) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1624)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1625)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1626) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1627)
Complex Obligation (OR)

----------------------------------------

(1628)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1629) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1630)
Complex Obligation (OR)

----------------------------------------

(1631)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1632) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1633)
Complex Obligation (OR)

----------------------------------------

(1634)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1635)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1636)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1637) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1638)
Complex Obligation (OR)

----------------------------------------

(1639)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1640)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1641)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1642) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1643)
Complex Obligation (OR)

----------------------------------------

(1644)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1645)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1646)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1647) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1648)
Complex Obligation (OR)

----------------------------------------

(1649)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1650) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1651)
Complex Obligation (OR)

----------------------------------------

(1652)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1653)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1654)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1655) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1656)
Complex Obligation (OR)

----------------------------------------

(1657)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1658)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1659)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1660) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1661)
Complex Obligation (OR)

----------------------------------------

(1662)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1663)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1664)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1665) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1666)
Complex Obligation (OR)

----------------------------------------

(1667)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1668) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1669)
Complex Obligation (OR)

----------------------------------------

(1670)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1671)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1672)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1673) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1674)
Complex Obligation (OR)

----------------------------------------

(1675)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1676)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1677)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1678) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1679)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1680) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(1681)
Complex Obligation (AND)

----------------------------------------

(1682)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1683)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1684)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1685)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1686)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1687)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1688)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1689) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1690)
Complex Obligation (OR)

----------------------------------------

(1691)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1692) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1693)
Complex Obligation (OR)

----------------------------------------

(1694)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1695)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1696)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1697) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1698)
Complex Obligation (OR)

----------------------------------------

(1699)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1700)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1701)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1702) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1703)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1704) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(1705)
Complex Obligation (AND)

----------------------------------------

(1706)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1707)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1708)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1709)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1710)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1711)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1712)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1713) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1714)
Complex Obligation (OR)

----------------------------------------

(1715)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1716) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1717)
Complex Obligation (OR)

----------------------------------------

(1718)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1719) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1720)
Complex Obligation (OR)

----------------------------------------

(1721)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1722)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1723)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1724) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1725)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1726) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1727)
Complex Obligation (AND)

----------------------------------------

(1728)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1729)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1730) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1731)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1732)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1733)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1734) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1735)
Complex Obligation (OR)

----------------------------------------

(1736)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1737)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1738)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1739) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1740)
Complex Obligation (OR)

----------------------------------------

(1741)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1742) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1743)
Complex Obligation (OR)

----------------------------------------

(1744)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1745)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1746)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1747) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1748)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1749) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1750)
Complex Obligation (AND)

----------------------------------------

(1751)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1752)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1753) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1754)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1755)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1756)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1757) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1758)
Complex Obligation (OR)

----------------------------------------

(1759)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1760)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1761)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1762) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = 1 + 2*x_1
   POL(a(x_1)) = 3 + 3*x_1
   POL(b(x_1)) = 3 + 3*x_1
   POL(c(x_1)) = 3 + 3*x_1

----------------------------------------

(1763)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1764) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1765)
Complex Obligation (AND)

----------------------------------------

(1766)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1767) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1768)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1769)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1770) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1771)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1772) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(1773)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1774)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1775) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1776)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1777)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1778) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1779)
Complex Obligation (OR)

----------------------------------------

(1780)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1781) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1782)
Complex Obligation (OR)

----------------------------------------

(1783)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1784)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1785)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1786) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1787)
Complex Obligation (OR)

----------------------------------------

(1788)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1789)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1790)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(1791) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1792)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1793) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(1794)
Complex Obligation (AND)

----------------------------------------

(1795)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1796)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1797)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1798)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1799)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1800)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1801)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1802) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1803)
Complex Obligation (OR)

----------------------------------------

(1804)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1805) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1806)
Complex Obligation (OR)

----------------------------------------

(1807)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1808) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1809)
Complex Obligation (OR)

----------------------------------------

(1810)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1811) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1812)
Complex Obligation (OR)

----------------------------------------

(1813)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1814)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1815)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1816) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1817)
Complex Obligation (OR)

----------------------------------------

(1818)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1819)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1820)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1821) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(1822)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1823) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1824)
Complex Obligation (AND)

----------------------------------------

(1825)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1826)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1827)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1828)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1829) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1830)
Complex Obligation (OR)

----------------------------------------

(1831)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1832) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1833)
Complex Obligation (OR)

----------------------------------------

(1834)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1835)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1836)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1837) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1838)
Complex Obligation (OR)

----------------------------------------

(1839)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1840)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1841)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1842) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1843)
Complex Obligation (OR)

----------------------------------------

(1844)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1845)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1846)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1847) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1848)
Complex Obligation (OR)

----------------------------------------

(1849)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1850) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1851)
Complex Obligation (OR)

----------------------------------------

(1852)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1853)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1854)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1855) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1856)
Complex Obligation (OR)

----------------------------------------

(1857)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1858)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1859)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1860) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1861)
Complex Obligation (OR)

----------------------------------------

(1862)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1863)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1864)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1865) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1866)
Complex Obligation (OR)

----------------------------------------

(1867)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1868) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(1869)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1870) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1871)
Complex Obligation (AND)

----------------------------------------

(1872)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1873)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1874) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1875)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1876)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1877)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1878) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1879)
Complex Obligation (OR)

----------------------------------------

(1880)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1881)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1882)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1883) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1884)
Complex Obligation (OR)

----------------------------------------

(1885)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1886)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1887)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1888) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1889)
Complex Obligation (OR)

----------------------------------------

(1890)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1891) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1892)
Complex Obligation (OR)

----------------------------------------

(1893)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1894) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1895)
Complex Obligation (OR)

----------------------------------------

(1896)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1897)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1898)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1899) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1900)
Complex Obligation (OR)

----------------------------------------

(1901)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1902)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1903)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1904) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(1905)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1906) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1907)
Complex Obligation (AND)

----------------------------------------

(1908)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1909)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1910) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1911)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1912)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1913)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1914) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1915)
Complex Obligation (OR)

----------------------------------------

(1916)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1917) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1918)
Complex Obligation (OR)

----------------------------------------

(1919)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1920)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1921)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1922) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1923)
Complex Obligation (OR)

----------------------------------------

(1924)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1925)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1926)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1927) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(1928)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1929) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1930)
Complex Obligation (AND)

----------------------------------------

(1931)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1932)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1933) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1934)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1935)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1936)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1937) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1938)
Complex Obligation (OR)

----------------------------------------

(1939)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1940) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1941)
Complex Obligation (OR)

----------------------------------------

(1942)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1943)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1944)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1945) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1946)
Complex Obligation (OR)

----------------------------------------

(1947)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1948)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(1949)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(1950) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1951)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1952) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1953)
Complex Obligation (AND)

----------------------------------------

(1954)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1955)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1956) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1957)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1958)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1959)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1960) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(1961)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1962) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1963)
Complex Obligation (AND)

----------------------------------------

(1964)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1965) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1966)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1967)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1968) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(1969)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1970) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(1971)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1972)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(1973) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(1974)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1975)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1976) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1977)
Complex Obligation (OR)

----------------------------------------

(1978)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1979) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1980)
Complex Obligation (OR)

----------------------------------------

(1981)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1982) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1983)
Complex Obligation (OR)

----------------------------------------

(1984)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1985)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1986)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1987) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1988)
Complex Obligation (OR)

----------------------------------------

(1989)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1990)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1991)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1992) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1993)
Complex Obligation (OR)

----------------------------------------

(1994)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(1995)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(1996)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(1997) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1998)
Complex Obligation (OR)

----------------------------------------

(1999)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2000) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2001)
Complex Obligation (OR)

----------------------------------------

(2002)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2003)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2004)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2005) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2006)
Complex Obligation (OR)

----------------------------------------

(2007)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2008)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2009)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2010) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2011)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2012) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2013)
Complex Obligation (AND)

----------------------------------------

(2014)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2015)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2016) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2017)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2018)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2019)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2020) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2021)
Complex Obligation (OR)

----------------------------------------

(2022)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2023) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2024)
Complex Obligation (OR)

----------------------------------------

(2025)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2026)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2027)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2028) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2029)
Complex Obligation (OR)

----------------------------------------

(2030)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2031)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2032)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2033) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2034)
Complex Obligation (OR)

----------------------------------------

(2035)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2036)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2037)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2038) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2039)
Complex Obligation (OR)

----------------------------------------

(2040)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2041) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2042)
Complex Obligation (OR)

----------------------------------------

(2043)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2044)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2045)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2046) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2047)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2048) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2049)
Complex Obligation (AND)

----------------------------------------

(2050)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2051)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2052) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2053)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2054)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2055)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2056) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2057)
Complex Obligation (OR)

----------------------------------------

(2058)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2059)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2060)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2061) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2062)
Complex Obligation (OR)

----------------------------------------

(2063)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2064) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2065)
Complex Obligation (OR)

----------------------------------------

(2066)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2067) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2068)
Complex Obligation (OR)

----------------------------------------

(2069)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2070)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2071)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2072) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2073)
Complex Obligation (OR)

----------------------------------------

(2074)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2075)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2076)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2077) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2078)
Complex Obligation (OR)

----------------------------------------

(2079)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2080)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2081)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2082) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2083)
Complex Obligation (OR)

----------------------------------------

(2084)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2085) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2086)
Complex Obligation (OR)

----------------------------------------

(2087)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2088)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2089)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2090) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2091)
Complex Obligation (OR)

----------------------------------------

(2092)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2093)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2094)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2095) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2096)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2097) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2098)
Complex Obligation (AND)

----------------------------------------

(2099)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2100)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2101) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2102)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2103)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2104)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2105) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2106)
Complex Obligation (OR)

----------------------------------------

(2107)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2108)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2109)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2110)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2111) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2112)
Complex Obligation (OR)

----------------------------------------

(2113)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2114) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2115)
Complex Obligation (OR)

----------------------------------------

(2116)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2117)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2118)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2119) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2120)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2121) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2122)
Complex Obligation (AND)

----------------------------------------

(2123)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2124)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2125) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2126)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2127)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2128)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2129) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2130)
Complex Obligation (OR)

----------------------------------------

(2131)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2132)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2133)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2134) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2135)
Complex Obligation (OR)

----------------------------------------

(2136)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2137) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2138)
Complex Obligation (OR)

----------------------------------------

(2139)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2140) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(2141)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2142) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2143)
Complex Obligation (AND)

----------------------------------------

(2144)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2145)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2146) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2147)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2148)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2149)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2150) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2151)
Complex Obligation (OR)

----------------------------------------

(2152)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2153)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2154)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2155) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2156)
Complex Obligation (OR)

----------------------------------------

(2157)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2158)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2159)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2160) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2161)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2162) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2163)
Complex Obligation (AND)

----------------------------------------

(2164)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2165) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2166)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2167)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2168) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2169)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2170) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(2171)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2172)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2173) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2174)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2175)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2176) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2177)
Complex Obligation (OR)

----------------------------------------

(2178)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2179) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2180)
Complex Obligation (OR)

----------------------------------------

(2181)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2182)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2183)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2184) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2185)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2186) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2187)
Complex Obligation (AND)

----------------------------------------

(2188)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2189)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2190) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2191)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2192)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2193)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2194) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2195)
Complex Obligation (OR)

----------------------------------------

(2196)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2197)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2198)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2199) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2200)
Complex Obligation (OR)

----------------------------------------

(2201)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2202) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2203)
Complex Obligation (OR)

----------------------------------------

(2204)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2205)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2206)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


----------------------------------------

(2207) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> a(B(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 1 + x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2208)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2209) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2210)
Complex Obligation (AND)

----------------------------------------

(2211)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2212)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2213)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2214)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2215) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2216)
Complex Obligation (OR)

----------------------------------------

(2217)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2218)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2219)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2220) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2221)
Complex Obligation (OR)

----------------------------------------

(2222)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2223) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2224)
Complex Obligation (OR)

----------------------------------------

(2225)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2226) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2227)
Complex Obligation (OR)

----------------------------------------

(2228)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2229) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2230)
Complex Obligation (OR)

----------------------------------------

(2231)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2232)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2233) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2234)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2235)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2236) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2237)
Complex Obligation (OR)

----------------------------------------

(2238)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2239)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2240)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2241) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2242)
Complex Obligation (OR)

----------------------------------------

(2243)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2244) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2245)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2246)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2247)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2248) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2249)
Complex Obligation (OR)

----------------------------------------

(2250)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2251) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2252)
Complex Obligation (OR)

----------------------------------------

(2253)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2254)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2255) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2256)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2257)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2258) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2259)
Complex Obligation (OR)

----------------------------------------

(2260)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2261)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2262) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2263)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2264)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2265) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(2266)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2267) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2268)
Complex Obligation (AND)

----------------------------------------

(2269)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2270) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2271)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2272) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(2273)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2274)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2275)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2276)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2277) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2278)
Complex Obligation (OR)

----------------------------------------

(2279)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2280) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2281)
Complex Obligation (OR)

----------------------------------------

(2282)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2283)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2284)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2285) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2286)
Complex Obligation (OR)

----------------------------------------

(2287)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2288)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2289) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2290)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2291) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2292)
Complex Obligation (AND)

----------------------------------------

(2293)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2294)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2295)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2296)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2297) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2298)
Complex Obligation (OR)

----------------------------------------

(2299)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2300)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2301) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2302)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2303) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2304)
Complex Obligation (AND)

----------------------------------------

(2305)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2306)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2307)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2308)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2309) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2310)
Complex Obligation (OR)

----------------------------------------

(2311)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2312) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2313)
Complex Obligation (OR)

----------------------------------------

(2314)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2315) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2316)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2317)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2318)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2319) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(2320)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2321) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2322)
Complex Obligation (AND)

----------------------------------------

(2323)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2324) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2325)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2326)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2327)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2328)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2329) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2330)
Complex Obligation (OR)

----------------------------------------

(2331)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2332)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2333) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2334)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2335)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2336) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2337)
Complex Obligation (OR)

----------------------------------------

(2338)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2339) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2340)
Complex Obligation (OR)

----------------------------------------

(2341)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2342) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2343)
Complex Obligation (OR)

----------------------------------------

(2344)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2345)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2346) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2347)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2348)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2349) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2350)
Complex Obligation (OR)

----------------------------------------

(2351)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2352)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2353)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2354) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2355)
Complex Obligation (OR)

----------------------------------------

(2356)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2357) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2358)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2359) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2360)
Complex Obligation (AND)

----------------------------------------

(2361)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2362)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2363)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2364)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2365)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2366) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2367)
Complex Obligation (OR)

----------------------------------------

(2368)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2369) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2370)
Complex Obligation (OR)

----------------------------------------

(2371)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2372)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2373) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2374)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2375)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2376) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2377)
Complex Obligation (OR)

----------------------------------------

(2378)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2379)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2380) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2381)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2382)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2383) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2384)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2385) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2386)
Complex Obligation (AND)

----------------------------------------

(2387)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2388) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2389)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2390)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2391) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2392)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2393) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(2394)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2395)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2396) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2397)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2398)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2399) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2400)
Complex Obligation (OR)

----------------------------------------

(2401)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2402) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2403)
Complex Obligation (OR)

----------------------------------------

(2404)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2405)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2406)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2407) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2408)
Complex Obligation (OR)

----------------------------------------

(2409)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2410)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2411) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2412)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2413) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2414)
Complex Obligation (AND)

----------------------------------------

(2415)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2416)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2417)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2418)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2419) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2420)
Complex Obligation (OR)

----------------------------------------

(2421)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2422)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2423) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2424)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2425) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2426)
Complex Obligation (AND)

----------------------------------------

(2427)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2428)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2429)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2430)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2431) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2432)
Complex Obligation (OR)

----------------------------------------

(2433)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2434) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2435)
Complex Obligation (OR)

----------------------------------------

(2436)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2437) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2438)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2439)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2440)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2441) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2442)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2443) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2444)
Complex Obligation (AND)

----------------------------------------

(2445)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2446) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2447)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2448)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2449) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2450)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2451) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(2452)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2453)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2454) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2455)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2456)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2457) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2458)
Complex Obligation (OR)

----------------------------------------

(2459)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2460)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2461) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2462)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2463)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2464) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2465)
Complex Obligation (OR)

----------------------------------------

(2466)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2467) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2468)
Complex Obligation (OR)

----------------------------------------

(2469)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2470) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2471)
Complex Obligation (OR)

----------------------------------------

(2472)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2473)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2474)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2475) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2476)
Complex Obligation (OR)

----------------------------------------

(2477)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2478)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2479)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2480) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(2481)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2482) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2483)
Complex Obligation (AND)

----------------------------------------

(2484)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2485)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2486)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2487)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2488) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2489)
Complex Obligation (OR)

----------------------------------------

(2490)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2491) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2492)
Complex Obligation (OR)

----------------------------------------

(2493)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2494)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2495)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2496) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2497)
Complex Obligation (OR)

----------------------------------------

(2498)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2499)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2500)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2501) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2502)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2503) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2504)
Complex Obligation (AND)

----------------------------------------

(2505)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2506)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2507)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2508)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2509) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2510)
Complex Obligation (OR)

----------------------------------------

(2511)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2512) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2513)
Complex Obligation (OR)

----------------------------------------

(2514)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2515)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2516)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2517) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2518)
Complex Obligation (OR)

----------------------------------------

(2519)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2520)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2521)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2522) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(2523)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2524) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(2525)
Complex Obligation (AND)

----------------------------------------

(2526)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2527)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2528)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2529)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2530)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2531)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2532)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2533) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(B(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 1 + 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2534)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2535) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2536)
Complex Obligation (AND)

----------------------------------------

(2537)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2538) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2539)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2540)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2541) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2542)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2543) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(2544)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2545)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2546) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2547)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2548)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2549) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2550)
Complex Obligation (OR)

----------------------------------------

(2551)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2552) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2553)
Complex Obligation (OR)

----------------------------------------

(2554)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2555) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2556)
Complex Obligation (OR)

----------------------------------------

(2557)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2558)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2559)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2560) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2561)
Complex Obligation (OR)

----------------------------------------

(2562)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2563)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2564) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2565)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2566)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2567) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2568)
Complex Obligation (OR)

----------------------------------------

(2569)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2570)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2571) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2572)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2573)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2574) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2575)
Complex Obligation (OR)

----------------------------------------

(2576)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2577) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2578)
Complex Obligation (OR)

----------------------------------------

(2579)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2580)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2581)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2582) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2583)
Complex Obligation (OR)

----------------------------------------

(2584)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2585)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2586) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2587)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2588) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2589)
Complex Obligation (AND)

----------------------------------------

(2590)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2591)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2592)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2593)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2594) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2595)
Complex Obligation (OR)

----------------------------------------

(2596)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2597)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2598) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2599)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2600) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2601)
Complex Obligation (AND)

----------------------------------------

(2602)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2603)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2604)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2605)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2606) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2607)
Complex Obligation (OR)

----------------------------------------

(2608)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2609) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2610)
Complex Obligation (OR)

----------------------------------------

(2611)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2612)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2613) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2614)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2615)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2616) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2617)
Complex Obligation (OR)

----------------------------------------

(2618)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(a(C(x1)))


----------------------------------------

(2619)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2620) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2621)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2622)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2623) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(2624)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2625) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(2626)
Complex Obligation (AND)

----------------------------------------

(2627)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2628)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2629)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2630) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(2631)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2632) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(2633)
YES

----------------------------------------

(2634)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2635) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(2636)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2637) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(2638)
YES

----------------------------------------

(2639)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2640) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(2641)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2642)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2643) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(2644)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2645)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2646) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2647)
Complex Obligation (OR)

----------------------------------------

(2648)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2649) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2650)
Complex Obligation (OR)

----------------------------------------

(2651)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2652)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2653) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2654)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2655)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2656) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2657)
Complex Obligation (OR)

----------------------------------------

(2658)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2659)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2660) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2661)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2662)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2663) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(2664)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2665) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(2666)
Complex Obligation (AND)

----------------------------------------

(2667)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2668)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2669) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2670)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2671)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2672) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(2673)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2674) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(2675)
YES

----------------------------------------

(2676)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2677) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(2678)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2679) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(2680)
YES

----------------------------------------

(2681)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2682) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(2683)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2684)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2685) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(2686)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2687)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2688) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2689)
Complex Obligation (OR)

----------------------------------------

(2690)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2691) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2692)
Complex Obligation (OR)

----------------------------------------

(2693)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2694) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2695)
Complex Obligation (OR)

----------------------------------------

(2696)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2697) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2698)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2699) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2700)
Complex Obligation (AND)

----------------------------------------

(2701)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2702)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2703)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2704)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2705)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2706) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(c(x_1)) = 3 + 2*x_1

----------------------------------------

(2707)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2708) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2709)
Complex Obligation (AND)

----------------------------------------

(2710)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2711) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2712)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2713) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(2714)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2715)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2716) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2717)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2718)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2719) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2720)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2721)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2722) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2723)
Complex Obligation (OR)

----------------------------------------

(2724)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2725)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2726) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2727)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2728)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2729) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2730)
Complex Obligation (OR)

----------------------------------------

(2731)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2732) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2733)
Complex Obligation (OR)

----------------------------------------

(2734)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2735) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2736)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   b(c(b(x1))) -> A(a(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2737) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2738)
Complex Obligation (AND)

----------------------------------------

(2739)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2740)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2741)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2742)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2743)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2744) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(2745)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2746) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2747)
Complex Obligation (AND)

----------------------------------------

(2748)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2749) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2750)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2751)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2752) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2753)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2754) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(2755)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2756)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2757) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2758)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2759)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2760) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2761)
Complex Obligation (OR)

----------------------------------------

(2762)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2763)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2764) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2765)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2766) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2767)
Complex Obligation (AND)

----------------------------------------

(2768)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2769)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2770)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2771)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   c(a(a(x1))) -> A(B(a(x1)))


----------------------------------------

(2772) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(B(a(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(B(x_1)) = 2 + 3*x_1
   POL(C(x_1)) = 1 + 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2773)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> A(B(a(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2774) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(2775)
Complex Obligation (AND)

----------------------------------------

(2776)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2777) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2778)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(b(a(x1))) -> B(b(c(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2779) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))
   B(b(a(x1))) -> B(b(c(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
90549, 90550, 90551, 90552, 90553, 90554, 90555, 90556, 90557, 90558, 90559, 90560, 90561, 90562, 90563, 90564, 90565, 90566, 90567, 90568, 90569, 90570, 90571, 90572, 90573, 90574, 90575, 90576, 90577, 90578, 90579, 90580, 90581, 90582, 90583, 90584

Node 90549 is start node and node 90550 is final node.

Those nodes are connected through the following edges:

* 90549 to 90551 labelled c_1(0), a_1(0)* 90549 to 90553 labelled a_1(0)* 90549 to 90555 labelled b_1(0), B_1(0)* 90549 to 90557 labelled c_1(0)* 90549 to 90567 labelled b_1(1), B_1(1)* 90549 to 90573 labelled c_1(1)* 90549 to 90575 labelled b_1(2), B_1(2)* 90550 to 90550 labelled #_1(0)* 90551 to 90552 labelled b_1(0)* 90552 to 90550 labelled a_1(0)* 90552 to 90559 labelled a_1(1)* 90553 to 90554 labelled a_1(0)* 90554 to 90550 labelled c_1(0), a_1(0)* 90554 to 90561 labelled c_1(1), a_1(1)* 90554 to 90563 labelled c_1(1)* 90554 to 90559 labelled a_1(1)* 90554 to 90583 labelled c_1(2)* 90555 to 90556 labelled b_1(0)* 90555 to 90565 labelled a_1(1)* 90556 to 90550 labelled c_1(0)* 90556 to 90561 labelled c_1(1), a_1(1)* 90556 to 90563 labelled c_1(1)* 90556 to 90583 labelled c_1(2)* 90557 to 90558 labelled c_1(0)* 90557 to 90569 labelled a_1(1)* 90557 to 90571 labelled c_1(1)* 90558 to 90550 labelled b_1(0)* 90558 to 90565 labelled a_1(1)* 90558 to 90567 labelled b_1(1)* 90558 to 90575 labelled b_1(2)* 90559 to 90560 labelled a_1(1)* 90560 to 90550 labelled c_1(1)* 90560 to 90561 labelled c_1(1), a_1(1)* 90560 to 90563 labelled c_1(1)* 90560 to 90583 labelled c_1(2)* 90561 to 90562 labelled b_1(1)* 90562 to 90550 labelled a_1(1)* 90562 to 90559 labelled a_1(1)* 90563 to 90564 labelled c_1(1)* 90563 to 90579 labelled a_1(2)* 90563 to 90581 labelled c_1(2)* 90564 to 90550 labelled b_1(1)* 90564 to 90565 labelled a_1(1)* 90564 to 90567 labelled b_1(1)* 90564 to 90575 labelled b_1(2)* 90565 to 90566 labelled a_1(1)* 90566 to 90550 labelled a_1(1)* 90566 to 90559 labelled a_1(1)* 90566 to 90562 labelled a_1(1)* 90566 to 90584 labelled a_1(1)* 90567 to 90568 labelled b_1(1)* 90567 to 90565 labelled a_1(1)* 90567 to 90577 labelled a_1(2)* 90568 to 90550 labelled c_1(1)* 90568 to 90561 labelled c_1(1), a_1(1)* 90568 to 90563 labelled c_1(1)* 90568 to 90583 labelled c_1(2)* 90569 to 90570 labelled b_1(1)* 90570 to 90566 labelled a_1(1)* 90571 to 90572 labelled c_1(1)* 90572 to 90566 labelled b_1(1)* 90573 to 90574 labelled b_1(1)* 90574 to 90570 labelled a_1(1)* 90575 to 90576 labelled b_1(2)* 90575 to 90577 labelled a_1(2)* 90576 to 90561 labelled c_1(2)* 90577 to 90578 labelled a_1(2)* 90578 to 90562 labelled a_1(2)* 90578 to 90584 labelled a_1(2)* 90579 to 90580 labelled b_1(2)* 90580 to 90566 labelled a_1(2)* 90581 to 90582 labelled c_1(2)* 90582 to 90566 labelled b_1(2)* 90583 to 90584 labelled b_1(2)* 90584 to 90580 labelled a_1(2)


----------------------------------------

(2780)
YES

----------------------------------------

(2781)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2782) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

b(x1)  =  b(x1)

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: [c, a] > b_1 > A_1

Status: A_1: multiset status
b_1: multiset status
c: multiset status
a: multiset status


----------------------------------------

(2783)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(b0(c)) -> A0(a)

The TRS R consists of the following rules:

   c -> c
   a -> a
   b0(c) -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2784) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(b0(c)) -> A0(a)

Strictly oriented rules of the TRS R:

   b0(c) -> a

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a) = 2
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c) = 2


----------------------------------------

(2785)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a -> a
   c -> a
   b0(b0(a)) -> b0(b0(c))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2786) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(2787)
YES

----------------------------------------

(2788)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2789) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(2790)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C(a(b(x1))) -> C(b(a(x1)))
   C(a(a(x1))) -> C(c(b(x1)))

The TRS R consists of the following rules:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(2791)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2792) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2793)
Complex Obligation (OR)

----------------------------------------

(2794)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2795) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2796)
Complex Obligation (OR)

----------------------------------------

(2797)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2798)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2799) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(2800)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2801)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2802) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(2803)
Complex Obligation (OR)

----------------------------------------

(2804)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> A(A(c(x1)))


----------------------------------------

(2805)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


----------------------------------------

(2806) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(2807)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2808)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(b(x1))) -> C(b(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))
   c(a(a(x1))) -> A(b(A(x1)))


----------------------------------------

(2809) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(a(x1))) -> b(b(C(x1)))
   c(a(a(x1))) -> c(c(B(x1)))
   b(c(b(x1))) -> a(A(a(x1)))
   c(a(b(x1))) -> c(B(a(x1)))
   c(a(a(x1))) -> c(C(b(x1)))
   c(a(a(x1))) -> a(b(A(x1)))
   b(c(b(x1))) -> a(a(A(x1)))
   c(a(a(x1))) -> a(B(a(x1)))
   a(b(c(x1))) -> a(a(C(x1)))
   b(b(a(x1))) -> b(B(c(x1)))
   b(c(b(x1))) -> A(a(a(x1)))
   a(b(c(x1))) -> a(A(c(x1)))
   c(a(a(x1))) -> A(b(a(x1)))
   c(a(b(x1))) -> c(b(A(x1)))

Relative ADPs:

   c(a(a(x1))) -> A(b(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:

   a(b(c(x1))) -> a(A(C(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(2810)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))
   c(a(a(x1))) -> C(c(b(x1)))
   a(b(c(x1))) -> A(a(c(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2811) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 6 subproblems.

----------------------------------------

(2812)
Complex Obligation (AND)

----------------------------------------

(2813)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(a(x1))) -> B(b(c(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2814)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))
   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2815)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2816) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(2817)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2818) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(2819)
YES

----------------------------------------

(2820)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2821) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(2822)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(a(x1))) -> C(c(b(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2823)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

and relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2824) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(b(c(x1))) -> A(a(c(x1)))

Relative ADPs:

   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(a(c(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 2*x_1 + 3*x_1^2
   POL(C(x_1)) = 2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 3

----------------------------------------

(2825)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2826) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(2827)
YES

----------------------------------------

(2828)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


----------------------------------------

(2829) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   a(b(c(x1))) -> a(A(C(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 2

----------------------------------------

(2830)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(b(x1))) -> C(b(a(x1)))

and relative ADPs:

   a(b(c(x1))) -> a(a(c(x1)))
   c(a(b(x1))) -> c(b(a(x1)))
   b(c(b(x1))) -> a(a(a(x1)))
   c(a(a(x1))) -> a(b(a(x1)))
   b(b(a(x1))) -> b(b(c(x1)))
   c(a(a(x1))) -> c(c(b(x1)))

