YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/sIMwo.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPDepGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) RelADPP
        (6) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (7) OR
            (8) RelADPP
                (9) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (10) OR
                    (11) RelADPP
                        (12) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (13) OR
                            (14) RelADPP
                                (15) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (16) OR
                                    (17) RelADPP
                                    (18) RelADPP
                                        (19) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (20) RelADPP
                                        (21) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (22) AND
                                            (23) RelADPP
                                            (24) RelADPP
                            (25) RelADPP
                                (26) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (27) OR
                                    (28) RelADPP
                                    (29) RelADPP
                                        (30) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                        (31) RelADPP
                                        (32) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (33) AND
                                            (34) RelADPP
                                            (35) RelADPP
                            (36) RelADPP
                                (37) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (38) RelADPP
                                (39) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (40) AND
                                    (41) RelADPP
                                        (42) RelADPCleverAfsProof [SOUND, 2 ms]
                                        (43) QDP
                                        (44) MRRProof [EQUIVALENT, 3 ms]
                                        (45) QDP
                                        (46) MRRProof [EQUIVALENT, 0 ms]
                                        (47) QDP
                                    (48) RelADPP
                                        (49) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (50) QDP
                                        (51) MRRProof [EQUIVALENT, 0 ms]
                                        (52) QDP
                                        (53) MRRProof [EQUIVALENT, 1 ms]
                                        (54) QDP
                    (55) RelADPP
                        (56) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (57) OR
                            (58) RelADPP
                                (59) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (60) OR
                                    (61) RelADPP
                                    (62) RelADPP
                            (63) RelADPP
                                (64) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (65) OR
                                    (66) RelADPP
                                    (67) RelADPP
                            (68) RelADPP
                                (69) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (70) OR
                                    (71) RelADPP
                                    (72) RelADPP
                    (73) RelADPP
                        (74) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (75) OR
                            (76) RelADPP
                                (77) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (78) OR
                                    (79) RelADPP
                                    (80) RelADPP
                            (81) RelADPP
                                (82) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (83) OR
                                    (84) RelADPP
                                    (85) RelADPP
                            (86) RelADPP
                                (87) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (88) OR
                                    (89) RelADPP
                                    (90) RelADPP
                    (91) RelADPP
                        (92) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (93) OR
                            (94) RelADPP
                                (95) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                                (96) RelADPP
                                (97) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (98) AND
                                    (99) RelADPP
                                        (100) RelADPCleverAfsProof [SOUND, 3 ms]
                                        (101) QDP
                                    (102) RelADPP
                                        (103) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (104) QDP
                            (105) RelADPP
                                (106) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (107) OR
                                    (108) RelADPP
                                    (109) RelADPP
                            (110) RelADPP
                                (111) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (112) OR
                                    (113) RelADPP
                                    (114) RelADPP
            (115) RelADPP
                (116) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (117) OR
                    (118) RelADPP
                        (119) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (120) OR
                            (121) RelADPP
                                (122) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (123) OR
                                    (124) RelADPP
                                    (125) RelADPP
                                        (126) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                        (127) RelADPP
                                        (128) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (129) AND
                                            (130) RelADPP
                                            (131) RelADPP
                            (132) RelADPP
                                (133) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (134) OR
                                    (135) RelADPP
                                    (136) RelADPP
                                        (137) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (138) RelADPP
                                        (139) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (140) AND
                                            (141) RelADPP
                                            (142) RelADPP
                            (143) RelADPP
                                (144) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (145) RelADPP
                                (146) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (147) AND
                                    (148) RelADPP
                                        (149) RelADPCleverAfsProof [SOUND, 14 ms]
                                        (150) QDP
                                        (151) MRRProof [EQUIVALENT, 0 ms]
                                        (152) QDP
                                    (153) RelADPP
                                        (154) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (155) QDP
                                        (156) MRRProof [EQUIVALENT, 1 ms]
                                        (157) QDP
                                        (158) MRRProof [EQUIVALENT, 1 ms]
                                        (159) QDP
                    (160) RelADPP
                        (161) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (162) OR
                            (163) RelADPP
                                (164) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (165) OR
                                    (166) RelADPP
                                    (167) RelADPP
                            (168) RelADPP
                                (169) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (170) OR
                                    (171) RelADPP
                                    (172) RelADPP
                            (173) RelADPP
                                (174) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (175) RelADPP
                                (176) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (177) AND
                                    (178) RelADPP
                                        (179) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (180) QDP
                                    (181) RelADPP
                                        (182) RelADPCleverAfsProof [SOUND, 10 ms]
                                        (183) QDP
                    (184) RelADPP
                        (185) RelADPDerelatifying2Proof [SOUND, 2 ms]
                        (186) OR
                            (187) RelADPP
                                (188) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (189) OR
                                    (190) RelADPP
                                    (191) RelADPP
                            (192) RelADPP
                                (193) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (194) OR
                                    (195) RelADPP
                                    (196) RelADPP
                            (197) RelADPP
                                (198) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (199) RelADPP
                                (200) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (201) AND
                                    (202) RelADPP
                                        (203) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (204) QDP
                                    (205) RelADPP
                                        (206) RelADPCleverAfsProof [SOUND, 15 ms]
                                        (207) QDP
                    (208) RelADPP
                        (209) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                        (210) RelADPP
                        (211) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (212) AND
                            (213) RelADPP
                                (214) RelADPCleverAfsProof [SOUND, 6 ms]
                                (215) QDP
                                (216) MRRProof [EQUIVALENT, 1 ms]
                                (217) QDP
                                (218) PisEmptyProof [EQUIVALENT, 0 ms]
                                (219) YES
                            (220) RelADPP
                                (221) RelADPCleverAfsProof [SOUND, 11 ms]
                                (222) QDP
                                (223) MRRProof [EQUIVALENT, 2 ms]
                                (224) QDP
                                (225) PisEmptyProof [EQUIVALENT, 0 ms]
                                (226) YES
            (227) RelADPP
                (228) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (229) OR
                    (230) RelADPP
                        (231) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (232) OR
                            (233) RelADPP
                                (234) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (235) OR
                                    (236) RelADPP
                                    (237) RelADPP
                            (238) RelADPP
                                (239) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (240) OR
                                    (241) RelADPP
                                    (242) RelADPP
                            (243) RelADPP
                                (244) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (245) OR
                                    (246) RelADPP
                                    (247) RelADPP
                    (248) RelADPP
                        (249) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (250) OR
                            (251) RelADPP
                                (252) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (253) OR
                                    (254) RelADPP
                                    (255) RelADPP
                            (256) RelADPP
                                (257) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (258) OR
                                    (259) RelADPP
                                    (260) RelADPP
                            (261) RelADPP
                                (262) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (263) RelADPP
                                (264) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (265) AND
                                    (266) RelADPP
                                        (267) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (268) QDP
                                    (269) RelADPP
                                        (270) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (271) QDP
                    (272) RelADPP
                        (273) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (274) OR
                            (275) RelADPP
                                (276) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (277) OR
                                    (278) RelADPP
                                    (279) RelADPP
                            (280) RelADPP
                                (281) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (282) OR
                                    (283) RelADPP
                                    (284) RelADPP
                            (285) RelADPP
                                (286) RelADPDerelatifying2Proof [SOUND, 2 ms]
                                (287) OR
                                    (288) RelADPP
                                    (289) RelADPP
                    (290) RelADPP
                        (291) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (292) OR
                            (293) RelADPP
                                (294) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (295) OR
                                    (296) RelADPP
                                    (297) RelADPP
                            (298) RelADPP
                                (299) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (300) RelADPP
                                (301) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (302) AND
                                    (303) RelADPP
                                        (304) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (305) QDP
                                    (306) RelADPP
                                        (307) RelADPCleverAfsProof [SOUND, 3 ms]
                                        (308) QDP
                            (309) RelADPP
                                (310) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (311) OR
                                    (312) RelADPP
                                    (313) RelADPP
            (314) RelADPP
                (315) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (316) OR
                    (317) RelADPP
                        (318) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (319) OR
                            (320) RelADPP
                                (321) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (322) OR
                                    (323) RelADPP
                                    (324) RelADPP
                            (325) RelADPP
                                (326) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (327) OR
                                    (328) RelADPP
                                    (329) RelADPP
                            (330) RelADPP
                                (331) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (332) OR
                                    (333) RelADPP
                                    (334) RelADPP
                    (335) RelADPP
                        (336) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (337) OR
                            (338) RelADPP
                                (339) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (340) OR
                                    (341) RelADPP
                                    (342) RelADPP
                            (343) RelADPP
                                (344) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (345) OR
                                    (346) RelADPP
                                    (347) RelADPP
                            (348) RelADPP
                                (349) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (350) RelADPP
                                (351) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (352) AND
                                    (353) RelADPP
                                        (354) RelADPCleverAfsProof [SOUND, 0 ms]
                                        (355) QDP
                                    (356) RelADPP
                                        (357) RelADPCleverAfsProof [SOUND, 9 ms]
                                        (358) QDP
                    (359) RelADPP
                        (360) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (361) OR
                            (362) RelADPP
                                (363) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (364) OR
                                    (365) RelADPP
                                    (366) RelADPP
                            (367) RelADPP
                                (368) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (369) OR
                                    (370) RelADPP
                                    (371) RelADPP
                            (372) RelADPP
                                (373) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (374) OR
                                    (375) RelADPP
                                    (376) RelADPP
                    (377) RelADPP
                        (378) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (379) OR
                            (380) RelADPP
                                (381) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (382) OR
                                    (383) RelADPP
                                        (384) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (385) RelADPP
                                        (386) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (387) AND
                                            (388) RelADPP
                                            (389) RelADPP
                                    (390) RelADPP
                            (391) RelADPP
                                (392) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (393) RelADPP
                                (394) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (395) AND
                                    (396) RelADPP
                                        (397) RelADPCleverAfsProof [SOUND, 3 ms]
                                        (398) QDP
                                        (399) MRRProof [EQUIVALENT, 1 ms]
                                        (400) QDP
                                        (401) MRRProof [EQUIVALENT, 0 ms]
                                        (402) QDP
                                    (403) RelADPP
                                        (404) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (405) QDP
                                        (406) MRRProof [EQUIVALENT, 1 ms]
                                        (407) QDP
                                        (408) MRRProof [EQUIVALENT, 0 ms]
                                        (409) QDP
                            (410) RelADPP
                                (411) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (412) OR
                                    (413) RelADPP
                                    (414) RelADPP
                                        (415) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (416) RelADPP
                                        (417) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (418) AND
                                            (419) RelADPP
                                            (420) RelADPP
            (421) RelADPP
                (422) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (423) OR
                    (424) RelADPP
                        (425) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (426) OR
                            (427) RelADPP
                                (428) RelADPReductionPairProof [EQUIVALENT, 14 ms]
                                (429) RelADPP
                                (430) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (431) AND
                                    (432) RelADPP
                                        (433) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (434) QDP
                                    (435) RelADPP
                                        (436) RelADPCleverAfsProof [SOUND, 2 ms]
                                        (437) QDP
                            (438) RelADPP
                                (439) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (440) OR
                                    (441) RelADPP
                                    (442) RelADPP
                            (443) RelADPP
                                (444) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (445) OR
                                    (446) RelADPP
                                    (447) RelADPP
                    (448) RelADPP
                        (449) RelADPReductionPairProof [EQUIVALENT, 8 ms]
                        (450) RelADPP
                        (451) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (452) AND
                            (453) RelADPP
                                (454) RelADPCleverAfsProof [SOUND, 4 ms]
                                (455) QDP
                                (456) MRRProof [EQUIVALENT, 1 ms]
                                (457) QDP
                                (458) PisEmptyProof [EQUIVALENT, 0 ms]
                                (459) YES
                            (460) RelADPP
                                (461) RelADPCleverAfsProof [SOUND, 5 ms]
                                (462) QDP
                                (463) MRRProof [EQUIVALENT, 2 ms]
                                (464) QDP
                                (465) PisEmptyProof [EQUIVALENT, 0 ms]
                                (466) YES
                    (467) RelADPP
                        (468) RelADPDerelatifying2Proof [SOUND, 2 ms]
                        (469) OR
                            (470) RelADPP
                                (471) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (472) OR
                                    (473) RelADPP
                                    (474) RelADPP
                            (475) RelADPP
                                (476) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (477) RelADPP
                                (478) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (479) AND
                                    (480) RelADPP
                                    (481) RelADPP
                            (482) RelADPP
                                (483) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (484) OR
                                    (485) RelADPP
                                    (486) RelADPP
                    (487) RelADPP
                        (488) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (489) OR
                            (490) RelADPP
                                (491) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (492) OR
                                    (493) RelADPP
                                    (494) RelADPP
                            (495) RelADPP
                                (496) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (497) RelADPP
                                (498) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (499) AND
                                    (500) RelADPP
                                        (501) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (502) QDP
                                    (503) RelADPP
                                        (504) RelADPCleverAfsProof [SOUND, 4 ms]
                                        (505) QDP
                            (506) RelADPP
                                (507) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (508) OR
                                    (509) RelADPP
                                    (510) RelADPP
    (511) RelADPP
        (512) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (513) OR
            (514) RelADPP
                (515) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (516) OR
                    (517) RelADPP
                        (518) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (519) OR
                            (520) RelADPP
                                (521) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (522) OR
                                    (523) RelADPP
                                    (524) RelADPP
                                        (525) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (526) RelADPP
                            (527) RelADPP
                                (528) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (529) OR
                                    (530) RelADPP
                                    (531) RelADPP
                                        (532) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (533) RelADPP
                            (534) RelADPP
                                (535) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (536) RelADPP
                                (537) RelADPCleverAfsProof [SOUND, 0 ms]
                                (538) QDP
                                (539) MRRProof [EQUIVALENT, 0 ms]
                                (540) QDP
                                (541) MRRProof [EQUIVALENT, 1 ms]
                                (542) QDP
                    (543) RelADPP
                        (544) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (545) OR
                            (546) RelADPP
                                (547) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (548) OR
                                    (549) RelADPP
                                    (550) RelADPP
                            (551) RelADPP
                                (552) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (553) OR
                                    (554) RelADPP
                                    (555) RelADPP
                            (556) RelADPP
                                (557) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (558) OR
                                    (559) RelADPP
                                    (560) RelADPP
                    (561) RelADPP
                        (562) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (563) OR
                            (564) RelADPP
                                (565) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (566) OR
                                    (567) RelADPP
                                    (568) RelADPP
                                        (569) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (570) RelADPP
                            (571) RelADPP
                                (572) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (573) OR
                                    (574) RelADPP
                                    (575) RelADPP
                            (576) RelADPP
                                (577) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (578) OR
                                    (579) RelADPP
                                        (580) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (581) RelADPP
                                    (582) RelADPP
                    (583) RelADPP
                        (584) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (585) OR
                            (586) RelADPP
                                (587) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (588) RelADPP
                                (589) RelADPCleverAfsProof [SOUND, 2 ms]
                                (590) QDP
                                (591) MRRProof [EQUIVALENT, 0 ms]
                                (592) QDP
                                (593) MRRProof [EQUIVALENT, 2 ms]
                                (594) QDP
                            (595) RelADPP
                                (596) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (597) OR
                                    (598) RelADPP
                                        (599) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (600) RelADPP
                                    (601) RelADPP
                            (602) RelADPP
                                (603) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (604) OR
                                    (605) RelADPP
                                        (606) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (607) RelADPP
                                    (608) RelADPP
            (609) RelADPP
                (610) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (611) OR
                    (612) RelADPP
                        (613) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (614) OR
                            (615) RelADPP
                                (616) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (617) OR
                                    (618) RelADPP
                                        (619) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (620) RelADPP
                                    (621) RelADPP
                                        (622) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (623) RelADPP
                                        (624) RelADPCleverAfsProof [SOUND, 6 ms]
                                        (625) QDP
                            (626) RelADPP
                                (627) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (628) OR
                                    (629) RelADPP
                                    (630) RelADPP
                                        (631) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (632) RelADPP
                            (633) RelADPP
                                (634) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (635) RelADPP
                                (636) RelADPCleverAfsProof [SOUND, 14 ms]
                                (637) QDP
                                (638) MRRProof [EQUIVALENT, 2 ms]
                                (639) QDP
                                (640) PisEmptyProof [EQUIVALENT, 0 ms]
                                (641) YES
                    (642) RelADPP
                        (643) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (644) OR
                            (645) RelADPP
                                (646) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (647) OR
                                    (648) RelADPP
                                    (649) RelADPP
                                        (650) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (651) RelADPP
                                        (652) RelADPCleverAfsProof [SOUND, 20 ms]
                                        (653) QDP
                            (654) RelADPP
                                (655) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (656) OR
                                    (657) RelADPP
                                    (658) RelADPP
                                        (659) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (660) RelADPP
                            (661) RelADPP
                                (662) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (663) RelADPP
                                (664) RelADPCleverAfsProof [SOUND, 4 ms]
                                (665) QDP
                                (666) MRRProof [EQUIVALENT, 2 ms]
                                (667) QDP
                                (668) PisEmptyProof [EQUIVALENT, 0 ms]
                                (669) YES
                    (670) RelADPP
                        (671) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (672) OR
                            (673) RelADPP
                                (674) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (675) OR
                                    (676) RelADPP
                                    (677) RelADPP
                            (678) RelADPP
                                (679) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (680) OR
                                    (681) RelADPP
                                    (682) RelADPP
                            (683) RelADPP
                                (684) RelADPReductionPairProof [EQUIVALENT, 14 ms]
                                (685) RelADPP
                                (686) RelADPCleverAfsProof [SOUND, 4 ms]
                                (687) QDP
                    (688) RelADPP
                        (689) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                        (690) RelADPP
                        (691) RelADPCleverAfsProof [SOUND, 8 ms]
                        (692) QDP
                        (693) MRRProof [EQUIVALENT, 1 ms]
                        (694) QDP
                        (695) PisEmptyProof [EQUIVALENT, 0 ms]
                        (696) YES
            (697) RelADPP
                (698) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (699) OR
                    (700) RelADPP
                        (701) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (702) OR
                            (703) RelADPP
                                (704) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (705) OR
                                    (706) RelADPP
                                    (707) RelADPP
                            (708) RelADPP
                                (709) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (710) OR
                                    (711) RelADPP
                                    (712) RelADPP
                            (713) RelADPP
                                (714) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (715) OR
                                    (716) RelADPP
                                    (717) RelADPP
                    (718) RelADPP
                        (719) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (720) OR
                            (721) RelADPP
                                (722) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (723) OR
                                    (724) RelADPP
                                    (725) RelADPP
                                        (726) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (727) RelADPP
                            (728) RelADPP
                                (729) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (730) OR
                                    (731) RelADPP
                                    (732) RelADPP
                                        (733) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (734) RelADPP
                            (735) RelADPP
                                (736) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (737) RelADPP
                                (738) RelADPCleverAfsProof [SOUND, 5 ms]
                                (739) QDP
                                (740) MRRProof [EQUIVALENT, 1 ms]
                                (741) QDP
                                (742) PisEmptyProof [EQUIVALENT, 0 ms]
                                (743) YES
                    (744) RelADPP
                        (745) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (746) OR
                            (747) RelADPP
                                (748) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (749) OR
                                    (750) RelADPP
                                    (751) RelADPP
                            (752) RelADPP
                                (753) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (754) OR
                                    (755) RelADPP
                                    (756) RelADPP
                            (757) RelADPP
                                (758) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (759) OR
                                    (760) RelADPP
                                    (761) RelADPP
                    (762) RelADPP
                        (763) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (764) OR
                            (765) RelADPP
                                (766) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (767) OR
                                    (768) RelADPP
                                    (769) RelADPP
                            (770) RelADPP
                                (771) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (772) RelADPP
                                (773) RelADPCleverAfsProof [SOUND, 14 ms]
                                (774) QDP
                            (775) RelADPP
                                (776) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (777) OR
                                    (778) RelADPP
                                    (779) RelADPP
            (780) RelADPP
                (781) RelADPDerelatifying2Proof [SOUND, 4 ms]
                (782) OR
                    (783) RelADPP
                        (784) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (785) OR
                            (786) RelADPP
                                (787) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (788) OR
                                    (789) RelADPP
                                    (790) RelADPP
                                        (791) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (792) RelADPP
                            (793) RelADPP
                                (794) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (795) OR
                                    (796) RelADPP
                                    (797) RelADPP
                            (798) RelADPP
                                (799) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (800) OR
                                    (801) RelADPP
                                        (802) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (803) RelADPP
                                    (804) RelADPP
                    (805) RelADPP
                        (806) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (807) OR
                            (808) RelADPP
                                (809) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (810) OR
                                    (811) RelADPP
                                    (812) RelADPP
                                        (813) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (814) RelADPP
                            (815) RelADPP
                                (816) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (817) OR
                                    (818) RelADPP
                                    (819) RelADPP
                                        (820) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (821) RelADPP
                            (822) RelADPP
                                (823) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (824) RelADPP
                                (825) RelADPCleverAfsProof [SOUND, 4 ms]
                                (826) QDP
                                (827) MRRProof [EQUIVALENT, 0 ms]
                                (828) QDP
                                (829) MRRProof [EQUIVALENT, 2 ms]
                                (830) QDP
                    (831) RelADPP
                        (832) RelADPDerelatifying2Proof [SOUND, 1 ms]
                        (833) OR
                            (834) RelADPP
                                (835) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (836) OR
                                    (837) RelADPP
                                    (838) RelADPP
                            (839) RelADPP
                                (840) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (841) OR
                                    (842) RelADPP
                                    (843) RelADPP
                                        (844) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (845) RelADPP
                            (846) RelADPP
                                (847) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (848) OR
                                    (849) RelADPP
                                    (850) RelADPP
                                        (851) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (852) RelADPP
                    (853) RelADPP
                        (854) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (855) OR
                            (856) RelADPP
                                (857) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (858) OR
                                    (859) RelADPP
                                        (860) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (861) RelADPP
                                    (862) RelADPP
                            (863) RelADPP
                                (864) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (865) RelADPP
                                (866) RelADPCleverAfsProof [SOUND, 5 ms]
                                (867) QDP
                                (868) MRRProof [EQUIVALENT, 0 ms]
                                (869) QDP
                                (870) MRRProof [EQUIVALENT, 2 ms]
                                (871) QDP
                            (872) RelADPP
                                (873) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (874) OR
                                    (875) RelADPP
                                    (876) RelADPP
                                        (877) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (878) RelADPP
            (879) RelADPP
                (880) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (881) OR
                    (882) RelADPP
                        (883) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (884) OR
                            (885) RelADPP
                                (886) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (887) RelADPP
                                (888) RelADPCleverAfsProof [SOUND, 5 ms]
                                (889) QDP
                                (890) MRRProof [EQUIVALENT, 0 ms]
                                (891) QDP
                                (892) MRRProof [EQUIVALENT, 2 ms]
                                (893) QDP
                            (894) RelADPP
                                (895) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (896) OR
                                    (897) RelADPP
                                        (898) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (899) RelADPP
                                    (900) RelADPP
                            (901) RelADPP
                                (902) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (903) OR
                                    (904) RelADPP
                                        (905) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (906) RelADPP
                                    (907) RelADPP
                    (908) RelADPP
                        (909) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                        (910) RelADPP
                        (911) RelADPCleverAfsProof [SOUND, 8 ms]
                        (912) QDP
                        (913) MRRProof [EQUIVALENT, 2 ms]
                        (914) QDP
                        (915) PisEmptyProof [EQUIVALENT, 0 ms]
                        (916) YES
                    (917) RelADPP
                        (918) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (919) OR
                            (920) RelADPP
                                (921) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (922) OR
                                    (923) RelADPP
                                        (924) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (925) RelADPP
                                    (926) RelADPP
                            (927) RelADPP
                                (928) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (929) RelADPP
                                (930) RelADPCleverAfsProof [SOUND, 5 ms]
                                (931) QDP
                                (932) MRRProof [EQUIVALENT, 0 ms]
                                (933) QDP
                                (934) MRRProof [EQUIVALENT, 0 ms]
                                (935) QDP
                            (936) RelADPP
                                (937) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (938) OR
                                    (939) RelADPP
                                    (940) RelADPP
                                        (941) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (942) RelADPP
                    (943) RelADPP
                        (944) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (945) OR
                            (946) RelADPP
                                (947) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (948) OR
                                    (949) RelADPP
                                        (950) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (951) RelADPP
                                    (952) RelADPP
                            (953) RelADPP
                                (954) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (955) RelADPP
                                (956) RelADPCleverAfsProof [SOUND, 5 ms]
                                (957) QDP
                                (958) MRRProof [EQUIVALENT, 0 ms]
                                (959) QDP
                                (960) MRRProof [EQUIVALENT, 0 ms]
                                (961) QDP
                            (962) RelADPP
                                (963) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (964) OR
                                    (965) RelADPP
                                    (966) RelADPP
                                        (967) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (968) RelADPP
    (969) RelADPP
        (970) RelADPReductionPairProof [EQUIVALENT, 29 ms]
        (971) RelADPP
        (972) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (973) YES
    (974) RelADPP
        (975) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (976) OR
            (977) RelADPP
                (978) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (979) OR
                    (980) RelADPP
                        (981) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (982) OR
                            (983) RelADPP
                                (984) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (985) RelADPP
                                (986) RelADPCleverAfsProof [SOUND, 6 ms]
                                (987) QDP
                                (988) MRRProof [EQUIVALENT, 2 ms]
                                (989) QDP
                            (990) RelADPP
                                (991) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (992) RelADPP
                                (993) RelADPCleverAfsProof [SOUND, 7 ms]
                                (994) QDP
                                (995) MRRProof [EQUIVALENT, 0 ms]
                                (996) QDP
                                (997) PisEmptyProof [EQUIVALENT, 0 ms]
                                (998) YES
                    (999) RelADPP
                        (1000) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1001) OR
                            (1002) RelADPP
                                (1003) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1004) RelADPP
                                (1005) RelADPCleverAfsProof [SOUND, 7 ms]
                                (1006) QDP
                                (1007) MRRProof [EQUIVALENT, 3 ms]
                                (1008) QDP
                            (1009) RelADPP
                                (1010) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1011) RelADPP
                                (1012) RelADPCleverAfsProof [SOUND, 7 ms]
                                (1013) QDP
                                (1014) MRRProof [EQUIVALENT, 3 ms]
                                (1015) QDP
                    (1016) RelADPP
                        (1017) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1018) OR
                            (1019) RelADPP
                                (1020) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (1021) RelADPP
                                (1022) RelADPCleverAfsProof [SOUND, 10 ms]
                                (1023) QDP
                                (1024) MRRProof [EQUIVALENT, 0 ms]
                                (1025) QDP
                                (1026) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1027) YES
                            (1028) RelADPP
                                (1029) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1030) RelADPP
                                (1031) RelADPCleverAfsProof [SOUND, 10 ms]
                                (1032) QDP
                                (1033) MRRProof [EQUIVALENT, 3 ms]
                                (1034) QDP
            (1035) RelADPP
                (1036) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1037) OR
                    (1038) RelADPP
                        (1039) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1040) OR
                            (1041) RelADPP
                                (1042) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1043) RelADPP
                                (1044) RelADPCleverAfsProof [SOUND, 10 ms]
                                (1045) QDP
                                (1046) MRRProof [EQUIVALENT, 3 ms]
                                (1047) QDP
                            (1048) RelADPP
                                (1049) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1050) RelADPP
                                (1051) RelADPCleverAfsProof [SOUND, 6 ms]
                                (1052) QDP
                                (1053) MRRProof [EQUIVALENT, 2 ms]
                                (1054) QDP
                                (1055) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1056) YES
                    (1057) RelADPP
                        (1058) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1059) OR
                            (1060) RelADPP
                                (1061) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1062) RelADPP
                                (1063) RelADPCleverAfsProof [SOUND, 6 ms]
                                (1064) QDP
                                (1065) MRRProof [EQUIVALENT, 2 ms]
                                (1066) QDP
                            (1067) RelADPP
                                (1068) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (1069) RelADPP
                                (1070) RelADPCleverAfsProof [SOUND, 0 ms]
                                (1071) QDP
                                (1072) MRRProof [EQUIVALENT, 0 ms]
                                (1073) QDP
                                (1074) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1075) YES
                    (1076) RelADPP
                        (1077) RelADPReductionPairProof [EQUIVALENT, 10 ms]
                        (1078) RelADPP
                        (1079) RelADPCleverAfsProof [SOUND, 8 ms]
                        (1080) QDP
                        (1081) MRRProof [EQUIVALENT, 0 ms]
                        (1082) QDP
                        (1083) PisEmptyProof [EQUIVALENT, 0 ms]
                        (1084) YES
            (1085) RelADPP
                (1086) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1087) OR
                    (1088) RelADPP
                        (1089) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1090) OR
                            (1091) RelADPP
                                (1092) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1093) RelADPP
                                (1094) RelADPCleverAfsProof [SOUND, 6 ms]
                                (1095) QDP
                                (1096) MRRProof [EQUIVALENT, 0 ms]
                                (1097) QDP
                            (1098) RelADPP
                                (1099) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1100) RelADPP
                                (1101) RelADPCleverAfsProof [SOUND, 26 ms]
                                (1102) QDP
                                (1103) MRRProof [EQUIVALENT, 2 ms]
                                (1104) QDP
                    (1105) RelADPP
                        (1106) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1107) OR
                            (1108) RelADPP
                                (1109) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1110) RelADPP
                                (1111) RelADPCleverAfsProof [SOUND, 8 ms]
                                (1112) QDP
                                (1113) MRRProof [EQUIVALENT, 2 ms]
                                (1114) QDP
                            (1115) RelADPP
                                (1116) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1117) RelADPP
                                (1118) RelADPCleverAfsProof [SOUND, 2 ms]
                                (1119) QDP
                                (1120) MRRProof [EQUIVALENT, 0 ms]
                                (1121) QDP
                                (1122) MRRProof [EQUIVALENT, 1 ms]
                                (1123) QDP
                    (1124) RelADPP
                        (1125) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1126) OR
                            (1127) RelADPP
                                (1128) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1129) RelADPP
                                (1130) RelADPCleverAfsProof [SOUND, 15 ms]
                                (1131) QDP
                                (1132) MRRProof [EQUIVALENT, 2 ms]
                                (1133) QDP
                            (1134) RelADPP
                                (1135) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1136) RelADPP
                                (1137) RelADPCleverAfsProof [SOUND, 4 ms]
                                (1138) QDP
                                (1139) MRRProof [EQUIVALENT, 0 ms]
                                (1140) QDP
                                (1141) MRRProof [EQUIVALENT, 2 ms]
                                (1142) QDP
            (1143) RelADPP
                (1144) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1145) OR
                    (1146) RelADPP
                        (1147) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1148) OR
                            (1149) RelADPP
                                (1150) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (1151) RelADPP
                                (1152) RelADPCleverAfsProof [SOUND, 7 ms]
                                (1153) QDP
                                (1154) MRRProof [EQUIVALENT, 0 ms]
                                (1155) QDP
                                (1156) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1157) YES
                            (1158) RelADPP
                                (1159) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1160) RelADPP
                                (1161) RelADPCleverAfsProof [SOUND, 7 ms]
                                (1162) QDP
                                (1163) MRRProof [EQUIVALENT, 3 ms]
                                (1164) QDP
                    (1165) RelADPP
                        (1166) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (1167) RelADPP
                        (1168) RelADPCleverAfsProof [SOUND, 18 ms]
                        (1169) QDP
                        (1170) MRRProof [EQUIVALENT, 1 ms]
                        (1171) QDP
                        (1172) PisEmptyProof [EQUIVALENT, 0 ms]
                        (1173) YES
                    (1174) RelADPP
                        (1175) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1176) OR
                            (1177) RelADPP
                                (1178) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1179) RelADPP
                                (1180) RelADPCleverAfsProof [SOUND, 16 ms]
                                (1181) QDP
                                (1182) MRRProof [EQUIVALENT, 3 ms]
                                (1183) QDP
                            (1184) RelADPP
                                (1185) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (1186) RelADPP
                                (1187) RelADPCleverAfsProof [SOUND, 26 ms]
                                (1188) QDP
                                (1189) MRRProof [EQUIVALENT, 0 ms]
                                (1190) QDP
                                (1191) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1192) YES
    (1193) RelADPP
        (1194) RelADPReductionPairProof [EQUIVALENT, 44 ms]
        (1195) RelADPP
        (1196) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (1197) YES
    (1198) RelADPP
        (1199) RelADPReductionPairProof [EQUIVALENT, 44 ms]
        (1200) RelADPP
        (1201) RelADPCleverAfsProof [SOUND, 16 ms]
        (1202) QDP
        (1203) MRRProof [EQUIVALENT, 1 ms]
        (1204) QDP
        (1205) PisEmptyProof [EQUIVALENT, 0 ms]
        (1206) YES
    (1207) RelADPP
        (1208) RelADPReductionPairProof [EQUIVALENT, 31 ms]
        (1209) RelADPP
        (1210) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (1211) YES
    (1212) RelADPP
        (1213) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (1214) OR
            (1215) RelADPP
                (1216) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1217) OR
                    (1218) RelADPP
                        (1219) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1220) OR
                            (1221) RelADPP
                                (1222) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1223) OR
                                    (1224) RelADPP
                                    (1225) RelADPP
                                        (1226) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1227) RelADPP
                            (1228) RelADPP
                                (1229) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1230) OR
                                    (1231) RelADPP
                                    (1232) RelADPP
                                        (1233) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1234) RelADPP
                            (1235) RelADPP
                                (1236) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1237) RelADPP
                                (1238) RelADPCleverAfsProof [SOUND, 4 ms]
                                (1239) QDP
                                (1240) MRRProof [EQUIVALENT, 1 ms]
                                (1241) QDP
                                (1242) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1243) YES
                    (1244) RelADPP
                        (1245) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1246) OR
                            (1247) RelADPP
                                (1248) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1249) OR
                                    (1250) RelADPP
                                    (1251) RelADPP
                                        (1252) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1253) RelADPP
                            (1254) RelADPP
                                (1255) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1256) OR
                                    (1257) RelADPP
                                    (1258) RelADPP
                                        (1259) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1260) RelADPP
                            (1261) RelADPP
                                (1262) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1263) OR
                                    (1264) RelADPP
                                        (1265) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1266) RelADPP
                                    (1267) RelADPP
                    (1268) RelADPP
                        (1269) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1270) OR
                            (1271) RelADPP
                                (1272) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1273) OR
                                    (1274) RelADPP
                                    (1275) RelADPP
                                        (1276) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1277) RelADPP
                            (1278) RelADPP
                                (1279) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1280) OR
                                    (1281) RelADPP
                                    (1282) RelADPP
                            (1283) RelADPP
                                (1284) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1285) OR
                                    (1286) RelADPP
                                        (1287) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1288) RelADPP
                                    (1289) RelADPP
                    (1290) RelADPP
                        (1291) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1292) OR
                            (1293) RelADPP
                                (1294) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                (1295) RelADPP
                                (1296) RelADPCleverAfsProof [SOUND, 10 ms]
                                (1297) QDP
                                (1298) MRRProof [EQUIVALENT, 0 ms]
                                (1299) QDP
                                (1300) MRRProof [EQUIVALENT, 0 ms]
                                (1301) QDP
                            (1302) RelADPP
                                (1303) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1304) OR
                                    (1305) RelADPP
                                        (1306) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1307) RelADPP
                                    (1308) RelADPP
                                        (1309) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1310) RelADPP
                            (1311) RelADPP
                                (1312) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1313) OR
                                    (1314) RelADPP
                                        (1315) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1316) RelADPP
                                    (1317) RelADPP
                                        (1318) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1319) RelADPP
            (1320) RelADPP
                (1321) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1322) OR
                    (1323) RelADPP
                        (1324) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1325) OR
                            (1326) RelADPP
                                (1327) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1328) OR
                                    (1329) RelADPP
                                    (1330) RelADPP
                                        (1331) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (1332) RelADPP
                            (1333) RelADPP
                                (1334) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1335) OR
                                    (1336) RelADPP
                                        (1337) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1338) RelADPP
                                    (1339) RelADPP
                                        (1340) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1341) RelADPP
                            (1342) RelADPP
                                (1343) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1344) RelADPP
                                (1345) RelADPCleverAfsProof [SOUND, 5 ms]
                                (1346) QDP
                                (1347) MRRProof [EQUIVALENT, 0 ms]
                                (1348) QDP
                                (1349) MRRProof [EQUIVALENT, 1 ms]
                                (1350) QDP
                    (1351) RelADPP
                        (1352) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1353) OR
                            (1354) RelADPP
                                (1355) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1356) OR
                                    (1357) RelADPP
                                    (1358) RelADPP
                                        (1359) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (1360) RelADPP
                            (1361) RelADPP
                                (1362) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1363) OR
                                    (1364) RelADPP
                                    (1365) RelADPP
                                        (1366) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1367) RelADPP
                                        (1368) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1369) AND
                                            (1370) RelADPP
                                            (1371) RelADPP
                                            (1372) RelADPP
                            (1373) RelADPP
                                (1374) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1375) RelADPP
                                (1376) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1377) AND
                                    (1378) RelADPP
                                        (1379) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (1380) RelADPP
                                        (1381) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1382) YES
                                    (1383) RelADPP
                                        (1384) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (1385) RelADPP
                                        (1386) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1387) YES
                                    (1388) RelADPP
                                        (1389) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                                        (1390) RelADPP
                                        (1391) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1392) YES
                    (1393) RelADPP
                        (1394) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1395) OR
                            (1396) RelADPP
                                (1397) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1398) OR
                                    (1399) RelADPP
                                    (1400) RelADPP
                            (1401) RelADPP
                                (1402) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1403) OR
                                    (1404) RelADPP
                                    (1405) RelADPP
                            (1406) RelADPP
                                (1407) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (1408) RelADPP
                                (1409) RelADPCleverAfsProof [SOUND, 6 ms]
                                (1410) QDP
                    (1411) RelADPP
                        (1412) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (1413) RelADPP
                        (1414) RelADPCleverAfsProof [SOUND, 15 ms]
                        (1415) QDP
                        (1416) MRRProof [EQUIVALENT, 0 ms]
                        (1417) QDP
                        (1418) PisEmptyProof [EQUIVALENT, 0 ms]
                        (1419) YES
            (1420) RelADPP
                (1421) RelADPDerelatifying2Proof [SOUND, 6 ms]
                (1422) OR
                    (1423) RelADPP
                        (1424) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1425) OR
                            (1426) RelADPP
                                (1427) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1428) OR
                                    (1429) RelADPP
                                        (1430) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1431) RelADPP
                                    (1432) RelADPP
                                        (1433) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                                        (1434) RelADPP
                            (1435) RelADPP
                                (1436) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1437) OR
                                    (1438) RelADPP
                                        (1439) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1440) RelADPP
                                    (1441) RelADPP
                                        (1442) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1443) RelADPP
                            (1444) RelADPP
                                (1445) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1446) OR
                                    (1447) RelADPP
                                        (1448) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1449) RelADPP
                                    (1450) RelADPP
                    (1451) RelADPP
                        (1452) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1453) OR
                            (1454) RelADPP
                                (1455) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1456) OR
                                    (1457) RelADPP
                                        (1458) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1459) RelADPP
                                    (1460) RelADPP
                                        (1461) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1462) RelADPP
                            (1463) RelADPP
                                (1464) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1465) OR
                                    (1466) RelADPP
                                        (1467) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1468) RelADPP
                                    (1469) RelADPP
                                        (1470) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (1471) RelADPP
                                        (1472) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1473) AND
                                            (1474) RelADPP
                                            (1475) RelADPP
                                            (1476) RelADPP
                            (1477) RelADPP
                                (1478) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1479) RelADPP
                                (1480) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1481) AND
                                    (1482) RelADPP
                                        (1483) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (1484) RelADPP
                                        (1485) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1486) YES
                                    (1487) RelADPP
                                        (1488) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1489) RelADPP
                                        (1490) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1491) YES
                                    (1492) RelADPP
                                        (1493) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (1494) RelADPP
                                        (1495) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1496) YES
                    (1497) RelADPP
                        (1498) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1499) OR
                            (1500) RelADPP
                                (1501) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1502) OR
                                    (1503) RelADPP
                                        (1504) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1505) RelADPP
                                    (1506) RelADPP
                            (1507) RelADPP
                                (1508) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1509) OR
                                    (1510) RelADPP
                                    (1511) RelADPP
                                        (1512) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1513) RelADPP
                                        (1514) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1515) AND
                                            (1516) RelADPP
                                            (1517) RelADPP
                                            (1518) RelADPP
                            (1519) RelADPP
                                (1520) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1521) OR
                                    (1522) RelADPP
                                    (1523) RelADPP
                                        (1524) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1525) RelADPP
                                        (1526) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1527) AND
                                            (1528) RelADPP
                                            (1529) RelADPP
                                            (1530) RelADPP
                    (1531) RelADPP
                        (1532) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1533) OR
                            (1534) RelADPP
                                (1535) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1536) OR
                                    (1537) RelADPP
                                        (1538) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1539) RelADPP
                                        (1540) RelADPCleverAfsProof [SOUND, 5 ms]
                                        (1541) QDP
                                    (1542) RelADPP
                                        (1543) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1544) RelADPP
                            (1545) RelADPP
                                (1546) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1547) RelADPP
                                (1548) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1549) AND
                                    (1550) RelADPP
                                        (1551) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1552) RelADPP
                                        (1553) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1554) YES
                                    (1555) RelADPP
                                        (1556) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1557) RelADPP
                                        (1558) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1559) YES
                                    (1560) RelADPP
                                        (1561) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1562) RelADPP
                                        (1563) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1564) YES
                            (1565) RelADPP
                                (1566) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1567) OR
                                    (1568) RelADPP
                                        (1569) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                        (1570) RelADPP
                                    (1571) RelADPP
                                        (1572) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1573) RelADPP
                                        (1574) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1575) AND
                                            (1576) RelADPP
                                            (1577) RelADPP
                                            (1578) RelADPP
            (1579) RelADPP
                (1580) RelADPDerelatifying2Proof [SOUND, 3 ms]
                (1581) OR
                    (1582) RelADPP
                        (1583) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1584) OR
                            (1585) RelADPP
                                (1586) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1587) OR
                                    (1588) RelADPP
                                    (1589) RelADPP
                            (1590) RelADPP
                                (1591) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1592) OR
                                    (1593) RelADPP
                                    (1594) RelADPP
                            (1595) RelADPP
                                (1596) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1597) OR
                                    (1598) RelADPP
                                    (1599) RelADPP
                    (1600) RelADPP
                        (1601) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1602) OR
                            (1603) RelADPP
                                (1604) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1605) OR
                                    (1606) RelADPP
                                    (1607) RelADPP
                                        (1608) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (1609) RelADPP
                            (1610) RelADPP
                                (1611) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1612) OR
                                    (1613) RelADPP
                                    (1614) RelADPP
                                        (1615) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (1616) RelADPP
                                        (1617) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1618) AND
                                            (1619) RelADPP
                                            (1620) RelADPP
                                            (1621) RelADPP
                            (1622) RelADPP
                                (1623) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1624) RelADPP
                                (1625) RelADPCleverAfsProof [SOUND, 4 ms]
                                (1626) QDP
                                (1627) MRRProof [EQUIVALENT, 2 ms]
                                (1628) QDP
                                (1629) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1630) YES
                    (1631) RelADPP
                        (1632) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1633) OR
                            (1634) RelADPP
                                (1635) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1636) OR
                                    (1637) RelADPP
                                    (1638) RelADPP
                            (1639) RelADPP
                                (1640) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1641) OR
                                    (1642) RelADPP
                                    (1643) RelADPP
                                        (1644) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1645) RelADPP
                                        (1646) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1647) AND
                                            (1648) RelADPP
                                            (1649) RelADPP
                                            (1650) RelADPP
                            (1651) RelADPP
                                (1652) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1653) OR
                                    (1654) RelADPP
                                    (1655) RelADPP
                                        (1656) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (1657) RelADPP
                                        (1658) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1659) AND
                                            (1660) RelADPP
                                            (1661) RelADPP
                                            (1662) RelADPP
                    (1663) RelADPP
                        (1664) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1665) OR
                            (1666) RelADPP
                                (1667) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1668) OR
                                    (1669) RelADPP
                                    (1670) RelADPP
                            (1671) RelADPP
                                (1672) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                (1673) RelADPP
                                (1674) RelADPCleverAfsProof [SOUND, 3 ms]
                                (1675) QDP
                            (1676) RelADPP
                                (1677) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1678) OR
                                    (1679) RelADPP
                                    (1680) RelADPP
            (1681) RelADPP
                (1682) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1683) OR
                    (1684) RelADPP
                        (1685) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1686) OR
                            (1687) RelADPP
                                (1688) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1689) RelADPP
                                (1690) RelADPCleverAfsProof [SOUND, 0 ms]
                                (1691) QDP
                                (1692) MRRProof [EQUIVALENT, 0 ms]
                                (1693) QDP
                                (1694) MRRProof [EQUIVALENT, 0 ms]
                                (1695) QDP
                            (1696) RelADPP
                                (1697) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1698) OR
                                    (1699) RelADPP
                                        (1700) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1701) RelADPP
                                    (1702) RelADPP
                            (1703) RelADPP
                                (1704) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1705) OR
                                    (1706) RelADPP
                                        (1707) RelADPReductionPairProof [EQUIVALENT, 5 ms]
                                        (1708) RelADPP
                                    (1709) RelADPP
                    (1710) RelADPP
                        (1711) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                        (1712) RelADPP
                        (1713) RelADPCleverAfsProof [SOUND, 17 ms]
                        (1714) QDP
                        (1715) MRRProof [EQUIVALENT, 1 ms]
                        (1716) QDP
                        (1717) PisEmptyProof [EQUIVALENT, 0 ms]
                        (1718) YES
                    (1719) RelADPP
                        (1720) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1721) OR
                            (1722) RelADPP
                                (1723) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1724) OR
                                    (1725) RelADPP
                                        (1726) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1727) RelADPP
                                    (1728) RelADPP
                            (1729) RelADPP
                                (1730) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1731) RelADPP
                                (1732) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                (1733) AND
                                    (1734) RelADPP
                                        (1735) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (1736) RelADPP
                                        (1737) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1738) YES
                                    (1739) RelADPP
                                        (1740) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (1741) RelADPP
                                        (1742) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1743) YES
                                    (1744) RelADPP
                                        (1745) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                        (1746) RelADPP
                                        (1747) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                                        (1748) YES
                            (1749) RelADPP
                                (1750) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1751) OR
                                    (1752) RelADPP
                                    (1753) RelADPP
                                        (1754) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                        (1755) RelADPP
                                        (1756) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                                        (1757) AND
                                            (1758) RelADPP
                                            (1759) RelADPP
                                            (1760) RelADPP
                    (1761) RelADPP
                        (1762) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1763) OR
                            (1764) RelADPP
                                (1765) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1766) OR
                                    (1767) RelADPP
                                    (1768) RelADPP
                            (1769) RelADPP
                                (1770) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (1771) RelADPP
                                (1772) RelADPCleverAfsProof [SOUND, 5 ms]
                                (1773) QDP
                            (1774) RelADPP
                                (1775) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1776) OR
                                    (1777) RelADPP
                                    (1778) RelADPP
    (1779) RelADPP
        (1780) RelADPReductionPairProof [EQUIVALENT, 45 ms]
        (1781) RelADPP
        (1782) RelADPCleverAfsProof [SOUND, 28 ms]
        (1783) QDP
        (1784) MRRProof [EQUIVALENT, 4 ms]
        (1785) QDP
        (1786) PisEmptyProof [EQUIVALENT, 0 ms]
        (1787) YES
    (1788) RelADPP
        (1789) RelADPDerelatifying2Proof [SOUND, 4 ms]
        (1790) OR
            (1791) RelADPP
                (1792) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1793) OR
                    (1794) RelADPP
                        (1795) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1796) OR
                            (1797) RelADPP
                                (1798) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1799) RelADPP
                                (1800) RelADPCleverAfsProof [SOUND, 26 ms]
                                (1801) QDP
                                (1802) MRRProof [EQUIVALENT, 3 ms]
                                (1803) QDP
                            (1804) RelADPP
                                (1805) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1806) RelADPP
                                (1807) RelADPCleverAfsProof [SOUND, 3 ms]
                                (1808) QDP
                                (1809) MRRProof [EQUIVALENT, 2 ms]
                                (1810) QDP
                                (1811) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1812) YES
                    (1813) RelADPP
                        (1814) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1815) OR
                            (1816) RelADPP
                                (1817) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1818) RelADPP
                                (1819) RelADPCleverAfsProof [SOUND, 6 ms]
                                (1820) QDP
                                (1821) MRRProof [EQUIVALENT, 2 ms]
                                (1822) QDP
                            (1823) RelADPP
                                (1824) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1825) RelADPP
                                (1826) RelADPCleverAfsProof [SOUND, 6 ms]
                                (1827) QDP
                                (1828) MRRProof [EQUIVALENT, 3 ms]
                                (1829) QDP
                    (1830) RelADPP
                        (1831) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1832) OR
                            (1833) RelADPP
                                (1834) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1835) RelADPP
                                (1836) RelADPCleverAfsProof [SOUND, 15 ms]
                                (1837) QDP
                                (1838) MRRProof [EQUIVALENT, 2 ms]
                                (1839) QDP
                                (1840) PisEmptyProof [EQUIVALENT, 0 ms]
                                (1841) YES
                            (1842) RelADPP
                                (1843) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1844) RelADPP
                                (1845) RelADPCleverAfsProof [SOUND, 20 ms]
                                (1846) QDP
                                (1847) MRRProof [EQUIVALENT, 2 ms]
                                (1848) QDP
            (1849) RelADPP
                (1850) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1851) OR
                    (1852) RelADPP
                        (1853) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1854) OR
                            (1855) RelADPP
                                (1856) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1857) RelADPP
                            (1858) RelADPP
                                (1859) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                                (1860) RelADPP
                                (1861) RelADPCleverAfsProof [SOUND, 16 ms]
                                (1862) QDP
                    (1863) RelADPP
                        (1864) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1865) OR
                            (1866) RelADPP
                                (1867) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1868) RelADPP
                            (1869) RelADPP
                                (1870) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1871) RelADPP
                                (1872) RelADPCleverAfsProof [SOUND, 4 ms]
                                (1873) QDP
                    (1874) RelADPP
                        (1875) RelADPReductionPairProof [EQUIVALENT, 6 ms]
                        (1876) RelADPP
                        (1877) RelADPCleverAfsProof [SOUND, 7 ms]
                        (1878) QDP
                        (1879) MRRProof [EQUIVALENT, 1 ms]
                        (1880) QDP
                        (1881) PisEmptyProof [EQUIVALENT, 0 ms]
                        (1882) YES
            (1883) RelADPP
                (1884) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1885) OR
                    (1886) RelADPP
                        (1887) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1888) OR
                            (1889) RelADPP
                                (1890) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1891) RelADPP
                            (1892) RelADPP
                                (1893) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1894) RelADPP
                    (1895) RelADPP
                        (1896) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1897) OR
                            (1898) RelADPP
                                (1899) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1900) RelADPP
                                (1901) RelADPCleverAfsProof [SOUND, 3 ms]
                                (1902) QDP
                            (1903) RelADPP
                                (1904) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1905) RelADPP
                                (1906) RelADPCleverAfsProof [SOUND, 5 ms]
                                (1907) QDP
                    (1908) RelADPP
                        (1909) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1910) OR
                            (1911) RelADPP
                                (1912) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1913) RelADPP
                                (1914) RelADPCleverAfsProof [SOUND, 3 ms]
                                (1915) QDP
                            (1916) RelADPP
                                (1917) RelADPReductionPairProof [EQUIVALENT, 0 ms]
                                (1918) RelADPP
                                (1919) RelADPCleverAfsProof [SOUND, 15 ms]
                                (1920) QDP
            (1921) RelADPP
                (1922) RelADPDerelatifying2Proof [SOUND, 0 ms]
                (1923) OR
                    (1924) RelADPP
                        (1925) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1926) OR
                            (1927) RelADPP
                                (1928) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                                (1929) RelADPP
                                (1930) RelADPCleverAfsProof [SOUND, 4 ms]
                                (1931) QDP
                                (1932) MRRProof [EQUIVALENT, 0 ms]
                                (1933) QDP
                                (1934) MRRProof [EQUIVALENT, 1 ms]
                                (1935) QDP
                            (1936) RelADPP
                                (1937) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1938) RelADPP
                                (1939) RelADPCleverAfsProof [SOUND, 6 ms]
                                (1940) QDP
                                (1941) MRRProof [EQUIVALENT, 2 ms]
                                (1942) QDP
                    (1943) RelADPP
                        (1944) RelADPReductionPairProof [EQUIVALENT, 7 ms]
                        (1945) RelADPP
                        (1946) RelADPCleverAfsProof [SOUND, 5 ms]
                        (1947) QDP
                        (1948) MRRProof [EQUIVALENT, 1 ms]
                        (1949) QDP
                        (1950) PisEmptyProof [EQUIVALENT, 0 ms]
                        (1951) YES
                    (1952) RelADPP
                        (1953) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (1954) OR
                            (1955) RelADPP
                                (1956) RelADPDerelatifying2Proof [SOUND, 0 ms]
                                (1957) RelADPP
                            (1958) RelADPP
                                (1959) RelADPReductionPairProof [EQUIVALENT, 1 ms]
                                (1960) RelADPP
                                (1961) RelADPCleverAfsProof [SOUND, 6 ms]
                                (1962) QDP


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))

The relative TRS consists of the following S rules:

   a(a(a(x1))) -> a(b(a(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   b(b(c(x1))) -> b(a(A(x1)))
   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> A(B(c(x1)))


----------------------------------------

(3) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  9 Lassos,
Result: This relative DT problem is equivalent to 10 subproblems.

----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(6) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(7)
Complex Obligation (OR)

----------------------------------------

(8)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(9) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(10)
Complex Obligation (OR)

----------------------------------------

(11)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(12) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(13)
Complex Obligation (OR)

----------------------------------------

(14)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(15) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(16)
Complex Obligation (OR)

----------------------------------------

(17)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(18)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(19) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(20)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(21) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(22)
Complex Obligation (AND)

----------------------------------------

(23)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(24)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(25)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(26) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(27)
Complex Obligation (OR)

----------------------------------------

(28)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(29)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(30) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(31)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(32) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(33)
Complex Obligation (AND)

----------------------------------------

(34)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(35)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(36)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(37) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(38)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(39) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(40)
Complex Obligation (AND)

----------------------------------------

(41)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(42) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(43)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(44) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b) -> B0(a)

Strictly oriented rules of the TRS R:

   a -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:B0_1 > b > a > c

and weight map:

   a=1
   b=1
   c=1
   B0_1=1

The variable weight is 1

----------------------------------------

(45)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(46) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b) -> B0(a)


Used ordering: Polynomial interpretation [POLO]:

   POL(B0(x_1)) = 2*x_1
   POL(a) = 0
   POL(b) = 1
   POL(c) = 0


----------------------------------------

(47)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(48)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(49) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(50)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(51) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))

Used ordering: Knuth-Bendix order [KBO] with precedence:A0_1 > b > a0_1 > c0_1

and weight map:

   b=1
   a0_1=3
   c0_1=2
   A0_1=1

The variable weight is 1

----------------------------------------

(52)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(53) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(54)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(55)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(56) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(57)
Complex Obligation (OR)

----------------------------------------

(58)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(59) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(60)
Complex Obligation (OR)

----------------------------------------

(61)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(62)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(63)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(64) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(65)
Complex Obligation (OR)

----------------------------------------

(66)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(67)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(68)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(69) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(70)
Complex Obligation (OR)

----------------------------------------

(71)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(72)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(73)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(74) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(75)
Complex Obligation (OR)

----------------------------------------

(76)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(77) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(78)
Complex Obligation (OR)

----------------------------------------

(79)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(80)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(81)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(82) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(83)
Complex Obligation (OR)

----------------------------------------

(84)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(85)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(86)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(87) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(88)
Complex Obligation (OR)

----------------------------------------

(89)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(90)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(91)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(92) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(93)
Complex Obligation (OR)

----------------------------------------

(94)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(95) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(96)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(97) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(98)
Complex Obligation (AND)

----------------------------------------

(99)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(100) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(101)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(102)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(103) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(104)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(105)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(106) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(107)
Complex Obligation (OR)

----------------------------------------

(108)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(109)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(110)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(111) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(112)
Complex Obligation (OR)

----------------------------------------

(113)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(114)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(115)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(116) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(117)
Complex Obligation (OR)

----------------------------------------

(118)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(119) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(120)
Complex Obligation (OR)

----------------------------------------

(121)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(122) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(123)
Complex Obligation (OR)

----------------------------------------

(124)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(125)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(126) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + x_1
   POL(B(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(127)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(128) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(129)
Complex Obligation (AND)

----------------------------------------

(130)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(131)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(132)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(133) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(134)
Complex Obligation (OR)

----------------------------------------

(135)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(136)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(137) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(138)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(139) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(140)
Complex Obligation (AND)

----------------------------------------

(141)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(142)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(143)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(144) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(145)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(146) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(147)
Complex Obligation (AND)

----------------------------------------

(148)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(149) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(150)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(151) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b) -> B0(a)

Strictly oriented rules of the TRS R:

   a -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:B0_1 > b > a > c

and weight map:

   a=1
   b=1
   c=1
   B0_1=1

The variable weight is 1

----------------------------------------

(152)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(153)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(154) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(155)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(156) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))

Used ordering: Knuth-Bendix order [KBO] with precedence:A0_1 > b > a0_1 > c0_1

and weight map:

   b=1
   a0_1=3
   c0_1=2
   A0_1=1

The variable weight is 1

----------------------------------------

(157)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(158) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(159)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(160)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(161) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(162)
Complex Obligation (OR)

----------------------------------------

(163)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(164) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(165)
Complex Obligation (OR)

----------------------------------------

(166)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(167)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(168)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(169) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(170)
Complex Obligation (OR)

----------------------------------------

(171)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(172)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(173)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(174) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(175)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(176) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(177)
Complex Obligation (AND)

----------------------------------------

(178)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(179) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(180)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(181)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(182) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(183)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(184)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(185) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(186)
Complex Obligation (OR)

----------------------------------------

(187)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(188) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(189)
Complex Obligation (OR)

----------------------------------------

(190)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(191)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(192)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(193) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(194)
Complex Obligation (OR)

----------------------------------------

(195)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(196)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(197)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(198) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(199)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(200) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(201)
Complex Obligation (AND)

----------------------------------------

(202)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(203) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(204)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(205)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(206) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(207)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(208)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(209) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(210)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(211) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(212)
Complex Obligation (AND)

----------------------------------------

(213)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(214) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(215)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(216) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b) -> B0(a)


Used ordering: Polynomial interpretation [POLO]:

   POL(B0(x_1)) = 2*x_1
   POL(a) = 0
   POL(b) = 1
   POL(c) = 0


----------------------------------------

(217)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(218) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(219)
YES

----------------------------------------

(220)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(221) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(222)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(223) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(224)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(225) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(226)
YES

----------------------------------------

(227)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(228) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(229)
Complex Obligation (OR)

----------------------------------------

(230)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(231) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(232)
Complex Obligation (OR)

----------------------------------------

(233)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(234) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(235)
Complex Obligation (OR)

----------------------------------------

(236)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(237)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(238)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(239) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(240)
Complex Obligation (OR)

----------------------------------------

(241)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(242)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(243)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(244) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(245)
Complex Obligation (OR)

----------------------------------------

(246)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(247)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(248)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(249) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(250)
Complex Obligation (OR)

----------------------------------------

(251)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(252) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(253)
Complex Obligation (OR)

----------------------------------------

(254)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(255)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(256)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(257) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(258)
Complex Obligation (OR)

----------------------------------------

(259)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(260)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(261)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(262) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(263)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(264) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(265)
Complex Obligation (AND)

----------------------------------------

(266)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(267) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(268)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(269)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(270) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(271)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(272)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(273) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(274)
Complex Obligation (OR)

----------------------------------------

(275)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(276) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(277)
Complex Obligation (OR)

----------------------------------------

(278)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(279)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(280)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(281) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(282)
Complex Obligation (OR)

----------------------------------------

(283)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(284)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(285)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(286) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(287)
Complex Obligation (OR)

----------------------------------------

(288)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(289)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(290)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(291) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(292)
Complex Obligation (OR)

----------------------------------------

(293)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(294) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(295)
Complex Obligation (OR)

----------------------------------------

(296)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(297)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(298)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(299) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(300)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(301) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(302)
Complex Obligation (AND)

----------------------------------------

(303)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(304) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(305)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(306)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(307) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(308)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(309)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(310) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(311)
Complex Obligation (OR)

----------------------------------------

(312)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(313)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(314)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(315) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(316)
Complex Obligation (OR)

----------------------------------------

(317)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(318) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(319)
Complex Obligation (OR)

----------------------------------------

(320)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(321) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(322)
Complex Obligation (OR)

----------------------------------------

(323)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(324)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(325)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(326) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(327)
Complex Obligation (OR)

----------------------------------------

(328)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(329)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(330)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(331) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(332)
Complex Obligation (OR)

----------------------------------------

(333)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(334)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(335)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(336) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(337)
Complex Obligation (OR)

----------------------------------------

(338)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(339) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(340)
Complex Obligation (OR)

----------------------------------------

(341)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(342)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(343)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(344) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(345)
Complex Obligation (OR)

----------------------------------------

(346)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(347)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(348)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(349) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(350)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(351) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(352)
Complex Obligation (AND)

----------------------------------------

(353)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(354) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(355)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(356)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(357) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(358)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(359)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(360) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(361)
Complex Obligation (OR)

----------------------------------------

(362)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(363) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(364)
Complex Obligation (OR)

----------------------------------------

(365)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(366)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(367)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(368) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(369)
Complex Obligation (OR)

----------------------------------------

(370)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(371)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(372)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(373) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(374)
Complex Obligation (OR)

----------------------------------------

(375)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(376)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(377)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(378) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(379)
Complex Obligation (OR)

----------------------------------------

(380)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(381) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(382)
Complex Obligation (OR)

----------------------------------------

(383)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(384) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(385)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(386) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(387)
Complex Obligation (AND)

----------------------------------------

(388)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(389)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(390)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(391)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(392) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(393)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(394) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(395)
Complex Obligation (AND)

----------------------------------------

(396)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(397) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(398)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(399) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b) -> B0(a)

Strictly oriented rules of the TRS R:

   a -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:B0_1 > b > a > c

and weight map:

   a=1
   b=1
   c=1
   B0_1=1

The variable weight is 1

----------------------------------------

(400)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(401) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b) -> B0(a)


Used ordering: Polynomial interpretation [POLO]:

   POL(B0(x_1)) = 2*x_1
   POL(a) = 0
   POL(b) = 1
   POL(c) = 0


----------------------------------------

(402)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(403)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(404) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(405)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(406) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(407)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(408) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))

Used ordering: Knuth-Bendix order [KBO] with precedence:A0_1 > b > a0_1 > c0_1

and weight map:

   b=1
   a0_1=3
   c0_1=2
   A0_1=1

The variable weight is 1

----------------------------------------

(409)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(410)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(411) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(412)
Complex Obligation (OR)

----------------------------------------

(413)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(414)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(415) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(416)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(417) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(418)
Complex Obligation (AND)

----------------------------------------

(419)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(420)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(421)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(422) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(423)
Complex Obligation (OR)

----------------------------------------

(424)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(425) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(426)
Complex Obligation (OR)

----------------------------------------

(427)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(428) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(429)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(430) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(431)
Complex Obligation (AND)

----------------------------------------

(432)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(433) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(434)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(435)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(436) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(437)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(438)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(439) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(440)
Complex Obligation (OR)

----------------------------------------

(441)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(442)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(443)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(444) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(445)
Complex Obligation (OR)

----------------------------------------

(446)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(447)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(448)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(449) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(450)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(451) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(452)
Complex Obligation (AND)

----------------------------------------

(453)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(454) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(455)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(456) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b) -> B0(a)


Used ordering: Polynomial interpretation [POLO]:

   POL(B0(x_1)) = 2*x_1
   POL(a) = 0
   POL(b) = 1
   POL(c) = 0


----------------------------------------

(457)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(458) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(459)
YES

----------------------------------------

(460)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(461) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(462)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(463) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(464)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(465) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(466)
YES

----------------------------------------

(467)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(468) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(469)
Complex Obligation (OR)

----------------------------------------

(470)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(471) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(472)
Complex Obligation (OR)

----------------------------------------

(473)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(474)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(475)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(476) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(B(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(477)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(478) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(479)
Complex Obligation (AND)

----------------------------------------

(480)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(481)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(482)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(483) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(484)
Complex Obligation (OR)

----------------------------------------

(485)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(486)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(487)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(488) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(489)
Complex Obligation (OR)

----------------------------------------

(490)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(491) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(492)
Complex Obligation (OR)

----------------------------------------

(493)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(494)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(495)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(496) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(497)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(498) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(499)
Complex Obligation (AND)

----------------------------------------

(500)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(501) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(502)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(503)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(504) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  x1

b(x1)  =  b

c(x1)  =  c(x1)


Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b
c_1 > b

Status: A_1: [1]
b: multiset status
c_1: [1]


----------------------------------------

(505)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)
   A0(c0(c0(x1))) -> A0(a0(b))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c0(c0(x1))) -> a0(a0(b))
   a0(c0(b)) -> c0(a0(b))
   a0(c0(c0(x1))) -> c0(c0(b))
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(506)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(507) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(508)
Complex Obligation (OR)

----------------------------------------

(509)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> A(b(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(510)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> c(a(B(x1)))
   a(c(c(x1))) -> a(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> a(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> B(a(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(511)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> b(A(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(512) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(513)
Complex Obligation (OR)

----------------------------------------

(514)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(515) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(516)
Complex Obligation (OR)

----------------------------------------

(517)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(518) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(519)
Complex Obligation (OR)

----------------------------------------

(520)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(521) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(522)
Complex Obligation (OR)

----------------------------------------

(523)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(524)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(525) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(526)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(527)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(528) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(529)
Complex Obligation (OR)

----------------------------------------

(530)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(531)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(532) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(533)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(534)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(535) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(536)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(537) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(538)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(539) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(540)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(541) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(542)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(543)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(544) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(545)
Complex Obligation (OR)

----------------------------------------

(546)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(547) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(548)
Complex Obligation (OR)

----------------------------------------

(549)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(550)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(551)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(552) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(553)
Complex Obligation (OR)

----------------------------------------

(554)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(555)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(556)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(557) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(558)
Complex Obligation (OR)

----------------------------------------

(559)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(560)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(561)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(562) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(563)
Complex Obligation (OR)

----------------------------------------

(564)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(565) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(566)
Complex Obligation (OR)

----------------------------------------

(567)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(568)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(569) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(570)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(571)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(572) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(573)
Complex Obligation (OR)

----------------------------------------

(574)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(575)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(576)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(577) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(578)
Complex Obligation (OR)

----------------------------------------

(579)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(580) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(581)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(582)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(583)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(584) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(585)
Complex Obligation (OR)

----------------------------------------

(586)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(587) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(588)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(589) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(590)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(591) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(592)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(593) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(594)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(595)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(596) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(597)
Complex Obligation (OR)

----------------------------------------

(598)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(599) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(600)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(601)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(602)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(603) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(604)
Complex Obligation (OR)

----------------------------------------

(605)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(606) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(607)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(608)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(609)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(610) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(611)
Complex Obligation (OR)

----------------------------------------

(612)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(613) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(614)
Complex Obligation (OR)

----------------------------------------

(615)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(616) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(617)
Complex Obligation (OR)

----------------------------------------

(618)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(619) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(620)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(621)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(622) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(623)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(624) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(625)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(626)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(627) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(628)
Complex Obligation (OR)

----------------------------------------

(629)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(630)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(631) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(632)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(633)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(634) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(635)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(636) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(637)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(638) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(639)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(640) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(641)
YES

----------------------------------------

(642)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(643) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(644)
Complex Obligation (OR)

----------------------------------------

(645)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(646) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(647)
Complex Obligation (OR)

----------------------------------------

(648)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(649)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(650) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(651)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(652) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(653)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(654)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(655) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(656)
Complex Obligation (OR)

----------------------------------------

(657)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(658)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(659) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(660)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(661)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(662) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(663)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(664) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(665)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(666) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(667)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(668) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(669)
YES

----------------------------------------

(670)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(671) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(672)
Complex Obligation (OR)

----------------------------------------

(673)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(674) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(675)
Complex Obligation (OR)

----------------------------------------

(676)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(677)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(678)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(679) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(680)
Complex Obligation (OR)

----------------------------------------

(681)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(682)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(683)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(684) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(685)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(686) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(687)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(688)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(689) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(690)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(691) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(692)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(693) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(694)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(695) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(696)
YES

----------------------------------------

(697)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(698) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(699)
Complex Obligation (OR)

----------------------------------------

(700)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(701) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(702)
Complex Obligation (OR)

----------------------------------------

(703)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(704) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(705)
Complex Obligation (OR)

----------------------------------------

(706)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(707)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(708)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(709) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(710)
Complex Obligation (OR)

----------------------------------------

(711)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(712)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(713)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(714) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(715)
Complex Obligation (OR)

----------------------------------------

(716)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(717)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(718)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(719) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(720)
Complex Obligation (OR)

----------------------------------------

(721)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(722) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(723)
Complex Obligation (OR)

----------------------------------------

(724)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(725)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(726) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(727)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(728)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(729) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(730)
Complex Obligation (OR)

----------------------------------------

(731)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(732)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(733) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(734)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(735)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(736) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(737)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(738) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(739)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(740) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(741)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(742) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(743)
YES

----------------------------------------

(744)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(745) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(746)
Complex Obligation (OR)

----------------------------------------

(747)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(748) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(749)
Complex Obligation (OR)

----------------------------------------

(750)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(751)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(752)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(753) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(754)
Complex Obligation (OR)

----------------------------------------

(755)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(756)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(757)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(758) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(759)
Complex Obligation (OR)

----------------------------------------

(760)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(761)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(762)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(763) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(764)
Complex Obligation (OR)

----------------------------------------

(765)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(766) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(767)
Complex Obligation (OR)

----------------------------------------

(768)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(769)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(770)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(771) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(772)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(773) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(774)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(775)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(776) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(777)
Complex Obligation (OR)

----------------------------------------

(778)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(779)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(780)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(781) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(782)
Complex Obligation (OR)

----------------------------------------

(783)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(784) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(785)
Complex Obligation (OR)

----------------------------------------

(786)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(787) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(788)
Complex Obligation (OR)

----------------------------------------

(789)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(790)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(791) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(792)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(793)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(794) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(795)
Complex Obligation (OR)

----------------------------------------

(796)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(797)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(798)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(799) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(800)
Complex Obligation (OR)

----------------------------------------

(801)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(802) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(803)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(804)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(805)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(806) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(807)
Complex Obligation (OR)

----------------------------------------

(808)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(809) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(810)
Complex Obligation (OR)

----------------------------------------

(811)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(812)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(813) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(814)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(815)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(816) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(817)
Complex Obligation (OR)

----------------------------------------

(818)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(819)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(820) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(821)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(822)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(823) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(824)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(825) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(826)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(827) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(828)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(829) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(830)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(831)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(832) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(833)
Complex Obligation (OR)

----------------------------------------

(834)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(835) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(836)
Complex Obligation (OR)

----------------------------------------

(837)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(838)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(839)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(840) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(841)
Complex Obligation (OR)

----------------------------------------

(842)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(843)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(844) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(845)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(846)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(847) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(848)
Complex Obligation (OR)

----------------------------------------

(849)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(850)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(851) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(852)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(853)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(854) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(855)
Complex Obligation (OR)

----------------------------------------

(856)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(857) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(858)
Complex Obligation (OR)

----------------------------------------

(859)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(860) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(861)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(862)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(863)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(864) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(865)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(866) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(867)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(868) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(869)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(870) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(871)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(872)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(873) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(874)
Complex Obligation (OR)

----------------------------------------

(875)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(876)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(877) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(878)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(879)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(880) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(881)
Complex Obligation (OR)

----------------------------------------

(882)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(883) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(884)
Complex Obligation (OR)

----------------------------------------

(885)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(886) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(887)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(888) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(889)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(890) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(891)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(892) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(893)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(894)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(895) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(896)
Complex Obligation (OR)

----------------------------------------

(897)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(898) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(899)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(900)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(901)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(902) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(903)
Complex Obligation (OR)

----------------------------------------

(904)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(905) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(906)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(907)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(908)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(909) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + 2*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(910)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(911) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(912)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(913) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(914)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(915) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(916)
YES

----------------------------------------

(917)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(918) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(919)
Complex Obligation (OR)

----------------------------------------

(920)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(921) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(922)
Complex Obligation (OR)

----------------------------------------

(923)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(924) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(925)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(926)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(927)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(928) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(c(x_1)) = 2 + 3*x_1

----------------------------------------

(929)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(930) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(931)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(932) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(933)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(934) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(935)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(936)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(937) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(938)
Complex Obligation (OR)

----------------------------------------

(939)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(940)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(941) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(942)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(943)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(944) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(945)
Complex Obligation (OR)

----------------------------------------

(946)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(947) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(948)
Complex Obligation (OR)

----------------------------------------

(949)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(950) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(951)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(952)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(953)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(954) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(955)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(956) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(957)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(958) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(959)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(960) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(961)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(962)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(963) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(964)
Complex Obligation (OR)

----------------------------------------

(965)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(966)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(967) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(968)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(969)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(970) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> A(a(b(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(971)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(972) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(973)
YES

----------------------------------------

(974)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> b(A(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(975) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(976)
Complex Obligation (OR)

----------------------------------------

(977)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(978) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(979)
Complex Obligation (OR)

----------------------------------------

(980)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(981) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(982)
Complex Obligation (OR)

----------------------------------------

(983)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(984) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(985)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(986) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

A(x1)  =  A(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, A_1, a_1]

Status: b_1: multiset status
c_1: multiset status
A_1: multiset status
a_1: multiset status


----------------------------------------

(987)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(988) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + x_1
   POL(B0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(989)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(990)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(991) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(992)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(993) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(994)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(995) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(996)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(997) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(998)
YES

----------------------------------------

(999)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1000) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1001)
Complex Obligation (OR)

----------------------------------------

(1002)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1003) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1004)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1005) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

A(x1)  =  A(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, A_1, a_1]

Status: b_1: multiset status
c_1: multiset status
A_1: multiset status
a_1: multiset status


----------------------------------------

(1006)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1007) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + x_1
   POL(B0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(1008)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1009)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1010) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1011)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1012) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

A(x1)  =  A(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, A_1, a_1]

Status: b_1: multiset status
c_1: multiset status
A_1: multiset status
a_1: multiset status


----------------------------------------

(1013)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1014) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + x_1
   POL(B0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(1015)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1016)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1017) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1018)
Complex Obligation (OR)

----------------------------------------

(1019)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1020) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1021)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1022) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1023)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1024) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1025)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1026) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1027)
YES

----------------------------------------

(1028)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1029) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1030)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1031) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

A(x1)  =  A(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, A_1, a_1]

Status: b_1: multiset status
c_1: multiset status
A_1: multiset status
a_1: multiset status


----------------------------------------

(1032)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1033) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + x_1
   POL(B0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(1034)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1035)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1036) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1037)
Complex Obligation (OR)

----------------------------------------

(1038)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1039) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1040)
Complex Obligation (OR)

----------------------------------------

(1041)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1042) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1043)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1044) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

A(x1)  =  A(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, A_1, a_1]

Status: b_1: multiset status
c_1: multiset status
A_1: multiset status
a_1: multiset status


----------------------------------------

(1045)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1046) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + x_1
   POL(B0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(1047)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1048)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1049) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1050)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1051) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1052)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1053) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(1054)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1055) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1056)
YES

----------------------------------------

(1057)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1058) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1059)
Complex Obligation (OR)

----------------------------------------

(1060)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1061) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1062)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1063) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

A(x1)  =  A(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, A_1, a_1]

Status: b_1: multiset status
c_1: multiset status
A_1: multiset status
a_1: multiset status


----------------------------------------

(1064)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1065) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + x_1
   POL(B0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(1066)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1067)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1068) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1069)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1070) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1071)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1072) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1073)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1074) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1075)
YES

----------------------------------------

(1076)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1077) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1078)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1079) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1080)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1081) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1082)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1083) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1084)
YES

----------------------------------------

(1085)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1086) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1087)
Complex Obligation (OR)

----------------------------------------

(1088)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1089) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1090)
Complex Obligation (OR)

----------------------------------------

(1091)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1092) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1093)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1094) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

A(x1)  =  A(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, A_1, a_1]

Status: b_1: multiset status
c_1: multiset status
A_1: multiset status
a_1: multiset status


----------------------------------------

(1095)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1096) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + x_1
   POL(B0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(1097)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1098)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1099) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1100)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1101) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

A(x1)  =  A(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, A_1, a_1]

Status: b_1: multiset status
c_1: multiset status
A_1: multiset status
a_1: multiset status


----------------------------------------

(1102)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1103) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + x_1
   POL(B0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(1104)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1105)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1106) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1107)
Complex Obligation (OR)

----------------------------------------

(1108)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1109) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1110)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1111) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

A(x1)  =  A(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, A_1, a_1]

Status: b_1: multiset status
c_1: multiset status
A_1: multiset status
a_1: multiset status


----------------------------------------

(1112)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1113) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + x_1
   POL(B0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(1114)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1115)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1116) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1117)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1118) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1119)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1120) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1121)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1122) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(1123)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1124)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1125) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1126)
Complex Obligation (OR)

----------------------------------------

(1127)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1128) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1129)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1130) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

A(x1)  =  A(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, A_1, a_1]

Status: b_1: multiset status
c_1: multiset status
A_1: multiset status
a_1: multiset status


----------------------------------------

(1131)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1132) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + x_1
   POL(B0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(1133)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1134)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1135) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1136)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1137) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1138)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1139) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1140)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1141) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(1142)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1143)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1144) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1145)
Complex Obligation (OR)

----------------------------------------

(1146)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1147) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1148)
Complex Obligation (OR)

----------------------------------------

(1149)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1150) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 1 + 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1151)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1152) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1153)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1154) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1155)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1156) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1157)
YES

----------------------------------------

(1158)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1159) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1160)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1161) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

A(x1)  =  A(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, A_1, a_1]

Status: b_1: multiset status
c_1: multiset status
A_1: multiset status
a_1: multiset status


----------------------------------------

(1162)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1163) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + x_1
   POL(B0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(1164)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1165)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1166) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(B(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1167)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1168) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1169)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1170) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1171)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1172) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1173)
YES

----------------------------------------

(1174)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1175) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1176)
Complex Obligation (OR)

----------------------------------------

(1177)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1178) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1179)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1180) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

b(x1)  =  b(x1)

c(x1)  =  c(x1)

A(x1)  =  A(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [b_1, c_1, A_1, a_1]

Status: b_1: multiset status
c_1: multiset status
A_1: multiset status
a_1: multiset status


----------------------------------------

(1181)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1182) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b0(c0(x1))) -> A0(a0(x1))
   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2 + x_1
   POL(B0(x_1)) = 2*x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(1183)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1184)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1185) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   b(b(c(x1))) -> b(A(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1186)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1187) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1188)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1189) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1190)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1191) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1192)
YES

----------------------------------------

(1193)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1194) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(a(B(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(1195)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1196) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1197)
YES

----------------------------------------

(1198)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1199) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 3

----------------------------------------

(1200)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1201) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(1202)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1203) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b) -> B0(a)

Strictly oriented rules of the TRS R:

   a -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:B0_1 > b > a > c

and weight map:

   a=1
   b=1
   c=1
   B0_1=1

The variable weight is 1

----------------------------------------

(1204)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1205) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1206)
YES

----------------------------------------

(1207)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> a(A(b(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1208) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(c(x1))) -> a(A(b(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(1209)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1210) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1211)
YES

----------------------------------------

(1212)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1213) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 5 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1214)
Complex Obligation (OR)

----------------------------------------

(1215)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1216) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1217)
Complex Obligation (OR)

----------------------------------------

(1218)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1219) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1220)
Complex Obligation (OR)

----------------------------------------

(1221)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1222) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1223)
Complex Obligation (OR)

----------------------------------------

(1224)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1225)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1226) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1227)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1228)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1229) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1230)
Complex Obligation (OR)

----------------------------------------

(1231)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1232)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1233) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1234)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1235)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1236) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1237)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1238) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1239)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1240) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1241)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1242) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1243)
YES

----------------------------------------

(1244)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1245) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1246)
Complex Obligation (OR)

----------------------------------------

(1247)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1248) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1249)
Complex Obligation (OR)

----------------------------------------

(1250)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1251)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1252) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1253)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1254)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1255) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1256)
Complex Obligation (OR)

----------------------------------------

(1257)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1258)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1259) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1260)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1261)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1262) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1263)
Complex Obligation (OR)

----------------------------------------

(1264)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1265) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1266)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1267)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1268)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1269) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1270)
Complex Obligation (OR)

----------------------------------------

(1271)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1272) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1273)
Complex Obligation (OR)

----------------------------------------

(1274)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1275)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1276) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1277)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1278)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1279) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1280)
Complex Obligation (OR)

----------------------------------------

(1281)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1282)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1283)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1284) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1285)
Complex Obligation (OR)

----------------------------------------

(1286)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1287) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1288)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1289)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1290)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1291) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1292)
Complex Obligation (OR)

----------------------------------------

(1293)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1294) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1295)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1296) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1297)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1298) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1299)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1300) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(1301)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1302)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1303) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1304)
Complex Obligation (OR)

----------------------------------------

(1305)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1306) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1307)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1308)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1309) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1310)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1311)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1312) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1313)
Complex Obligation (OR)

----------------------------------------

(1314)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1315) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1316)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1317)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1318) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1319)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1320)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1321) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1322)
Complex Obligation (OR)

----------------------------------------

(1323)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1324) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1325)
Complex Obligation (OR)

----------------------------------------

(1326)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1327) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1328)
Complex Obligation (OR)

----------------------------------------

(1329)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1330)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1331) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1332)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1333)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1334) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1335)
Complex Obligation (OR)

----------------------------------------

(1336)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1337) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1338)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1339)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1340) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1341)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1342)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1343) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1344)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1345) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1346)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1347) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1348)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1349) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(1350)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1351)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1352) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1353)
Complex Obligation (OR)

----------------------------------------

(1354)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1355) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1356)
Complex Obligation (OR)

----------------------------------------

(1357)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1358)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1359) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1360)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1361)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1362) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1363)
Complex Obligation (OR)

----------------------------------------

(1364)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1365)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1366) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1367)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1368) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1369)
Complex Obligation (AND)

----------------------------------------

(1370)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1371)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1372)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1373)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1374) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1375)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1376) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1377)
Complex Obligation (AND)

----------------------------------------

(1378)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1379) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 2

----------------------------------------

(1380)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1381) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1382)
YES

----------------------------------------

(1383)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1384) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(B(x_1)) = 3
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 1

----------------------------------------

(1385)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1386) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1387)
YES

----------------------------------------

(1388)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1389) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 2

----------------------------------------

(1390)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1391) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1392)
YES

----------------------------------------

(1393)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1394) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1395)
Complex Obligation (OR)

----------------------------------------

(1396)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1397) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1398)
Complex Obligation (OR)

----------------------------------------

(1399)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1400)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1401)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1402) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1403)
Complex Obligation (OR)

----------------------------------------

(1404)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1405)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1406)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1407) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1408)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1409) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1410)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1411)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1412) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1413)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1414) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1415)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1416) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1417)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1418) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1419)
YES

----------------------------------------

(1420)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1421) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1422)
Complex Obligation (OR)

----------------------------------------

(1423)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1424) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1425)
Complex Obligation (OR)

----------------------------------------

(1426)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1427) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1428)
Complex Obligation (OR)

----------------------------------------

(1429)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1430) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1431)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1432)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1433) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1434)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1435)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1436) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1437)
Complex Obligation (OR)

----------------------------------------

(1438)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1439) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1440)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1441)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1442) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1443)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1444)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1445) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1446)
Complex Obligation (OR)

----------------------------------------

(1447)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1448) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1449)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1450)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1451)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1452) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1453)
Complex Obligation (OR)

----------------------------------------

(1454)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1455) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1456)
Complex Obligation (OR)

----------------------------------------

(1457)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1458) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1459)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1460)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1461) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1462)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1463)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1464) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1465)
Complex Obligation (OR)

----------------------------------------

(1466)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1467) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1468)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1469)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1470) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1471)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1472) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1473)
Complex Obligation (AND)

----------------------------------------

(1474)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1475)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1476)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1477)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1478) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1479)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1480) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1481)
Complex Obligation (AND)

----------------------------------------

(1482)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1483) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 2

----------------------------------------

(1484)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1485) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1486)
YES

----------------------------------------

(1487)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1488) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(B(x_1)) = 3
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 1

----------------------------------------

(1489)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1490) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1491)
YES

----------------------------------------

(1492)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1493) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 2

----------------------------------------

(1494)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1495) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1496)
YES

----------------------------------------

(1497)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1498) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1499)
Complex Obligation (OR)

----------------------------------------

(1500)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1501) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1502)
Complex Obligation (OR)

----------------------------------------

(1503)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1504) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1505)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1506)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1507)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1508) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1509)
Complex Obligation (OR)

----------------------------------------

(1510)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1511)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1512) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1513)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1514) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1515)
Complex Obligation (AND)

----------------------------------------

(1516)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1517)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1518)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1519)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1520) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1521)
Complex Obligation (OR)

----------------------------------------

(1522)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1523)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1524) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1525)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1526) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1527)
Complex Obligation (AND)

----------------------------------------

(1528)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1529)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1530)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1531)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1532) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1533)
Complex Obligation (OR)

----------------------------------------

(1534)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1535) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1536)
Complex Obligation (OR)

----------------------------------------

(1537)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1538) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1539)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1540) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1541)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1542)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1543) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1544)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1545)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1546) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1547)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1548) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1549)
Complex Obligation (AND)

----------------------------------------

(1550)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1551) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 2

----------------------------------------

(1552)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1553) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1554)
YES

----------------------------------------

(1555)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1556) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(B(x_1)) = 3
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 1

----------------------------------------

(1557)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1558) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1559)
YES

----------------------------------------

(1560)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1561) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 2

----------------------------------------

(1562)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1563) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1564)
YES

----------------------------------------

(1565)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1566) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1567)
Complex Obligation (OR)

----------------------------------------

(1568)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1569) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1570)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1571)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1572) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1573)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1574) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1575)
Complex Obligation (AND)

----------------------------------------

(1576)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1577)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1578)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1579)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1580) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1581)
Complex Obligation (OR)

----------------------------------------

(1582)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1583) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1584)
Complex Obligation (OR)

----------------------------------------

(1585)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1586) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1587)
Complex Obligation (OR)

----------------------------------------

(1588)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1589)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1590)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1591) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1592)
Complex Obligation (OR)

----------------------------------------

(1593)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1594)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1595)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1596) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1597)
Complex Obligation (OR)

----------------------------------------

(1598)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1599)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1600)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1601) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1602)
Complex Obligation (OR)

----------------------------------------

(1603)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1604) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1605)
Complex Obligation (OR)

----------------------------------------

(1606)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1607)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1608) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1609)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1610)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1611) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1612)
Complex Obligation (OR)

----------------------------------------

(1613)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1614)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1615) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1616)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1617) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1618)
Complex Obligation (AND)

----------------------------------------

(1619)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1620)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1621)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1622)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1623) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1624)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1625) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1626)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1627) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(1628)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1629) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1630)
YES

----------------------------------------

(1631)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1632) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1633)
Complex Obligation (OR)

----------------------------------------

(1634)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1635) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1636)
Complex Obligation (OR)

----------------------------------------

(1637)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1638)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1639)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1640) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1641)
Complex Obligation (OR)

----------------------------------------

(1642)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1643)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1644) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1645)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1646) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1647)
Complex Obligation (AND)

----------------------------------------

(1648)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1649)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1650)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1651)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1652) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1653)
Complex Obligation (OR)

----------------------------------------

(1654)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1655)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1656) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1657)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1658) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1659)
Complex Obligation (AND)

----------------------------------------

(1660)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1661)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1662)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1663)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1664) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1665)
Complex Obligation (OR)

----------------------------------------

(1666)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1667) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1668)
Complex Obligation (OR)

----------------------------------------

(1669)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1670)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1671)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1672) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1673)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1674) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1675)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1676)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1677) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1678)
Complex Obligation (OR)

----------------------------------------

(1679)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1680)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1681)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1682) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1683)
Complex Obligation (OR)

----------------------------------------

(1684)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1685) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1686)
Complex Obligation (OR)

----------------------------------------

(1687)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1688) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1689)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1690) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1691)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1692) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1693)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1694) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(1695)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1696)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1697) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1698)
Complex Obligation (OR)

----------------------------------------

(1699)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1700) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1701)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1702)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1703)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1704) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1705)
Complex Obligation (OR)

----------------------------------------

(1706)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1707) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1708)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1709)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1710)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1711) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1712)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1713) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1714)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1715) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1716)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1717) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1718)
YES

----------------------------------------

(1719)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1720) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1721)
Complex Obligation (OR)

----------------------------------------

(1722)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1723) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1724)
Complex Obligation (OR)

----------------------------------------

(1725)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1726) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(1727)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1728)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1729)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1730) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1731)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1732) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1733)
Complex Obligation (AND)

----------------------------------------

(1734)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1735) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 2

----------------------------------------

(1736)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1737) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1738)
YES

----------------------------------------

(1739)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1740) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(B(x_1)) = 3
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 1

----------------------------------------

(1741)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1742) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1743)
YES

----------------------------------------

(1744)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1745) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 2

----------------------------------------

(1746)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1747) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(1748)
YES

----------------------------------------

(1749)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1750) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1751)
Complex Obligation (OR)

----------------------------------------

(1752)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1753)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1754) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = 2 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1755)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1756) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(1757)
Complex Obligation (AND)

----------------------------------------

(1758)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1759)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1760)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1761)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1762) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1763)
Complex Obligation (OR)

----------------------------------------

(1764)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1765) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1766)
Complex Obligation (OR)

----------------------------------------

(1767)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1768)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1769)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1770) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1771)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1772) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1773)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1774)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1775) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1776)
Complex Obligation (OR)

----------------------------------------

(1777)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1778)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(c(c(x1))) -> c(c(B(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1779)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1780) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 0
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(1781)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> B(a(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1782) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 0
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

b(x1)  =  b

c(x1)  =  c

a(x1)  =  a


Recursive path order with status [RPO].
Quasi-Precedence: b > [B_1, a] > c

Status: B_1: multiset status
b: multiset status
c: multiset status
a: []


----------------------------------------

(1783)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(b) -> B0(a)

The TRS R consists of the following rules:

   a -> a
   b -> b
   a -> c

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1784) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(b) -> B0(a)

Strictly oriented rules of the TRS R:

   a -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:B0_1 > b > a > c

and weight map:

   a=1
   b=1
   c=1
   B0_1=1

The variable weight is 1

----------------------------------------

(1785)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a -> a
   b -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1786) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1787)
YES

----------------------------------------

(1788)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1789) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 4 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1790)
Complex Obligation (OR)

----------------------------------------

(1791)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1792) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1793)
Complex Obligation (OR)

----------------------------------------

(1794)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1795) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1796)
Complex Obligation (OR)

----------------------------------------

(1797)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1798) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1799)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1800) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

c(x1)  =  c(x1)

b(x1)  =  b(x1)

B(x1)  =  B(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, c_1, b_1, B_1]

Status: a_1: multiset status
c_1: multiset status
b_1: multiset status
B_1: multiset status


----------------------------------------

(1801)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))
   B0(b0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1802) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))
   B0(b0(c0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1803)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1804)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1805) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(B(x_1)) = 3 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1806)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1807) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1808)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1809) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(1810)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1811) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1812)
YES

----------------------------------------

(1813)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1814) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1815)
Complex Obligation (OR)

----------------------------------------

(1816)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1817) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1818)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1819) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

c(x1)  =  c(x1)

b(x1)  =  b(x1)

B(x1)  =  B(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, c_1, b_1, B_1]

Status: a_1: multiset status
c_1: multiset status
b_1: multiset status
B_1: multiset status


----------------------------------------

(1820)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))
   B0(b0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1821) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))
   B0(b0(c0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1822)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1823)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1824) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1825)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1826) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

c(x1)  =  c(x1)

b(x1)  =  b(x1)

B(x1)  =  B(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, c_1, b_1, B_1]

Status: a_1: multiset status
c_1: multiset status
b_1: multiset status
B_1: multiset status


----------------------------------------

(1827)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))
   B0(b0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1828) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))
   B0(b0(c0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1829)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1830)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1831) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1832)
Complex Obligation (OR)

----------------------------------------

(1833)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1834) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(B(x_1)) = 3 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1835)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1836) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1837)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1838) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(1839)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1840) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1841)
YES

----------------------------------------

(1842)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1843) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1844)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1845) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

c(x1)  =  c(x1)

b(x1)  =  b(x1)

B(x1)  =  B(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, c_1, b_1, B_1]

Status: a_1: multiset status
c_1: multiset status
b_1: multiset status
B_1: multiset status


----------------------------------------

(1846)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))
   B0(b0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1847) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))
   B0(b0(c0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1848)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1849)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1850) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1851)
Complex Obligation (OR)

----------------------------------------

(1852)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1853) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1854)
Complex Obligation (OR)

----------------------------------------

(1855)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1856) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1857)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1858)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1859) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(B(x_1)) = 3 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1860)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1861) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1862)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1863)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1864) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1865)
Complex Obligation (OR)

----------------------------------------

(1866)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1867) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1868)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1869)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1870) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1871)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1872) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1873)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1874)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1875) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1876)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1877) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1878)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1879) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1880)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1881) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1882)
YES

----------------------------------------

(1883)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1884) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1885)
Complex Obligation (OR)

----------------------------------------

(1886)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1887) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1888)
Complex Obligation (OR)

----------------------------------------

(1889)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1890) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1891)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1892)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1893) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1894)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1895)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1896) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1897)
Complex Obligation (OR)

----------------------------------------

(1898)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(a(a(x1))) -> A(B(a(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1899) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1900)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1901) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

c(x1)  =  c(x1)

b(x1)  =  b(x1)

B(x1)  =  B(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, c_1, b_1, B_1]

Status: a_1: multiset status
c_1: multiset status
b_1: multiset status
B_1: multiset status


----------------------------------------

(1902)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))
   B0(b0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1903)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1904) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1905)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1906) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1907)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1908)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1909) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1910)
Complex Obligation (OR)

----------------------------------------

(1911)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1912) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1913)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1914) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

c(x1)  =  c(x1)

b(x1)  =  b(x1)

B(x1)  =  B(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, c_1, b_1, B_1]

Status: a_1: multiset status
c_1: multiset status
b_1: multiset status
B_1: multiset status


----------------------------------------

(1915)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))
   B0(b0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1916)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1917) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1918)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1919) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1920)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1921)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1922) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 3 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1923)
Complex Obligation (OR)

----------------------------------------

(1924)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1925) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1926)
Complex Obligation (OR)

----------------------------------------

(1927)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1928) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1
   POL(B(x_1)) = 3 + x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1929)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1930) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1931)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1932) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Knuth-Bendix order [KBO] with precedence:a0_1 > A0_1 > c > b

and weight map:

   b=1
   c=2
   a0_1=0
   A0_1=1

The variable weight is 1

----------------------------------------

(1933)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1934) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(1935)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1936)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1937) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1938)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1939) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

c(x1)  =  c(x1)

b(x1)  =  b(x1)

B(x1)  =  B(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, c_1, b_1, B_1]

Status: a_1: multiset status
c_1: multiset status
b_1: multiset status
B_1: multiset status


----------------------------------------

(1940)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(a0(a0(x1))) -> A0(b0(a0(x1)))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))
   B0(b0(c0(x1))) -> A0(x1)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1941) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(x1)
   A0(c0(b0(x1))) -> A0(b0(x1))
   A0(c0(b0(x1))) -> B0(x1)
   A0(a0(a0(x1))) -> B0(a0(x1))
   B0(b0(c0(x1))) -> A0(x1)


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = 2*x_1
   POL(B0(x_1)) = 2 + 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 1 + 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(1942)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b0(a0(x1)))

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b0(a0(x1)))
   b0(b0(c0(x1))) -> b0(a0(a0(x1)))
   a0(c0(c0(x1))) -> a0(a0(b0(x1)))
   a0(c0(b0(x1))) -> c0(a0(b0(x1)))
   a0(c0(c0(x1))) -> c0(c0(b0(x1)))
   a0(b0(a0(x1))) -> a0(b0(c0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1943)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1944) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(B(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(b(x1))) -> c(A(B(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 3*x_1
   POL(a(x_1)) = 1 + 3*x_1
   POL(b(x_1)) = 1 + 3*x_1
   POL(c(x_1)) = 1 + 3*x_1

----------------------------------------

(1945)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1946) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1947)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1948) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(a0(a0(x1))) -> A0(b)

Strictly oriented rules of the TRS R:

   a0(a0(a0(x1))) -> a0(b)
   a0(c) -> a0(a0(b))
   a0(c) -> c

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b) = 0
   POL(c) = 2


----------------------------------------

(1949)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   b -> b
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(1950) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(1951)
YES

----------------------------------------

(1952)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1953) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1954)
Complex Obligation (OR)

----------------------------------------

(1955)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(a(a(x1))) -> A(b(A(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1956) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(1957)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1958)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> A(b(a(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1959) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> c(a(B(x1)))
   a(a(a(x1))) -> a(B(a(x1)))
   a(c(b(x1))) -> c(A(b(x1)))
   a(a(a(x1))) -> a(b(A(x1)))
   b(b(c(x1))) -> b(a(A(x1)))

Relative ADPs:

   a(a(a(x1))) -> a(B(A(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(1960)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(b(a(x1)))

and relative ADPs:

   a(a(a(x1))) -> a(b(a(x1)))
   b(b(c(x1))) -> b(a(a(x1)))
   a(c(c(x1))) -> a(a(b(x1)))
   a(c(b(x1))) -> c(a(b(x1)))
   a(c(c(x1))) -> c(c(b(x1)))
   a(b(a(x1))) -> a(b(c(x1)))


----------------------------------------

(1961) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: c > [a_1, b]

Status: a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(1962)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(b)

The TRS R consists of the following rules:

   a0(a0(a0(x1))) -> a0(b)
   b -> b
   a0(c) -> a0(a0(b))
   a0(c) -> c
   a0(b) -> a0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.