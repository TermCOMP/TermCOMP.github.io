YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/eeao2.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPRuleRemovalProof [EQUIVALENT, 0 ms]
(4) RelADPP
(5) RelADPDepGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) RelADPP
        (8) RelADPCleverAfsProof [SOUND, 9 ms]
        (9) QDP
        (10) MRRProof [EQUIVALENT, 6 ms]
        (11) QDP
        (12) MRRProof [EQUIVALENT, 0 ms]
        (13) QDP
        (14) PisEmptyProof [EQUIVALENT, 0 ms]
        (15) YES
    (16) RelADPP
        (17) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (18) RelADPP
        (19) RelADPReductionPairProof [EQUIVALENT, 4 ms]
        (20) RelADPP
        (21) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (22) OR
            (23) RelADPP
                (24) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (25) AND
                    (26) RelADPP
                        (27) RelADPCleverAfsProof [SOUND, 3 ms]
                        (28) QDP
                        (29) MRRProof [EQUIVALENT, 1 ms]
                        (30) QDP
                        (31) PisEmptyProof [EQUIVALENT, 0 ms]
                        (32) YES
                    (33) RelADPP
                        (34) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (35) RelADPP
                        (36) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (37) RelADPP
                        (38) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (39) QDP
                        (40) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (41) YES
                    (42) RelADPP
                        (43) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (44) RelADPP
                        (45) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (46) RelADPP
                        (47) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (48) QDP
                        (49) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (50) YES
                    (51) RelADPP
                        (52) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                        (53) RelADPP
                        (54) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (55) YES
                    (56) RelADPP
                        (57) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (58) RelADPP
                        (59) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (60) AND
                            (61) RelADPP
                                (62) RelADPCleverAfsProof [SOUND, 0 ms]
                                (63) QDP
                                (64) MRRProof [EQUIVALENT, 2 ms]
                                (65) QDP
                                (66) PisEmptyProof [EQUIVALENT, 0 ms]
                                (67) YES
                            (68) RelADPP
                                (69) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                                (70) QDP
                                (71) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                                (72) YES
            (73) RelADPP
                (74) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (75) AND
                    (76) RelADPP
                        (77) RelADPCleverAfsProof [SOUND, 1 ms]
                        (78) QDP
                        (79) MRRProof [EQUIVALENT, 0 ms]
                        (80) QDP
                        (81) PisEmptyProof [EQUIVALENT, 0 ms]
                        (82) YES
                    (83) RelADPP
                        (84) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (85) RelADPP
                        (86) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (87) RelADPP
                        (88) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (89) QDP
                        (90) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (91) YES
                    (92) RelADPP
                        (93) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (94) RelADPP
                        (95) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (96) RelADPP
                        (97) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (98) QDP
                        (99) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (100) YES
                    (101) RelADPP
                        (102) RelADPReductionPairProof [EQUIVALENT, 2 ms]
                        (103) RelADPP
                        (104) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (105) YES
    (106) RelADPP
        (107) RelADPRuleRemovalProof [EQUIVALENT, 0 ms]
        (108) RelADPP
        (109) RelADPReductionPairProof [EQUIVALENT, 3 ms]
        (110) RelADPP
        (111) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (112) OR
            (113) RelADPP
                (114) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (115) AND
                    (116) RelADPP
                        (117) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (118) RelADPP
                        (119) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (120) RelADPP
                        (121) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (122) QDP
                        (123) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (124) YES
                    (125) RelADPP
                        (126) RelADPReductionPairProof [EQUIVALENT, 1 ms]
                        (127) RelADPP
                        (128) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (129) YES
                    (130) RelADPP
                        (131) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (132) RelADPP
                        (133) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (134) RelADPP
                        (135) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (136) QDP
                        (137) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (138) YES
                    (139) RelADPP
                        (140) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (141) RelADPP
                        (142) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (143) RelADPP
                        (144) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (145) QDP
                        (146) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (147) YES
            (148) RelADPP
                (149) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (150) AND
                    (151) RelADPP
                        (152) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (153) RelADPP
                        (154) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (155) RelADPP
                        (156) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (157) QDP
                        (158) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (159) YES
                    (160) RelADPP
                        (161) RelADPReductionPairProof [EQUIVALENT, 1 ms]
                        (162) RelADPP
                        (163) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (164) YES
                    (165) RelADPP
                        (166) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (167) RelADPP
                        (168) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (169) RelADPP
                        (170) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (171) QDP
                        (172) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (173) YES
    (174) RelADPP
        (175) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (176) RelADPP
        (177) RelADPReductionPairProof [EQUIVALENT, 0 ms]
        (178) RelADPP
        (179) RelADPDerelatifying2Proof [SOUND, 0 ms]
        (180) OR
            (181) RelADPP
                (182) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (183) AND
                    (184) RelADPP
                        (185) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (186) RelADPP
                        (187) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (188) RelADPP
                        (189) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (190) QDP
                        (191) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (192) YES
                    (193) RelADPP
                        (194) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (195) RelADPP
                        (196) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (197) RelADPP
                        (198) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (199) QDP
                    (200) RelADPP
                        (201) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (202) RelADPP
                        (203) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (204) RelADPP
                        (205) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (206) QDP
                    (207) RelADPP
                        (208) RelADPReductionPairProof [EQUIVALENT, 3 ms]
                        (209) RelADPP
                        (210) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (211) YES
            (212) RelADPP
                (213) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                (214) AND
                    (215) RelADPP
                        (216) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (217) RelADPP
                        (218) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (219) RelADPP
                        (220) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (221) QDP
                        (222) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (223) YES
                    (224) RelADPP
                        (225) RelADPReductionPairProof [EQUIVALENT, 4 ms]
                        (226) RelADPP
                        (227) DAbsisEmptyProof [EQUIVALENT, 0 ms]
                        (228) YES
                    (229) RelADPP
                        (230) RelADPDerelatifying2Proof [SOUND, 0 ms]
                        (231) RelADPP
                        (232) RelADPDepGraphProof [EQUIVALENT, 0 ms]
                        (233) RelADPP
                        (234) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
                        (235) QDP
                        (236) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
                        (237) YES


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   a(c(a(x1))) -> c(a(c(x1)))
   c(b(a(x1))) -> b(c(b(x1)))

The relative TRS consists of the following S rules:

   c(c(c(x1))) -> a(b(c(x1)))
   b(a(a(x1))) -> b(c(b(x1)))
   a(a(b(x1))) -> c(b(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> C(a(c(x1)))
   a(c(a(x1))) -> c(A(c(x1)))
   a(c(a(x1))) -> c(a(C(x1)))
   c(b(a(x1))) -> B(c(b(x1)))
   c(b(a(x1))) -> b(C(b(x1)))
   c(b(a(x1))) -> b(c(B(x1)))

and relative ADPs:

   c(c(c(x1))) -> A(B(c(x1)))
   c(c(c(x1))) -> A(b(C(x1)))
   c(c(c(x1))) -> a(B(C(x1)))
   b(a(a(x1))) -> B(C(b(x1)))
   b(a(a(x1))) -> B(c(B(x1)))
   b(a(a(x1))) -> b(C(B(x1)))
   a(a(b(x1))) -> C(B(a(x1)))
   a(a(b(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> c(B(A(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))
   b(c(c(x1))) -> b(C(A(x1)))


----------------------------------------

(3) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   c(b(a(x1))) -> b(C(b(x1)))
   c(b(a(x1))) -> B(c(b(x1)))
   c(b(a(x1))) -> b(c(B(x1)))

   c(c(c(x1))) -> A(b(C(x1)))
   b(a(a(x1))) -> b(C(B(x1)))
   b(a(a(x1))) -> B(c(B(x1)))
   c(c(c(x1))) -> A(B(c(x1)))
   c(c(c(x1))) -> a(B(C(x1)))
   b(a(a(x1))) -> B(C(b(x1)))

c:

   a(c(a(x1))) -> c(A(c(x1)))
   a(c(a(x1))) -> C(a(c(x1)))
   a(c(a(x1))) -> c(a(C(x1)))

   a(a(b(x1))) -> C(b(A(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(C(A(x1)))
   a(a(b(x1))) -> C(B(a(x1)))
   a(a(b(x1))) -> c(B(A(x1)))
   b(c(c(x1))) -> B(c(A(x1)))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(4)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(A(c(x1)))
   a(c(a(x1))) -> C(a(c(x1)))
   a(c(a(x1))) -> c(a(C(x1)))

and relative ADPs:

   a(a(b(x1))) -> C(b(A(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(C(A(x1)))
   a(a(b(x1))) -> C(B(a(x1)))
   a(a(b(x1))) -> c(B(A(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(5) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   a(a(b(x1))) -> c(b(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(8) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> c0(a0(c0(x1)))
   a0(a0(b0(x1))) -> c0(b0(a0(x1)))
   b0(c0(c0(x1))) -> b0(c0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(10) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   a0(a0(b0(x1))) -> c0(b0(a0(x1)))

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 2*x_1
   POL(b0(x_1)) = 2 + 2*x_1
   POL(c0(x_1)) = 2*x_1


----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> c0(a0(c0(x1)))
   b0(c0(c0(x1))) -> b0(c0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(12) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(13)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> c0(a0(c0(x1)))
   b0(c0(c0(x1))) -> b0(c0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(14) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(15)
YES

----------------------------------------

(16)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   a(a(b(x1))) -> C(b(A(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(C(A(x1)))
   a(a(b(x1))) -> C(B(a(x1)))
   a(a(b(x1))) -> c(B(A(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(17) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   a(a(b(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(B(a(x1)))
   a(a(b(x1))) -> c(B(A(x1)))

c:

   a(c(a(x1))) -> c(A(c(x1)))

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(C(A(x1)))
   b(c(c(x1))) -> B(c(A(x1)))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 2*x_1

----------------------------------------

(18)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(C(A(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(19) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(C(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(a(x1))) -> c(A(c(x1)))

Relative ADPs:

   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 2 + 2*x_1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 0
   POL(c(x_1)) = 3

----------------------------------------

(20)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(21) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(22)
Complex Obligation (OR)

----------------------------------------

(23)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> c(A(c(x1)))
   b(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(24) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 5 subproblems.

----------------------------------------

(25)
Complex Obligation (AND)

----------------------------------------

(26)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(27) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> c0(a0(c0(x1)))
   b0(c0(c0(x1))) -> b0(c0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(29) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(30)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> c0(a0(c0(x1)))
   b0(c0(c0(x1))) -> b0(c0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(31) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(32)
YES

----------------------------------------

(33)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(34) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(35)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(36) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(37)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(38) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(39)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(40) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
997, 998, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094

Node 997 is start node and node 998 is final node.

Those nodes are connected through the following edges:

* 997 to 1083 labelled c_1(0)* 997 to 1085 labelled b_1(0), B_1(0)* 997 to 1089 labelled b_1(1), B_1(1)* 997 to 1093 labelled b_1(2), B_1(2)* 998 to 998 labelled #_1(0)* 1083 to 1084 labelled a_1(0)* 1083 to 1087 labelled c_1(1)* 1084 to 998 labelled c_1(0)* 1085 to 1086 labelled c_1(0)* 1086 to 998 labelled a_1(0)* 1086 to 1087 labelled c_1(1)* 1087 to 1088 labelled a_1(1)* 1087 to 1087 labelled c_1(1)* 1088 to 998 labelled c_1(1)* 1089 to 1090 labelled c_1(1)* 1090 to 1087 labelled a_1(1)* 1090 to 1091 labelled c_1(2)* 1091 to 1092 labelled a_1(2)* 1092 to 1088 labelled c_1(2)* 1093 to 1094 labelled c_1(2)* 1094 to 1091 labelled a_1(2)


----------------------------------------

(41)
YES

----------------------------------------

(42)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(43) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(44)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(45) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(46)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(47) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(48)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(49) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148

Node 1135 is start node and node 1136 is final node.

Those nodes are connected through the following edges:

* 1135 to 1137 labelled c_1(0)* 1135 to 1139 labelled b_1(0), B_1(0)* 1135 to 1143 labelled b_1(1), B_1(1)* 1135 to 1147 labelled b_1(2), B_1(2)* 1136 to 1136 labelled #_1(0)* 1137 to 1138 labelled a_1(0)* 1137 to 1141 labelled c_1(1)* 1138 to 1136 labelled c_1(0)* 1139 to 1140 labelled c_1(0)* 1140 to 1136 labelled a_1(0)* 1140 to 1141 labelled c_1(1)* 1141 to 1142 labelled a_1(1)* 1141 to 1141 labelled c_1(1)* 1142 to 1136 labelled c_1(1)* 1143 to 1144 labelled c_1(1)* 1144 to 1141 labelled a_1(1)* 1144 to 1145 labelled c_1(2)* 1145 to 1146 labelled a_1(2)* 1146 to 1142 labelled c_1(2)* 1147 to 1148 labelled c_1(2)* 1148 to 1145 labelled a_1(2)


----------------------------------------

(50)
YES

----------------------------------------

(51)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(52) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(53)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(54) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(55)
YES

----------------------------------------

(56)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(57) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(58)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> c(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(59) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 2 subproblems.

----------------------------------------

(60)
Complex Obligation (AND)

----------------------------------------

(61)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(62) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(63)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> c0(a0(c0(x1)))
   b0(c0(c0(x1))) -> b0(c0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(64) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(65)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> c0(a0(c0(x1)))
   b0(c0(c0(x1))) -> b0(c0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(66) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(67)
YES

----------------------------------------

(68)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(69) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(71) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
987, 988, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106

Node 987 is start node and node 988 is final node.

Those nodes are connected through the following edges:

* 987 to 1095 labelled c_1(0)* 987 to 1097 labelled b_1(0), B_1(0)* 987 to 1101 labelled b_1(1), B_1(1)* 987 to 1105 labelled b_1(2), B_1(2)* 988 to 988 labelled #_1(0)* 1095 to 1096 labelled a_1(0)* 1095 to 1099 labelled c_1(1)* 1096 to 988 labelled c_1(0)* 1097 to 1098 labelled c_1(0)* 1098 to 988 labelled a_1(0)* 1098 to 1099 labelled c_1(1)* 1099 to 1100 labelled a_1(1)* 1099 to 1099 labelled c_1(1)* 1100 to 988 labelled c_1(1)* 1101 to 1102 labelled c_1(1)* 1102 to 1099 labelled a_1(1)* 1102 to 1103 labelled c_1(2)* 1103 to 1104 labelled a_1(2)* 1104 to 1100 labelled c_1(2)* 1105 to 1106 labelled c_1(2)* 1106 to 1103 labelled a_1(2)


----------------------------------------

(72)
YES

----------------------------------------

(73)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> c(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(74) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(75)
Complex Obligation (AND)

----------------------------------------

(76)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(A(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(77) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  x1

c(x1)  =  c(x1)

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: [c_1, a_1]

Status: c_1: [1]
a_1: multiset status


----------------------------------------

(78)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(a0(x1))) -> A0(c0(x1))

The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> c0(a0(c0(x1)))
   b0(c0(c0(x1))) -> b0(c0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(79) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(a0(x1))) -> A0(c0(x1))


Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(80)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   a0(c0(a0(x1))) -> c0(a0(c0(x1)))
   b0(c0(c0(x1))) -> b0(c0(a0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(81) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(82)
YES

----------------------------------------

(83)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(84) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(85)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(86) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(87)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(88) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(89)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(90) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134

Node 1121 is start node and node 1122 is final node.

Those nodes are connected through the following edges:

* 1121 to 1123 labelled c_1(0)* 1121 to 1125 labelled b_1(0), B_1(0)* 1121 to 1129 labelled b_1(1), B_1(1)* 1121 to 1133 labelled b_1(2), B_1(2)* 1122 to 1122 labelled #_1(0)* 1123 to 1124 labelled a_1(0)* 1123 to 1127 labelled c_1(1)* 1124 to 1122 labelled c_1(0)* 1125 to 1126 labelled c_1(0)* 1126 to 1122 labelled a_1(0)* 1126 to 1127 labelled c_1(1)* 1127 to 1128 labelled a_1(1)* 1127 to 1127 labelled c_1(1)* 1128 to 1122 labelled c_1(1)* 1129 to 1130 labelled c_1(1)* 1130 to 1127 labelled a_1(1)* 1130 to 1131 labelled c_1(2)* 1131 to 1132 labelled a_1(2)* 1132 to 1128 labelled c_1(2)* 1133 to 1134 labelled c_1(2)* 1134 to 1131 labelled a_1(2)


----------------------------------------

(91)
YES

----------------------------------------

(92)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(93) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(94)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(95) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(96)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(97) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(98)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(99) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
991, 992, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048

Node 991 is start node and node 992 is final node.

Those nodes are connected through the following edges:

* 991 to 1037 labelled c_1(0)* 991 to 1039 labelled b_1(0), B_1(0)* 991 to 1043 labelled b_1(1), B_1(1)* 991 to 1047 labelled b_1(2), B_1(2)* 992 to 992 labelled #_1(0)* 1037 to 1038 labelled a_1(0)* 1037 to 1041 labelled c_1(1)* 1038 to 992 labelled c_1(0)* 1039 to 1040 labelled c_1(0)* 1040 to 992 labelled a_1(0)* 1040 to 1041 labelled c_1(1)* 1041 to 1042 labelled a_1(1)* 1041 to 1041 labelled c_1(1)* 1042 to 992 labelled c_1(1)* 1043 to 1044 labelled c_1(1)* 1044 to 1041 labelled a_1(1)* 1044 to 1045 labelled c_1(2)* 1045 to 1046 labelled a_1(2)* 1046 to 1042 labelled c_1(2)* 1047 to 1048 labelled c_1(2)* 1048 to 1045 labelled a_1(2)


----------------------------------------

(100)
YES

----------------------------------------

(101)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> b(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(102) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(c(c(x1))) -> b(c(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(103)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(104) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(105)
YES

----------------------------------------

(106)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   a(a(b(x1))) -> C(b(A(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(C(A(x1)))
   a(a(b(x1))) -> C(B(a(x1)))
   a(a(b(x1))) -> c(B(A(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(107) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   a(a(b(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(B(a(x1)))
   a(a(b(x1))) -> c(B(A(x1)))

c:

   a(c(a(x1))) -> C(a(c(x1)))

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(C(A(x1)))
   b(c(c(x1))) -> B(c(A(x1)))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 2*x_1

----------------------------------------

(108)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(C(A(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(109) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(C(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(a(x1))) -> C(a(c(x1)))

Relative ADPs:

   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(110)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(111) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(112)
Complex Obligation (OR)

----------------------------------------

(113)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   a(c(a(x1))) -> C(a(c(x1)))
   b(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(114) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(115)
Complex Obligation (AND)

----------------------------------------

(116)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(117) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(118)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(119) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(120)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(121) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(122)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(123) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
981, 983, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1119, 1120

Node 981 is start node and node 983 is final node.

Those nodes are connected through the following edges:

* 981 to 1049 labelled c_1(0)* 981 to 1051 labelled b_1(0), B_1(0)* 981 to 1055 labelled b_1(1), B_1(1)* 981 to 1119 labelled b_1(2), B_1(2)* 983 to 983 labelled #_1(0)* 1049 to 1050 labelled a_1(0)* 1049 to 1053 labelled c_1(1)* 1050 to 983 labelled c_1(0)* 1051 to 1052 labelled c_1(0)* 1052 to 983 labelled a_1(0)* 1052 to 1053 labelled c_1(1)* 1053 to 1054 labelled a_1(1)* 1053 to 1053 labelled c_1(1)* 1054 to 983 labelled c_1(1)* 1055 to 1056 labelled c_1(1)* 1056 to 1053 labelled a_1(1)* 1056 to 1057 labelled c_1(2)* 1057 to 1058 labelled a_1(2)* 1058 to 1054 labelled c_1(2)* 1119 to 1120 labelled c_1(2)* 1120 to 1057 labelled a_1(2)


----------------------------------------

(124)
YES

----------------------------------------

(125)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(126) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(127)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(128) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(129)
YES

----------------------------------------

(130)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(131) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(132)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(133) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(134)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(135) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(136)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(137) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
985, 986, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082

Node 985 is start node and node 986 is final node.

Those nodes are connected through the following edges:

* 985 to 1071 labelled c_1(0)* 985 to 1073 labelled b_1(0), B_1(0)* 985 to 1077 labelled b_1(1), B_1(1)* 985 to 1081 labelled b_1(2), B_1(2)* 986 to 986 labelled #_1(0)* 1071 to 1072 labelled a_1(0)* 1071 to 1075 labelled c_1(1)* 1072 to 986 labelled c_1(0)* 1073 to 1074 labelled c_1(0)* 1074 to 986 labelled a_1(0)* 1074 to 1075 labelled c_1(1)* 1075 to 1076 labelled a_1(1)* 1075 to 1075 labelled c_1(1)* 1076 to 986 labelled c_1(1)* 1077 to 1078 labelled c_1(1)* 1078 to 1075 labelled a_1(1)* 1078 to 1079 labelled c_1(2)* 1079 to 1080 labelled a_1(2)* 1080 to 1076 labelled c_1(2)* 1081 to 1082 labelled c_1(2)* 1082 to 1079 labelled a_1(2)


----------------------------------------

(138)
YES

----------------------------------------

(139)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(140) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(141)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(142) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(143)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(144) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(145)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(146) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
989, 990, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036

Node 989 is start node and node 990 is final node.

Those nodes are connected through the following edges:

* 989 to 1025 labelled c_1(0)* 989 to 1027 labelled b_1(0), B_1(0)* 989 to 1031 labelled b_1(1), B_1(1)* 989 to 1035 labelled b_1(2), B_1(2)* 990 to 990 labelled #_1(0)* 1025 to 1026 labelled a_1(0)* 1025 to 1029 labelled c_1(1)* 1026 to 990 labelled c_1(0)* 1027 to 1028 labelled c_1(0)* 1028 to 990 labelled a_1(0)* 1028 to 1029 labelled c_1(1)* 1029 to 1030 labelled a_1(1)* 1029 to 1029 labelled c_1(1)* 1030 to 990 labelled c_1(1)* 1031 to 1032 labelled c_1(1)* 1032 to 1029 labelled a_1(1)* 1032 to 1033 labelled c_1(2)* 1033 to 1034 labelled a_1(2)* 1034 to 1030 labelled c_1(2)* 1035 to 1036 labelled c_1(2)* 1036 to 1033 labelled a_1(2)


----------------------------------------

(147)
YES

----------------------------------------

(148)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> C(a(c(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(149) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(150)
Complex Obligation (AND)

----------------------------------------

(151)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(152) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(153)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(154) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(155)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(156) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(157)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(158) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
982, 984, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118

Node 982 is start node and node 984 is final node.

Those nodes are connected through the following edges:

* 982 to 1107 labelled c_1(0)* 982 to 1109 labelled b_1(0), B_1(0)* 982 to 1113 labelled b_1(1), B_1(1)* 982 to 1117 labelled b_1(2), B_1(2)* 984 to 984 labelled #_1(0)* 1107 to 1108 labelled a_1(0)* 1107 to 1111 labelled c_1(1)* 1108 to 984 labelled c_1(0)* 1109 to 1110 labelled c_1(0)* 1110 to 984 labelled a_1(0)* 1110 to 1111 labelled c_1(1)* 1111 to 1112 labelled a_1(1)* 1111 to 1111 labelled c_1(1)* 1112 to 984 labelled c_1(1)* 1113 to 1114 labelled c_1(1)* 1114 to 1111 labelled a_1(1)* 1114 to 1115 labelled c_1(2)* 1115 to 1116 labelled a_1(2)* 1116 to 1112 labelled c_1(2)* 1117 to 1118 labelled c_1(2)* 1118 to 1115 labelled a_1(2)


----------------------------------------

(159)
YES

----------------------------------------

(160)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> b(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(161) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(c(c(x1))) -> b(c(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(162)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(163) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(164)
YES

----------------------------------------

(165)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(166) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(167)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(168) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(169)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(170) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(171)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(172) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
993, 994, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024

Node 993 is start node and node 994 is final node.

Those nodes are connected through the following edges:

* 993 to 1013 labelled c_1(0)* 993 to 1015 labelled b_1(0), B_1(0)* 993 to 1019 labelled b_1(1), B_1(1)* 993 to 1023 labelled b_1(2), B_1(2)* 994 to 994 labelled #_1(0)* 1013 to 1014 labelled a_1(0)* 1013 to 1017 labelled c_1(1)* 1014 to 994 labelled c_1(0)* 1015 to 1016 labelled c_1(0)* 1016 to 994 labelled a_1(0)* 1016 to 1017 labelled c_1(1)* 1017 to 1018 labelled a_1(1)* 1017 to 1017 labelled c_1(1)* 1018 to 994 labelled c_1(1)* 1019 to 1020 labelled c_1(1)* 1020 to 1017 labelled a_1(1)* 1020 to 1021 labelled c_1(2)* 1021 to 1022 labelled a_1(2)* 1022 to 1018 labelled c_1(2)* 1023 to 1024 labelled c_1(2)* 1024 to 1021 labelled a_1(2)


----------------------------------------

(173)
YES

----------------------------------------

(174)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(a(C(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   a(a(b(x1))) -> C(b(A(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(C(A(x1)))
   a(a(b(x1))) -> C(B(a(x1)))
   a(a(b(x1))) -> c(B(A(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(175) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   a(a(b(x1))) -> C(b(A(x1)))
   a(a(b(x1))) -> C(B(a(x1)))
   a(a(b(x1))) -> c(B(A(x1)))

c:

   a(c(a(x1))) -> c(a(C(x1)))

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(C(A(x1)))
   b(c(c(x1))) -> B(c(A(x1)))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 2*x_1
   POL(b(x_1)) = 1 + x_1
   POL(c(x_1)) = 2*x_1

----------------------------------------

(176)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(a(C(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(C(A(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(177) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(C(A(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(a(x1))) -> c(a(C(x1)))

Relative ADPs:

   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 2
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(178)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(a(C(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(179) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 2 subproblems.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(180)
Complex Obligation (OR)

----------------------------------------

(181)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(C(a(x1)))
   a(c(a(x1))) -> c(a(C(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(182) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  3 Lassos,
Result: This relative DT problem is equivalent to 4 subproblems.

----------------------------------------

(183)
Complex Obligation (AND)

----------------------------------------

(184)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(185) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(186)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(187) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(188)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(189) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(190)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(191) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
995, 996, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070

Node 995 is start node and node 996 is final node.

Those nodes are connected through the following edges:

* 995 to 1059 labelled c_1(0)* 995 to 1061 labelled b_1(0), B_1(0)* 995 to 1065 labelled b_1(1), B_1(1)* 995 to 1069 labelled b_1(2), B_1(2)* 996 to 996 labelled #_1(0)* 1059 to 1060 labelled a_1(0)* 1059 to 1063 labelled c_1(1)* 1060 to 996 labelled c_1(0)* 1061 to 1062 labelled c_1(0)* 1062 to 996 labelled a_1(0)* 1062 to 1063 labelled c_1(1)* 1063 to 1064 labelled a_1(1)* 1063 to 1063 labelled c_1(1)* 1064 to 996 labelled c_1(1)* 1065 to 1066 labelled c_1(1)* 1066 to 1063 labelled a_1(1)* 1066 to 1067 labelled c_1(2)* 1067 to 1068 labelled a_1(2)* 1068 to 1064 labelled c_1(2)* 1069 to 1070 labelled c_1(2)* 1070 to 1067 labelled a_1(2)


----------------------------------------

(192)
YES

----------------------------------------

(193)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(194) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(195)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(196) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(197)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(198) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(199)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(200)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(a(x1))) -> c(a(C(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(201) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(202)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> c(a(C(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(203) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(204)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(205) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(206)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(207)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(208) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(c(c(x1))) -> b(C(a(x1)))

Relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(209)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   b(c(c(x1))) -> B(c(A(x1)))


----------------------------------------

(210) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(211)
YES

----------------------------------------

(212)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(c(A(x1)))
   a(c(a(x1))) -> c(a(C(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(213) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  2 Lassos,
Result: This relative DT problem is equivalent to 3 subproblems.

----------------------------------------

(214)
Complex Obligation (AND)

----------------------------------------

(215)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(216) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(217)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(218) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(219)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(220) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(221)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(222) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163

Node 1150 is start node and node 1151 is final node.

Those nodes are connected through the following edges:

* 1150 to 1152 labelled c_1(0)* 1150 to 1154 labelled b_1(0), B_1(0)* 1150 to 1158 labelled b_1(1), B_1(1)* 1150 to 1162 labelled b_1(2), B_1(2)* 1151 to 1151 labelled #_1(0)* 1152 to 1153 labelled a_1(0)* 1152 to 1156 labelled c_1(1)* 1153 to 1151 labelled c_1(0)* 1154 to 1155 labelled c_1(0)* 1155 to 1151 labelled a_1(0)* 1155 to 1156 labelled c_1(1)* 1156 to 1157 labelled a_1(1)* 1156 to 1156 labelled c_1(1)* 1157 to 1151 labelled c_1(1)* 1158 to 1159 labelled c_1(1)* 1159 to 1156 labelled a_1(1)* 1159 to 1160 labelled c_1(2)* 1160 to 1161 labelled a_1(2)* 1161 to 1157 labelled c_1(2)* 1162 to 1163 labelled c_1(2)* 1163 to 1160 labelled a_1(2)


----------------------------------------

(223)
YES

----------------------------------------

(224)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> b(c(A(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(225) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(c(c(x1))) -> b(c(A(x1)))

Relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 1
   POL(C(x_1)) = 0
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(226)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(227) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(228)
YES

----------------------------------------

(229)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> B(C(a(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(230) RelADPDerelatifying2Proof (SOUND)


We use the second derelatifying processor (moving relative rules)[IJCAR24].
We move one relative ADP with annotations to the non-relative part and create an own Problem for each movable rule.

Resulting in 1 subproblem.
If one of them is SN, then our original relative ADP problem is SN
----------------------------------------

(231)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))
   b(c(c(x1))) -> b(C(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(232) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(233)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(c(c(x1))) -> B(c(a(x1)))

and relative ADPs:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))


----------------------------------------

(234) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(235)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B(c(c(x1))) -> B(c(a(x1)))

The TRS R consists of the following rules:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(236) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 2. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   a(c(a(x1))) -> c(a(c(x1)))
   b(c(c(x1))) -> b(c(a(x1)))
   B(c(c(x1))) -> B(c(a(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200

Node 1187 is start node and node 1188 is final node.

Those nodes are connected through the following edges:

* 1187 to 1189 labelled c_1(0)* 1187 to 1191 labelled b_1(0), B_1(0)* 1187 to 1195 labelled b_1(1), B_1(1)* 1187 to 1199 labelled b_1(2), B_1(2)* 1188 to 1188 labelled #_1(0)* 1189 to 1190 labelled a_1(0)* 1189 to 1193 labelled c_1(1)* 1190 to 1188 labelled c_1(0)* 1191 to 1192 labelled c_1(0)* 1192 to 1188 labelled a_1(0)* 1192 to 1193 labelled c_1(1)* 1193 to 1194 labelled a_1(1)* 1193 to 1193 labelled c_1(1)* 1194 to 1188 labelled c_1(1)* 1195 to 1196 labelled c_1(1)* 1196 to 1193 labelled a_1(1)* 1196 to 1197 labelled c_1(2)* 1197 to 1198 labelled a_1(2)* 1198 to 1194 labelled c_1(2)* 1199 to 1200 labelled c_1(2)* 1200 to 1197 labelled a_1(2)


----------------------------------------

(237)
YES
